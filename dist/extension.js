"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs9 = require("fs");
    function checkPathExt(path15, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i2 = 0; i2 < pathext.length; i2++) {
        var p = pathext[i2].toLowerCase();
        if (p && path15.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path15, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path15, options);
    }
    function isexe(path15, options, cb) {
      fs9.stat(path15, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path15, options));
      });
    }
    function sync2(path15, options) {
      return checkStat(fs9.statSync(path15), path15, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs9 = require("fs");
    function isexe(path15, options, cb) {
      fs9.stat(path15, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync2(path15, options) {
      return checkStat(fs9.statSync(path15), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u2 = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o2 = parseInt("001", 8);
      var ug = u2 | g;
      var ret = mod & o2 || mod & g && gid === myGid || mod & u2 && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports2, module2) {
    var fs9 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync2;
    function isexe(path15, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve4, reject) {
          isexe(path15, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve4(is);
            }
          });
        });
      }
      core(path15, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync2(path15, options) {
      try {
        return core.sync(path15, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports2, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path15 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i2) => new Promise((resolve4, reject) => {
        if (i2 === pathEnv.length)
          return opt.all && found.length ? resolve4(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i2];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path15.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve4(subStep(p, i2, 0));
      });
      const subStep = (p, i2, ii) => new Promise((resolve4, reject) => {
        if (ii === pathExt.length)
          return resolve4(step(i2 + 1));
        const ext2 = pathExt[ii];
        isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext2);
            else
              return resolve4(p + ext2);
          }
          return resolve4(subStep(p, i2, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i2 = 0; i2 < pathEnv.length; i2++) {
        const ppRaw = pathEnv[i2];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path15.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  }
});

// node_modules/path-key/index.js
var require_path_key = __commonJS({
  "node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey2 = (options = {}) => {
      const environment = options.env || process.env;
      const platform2 = options.platform || process.platform;
      if (platform2 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey2;
    module2.exports.default = pathKey2;
  }
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path15 = require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path15.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path15.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
      arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match3 = string.match(shebangRegex);
      if (!match3) {
        return null;
      }
      const [path15, argument] = match3[0].replace(/#! ?/, "").split(" ");
      const binary = path15.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs9 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs9.openSync(command, "r");
        fs9.readSync(fd, buffer, 0, size, 0);
        fs9.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path15 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape4 = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path15.normalize(parsed.command);
        parsed.command = escape4.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape4.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse;
  }
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed);
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process");
    var parse = require_parse();
    var enoent = require_enoent();
    function spawn2(command, args, options) {
      const parsed = parse(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync2(command, args, options) {
      const parsed = parse(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync2;
    module2.exports._parse = parse;
    module2.exports._enoent = enoent;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream2 = require("stream").Stream;
    var util3 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util3.inherits(DelayedStream, Stream2);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream2.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util3 = require("util");
    var Stream2 = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util3.inherits(CombinedStream, Stream2);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream5) {
      return typeof stream5 !== "function" && typeof stream5 !== "string" && typeof stream5 !== "boolean" && typeof stream5 !== "number" && !Buffer.isBuffer(stream5);
    };
    CombinedStream.prototype.append = function(stream5) {
      var isStreamLike = CombinedStream.isStreamLike(stream5);
      if (isStreamLike) {
        if (!(stream5 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream5, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream5.on("data", this._checkDataSize.bind(this));
          stream5 = newStream;
        }
        this._handleErrors(stream5);
        if (this.pauseStreams) {
          stream5.pause();
        }
      }
      this._streams.push(stream5);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream2.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream5 = this._streams.shift();
      if (typeof stream5 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream5 !== "function") {
        this._pipeNext(stream5);
        return;
      }
      var getStream = stream5;
      getStream(function(stream6) {
        var isStreamLike = CombinedStream.isStreamLike(stream6);
        if (isStreamLike) {
          stream6.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream6);
        }
        this._pipeNext(stream6);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream5) {
      this._currentStream = stream5;
      var isStreamLike = CombinedStream.isStreamLike(stream5);
      if (isStreamLike) {
        stream5.on("end", this._getNext.bind(this));
        stream5.pipe(this, { end: false });
        return;
      }
      var value = stream5;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream5) {
      var self2 = this;
      stream5.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream5) {
        if (!stream5.dataSize) {
          return;
        }
        self2.dataSize += stream5.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname2 = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match3 = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match3 && db[match3[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match3 && TEXT_TYPE_REGEXP.test(match3[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match3 = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match3 && exports2.extensions[match3[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path15) {
      if (!path15 || typeof path15 !== "string") {
        return false;
      }
      var extension2 = extname2("x." + path15).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions2, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions2[type] = exts;
        for (var i2 = 0; i2 < exts.length; i2++) {
          var extension2 = exts[i2];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer2;
    function defer2(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer2 = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer2(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer2(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate2;
    function iterate2(list2, iterator2, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator2, key, list2[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator2, key, item, callback) {
      var aborter;
      if (iterator2.length == 2) {
        aborter = iterator2(item, async(callback));
      } else {
        aborter = iterator2(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list2, sortMethod) {
      var isNamedList = !Array.isArray(list2), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list2) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list2).length : list2.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a2, b) {
          return sortMethod(list2[a2], list2[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate2 = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list2, iterator2, callback) {
      var state = initState(list2);
      while (state.index < (state["keyedList"] || list2).length) {
        iterate2(list2, iterator2, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate2 = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list2, iterator2, sortMethod, callback) {
      var state = initState(list2, sortMethod);
      iterate2(list2, iterator2, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list2).length) {
          iterate2(list2, iterator2, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a2, b) {
      return a2 < b ? -1 : a2 > b ? 1 : 0;
    }
    function descending(a2, b) {
      return -1 * ascending(a2, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list2, iterator2, callback) {
      return serialOrdered(list2, iterator2, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a2) {
      return a2 !== a2;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a2, b) {
      var arr = [];
      for (var i2 = 0; i2 < a2.length; i2 += 1) {
        arr[i2] = a2[i2];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a2.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i2 = offset || 0, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
        arr[j] = arrLike[i2];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        str += arr[i2];
        if (i2 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs[i2] = "$" + i2;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind2.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind2 = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind2, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module2.exports = bind2.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind2.call($call, Array.prototype.concat);
    var $spliceApply = bind2.call($apply, Array.prototype.splice);
    var $replace = bind2.call($call, String.prototype.replace);
    var $strSlice = bind2.call($call, String.prototype.slice);
    var $exec = bind2.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match3, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match3;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag2, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag2] = value;
        }
      }
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util3 = require("util");
    var path15 = require("path");
    var http2 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs9 = require("fs");
    var Stream2 = require("stream").Stream;
    var crypto2 = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util3.inherits(FormData3, CombinedStream);
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream2)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs9.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path15.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path15.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path15.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i2 = 0, len = this._streams.length; i2 < len; i2++) {
        if (typeof this._streams[i2] !== "function") {
          if (Buffer.isBuffer(this._streams[i2])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i2]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i2])]);
          }
          if (typeof this._streams[i2] !== "string" || this._streams[i2].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults3 = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults3);
      } else {
        options = populate(params, defaults3);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData3, "FormData");
    module2.exports = FormData3;
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv2("npm_config_" + proto + "_proxy") || getEnv2(proto + "_proxy") || getEnv2("npm_config_proxy") || getEnv2("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv2("npm_config_no_proxy") || getEnv2("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv2(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h2 = m * 60;
    var d = h2 * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match3) {
        return;
      }
      var n2 = parseFloat(match3[1]);
      var type = (match3[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match3, format3) => {
            if (match3 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format3];
            if (typeof formatter === "function") {
              const val = args[index];
              match3 = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match3;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match3) => {
        if (match3 === "%%") {
          return;
        }
        index++;
        if (match3 === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty3 = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream5) {
      const level = supportsColor(stream5, stream5 && stream5.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty3.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty3.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty3 = require("tty");
    var util3 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty3.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c3 = this.color;
        const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util3.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url2 = require("url");
    var URL2 = url2.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable4 = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction4(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable4.prototype.destroy || noop4;
    function RedirectableRequest(options, responseCallback) {
      Writable4.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable4.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString4(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction4(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction4(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction4(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a2, b) {
        return this._currentRequest[method](a2, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i2 = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i2 < buffers.length) {
              var buffer = buffers[i2++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction4(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString4(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction4(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString4(options.host) && !isString4(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop4() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url2.parse(input));
        if (!isString4(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread3 = target || {};
      for (var key of preservedUrlFields) {
        spread3[key] = urlObject[key];
      }
      if (spread3.hostname.startsWith("[")) {
        spread3.hostname = spread3.hostname.slice(1, -1);
      }
      if (spread3.port !== "") {
        spread3.port = Number(spread3.port);
      }
      spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
      return spread3;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code2, message, baseClass) {
      function CustomError(properties) {
        if (isFunction4(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code2;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code2 + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop4);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString4(subdomain) && isString4(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString4(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction4(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function") fn.apply(this, args);
        else {
          return new Promise((resolve4, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve4(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function") return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants4 = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs9) {
      if (constants4.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs9);
      }
      if (!fs9.lutimes) {
        patchLutimes(fs9);
      }
      fs9.chown = chownFix(fs9.chown);
      fs9.fchown = chownFix(fs9.fchown);
      fs9.lchown = chownFix(fs9.lchown);
      fs9.chmod = chmodFix(fs9.chmod);
      fs9.fchmod = chmodFix(fs9.fchmod);
      fs9.lchmod = chmodFix(fs9.lchmod);
      fs9.chownSync = chownFixSync(fs9.chownSync);
      fs9.fchownSync = chownFixSync(fs9.fchownSync);
      fs9.lchownSync = chownFixSync(fs9.lchownSync);
      fs9.chmodSync = chmodFixSync(fs9.chmodSync);
      fs9.fchmodSync = chmodFixSync(fs9.fchmodSync);
      fs9.lchmodSync = chmodFixSync(fs9.lchmodSync);
      fs9.stat = statFix(fs9.stat);
      fs9.fstat = statFix(fs9.fstat);
      fs9.lstat = statFix(fs9.lstat);
      fs9.statSync = statFixSync(fs9.statSync);
      fs9.fstatSync = statFixSync(fs9.fstatSync);
      fs9.lstatSync = statFixSync(fs9.lstatSync);
      if (fs9.chmod && !fs9.lchmod) {
        fs9.lchmod = function(path15, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs9.lchmodSync = function() {
        };
      }
      if (fs9.chown && !fs9.lchown) {
        fs9.lchown = function(path15, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs9.lchownSync = function() {
        };
      }
      if (platform2 === "win32") {
        fs9.rename = typeof fs9.rename !== "function" ? fs9.rename : (function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs9.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            });
          }
          if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
          return rename;
        })(fs9.rename);
      }
      fs9.read = typeof fs9.read !== "function" ? fs9.read : (function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs9, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs9, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      })(fs9.read);
      fs9.readSync = typeof fs9.readSync !== "function" ? fs9.readSync : /* @__PURE__ */ (function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs9, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      })(fs9.readSync);
      function patchLchmod(fs10) {
        fs10.lchmod = function(path15, mode, callback) {
          fs10.open(
            path15,
            constants4.O_WRONLY | constants4.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs10.fchmod(fd, mode, function(err2) {
                fs10.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs10.lchmodSync = function(path15, mode) {
          var fd = fs10.openSync(path15, constants4.O_WRONLY | constants4.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs10.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs10.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs10.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs10) {
        if (constants4.hasOwnProperty("O_SYMLINK") && fs10.futimes) {
          fs10.lutimes = function(path15, at, mt, cb) {
            fs10.open(path15, constants4.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs10.futimes(fd, at, mt, function(er2) {
                fs10.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs10.lutimesSync = function(path15, at, mt) {
            var fd = fs10.openSync(path15, constants4.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs10.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs10.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs10.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs10.futimes) {
          fs10.lutimes = function(_a2, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs10.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs9, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs9, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs9, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs9, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs9, target, options, callback) : orig.call(fs9, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs9, target, options) : orig.call(fs9, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream2 = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs9) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path15, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path15, options);
        Stream2.call(this);
        var self2 = this;
        this.path = path15;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs9.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path15, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path15, options);
        Stream2.call(this);
        this.path = path15;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs9.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf2 = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf2(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs9 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util3 = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop4() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop4;
    if (util3.debuglog)
      debug = util3.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util3.format.apply(util3, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs9[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs9, queue);
      fs9.close = (function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs9, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      })(fs9.close);
      fs9.closeSync = (function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs9, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      })(fs9.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs9[gracefulQueue]);
          require("assert").equal(fs9[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs9[gracefulQueue]);
    }
    module2.exports = patch(clone(fs9));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs9.__patched) {
      module2.exports = patch(fs9);
      fs9.__patched = true;
    }
    function patch(fs10) {
      polyfills(fs10);
      fs10.gracefulify = patch;
      fs10.createReadStream = createReadStream2;
      fs10.createWriteStream = createWriteStream2;
      var fs$readFile = fs10.readFile;
      fs10.readFile = readFile5;
      function readFile5(path15, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path15, options, cb);
        function go$readFile(path16, options2, cb2, startTime) {
          return fs$readFile(path16, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path16, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs10.writeFile;
      fs10.writeFile = writeFile4;
      function writeFile4(path15, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path15, data, options, cb);
        function go$writeFile(path16, data2, options2, cb2, startTime) {
          return fs$writeFile(path16, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path16, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs10.appendFile;
      if (fs$appendFile)
        fs10.appendFile = appendFile2;
      function appendFile2(path15, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path15, data, options, cb);
        function go$appendFile(path16, data2, options2, cb2, startTime) {
          return fs$appendFile(path16, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path16, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs10.copyFile;
      if (fs$copyFile)
        fs10.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs10.readdir;
      fs10.readdir = readdir3;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir3(path15, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path16, options2, cb2, startTime) {
          return fs$readdir(path16, fs$readdirCallback(
            path16,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path16, options2, cb2, startTime) {
          return fs$readdir(path16, options2, fs$readdirCallback(
            path16,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path15, options, cb);
        function fs$readdirCallback(path16, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path16, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs10);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs10.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs10.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs10, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs10, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs10, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs10, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path15, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path15, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path15, options) {
        return new fs10.ReadStream(path15, options);
      }
      function createWriteStream2(path15, options) {
        return new fs10.WriteStream(path15, options);
      }
      var fs$open = fs10.open;
      fs10.open = open;
      function open(path15, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path15, flags, mode, cb);
        function go$open(path16, flags2, mode2, cb2, startTime) {
          return fs$open(path16, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path16, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs10;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs9[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i2 = 0; i2 < fs9[gracefulQueue].length; ++i2) {
        if (fs9[gracefulQueue][i2].length > 2) {
          fs9[gracefulQueue][i2][3] = now;
          fs9[gracefulQueue][i2][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs9[gracefulQueue].length === 0)
        return;
      var elem = fs9[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs9[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var fs9 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "cp",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "glob",
      "lchmod",
      "lchown",
      "lutimes",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "statfs",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs9[key] === "function";
    });
    Object.assign(exports2, fs9);
    api.forEach((method) => {
      exports2[method] = u2(fs9[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs9.exists(filename, callback);
      }
      return new Promise((resolve4) => {
        return fs9.exists(filename, resolve4);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs9.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve4, reject) => {
        fs9.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve4({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs9.write(fd, buffer, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs9.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve4({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports2.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs9.readv(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs9.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err) return reject(err);
          resolve4({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports2.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs9.writev(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs9.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve4({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs9.realpath.native === "function") {
      exports2.realpath.native = u2(fs9.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/utils.js"(exports2, module2) {
    "use strict";
    var path15 = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path15.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs9 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults3 = { mode: 511 };
      if (typeof options === "number") return options;
      return { ...defaults3, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs9.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs9.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u2(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var fs9 = require_fs();
    function pathExists5(path15) {
      return fs9.access(path15).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u2(pathExists5),
      pathExistsSync: fs9.existsSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs9 = require_fs();
    var u2 = require_universalify().fromPromise;
    async function utimesMillis(path15, atime, mtime) {
      const fd = await fs9.open(path15, "r+");
      let closeErr = null;
      try {
        await fs9.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs9.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path15, atime, mtime) {
      const fd = fs9.openSync(path15, "r+");
      fs9.futimesSync(fd, atime, mtime);
      return fs9.closeSync(fd);
    }
    module2.exports = {
      utimesMillis: u2(utimesMillis),
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs9 = require_fs();
    var path15 = require("path");
    var u2 = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs9.stat(file, { bigint: true }) : (file) => fs9.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs9.statSync(file, { bigint: true }) : (file) => fs9.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path15.basename(src);
          const destBaseName = path15.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path15.basename(src);
          const destBaseName = path15.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path15.resolve(path15.dirname(src));
      const destParent = path15.resolve(path15.dirname(dest));
      if (destParent === srcParent || destParent === path15.parse(destParent).root) return;
      let destStat;
      try {
        destStat = await fs9.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path15.resolve(path15.dirname(src));
      const destParent = path15.resolve(path15.dirname(dest));
      if (destParent === srcParent || destParent === path15.parse(destParent).root) return;
      let destStat;
      try {
        destStat = fs9.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino !== void 0 && destStat.dev !== void 0 && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path15.resolve(src).split(path15.sep).filter((i2) => i2);
      const destArr = path15.resolve(dest).split(path15.sep).filter((i2) => i2);
      return srcArr.every((cur, i2) => destArr[i2] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      // checkPaths
      checkPaths: u2(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u2(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/fs-extra/lib/util/async.js
var require_async2 = __commonJS({
  "node_modules/fs-extra/lib/util/async.js"(exports2, module2) {
    "use strict";
    async function asyncIteratorConcurrentProcess(iterator2, fn) {
      const promises = [];
      for await (const item of iterator2) {
        promises.push(
          fn(item).then(
            () => null,
            (err) => err ?? new Error("unknown error")
          )
        );
      }
      await Promise.all(
        promises.map(
          (promise) => promise.then((possibleErr) => {
            if (possibleErr !== null) throw possibleErr;
          })
        )
      );
    }
    module2.exports = {
      asyncIteratorConcurrentProcess
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs9 = require_fs();
    var path15 = require("path");
    var { mkdirs } = require_mkdirs();
    var { pathExists: pathExists5 } = require_path_exists();
    var { utimesMillis } = require_utimes();
    var stat = require_stat();
    var { asyncIteratorConcurrentProcess } = require_async2();
    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
      await stat.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include) return;
      const destParent = path15.dirname(dest);
      const dirExists = await pathExists5(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter) return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs9.stat : fs9.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs9.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs9.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs9.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs9.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs9.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs9.mkdir(dest);
      }
      await asyncIteratorConcurrentProcess(await fs9.opendir(src), async (item) => {
        const srcItem = path15.join(src, item.name);
        const destItem = path15.join(dest, item.name);
        const include = await runFilter(srcItem, destItem, opts);
        if (include) {
          const { destStat: destStat2 } = await stat.checkPaths(srcItem, destItem, "copy", opts);
          await getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
        }
      });
      if (!destStat) {
        await fs9.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs9.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path15.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs9.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs9.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN") return fs9.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path15.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs9.unlink(dest);
      return fs9.symlink(resolvedSrc, dest);
    }
    module2.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/fs-extra/lib/copy/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs9 = require_graceful_fs();
    var path15 = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest)) return;
      const destParent = path15.dirname(dest);
      if (!fs9.existsSync(destParent)) mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync2 = opts.dereference ? fs9.statSync : fs9.lstatSync;
      const srcStat = statSync2(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs9.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs9.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs9.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs9.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs9.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      const dir = fs9.opendirSync(src);
      try {
        let dirent;
        while ((dirent = dir.readSync()) !== null) {
          copyDirItem(dirent.name, src, dest, opts);
        }
      } finally {
        dir.closeSync();
      }
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path15.join(src, item);
      const destItem = path15.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs9.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path15.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs9.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs9.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs9.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path15.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs9.unlinkSync(dest);
      return fs9.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    module2.exports = {
      copy: u2(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var fs9 = require_graceful_fs();
    var u2 = require_universalify().fromCallback;
    function remove(path15, callback) {
      fs9.rm(path15, { recursive: true, force: true }, callback);
    }
    function removeSync(path15) {
      fs9.rmSync(path15, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u2(remove),
      removeSync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var fs9 = require_fs();
    var path15 = require("path");
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir3 = u2(async function emptyDir4(dir) {
      let items;
      try {
        items = await fs9.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path15.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs9.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path15.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir: emptyDir3,
      emptydir: emptyDir3
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var path15 = require("path");
    var fs9 = require_fs();
    var mkdir = require_mkdirs();
    async function createFile(file) {
      let stats;
      try {
        stats = await fs9.stat(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path15.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs9.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs9.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs9.writeFile(file, "");
      } else {
        await fs9.readdir(dir);
      }
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs9.statSync(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path15.dirname(file);
      try {
        if (!fs9.statSync(dir).isDirectory()) {
          fs9.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
        else throw err;
      }
      fs9.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u2(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var path15 = require("path");
    var fs9 = require_fs();
    var mkdir = require_mkdirs();
    var { pathExists: pathExists5 } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs9.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs9.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat)) return;
      const dir = path15.dirname(dstpath);
      const dirExists = await pathExists5(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs9.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs9.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs9.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path15.dirname(dstpath);
      const dirExists = fs9.existsSync(dir);
      if (dirExists) return fs9.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs9.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u2(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path15 = require("path");
    var fs9 = require_fs();
    var { pathExists: pathExists5 } = require_path_exists();
    var u2 = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path15.isAbsolute(srcpath)) {
        try {
          await fs9.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path15.dirname(dstpath);
      const relativeToDst = path15.join(dstdir, srcpath);
      const exists = await pathExists5(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs9.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path15.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path15.isAbsolute(srcpath)) {
        const exists2 = fs9.existsSync(srcpath);
        if (!exists2) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path15.dirname(dstpath);
      const relativeToDst = path15.join(dstdir, srcpath);
      const exists = fs9.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs9.existsSync(srcpath);
      if (!srcExists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path15.relative(dstdir, srcpath)
      };
    }
    module2.exports = {
      symlinkPaths: u2(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs9 = require_fs();
    var u2 = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = await fs9.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = fs9.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType: u2(symlinkType),
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var path15 = require("path");
    var fs9 = require_fs();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists: pathExists5 } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs9.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs9.stat(srcpath),
          fs9.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path15.dirname(dstpath);
      if (!await pathExists5(dir)) {
        await mkdirs(dir);
      }
      return fs9.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs9.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs9.statSync(srcpath);
        const dstStat = fs9.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path15.dirname(dstpath);
      const exists = fs9.existsSync(dir);
      if (exists) return fs9.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs9.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u2(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF2 = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF2;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content)) content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs9 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs9.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile5 = universalify.fromPromise(_readFile);
    function readFileSync5(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs9 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs9.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs9 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs9.writeFile)(file, str, options);
    }
    var writeFile4 = universalify.fromPromise(_writeFile);
    function writeFileSync4(file, obj, options = {}) {
      const fs9 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs9.writeFileSync(file, str, options);
    }
    module2.exports = {
      readFile: readFile5,
      readFileSync: readFileSync5,
      writeFile: writeFile4,
      writeFileSync: writeFileSync4
    };
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/fs-extra/lib/output-file/index.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var fs9 = require_fs();
    var path15 = require("path");
    var mkdir = require_mkdirs();
    var pathExists5 = require_path_exists().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path15.dirname(file);
      if (!await pathExists5(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs9.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      const dir = path15.dirname(file);
      if (!fs9.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs9.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u2(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u2(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs9 = require_fs();
    var path15 = require("path");
    var { copy } = require_copy2();
    var { remove } = require_remove();
    var { mkdirp } = require_mkdirs();
    var { pathExists: pathExists5 } = require_path_exists();
    var stat = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
      await stat.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path15.dirname(dest);
      const parsedParentPath = path15.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists5(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs9.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy(src, dest, opts);
      return remove(src);
    }
    module2.exports = move;
  }
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/fs-extra/lib/move/move-sync.js"(exports2, module2) {
    "use strict";
    var fs9 = require_graceful_fs();
    var path15 = require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest)) mkdirpSync(path15.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path15.dirname(dest);
      const parsedPath = path15.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs9.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs9.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    module2.exports = {
      move: u2(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// node_modules/punycode.js/punycode.js
var require_punycode = __commonJS({
  "node_modules/punycode.js/punycode.js"(exports2, module2) {
    "use strict";
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7F]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, callback) {
      const result = [];
      let length = array.length;
      while (length--) {
        result[length] = callback(array[length]);
      }
      return result;
    }
    function mapDomain(domain, callback) {
      const parts = domain.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        domain = parts[1];
      }
      domain = domain.replace(regexSeparators, ".");
      const labels = domain.split(".");
      const encoded = map(labels, callback).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          const extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    var basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode2 = function(input) {
      const output = [];
      const inputLength = input.length;
      let i2 = 0;
      let n2 = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i2;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i2) / w)) {
            error("overflow");
          }
          i2 += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n2) {
          error("overflow");
        }
        n2 += floor(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n2);
      }
      return String.fromCodePoint(...output);
    };
    var encode4 = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n2 = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n2 && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n2) * handledCPCountPlusOne;
        n2 = m;
        for (const currentValue of input) {
          if (currentValue < n2 && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n2) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    };
    var toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode4(string) : string;
      });
    };
    var punycode2 = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode4,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    module2.exports = punycode2;
  }
});

// node_modules/nunjucks/src/lib.js
var require_lib2 = __commonJS({
  "node_modules/nunjucks/src/lib.js"(exports2, module2) {
    "use strict";
    var ArrayProto = Array.prototype;
    var ObjProto = Object.prototype;
    var escapeMap = {
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "\\": "&#92;"
    };
    var escapeRegex = /[&"'<>\\]/g;
    var _exports = module2.exports = {};
    function hasOwnProp(obj, k) {
      return ObjProto.hasOwnProperty.call(obj, k);
    }
    _exports.hasOwnProp = hasOwnProp;
    function lookupEscape(ch) {
      return escapeMap[ch];
    }
    function _prettifyError(path15, withInternals, err) {
      if (!err.Update) {
        err = new _exports.TemplateError(err);
      }
      err.Update(path15);
      if (!withInternals) {
        var old = err;
        err = new Error(old.message);
        err.name = old.name;
      }
      return err;
    }
    _exports._prettifyError = _prettifyError;
    function TemplateError(message, lineno, colno) {
      var err;
      var cause;
      if (message instanceof Error) {
        cause = message;
        message = cause.name + ": " + cause.message;
      }
      if (Object.setPrototypeOf) {
        err = new Error(message);
        Object.setPrototypeOf(err, TemplateError.prototype);
      } else {
        err = this;
        Object.defineProperty(err, "message", {
          enumerable: false,
          writable: true,
          value: message
        });
      }
      Object.defineProperty(err, "name", {
        value: "Template render error"
      });
      if (Error.captureStackTrace) {
        Error.captureStackTrace(err, this.constructor);
      }
      var getStack;
      if (cause) {
        var stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
        getStack = stackDescriptor && (stackDescriptor.get || function() {
          return stackDescriptor.value;
        });
        if (!getStack) {
          getStack = function getStack2() {
            return cause.stack;
          };
        }
      } else {
        var stack = new Error(message).stack;
        getStack = function getStack2() {
          return stack;
        };
      }
      Object.defineProperty(err, "stack", {
        get: function get() {
          return getStack.call(err);
        }
      });
      Object.defineProperty(err, "cause", {
        value: cause
      });
      err.lineno = lineno;
      err.colno = colno;
      err.firstUpdate = true;
      err.Update = function Update(path15) {
        var msg = "(" + (path15 || "unknown path") + ")";
        if (this.firstUpdate) {
          if (this.lineno && this.colno) {
            msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
          } else if (this.lineno) {
            msg += " [Line " + this.lineno + "]";
          }
        }
        msg += "\n ";
        if (this.firstUpdate) {
          msg += " ";
        }
        this.message = msg + (this.message || "");
        this.firstUpdate = false;
        return this;
      };
      return err;
    }
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
    } else {
      TemplateError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: TemplateError
        }
      });
    }
    _exports.TemplateError = TemplateError;
    function escape4(val) {
      return val.replace(escapeRegex, lookupEscape);
    }
    _exports.escape = escape4;
    function isFunction4(obj) {
      return ObjProto.toString.call(obj) === "[object Function]";
    }
    _exports.isFunction = isFunction4;
    function isArray2(obj) {
      return ObjProto.toString.call(obj) === "[object Array]";
    }
    _exports.isArray = isArray2;
    function isString4(obj) {
      return ObjProto.toString.call(obj) === "[object String]";
    }
    _exports.isString = isString4;
    function isObject4(obj) {
      return ObjProto.toString.call(obj) === "[object Object]";
    }
    _exports.isObject = isObject4;
    function _prepareAttributeParts(attr) {
      if (!attr) {
        return [];
      }
      if (typeof attr === "string") {
        return attr.split(".");
      }
      return [attr];
    }
    function getAttrGetter(attribute2) {
      var parts = _prepareAttributeParts(attribute2);
      return function attrGetter(item) {
        var _item = item;
        for (var i2 = 0; i2 < parts.length; i2++) {
          var part = parts[i2];
          if (hasOwnProp(_item, part)) {
            _item = _item[part];
          } else {
            return void 0;
          }
        }
        return _item;
      };
    }
    _exports.getAttrGetter = getAttrGetter;
    function groupBy(obj, val, throwOnUndefined) {
      var result = {};
      var iterator2 = isFunction4(val) ? val : getAttrGetter(val);
      for (var i2 = 0; i2 < obj.length; i2++) {
        var value = obj[i2];
        var key = iterator2(value, i2);
        if (key === void 0 && throwOnUndefined === true) {
          throw new TypeError('groupby: attribute "' + val + '" resolved to undefined');
        }
        (result[key] || (result[key] = [])).push(value);
      }
      return result;
    }
    _exports.groupBy = groupBy;
    function toArray2(obj) {
      return Array.prototype.slice.call(obj);
    }
    _exports.toArray = toArray2;
    function without(array) {
      var result = [];
      if (!array) {
        return result;
      }
      var length = array.length;
      var contains = toArray2(arguments).slice(1);
      var index = -1;
      while (++index < length) {
        if (indexOf(contains, array[index]) === -1) {
          result.push(array[index]);
        }
      }
      return result;
    }
    _exports.without = without;
    function repeat(char_, n2) {
      var str = "";
      for (var i2 = 0; i2 < n2; i2++) {
        str += char_;
      }
      return str;
    }
    _exports.repeat = repeat;
    function each(obj, func, context) {
      if (obj == null) {
        return;
      }
      if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
        obj.forEach(func, context);
      } else if (obj.length === +obj.length) {
        for (var i2 = 0, l = obj.length; i2 < l; i2++) {
          func.call(context, obj[i2], i2, obj);
        }
      }
    }
    _exports.each = each;
    function map(obj, func) {
      var results = [];
      if (obj == null) {
        return results;
      }
      if (ArrayProto.map && obj.map === ArrayProto.map) {
        return obj.map(func);
      }
      for (var i2 = 0; i2 < obj.length; i2++) {
        results[results.length] = func(obj[i2], i2);
      }
      if (obj.length === +obj.length) {
        results.length = obj.length;
      }
      return results;
    }
    _exports.map = map;
    function asyncIter(arr, iter, cb) {
      var i2 = -1;
      function next() {
        i2++;
        if (i2 < arr.length) {
          iter(arr[i2], i2, next, cb);
        } else {
          cb();
        }
      }
      next();
    }
    _exports.asyncIter = asyncIter;
    function asyncFor(obj, iter, cb) {
      var keys = keys_(obj || {});
      var len = keys.length;
      var i2 = -1;
      function next() {
        i2++;
        var k = keys[i2];
        if (i2 < len) {
          iter(k, obj[k], i2, len, next);
        } else {
          cb();
        }
      }
      next();
    }
    _exports.asyncFor = asyncFor;
    function indexOf(arr, searchElement, fromIndex) {
      return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
    }
    _exports.indexOf = indexOf;
    function keys_(obj) {
      var arr = [];
      for (var k in obj) {
        if (hasOwnProp(obj, k)) {
          arr.push(k);
        }
      }
      return arr;
    }
    _exports.keys = keys_;
    function _entries(obj) {
      return keys_(obj).map(function(k) {
        return [k, obj[k]];
      });
    }
    _exports._entries = _entries;
    function _values(obj) {
      return keys_(obj).map(function(k) {
        return obj[k];
      });
    }
    _exports._values = _values;
    function extend2(obj1, obj2) {
      obj1 = obj1 || {};
      keys_(obj2).forEach(function(k) {
        obj1[k] = obj2[k];
      });
      return obj1;
    }
    _exports._assign = _exports.extend = extend2;
    function inOperator(key, val) {
      if (isArray2(val) || isString4(val)) {
        return val.indexOf(key) !== -1;
      } else if (isObject4(val)) {
        return key in val;
      }
      throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
    }
    _exports.inOperator = inOperator;
  }
});

// node_modules/asap/raw.js
var require_raw = __commonJS({
  "node_modules/asap/raw.js"(exports2, module2) {
    "use strict";
    var domain;
    var hasSetImmediate = typeof setImmediate === "function";
    module2.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    rawAsap.requestFlush = requestFlush;
    function requestFlush() {
      var parentDomain = process.domain;
      if (parentDomain) {
        if (!domain) {
          domain = require("domain");
        }
        domain.active = process.domain = null;
      }
      if (flushing && hasSetImmediate) {
        setImmediate(flush);
      } else {
        process.nextTick(flush);
      }
      if (parentDomain) {
        domain.active = process.domain = parentDomain;
      }
    }
  }
});

// node_modules/asap/asap.js
var require_asap = __commonJS({
  "node_modules/asap/asap.js"(exports2, module2) {
    "use strict";
    var rawAsap = require_raw();
    var freeTasks = [];
    module2.exports = asap2;
    function asap2(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawTask.domain = process.domain;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
      this.domain = null;
    }
    RawTask.prototype.call = function() {
      if (this.domain) {
        this.domain.enter();
      }
      var threw = true;
      try {
        this.task.call();
        threw = false;
        if (this.domain) {
          this.domain.exit();
        }
      } finally {
        if (threw) {
          rawAsap.requestFlush();
        }
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
      }
    };
  }
});

// node_modules/a-sync-waterfall/index.js
var require_a_sync_waterfall = __commonJS({
  "node_modules/a-sync-waterfall/index.js"(exports2, module2) {
    (function(globals) {
      "use strict";
      var executeSync = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "function") {
          args[0].apply(null, args.splice(1));
        }
      };
      var executeAsync = function(fn) {
        if (typeof setImmediate === "function") {
          setImmediate(fn);
        } else if (typeof process !== "undefined" && process.nextTick) {
          process.nextTick(fn);
        } else {
          setTimeout(fn, 0);
        }
      };
      var makeIterator = function(tasks) {
        var makeCallback = function(index) {
          var fn = function() {
            if (tasks.length) {
              tasks[index].apply(null, arguments);
            }
            return fn.next();
          };
          fn.next = function() {
            return index < tasks.length - 1 ? makeCallback(index + 1) : null;
          };
          return fn;
        };
        return makeCallback(0);
      };
      var _isArray = Array.isArray || function(maybeArray) {
        return Object.prototype.toString.call(maybeArray) === "[object Array]";
      };
      var waterfall = function(tasks, callback, forceAsync) {
        var nextTick = forceAsync ? executeAsync : executeSync;
        callback = callback || function() {
        };
        if (!_isArray(tasks)) {
          var err = new Error("First argument to waterfall must be an array of functions");
          return callback(err);
        }
        if (!tasks.length) {
          return callback();
        }
        var wrapIterator = function(iterator2) {
          return function(err2) {
            if (err2) {
              callback.apply(null, arguments);
              callback = function() {
              };
            } else {
              var args = Array.prototype.slice.call(arguments, 1);
              var next = iterator2.next();
              if (next) {
                args.push(wrapIterator(next));
              } else {
                args.push(callback);
              }
              nextTick(function() {
                iterator2.apply(null, args);
              });
            }
          };
        };
        wrapIterator(makeIterator(tasks))();
      };
      if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return waterfall;
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = waterfall;
      } else {
        globals.waterfall = waterfall;
      }
    })(exports2);
  }
});

// node_modules/nunjucks/src/lexer.js
var require_lexer = __commonJS({
  "node_modules/nunjucks/src/lexer.js"(exports2, module2) {
    "use strict";
    var lib2 = require_lib2();
    var whitespaceChars = " \n	\r\xA0";
    var delimChars = "()[]{}%*-+~/#,:|.<>=!";
    var intChars = "0123456789";
    var BLOCK_START = "{%";
    var BLOCK_END = "%}";
    var VARIABLE_START = "{{";
    var VARIABLE_END = "}}";
    var COMMENT_START = "{#";
    var COMMENT_END = "#}";
    var TOKEN_STRING = "string";
    var TOKEN_WHITESPACE = "whitespace";
    var TOKEN_DATA = "data";
    var TOKEN_BLOCK_START = "block-start";
    var TOKEN_BLOCK_END = "block-end";
    var TOKEN_VARIABLE_START = "variable-start";
    var TOKEN_VARIABLE_END = "variable-end";
    var TOKEN_COMMENT = "comment";
    var TOKEN_LEFT_PAREN = "left-paren";
    var TOKEN_RIGHT_PAREN = "right-paren";
    var TOKEN_LEFT_BRACKET = "left-bracket";
    var TOKEN_RIGHT_BRACKET = "right-bracket";
    var TOKEN_LEFT_CURLY = "left-curly";
    var TOKEN_RIGHT_CURLY = "right-curly";
    var TOKEN_OPERATOR = "operator";
    var TOKEN_COMMA = "comma";
    var TOKEN_COLON = "colon";
    var TOKEN_TILDE = "tilde";
    var TOKEN_PIPE = "pipe";
    var TOKEN_INT = "int";
    var TOKEN_FLOAT = "float";
    var TOKEN_BOOLEAN = "boolean";
    var TOKEN_NONE = "none";
    var TOKEN_SYMBOL = "symbol";
    var TOKEN_SPECIAL = "special";
    var TOKEN_REGEX = "regex";
    function token(type, value, lineno, colno) {
      return {
        type,
        value,
        lineno,
        colno
      };
    }
    var Tokenizer = /* @__PURE__ */ (function() {
      function Tokenizer2(str, opts) {
        this.str = str;
        this.index = 0;
        this.len = str.length;
        this.lineno = 0;
        this.colno = 0;
        this.in_code = false;
        opts = opts || {};
        var tags = opts.tags || {};
        this.tags = {
          BLOCK_START: tags.blockStart || BLOCK_START,
          BLOCK_END: tags.blockEnd || BLOCK_END,
          VARIABLE_START: tags.variableStart || VARIABLE_START,
          VARIABLE_END: tags.variableEnd || VARIABLE_END,
          COMMENT_START: tags.commentStart || COMMENT_START,
          COMMENT_END: tags.commentEnd || COMMENT_END
        };
        this.trimBlocks = !!opts.trimBlocks;
        this.lstripBlocks = !!opts.lstripBlocks;
      }
      var _proto = Tokenizer2.prototype;
      _proto.nextToken = function nextToken() {
        var lineno = this.lineno;
        var colno = this.colno;
        var tok;
        if (this.in_code) {
          var cur = this.current();
          if (this.isFinished()) {
            return null;
          } else if (cur === '"' || cur === "'") {
            return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
          } else if (tok = this._extract(whitespaceChars)) {
            return token(TOKEN_WHITESPACE, tok, lineno, colno);
          } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
            this.in_code = false;
            if (this.trimBlocks) {
              cur = this.current();
              if (cur === "\n") {
                this.forward();
              } else if (cur === "\r") {
                this.forward();
                cur = this.current();
                if (cur === "\n") {
                  this.forward();
                } else {
                  this.back();
                }
              }
            }
            return token(TOKEN_BLOCK_END, tok, lineno, colno);
          } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
            this.in_code = false;
            return token(TOKEN_VARIABLE_END, tok, lineno, colno);
          } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
            this.forwardN(2);
            var regexBody = "";
            while (!this.isFinished()) {
              if (this.current() === "/" && this.previous() !== "\\") {
                this.forward();
                break;
              } else {
                regexBody += this.current();
                this.forward();
              }
            }
            var POSSIBLE_FLAGS = ["g", "i", "m", "y"];
            var regexFlags = "";
            while (!this.isFinished()) {
              var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
              if (isCurrentAFlag) {
                regexFlags += this.current();
                this.forward();
              } else {
                break;
              }
            }
            return token(TOKEN_REGEX, {
              body: regexBody,
              flags: regexFlags
            }, lineno, colno);
          } else if (delimChars.indexOf(cur) !== -1) {
            this.forward();
            var complexOps = ["==", "===", "!=", "!==", "<=", ">=", "//", "**"];
            var curComplex = cur + this.current();
            var type;
            if (lib2.indexOf(complexOps, curComplex) !== -1) {
              this.forward();
              cur = curComplex;
              if (lib2.indexOf(complexOps, curComplex + this.current()) !== -1) {
                cur = curComplex + this.current();
                this.forward();
              }
            }
            switch (cur) {
              case "(":
                type = TOKEN_LEFT_PAREN;
                break;
              case ")":
                type = TOKEN_RIGHT_PAREN;
                break;
              case "[":
                type = TOKEN_LEFT_BRACKET;
                break;
              case "]":
                type = TOKEN_RIGHT_BRACKET;
                break;
              case "{":
                type = TOKEN_LEFT_CURLY;
                break;
              case "}":
                type = TOKEN_RIGHT_CURLY;
                break;
              case ",":
                type = TOKEN_COMMA;
                break;
              case ":":
                type = TOKEN_COLON;
                break;
              case "~":
                type = TOKEN_TILDE;
                break;
              case "|":
                type = TOKEN_PIPE;
                break;
              default:
                type = TOKEN_OPERATOR;
            }
            return token(type, cur, lineno, colno);
          } else {
            tok = this._extractUntil(whitespaceChars + delimChars);
            if (tok.match(/^[-+]?[0-9]+$/)) {
              if (this.current() === ".") {
                this.forward();
                var dec = this._extract(intChars);
                return token(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
              } else {
                return token(TOKEN_INT, tok, lineno, colno);
              }
            } else if (tok.match(/^(true|false)$/)) {
              return token(TOKEN_BOOLEAN, tok, lineno, colno);
            } else if (tok === "none") {
              return token(TOKEN_NONE, tok, lineno, colno);
            } else if (tok === "null") {
              return token(TOKEN_NONE, tok, lineno, colno);
            } else if (tok) {
              return token(TOKEN_SYMBOL, tok, lineno, colno);
            } else {
              throw new Error("Unexpected value while parsing: " + tok);
            }
          }
        } else {
          var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
          if (this.isFinished()) {
            return null;
          } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
            this.in_code = true;
            return token(TOKEN_BLOCK_START, tok, lineno, colno);
          } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
            this.in_code = true;
            return token(TOKEN_VARIABLE_START, tok, lineno, colno);
          } else {
            tok = "";
            var data;
            var inComment = false;
            if (this._matches(this.tags.COMMENT_START)) {
              inComment = true;
              tok = this._extractString(this.tags.COMMENT_START);
            }
            while ((data = this._extractUntil(beginChars)) !== null) {
              tok += data;
              if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                  var lastLine = tok.slice(-this.colno);
                  if (/^\s+$/.test(lastLine)) {
                    tok = tok.slice(0, -this.colno);
                    if (!tok.length) {
                      return this.nextToken();
                    }
                  }
                }
                break;
              } else if (this._matches(this.tags.COMMENT_END)) {
                if (!inComment) {
                  throw new Error("unexpected end of comment");
                }
                tok += this._extractString(this.tags.COMMENT_END);
                break;
              } else {
                tok += this.current();
                this.forward();
              }
            }
            if (data === null && inComment) {
              throw new Error("expected end of comment, got end of file");
            }
            return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
          }
        }
      };
      _proto._parseString = function _parseString(delimiter) {
        this.forward();
        var str = "";
        while (!this.isFinished() && this.current() !== delimiter) {
          var cur = this.current();
          if (cur === "\\") {
            this.forward();
            switch (this.current()) {
              case "n":
                str += "\n";
                break;
              case "t":
                str += "	";
                break;
              case "r":
                str += "\r";
                break;
              default:
                str += this.current();
            }
            this.forward();
          } else {
            str += cur;
            this.forward();
          }
        }
        this.forward();
        return str;
      };
      _proto._matches = function _matches(str) {
        if (this.index + str.length > this.len) {
          return null;
        }
        var m = this.str.slice(this.index, this.index + str.length);
        return m === str;
      };
      _proto._extractString = function _extractString(str) {
        if (this._matches(str)) {
          this.forwardN(str.length);
          return str;
        }
        return null;
      };
      _proto._extractUntil = function _extractUntil(charString) {
        return this._extractMatching(true, charString || "");
      };
      _proto._extract = function _extract(charString) {
        return this._extractMatching(false, charString);
      };
      _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
        if (this.isFinished()) {
          return null;
        }
        var first = charString.indexOf(this.current());
        if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
          var t = this.current();
          this.forward();
          var idx = charString.indexOf(this.current());
          while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
            t += this.current();
            this.forward();
            idx = charString.indexOf(this.current());
          }
          return t;
        }
        return "";
      };
      _proto._extractRegex = function _extractRegex(regex) {
        var matches = this.currentStr().match(regex);
        if (!matches) {
          return null;
        }
        this.forwardN(matches[0].length);
        return matches;
      };
      _proto.isFinished = function isFinished() {
        return this.index >= this.len;
      };
      _proto.forwardN = function forwardN(n2) {
        for (var i2 = 0; i2 < n2; i2++) {
          this.forward();
        }
      };
      _proto.forward = function forward() {
        this.index++;
        if (this.previous() === "\n") {
          this.lineno++;
          this.colno = 0;
        } else {
          this.colno++;
        }
      };
      _proto.backN = function backN(n2) {
        for (var i2 = 0; i2 < n2; i2++) {
          this.back();
        }
      };
      _proto.back = function back() {
        this.index--;
        if (this.current() === "\n") {
          this.lineno--;
          var idx = this.src.lastIndexOf("\n", this.index - 1);
          if (idx === -1) {
            this.colno = this.index;
          } else {
            this.colno = this.index - idx;
          }
        } else {
          this.colno--;
        }
      };
      _proto.current = function current() {
        if (!this.isFinished()) {
          return this.str.charAt(this.index);
        }
        return "";
      };
      _proto.currentStr = function currentStr() {
        if (!this.isFinished()) {
          return this.str.substr(this.index);
        }
        return "";
      };
      _proto.previous = function previous() {
        return this.str.charAt(this.index - 1);
      };
      return Tokenizer2;
    })();
    module2.exports = {
      lex: function lex(src, opts) {
        return new Tokenizer(src, opts);
      },
      TOKEN_STRING,
      TOKEN_WHITESPACE,
      TOKEN_DATA,
      TOKEN_BLOCK_START,
      TOKEN_BLOCK_END,
      TOKEN_VARIABLE_START,
      TOKEN_VARIABLE_END,
      TOKEN_COMMENT,
      TOKEN_LEFT_PAREN,
      TOKEN_RIGHT_PAREN,
      TOKEN_LEFT_BRACKET,
      TOKEN_RIGHT_BRACKET,
      TOKEN_LEFT_CURLY,
      TOKEN_RIGHT_CURLY,
      TOKEN_OPERATOR,
      TOKEN_COMMA,
      TOKEN_COLON,
      TOKEN_TILDE,
      TOKEN_PIPE,
      TOKEN_INT,
      TOKEN_FLOAT,
      TOKEN_BOOLEAN,
      TOKEN_NONE,
      TOKEN_SYMBOL,
      TOKEN_SPECIAL,
      TOKEN_REGEX
    };
  }
});

// node_modules/nunjucks/src/object.js
var require_object = __commonJS({
  "node_modules/nunjucks/src/object.js"(exports2, module2) {
    "use strict";
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var EventEmitter6 = require("events");
    var lib2 = require_lib2();
    function parentWrap(parent, prop) {
      if (typeof parent !== "function" || typeof prop !== "function") {
        return prop;
      }
      return function wrap() {
        var tmp = this.parent;
        this.parent = parent;
        var res = prop.apply(this, arguments);
        this.parent = tmp;
        return res;
      };
    }
    function extendClass(cls, name, props) {
      props = props || {};
      lib2.keys(props).forEach(function(k) {
        props[k] = parentWrap(cls.prototype[k], props[k]);
      });
      var subclass = /* @__PURE__ */ (function(_cls) {
        _inheritsLoose(subclass2, _cls);
        function subclass2() {
          return _cls.apply(this, arguments) || this;
        }
        _createClass(subclass2, [{
          key: "typename",
          get: function get() {
            return name;
          }
        }]);
        return subclass2;
      })(cls);
      lib2._assign(subclass.prototype, props);
      return subclass;
    }
    var Obj = /* @__PURE__ */ (function() {
      function Obj2() {
        this.init.apply(this, arguments);
      }
      var _proto = Obj2.prototype;
      _proto.init = function init() {
      };
      Obj2.extend = function extend2(name, props) {
        if (typeof name === "object") {
          props = name;
          name = "anonymous";
        }
        return extendClass(this, name, props);
      };
      _createClass(Obj2, [{
        key: "typename",
        get: function get() {
          return this.constructor.name;
        }
      }]);
      return Obj2;
    })();
    var EmitterObj = /* @__PURE__ */ (function(_EventEmitter) {
      _inheritsLoose(EmitterObj2, _EventEmitter);
      function EmitterObj2() {
        var _this2;
        var _this;
        _this = _EventEmitter.call(this) || this;
        (_this2 = _this).init.apply(_this2, arguments);
        return _this;
      }
      var _proto2 = EmitterObj2.prototype;
      _proto2.init = function init() {
      };
      EmitterObj2.extend = function extend2(name, props) {
        if (typeof name === "object") {
          props = name;
          name = "anonymous";
        }
        return extendClass(this, name, props);
      };
      _createClass(EmitterObj2, [{
        key: "typename",
        get: function get() {
          return this.constructor.name;
        }
      }]);
      return EmitterObj2;
    })(EventEmitter6);
    module2.exports = {
      Obj,
      EmitterObj
    };
  }
});

// node_modules/nunjucks/src/nodes.js
var require_nodes = __commonJS({
  "node_modules/nunjucks/src/nodes.js"(exports2, module2) {
    "use strict";
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var _require = require_object();
    var Obj = _require.Obj;
    function traverseAndCheck(obj, type, results) {
      if (obj instanceof type) {
        results.push(obj);
      }
      if (obj instanceof Node) {
        obj.findAll(type, results);
      }
    }
    var Node = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Node2, _Obj);
      function Node2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto = Node2.prototype;
      _proto.init = function init(lineno, colno) {
        var _arguments = arguments, _this = this;
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        this.lineno = lineno;
        this.colno = colno;
        this.fields.forEach(function(field, i2) {
          var val = _arguments[i2 + 2];
          if (val === void 0) {
            val = null;
          }
          _this[field] = val;
        });
      };
      _proto.findAll = function findAll(type, results) {
        var _this2 = this;
        results = results || [];
        if (this instanceof NodeList) {
          this.children.forEach(function(child) {
            return traverseAndCheck(child, type, results);
          });
        } else {
          this.fields.forEach(function(field) {
            return traverseAndCheck(_this2[field], type, results);
          });
        }
        return results;
      };
      _proto.iterFields = function iterFields(func) {
        var _this3 = this;
        this.fields.forEach(function(field) {
          func(_this3[field], field);
        });
      };
      return Node2;
    })(Obj);
    var Value = /* @__PURE__ */ (function(_Node) {
      _inheritsLoose(Value2, _Node);
      function Value2() {
        return _Node.apply(this, arguments) || this;
      }
      _createClass(Value2, [{
        key: "typename",
        get: function get() {
          return "Value";
        }
      }, {
        key: "fields",
        get: function get() {
          return ["value"];
        }
      }]);
      return Value2;
    })(Node);
    var NodeList = /* @__PURE__ */ (function(_Node2) {
      _inheritsLoose(NodeList2, _Node2);
      function NodeList2() {
        return _Node2.apply(this, arguments) || this;
      }
      var _proto2 = NodeList2.prototype;
      _proto2.init = function init(lineno, colno, nodes) {
        _Node2.prototype.init.call(this, lineno, colno, nodes || []);
      };
      _proto2.addChild = function addChild2(node) {
        this.children.push(node);
      };
      _createClass(NodeList2, [{
        key: "typename",
        get: function get() {
          return "NodeList";
        }
      }, {
        key: "fields",
        get: function get() {
          return ["children"];
        }
      }]);
      return NodeList2;
    })(Node);
    var Root = NodeList.extend("Root");
    var Literal = Value.extend("Literal");
    var _Symbol = Value.extend("Symbol");
    var Group = NodeList.extend("Group");
    var ArrayNode = NodeList.extend("Array");
    var Pair = Node.extend("Pair", {
      fields: ["key", "value"]
    });
    var Dict = NodeList.extend("Dict");
    var LookupVal = Node.extend("LookupVal", {
      fields: ["target", "val"]
    });
    var If = Node.extend("If", {
      fields: ["cond", "body", "else_"]
    });
    var IfAsync = If.extend("IfAsync");
    var InlineIf = Node.extend("InlineIf", {
      fields: ["cond", "body", "else_"]
    });
    var For = Node.extend("For", {
      fields: ["arr", "name", "body", "else_"]
    });
    var AsyncEach = For.extend("AsyncEach");
    var AsyncAll = For.extend("AsyncAll");
    var Macro = Node.extend("Macro", {
      fields: ["name", "args", "body"]
    });
    var Caller = Macro.extend("Caller");
    var Import = Node.extend("Import", {
      fields: ["template", "target", "withContext"]
    });
    var FromImport = /* @__PURE__ */ (function(_Node3) {
      _inheritsLoose(FromImport2, _Node3);
      function FromImport2() {
        return _Node3.apply(this, arguments) || this;
      }
      var _proto3 = FromImport2.prototype;
      _proto3.init = function init(lineno, colno, template, names, withContext) {
        _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
      };
      _createClass(FromImport2, [{
        key: "typename",
        get: function get() {
          return "FromImport";
        }
      }, {
        key: "fields",
        get: function get() {
          return ["template", "names", "withContext"];
        }
      }]);
      return FromImport2;
    })(Node);
    var FunCall = Node.extend("FunCall", {
      fields: ["name", "args"]
    });
    var Filter = FunCall.extend("Filter");
    var FilterAsync = Filter.extend("FilterAsync", {
      fields: ["name", "args", "symbol"]
    });
    var KeywordArgs = Dict.extend("KeywordArgs");
    var Block = Node.extend("Block", {
      fields: ["name", "body"]
    });
    var Super = Node.extend("Super", {
      fields: ["blockName", "symbol"]
    });
    var TemplateRef = Node.extend("TemplateRef", {
      fields: ["template"]
    });
    var Extends = TemplateRef.extend("Extends");
    var Include = Node.extend("Include", {
      fields: ["template", "ignoreMissing"]
    });
    var Set2 = Node.extend("Set", {
      fields: ["targets", "value"]
    });
    var Switch = Node.extend("Switch", {
      fields: ["expr", "cases", "default"]
    });
    var Case = Node.extend("Case", {
      fields: ["cond", "body"]
    });
    var Output = NodeList.extend("Output");
    var Capture = Node.extend("Capture", {
      fields: ["body"]
    });
    var TemplateData = Literal.extend("TemplateData");
    var UnaryOp = Node.extend("UnaryOp", {
      fields: ["target"]
    });
    var BinOp = Node.extend("BinOp", {
      fields: ["left", "right"]
    });
    var In = BinOp.extend("In");
    var Is = BinOp.extend("Is");
    var Or = BinOp.extend("Or");
    var And = BinOp.extend("And");
    var Not = UnaryOp.extend("Not");
    var Add = BinOp.extend("Add");
    var Concat = BinOp.extend("Concat");
    var Sub = BinOp.extend("Sub");
    var Mul = BinOp.extend("Mul");
    var Div = BinOp.extend("Div");
    var FloorDiv = BinOp.extend("FloorDiv");
    var Mod = BinOp.extend("Mod");
    var Pow = BinOp.extend("Pow");
    var Neg = UnaryOp.extend("Neg");
    var Pos = UnaryOp.extend("Pos");
    var Compare = Node.extend("Compare", {
      fields: ["expr", "ops"]
    });
    var CompareOperand = Node.extend("CompareOperand", {
      fields: ["expr", "type"]
    });
    var CallExtension = Node.extend("CallExtension", {
      init: function init(ext2, prop, args, contentArgs) {
        this.parent();
        this.extName = ext2.__name || ext2;
        this.prop = prop;
        this.args = args || new NodeList();
        this.contentArgs = contentArgs || [];
        this.autoescape = ext2.autoescape;
      },
      fields: ["extName", "prop", "args", "contentArgs"]
    });
    var CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
    function print(str, indent, inline2) {
      var lines = str.split("\n");
      lines.forEach(function(line, i2) {
        if (line && (inline2 && i2 > 0 || !inline2)) {
          process.stdout.write(" ".repeat(indent));
        }
        var nl = i2 === lines.length - 1 ? "" : "\n";
        process.stdout.write("" + line + nl);
      });
    }
    function printNodes(node, indent) {
      indent = indent || 0;
      print(node.typename + ": ", indent);
      if (node instanceof NodeList) {
        print("\n");
        node.children.forEach(function(n2) {
          printNodes(n2, indent + 2);
        });
      } else if (node instanceof CallExtension) {
        print(node.extName + "." + node.prop + "\n");
        if (node.args) {
          printNodes(node.args, indent + 2);
        }
        if (node.contentArgs) {
          node.contentArgs.forEach(function(n2) {
            printNodes(n2, indent + 2);
          });
        }
      } else {
        var nodes = [];
        var props = null;
        node.iterFields(function(val, fieldName) {
          if (val instanceof Node) {
            nodes.push([fieldName, val]);
          } else {
            props = props || {};
            props[fieldName] = val;
          }
        });
        if (props) {
          print(JSON.stringify(props, null, 2) + "\n", null, true);
        } else {
          print("\n");
        }
        nodes.forEach(function(_ref) {
          var fieldName = _ref[0], n2 = _ref[1];
          print("[" + fieldName + "] =>", indent + 2);
          printNodes(n2, indent + 4);
        });
      }
    }
    module2.exports = {
      Node,
      Root,
      NodeList,
      Value,
      Literal,
      Symbol: _Symbol,
      Group,
      Array: ArrayNode,
      Pair,
      Dict,
      Output,
      Capture,
      TemplateData,
      If,
      IfAsync,
      InlineIf,
      For,
      AsyncEach,
      AsyncAll,
      Macro,
      Caller,
      Import,
      FromImport,
      FunCall,
      Filter,
      FilterAsync,
      KeywordArgs,
      Block,
      Super,
      Extends,
      Include,
      Set: Set2,
      Switch,
      Case,
      LookupVal,
      BinOp,
      In,
      Is,
      Or,
      And,
      Not,
      Add,
      Concat,
      Sub,
      Mul,
      Div,
      FloorDiv,
      Mod,
      Pow,
      Neg,
      Pos,
      Compare,
      CompareOperand,
      CallExtension,
      CallExtensionAsync,
      printNodes
    };
  }
});

// node_modules/nunjucks/src/parser.js
var require_parser = __commonJS({
  "node_modules/nunjucks/src/parser.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var lexer = require_lexer();
    var nodes = require_nodes();
    var Obj = require_object().Obj;
    var lib2 = require_lib2();
    var Parser = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Parser2, _Obj);
      function Parser2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto = Parser2.prototype;
      _proto.init = function init(tokens) {
        this.tokens = tokens;
        this.peeked = null;
        this.breakOnBlocks = null;
        this.dropLeadingWhitespace = false;
        this.extensions = [];
      };
      _proto.nextToken = function nextToken(withWhitespace) {
        var tok;
        if (this.peeked) {
          if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
            this.peeked = null;
          } else {
            tok = this.peeked;
            this.peeked = null;
            return tok;
          }
        }
        tok = this.tokens.nextToken();
        if (!withWhitespace) {
          while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
            tok = this.tokens.nextToken();
          }
        }
        return tok;
      };
      _proto.peekToken = function peekToken() {
        this.peeked = this.peeked || this.nextToken();
        return this.peeked;
      };
      _proto.pushToken = function pushToken(tok) {
        if (this.peeked) {
          throw new Error("pushToken: can only push one token on between reads");
        }
        this.peeked = tok;
      };
      _proto.error = function error(msg, lineno, colno) {
        if (lineno === void 0 || colno === void 0) {
          var tok = this.peekToken() || {};
          lineno = tok.lineno;
          colno = tok.colno;
        }
        if (lineno !== void 0) {
          lineno += 1;
        }
        if (colno !== void 0) {
          colno += 1;
        }
        return new lib2.TemplateError(msg, lineno, colno);
      };
      _proto.fail = function fail(msg, lineno, colno) {
        throw this.error(msg, lineno, colno);
      };
      _proto.skip = function skip(type) {
        var tok = this.nextToken();
        if (!tok || tok.type !== type) {
          this.pushToken(tok);
          return false;
        }
        return true;
      };
      _proto.expect = function expect(type) {
        var tok = this.nextToken();
        if (tok.type !== type) {
          this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
        }
        return tok;
      };
      _proto.skipValue = function skipValue(type, val) {
        var tok = this.nextToken();
        if (!tok || tok.type !== type || tok.value !== val) {
          this.pushToken(tok);
          return false;
        }
        return true;
      };
      _proto.skipSymbol = function skipSymbol(val) {
        return this.skipValue(lexer.TOKEN_SYMBOL, val);
      };
      _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
        var tok;
        if (!name) {
          tok = this.peekToken();
          if (!tok) {
            this.fail("unexpected end of file");
          }
          if (tok.type !== lexer.TOKEN_SYMBOL) {
            this.fail("advanceAfterBlockEnd: expected symbol token or explicit name to be passed");
          }
          name = this.nextToken().value;
        }
        tok = this.nextToken();
        if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
          if (tok.value.charAt(0) === "-") {
            this.dropLeadingWhitespace = true;
          }
        } else {
          this.fail("expected block end in " + name + " statement");
        }
        return tok;
      };
      _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
        var tok = this.nextToken();
        if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
          this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
        } else {
          this.pushToken(tok);
          this.fail("expected variable end");
        }
      };
      _proto.parseFor = function parseFor() {
        var forTok = this.peekToken();
        var node;
        var endBlock;
        if (this.skipSymbol("for")) {
          node = new nodes.For(forTok.lineno, forTok.colno);
          endBlock = "endfor";
        } else if (this.skipSymbol("asyncEach")) {
          node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
          endBlock = "endeach";
        } else if (this.skipSymbol("asyncAll")) {
          node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
          endBlock = "endall";
        } else {
          this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
        }
        node.name = this.parsePrimary();
        if (!(node.name instanceof nodes.Symbol)) {
          this.fail("parseFor: variable name expected for loop");
        }
        var type = this.peekToken().type;
        if (type === lexer.TOKEN_COMMA) {
          var key = node.name;
          node.name = new nodes.Array(key.lineno, key.colno);
          node.name.addChild(key);
          while (this.skip(lexer.TOKEN_COMMA)) {
            var prim = this.parsePrimary();
            node.name.addChild(prim);
          }
        }
        if (!this.skipSymbol("in")) {
          this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
        }
        node.arr = this.parseExpression();
        this.advanceAfterBlockEnd(forTok.value);
        node.body = this.parseUntilBlocks(endBlock, "else");
        if (this.skipSymbol("else")) {
          this.advanceAfterBlockEnd("else");
          node.else_ = this.parseUntilBlocks(endBlock);
        }
        this.advanceAfterBlockEnd();
        return node;
      };
      _proto.parseMacro = function parseMacro() {
        var macroTok = this.peekToken();
        if (!this.skipSymbol("macro")) {
          this.fail("expected macro");
        }
        var name = this.parsePrimary(true);
        var args = this.parseSignature();
        var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
        this.advanceAfterBlockEnd(macroTok.value);
        node.body = this.parseUntilBlocks("endmacro");
        this.advanceAfterBlockEnd();
        return node;
      };
      _proto.parseCall = function parseCall() {
        var callTok = this.peekToken();
        if (!this.skipSymbol("call")) {
          this.fail("expected call");
        }
        var callerArgs = this.parseSignature(true) || new nodes.NodeList();
        var macroCall = this.parsePrimary();
        this.advanceAfterBlockEnd(callTok.value);
        var body = this.parseUntilBlocks("endcall");
        this.advanceAfterBlockEnd();
        var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, "caller");
        var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
        var args = macroCall.args.children;
        if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
          args.push(new nodes.KeywordArgs());
        }
        var kwargs = args[args.length - 1];
        kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
        return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
      };
      _proto.parseWithContext = function parseWithContext() {
        var tok = this.peekToken();
        var withContext = null;
        if (this.skipSymbol("with")) {
          withContext = true;
        } else if (this.skipSymbol("without")) {
          withContext = false;
        }
        if (withContext !== null) {
          if (!this.skipSymbol("context")) {
            this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
          }
        }
        return withContext;
      };
      _proto.parseImport = function parseImport() {
        var importTok = this.peekToken();
        if (!this.skipSymbol("import")) {
          this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
        }
        var template = this.parseExpression();
        if (!this.skipSymbol("as")) {
          this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
        }
        var target = this.parseExpression();
        var withContext = this.parseWithContext();
        var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
        this.advanceAfterBlockEnd(importTok.value);
        return node;
      };
      _proto.parseFrom = function parseFrom() {
        var fromTok = this.peekToken();
        if (!this.skipSymbol("from")) {
          this.fail("parseFrom: expected from");
        }
        var template = this.parseExpression();
        if (!this.skipSymbol("import")) {
          this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
        }
        var names = new nodes.NodeList();
        var withContext;
        while (1) {
          var nextTok = this.peekToken();
          if (nextTok.type === lexer.TOKEN_BLOCK_END) {
            if (!names.children.length) {
              this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
            }
            if (nextTok.value.charAt(0) === "-") {
              this.dropLeadingWhitespace = true;
            }
            this.nextToken();
            break;
          }
          if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
            this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
          }
          var name = this.parsePrimary();
          if (name.value.charAt(0) === "_") {
            this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
          }
          if (this.skipSymbol("as")) {
            var alias = this.parsePrimary();
            names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
          } else {
            names.addChild(name);
          }
          withContext = this.parseWithContext();
        }
        return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
      };
      _proto.parseBlock = function parseBlock() {
        var tag = this.peekToken();
        if (!this.skipSymbol("block")) {
          this.fail("parseBlock: expected block", tag.lineno, tag.colno);
        }
        var node = new nodes.Block(tag.lineno, tag.colno);
        node.name = this.parsePrimary();
        if (!(node.name instanceof nodes.Symbol)) {
          this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
        }
        this.advanceAfterBlockEnd(tag.value);
        node.body = this.parseUntilBlocks("endblock");
        this.skipSymbol("endblock");
        this.skipSymbol(node.name.value);
        var tok = this.peekToken();
        if (!tok) {
          this.fail("parseBlock: expected endblock, got end of file");
        }
        this.advanceAfterBlockEnd(tok.value);
        return node;
      };
      _proto.parseExtends = function parseExtends() {
        var tagName = "extends";
        var tag = this.peekToken();
        if (!this.skipSymbol(tagName)) {
          this.fail("parseTemplateRef: expected " + tagName);
        }
        var node = new nodes.Extends(tag.lineno, tag.colno);
        node.template = this.parseExpression();
        this.advanceAfterBlockEnd(tag.value);
        return node;
      };
      _proto.parseInclude = function parseInclude() {
        var tagName = "include";
        var tag = this.peekToken();
        if (!this.skipSymbol(tagName)) {
          this.fail("parseInclude: expected " + tagName);
        }
        var node = new nodes.Include(tag.lineno, tag.colno);
        node.template = this.parseExpression();
        if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
          node.ignoreMissing = true;
        }
        this.advanceAfterBlockEnd(tag.value);
        return node;
      };
      _proto.parseIf = function parseIf() {
        var tag = this.peekToken();
        var node;
        if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
          node = new nodes.If(tag.lineno, tag.colno);
        } else if (this.skipSymbol("ifAsync")) {
          node = new nodes.IfAsync(tag.lineno, tag.colno);
        } else {
          this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
        }
        node.cond = this.parseExpression();
        this.advanceAfterBlockEnd(tag.value);
        node.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
        var tok = this.peekToken();
        switch (tok && tok.value) {
          case "elseif":
          case "elif":
            node.else_ = this.parseIf();
            break;
          case "else":
            this.advanceAfterBlockEnd();
            node.else_ = this.parseUntilBlocks("endif");
            this.advanceAfterBlockEnd();
            break;
          case "endif":
            node.else_ = null;
            this.advanceAfterBlockEnd();
            break;
          default:
            this.fail("parseIf: expected elif, else, or endif, got end of file");
        }
        return node;
      };
      _proto.parseSet = function parseSet() {
        var tag = this.peekToken();
        if (!this.skipSymbol("set")) {
          this.fail("parseSet: expected set", tag.lineno, tag.colno);
        }
        var node = new nodes.Set(tag.lineno, tag.colno, []);
        var target;
        while (target = this.parsePrimary()) {
          node.targets.push(target);
          if (!this.skip(lexer.TOKEN_COMMA)) {
            break;
          }
        }
        if (!this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
          if (!this.skip(lexer.TOKEN_BLOCK_END)) {
            this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
          } else {
            node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
            node.value = null;
            this.advanceAfterBlockEnd();
          }
        } else {
          node.value = this.parseExpression();
          this.advanceAfterBlockEnd(tag.value);
        }
        return node;
      };
      _proto.parseSwitch = function parseSwitch() {
        var switchStart = "switch";
        var switchEnd = "endswitch";
        var caseStart = "case";
        var caseDefault = "default";
        var tag = this.peekToken();
        if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
          this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
        }
        var expr = this.parseExpression();
        this.advanceAfterBlockEnd(switchStart);
        this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
        var tok = this.peekToken();
        var cases = [];
        var defaultCase;
        do {
          this.skipSymbol(caseStart);
          var cond = this.parseExpression();
          this.advanceAfterBlockEnd(switchStart);
          var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
          cases.push(new nodes.Case(tok.line, tok.col, cond, body));
          tok = this.peekToken();
        } while (tok && tok.value === caseStart);
        switch (tok.value) {
          case caseDefault:
            this.advanceAfterBlockEnd();
            defaultCase = this.parseUntilBlocks(switchEnd);
            this.advanceAfterBlockEnd();
            break;
          case switchEnd:
            this.advanceAfterBlockEnd();
            break;
          default:
            this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
        }
        return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
      };
      _proto.parseStatement = function parseStatement() {
        var tok = this.peekToken();
        var node;
        if (tok.type !== lexer.TOKEN_SYMBOL) {
          this.fail("tag name expected", tok.lineno, tok.colno);
        }
        if (this.breakOnBlocks && lib2.indexOf(this.breakOnBlocks, tok.value) !== -1) {
          return null;
        }
        switch (tok.value) {
          case "raw":
            return this.parseRaw();
          case "verbatim":
            return this.parseRaw("verbatim");
          case "if":
          case "ifAsync":
            return this.parseIf();
          case "for":
          case "asyncEach":
          case "asyncAll":
            return this.parseFor();
          case "block":
            return this.parseBlock();
          case "extends":
            return this.parseExtends();
          case "include":
            return this.parseInclude();
          case "set":
            return this.parseSet();
          case "macro":
            return this.parseMacro();
          case "call":
            return this.parseCall();
          case "import":
            return this.parseImport();
          case "from":
            return this.parseFrom();
          case "filter":
            return this.parseFilterStatement();
          case "switch":
            return this.parseSwitch();
          default:
            if (this.extensions.length) {
              for (var i2 = 0; i2 < this.extensions.length; i2++) {
                var ext2 = this.extensions[i2];
                if (lib2.indexOf(ext2.tags || [], tok.value) !== -1) {
                  return ext2.parse(this, nodes, lexer);
                }
              }
            }
            this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
        }
        return node;
      };
      _proto.parseRaw = function parseRaw(tagName) {
        tagName = tagName || "raw";
        var endTagName = "end" + tagName;
        var rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
        var rawLevel = 1;
        var str = "";
        var matches = null;
        var begun = this.advanceAfterBlockEnd();
        while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
          var all3 = matches[0];
          var pre = matches[1];
          var blockName = matches[2];
          if (blockName === tagName) {
            rawLevel += 1;
          } else if (blockName === endTagName) {
            rawLevel -= 1;
          }
          if (rawLevel === 0) {
            str += pre;
            this.tokens.backN(all3.length - pre.length);
          } else {
            str += all3;
          }
        }
        return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
      };
      _proto.parsePostfix = function parsePostfix(node) {
        var lookup;
        var tok = this.peekToken();
        while (tok) {
          if (tok.type === lexer.TOKEN_LEFT_PAREN) {
            node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
          } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
            lookup = this.parseAggregate();
            if (lookup.children.length > 1) {
              this.fail("invalid index");
            }
            node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
          } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === ".") {
            this.nextToken();
            var val = this.nextToken();
            if (val.type !== lexer.TOKEN_SYMBOL) {
              this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
            }
            lookup = new nodes.Literal(val.lineno, val.colno, val.value);
            node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
          } else {
            break;
          }
          tok = this.peekToken();
        }
        return node;
      };
      _proto.parseExpression = function parseExpression2() {
        var node = this.parseInlineIf();
        return node;
      };
      _proto.parseInlineIf = function parseInlineIf() {
        var node = this.parseOr();
        if (this.skipSymbol("if")) {
          var condNode = this.parseOr();
          var bodyNode = node;
          node = new nodes.InlineIf(node.lineno, node.colno);
          node.body = bodyNode;
          node.cond = condNode;
          if (this.skipSymbol("else")) {
            node.else_ = this.parseOr();
          } else {
            node.else_ = null;
          }
        }
        return node;
      };
      _proto.parseOr = function parseOr() {
        var node = this.parseAnd();
        while (this.skipSymbol("or")) {
          var node2 = this.parseAnd();
          node = new nodes.Or(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseAnd = function parseAnd() {
        var node = this.parseNot();
        while (this.skipSymbol("and")) {
          var node2 = this.parseNot();
          node = new nodes.And(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseNot = function parseNot() {
        var tok = this.peekToken();
        if (this.skipSymbol("not")) {
          return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
        }
        return this.parseIn();
      };
      _proto.parseIn = function parseIn() {
        var node = this.parseIs();
        while (1) {
          var tok = this.nextToken();
          if (!tok) {
            break;
          }
          var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === "not";
          if (!invert) {
            this.pushToken(tok);
          }
          if (this.skipSymbol("in")) {
            var node2 = this.parseIs();
            node = new nodes.In(node.lineno, node.colno, node, node2);
            if (invert) {
              node = new nodes.Not(node.lineno, node.colno, node);
            }
          } else {
            if (invert) {
              this.pushToken(tok);
            }
            break;
          }
        }
        return node;
      };
      _proto.parseIs = function parseIs() {
        var node = this.parseCompare();
        if (this.skipSymbol("is")) {
          var not = this.skipSymbol("not");
          var node2 = this.parseCompare();
          node = new nodes.Is(node.lineno, node.colno, node, node2);
          if (not) {
            node = new nodes.Not(node.lineno, node.colno, node);
          }
        }
        return node;
      };
      _proto.parseCompare = function parseCompare() {
        var compareOps = ["==", "===", "!=", "!==", "<", ">", "<=", ">="];
        var expr = this.parseConcat();
        var ops = [];
        while (1) {
          var tok = this.nextToken();
          if (!tok) {
            break;
          } else if (compareOps.indexOf(tok.value) !== -1) {
            ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
          } else {
            this.pushToken(tok);
            break;
          }
        }
        if (ops.length) {
          return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
        } else {
          return expr;
        }
      };
      _proto.parseConcat = function parseConcat() {
        var node = this.parseAdd();
        while (this.skipValue(lexer.TOKEN_TILDE, "~")) {
          var node2 = this.parseAdd();
          node = new nodes.Concat(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseAdd = function parseAdd() {
        var node = this.parseSub();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
          var node2 = this.parseSub();
          node = new nodes.Add(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseSub = function parseSub() {
        var node = this.parseMul();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
          var node2 = this.parseMul();
          node = new nodes.Sub(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseMul = function parseMul() {
        var node = this.parseDiv();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "*")) {
          var node2 = this.parseDiv();
          node = new nodes.Mul(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseDiv = function parseDiv() {
        var node = this.parseFloorDiv();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "/")) {
          var node2 = this.parseFloorDiv();
          node = new nodes.Div(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseFloorDiv = function parseFloorDiv() {
        var node = this.parseMod();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "//")) {
          var node2 = this.parseMod();
          node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseMod = function parseMod() {
        var node = this.parsePow();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "%")) {
          var node2 = this.parsePow();
          node = new nodes.Mod(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parsePow = function parsePow() {
        var node = this.parseUnary();
        while (this.skipValue(lexer.TOKEN_OPERATOR, "**")) {
          var node2 = this.parseUnary();
          node = new nodes.Pow(node.lineno, node.colno, node, node2);
        }
        return node;
      };
      _proto.parseUnary = function parseUnary(noFilters) {
        var tok = this.peekToken();
        var node;
        if (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
          node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
        } else if (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
          node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
        } else {
          node = this.parsePrimary();
        }
        if (!noFilters) {
          node = this.parseFilter(node);
        }
        return node;
      };
      _proto.parsePrimary = function parsePrimary(noPostfix) {
        var tok = this.nextToken();
        var val;
        var node = null;
        if (!tok) {
          this.fail("expected expression, got end of file");
        } else if (tok.type === lexer.TOKEN_STRING) {
          val = tok.value;
        } else if (tok.type === lexer.TOKEN_INT) {
          val = parseInt(tok.value, 10);
        } else if (tok.type === lexer.TOKEN_FLOAT) {
          val = parseFloat(tok.value);
        } else if (tok.type === lexer.TOKEN_BOOLEAN) {
          if (tok.value === "true") {
            val = true;
          } else if (tok.value === "false") {
            val = false;
          } else {
            this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
          }
        } else if (tok.type === lexer.TOKEN_NONE) {
          val = null;
        } else if (tok.type === lexer.TOKEN_REGEX) {
          val = new RegExp(tok.value.body, tok.value.flags);
        }
        if (val !== void 0) {
          node = new nodes.Literal(tok.lineno, tok.colno, val);
        } else if (tok.type === lexer.TOKEN_SYMBOL) {
          node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
        } else {
          this.pushToken(tok);
          node = this.parseAggregate();
        }
        if (!noPostfix) {
          node = this.parsePostfix(node);
        }
        if (node) {
          return node;
        } else {
          throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
        }
      };
      _proto.parseFilterName = function parseFilterName() {
        var tok = this.expect(lexer.TOKEN_SYMBOL);
        var name = tok.value;
        while (this.skipValue(lexer.TOKEN_OPERATOR, ".")) {
          name += "." + this.expect(lexer.TOKEN_SYMBOL).value;
        }
        return new nodes.Symbol(tok.lineno, tok.colno, name);
      };
      _proto.parseFilterArgs = function parseFilterArgs(node) {
        if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
          var call = this.parsePostfix(node);
          return call.args.children;
        }
        return [];
      };
      _proto.parseFilter = function parseFilter(node) {
        while (this.skip(lexer.TOKEN_PIPE)) {
          var name = this.parseFilterName();
          node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
        }
        return node;
      };
      _proto.parseFilterStatement = function parseFilterStatement() {
        var filterTok = this.peekToken();
        if (!this.skipSymbol("filter")) {
          this.fail("parseFilterStatement: expected filter");
        }
        var name = this.parseFilterName();
        var args = this.parseFilterArgs(name);
        this.advanceAfterBlockEnd(filterTok.value);
        var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
        this.advanceAfterBlockEnd();
        var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
        return new nodes.Output(name.lineno, name.colno, [node]);
      };
      _proto.parseAggregate = function parseAggregate() {
        var tok = this.nextToken();
        var node;
        switch (tok.type) {
          case lexer.TOKEN_LEFT_PAREN:
            node = new nodes.Group(tok.lineno, tok.colno);
            break;
          case lexer.TOKEN_LEFT_BRACKET:
            node = new nodes.Array(tok.lineno, tok.colno);
            break;
          case lexer.TOKEN_LEFT_CURLY:
            node = new nodes.Dict(tok.lineno, tok.colno);
            break;
          default:
            return null;
        }
        while (1) {
          var type = this.peekToken().type;
          if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
            this.nextToken();
            break;
          }
          if (node.children.length > 0) {
            if (!this.skip(lexer.TOKEN_COMMA)) {
              this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
            }
          }
          if (node instanceof nodes.Dict) {
            var key = this.parsePrimary();
            if (!this.skip(lexer.TOKEN_COLON)) {
              this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
            }
            var value = this.parseExpression();
            node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
          } else {
            var expr = this.parseExpression();
            node.addChild(expr);
          }
        }
        return node;
      };
      _proto.parseSignature = function parseSignature(tolerant, noParens) {
        var tok = this.peekToken();
        if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
          if (tolerant) {
            return null;
          } else {
            this.fail("expected arguments", tok.lineno, tok.colno);
          }
        }
        if (tok.type === lexer.TOKEN_LEFT_PAREN) {
          tok = this.nextToken();
        }
        var args = new nodes.NodeList(tok.lineno, tok.colno);
        var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
        var checkComma = false;
        while (1) {
          tok = this.peekToken();
          if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
            this.nextToken();
            break;
          } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
            break;
          }
          if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
            this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
          } else {
            var arg = this.parseExpression();
            if (this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
              kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
            } else {
              args.addChild(arg);
            }
          }
          checkComma = true;
        }
        if (kwargs.children.length) {
          args.addChild(kwargs);
        }
        return args;
      };
      _proto.parseUntilBlocks = function parseUntilBlocks() {
        var prev = this.breakOnBlocks;
        for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
          blockNames[_key] = arguments[_key];
        }
        this.breakOnBlocks = blockNames;
        var ret = this.parse();
        this.breakOnBlocks = prev;
        return ret;
      };
      _proto.parseNodes = function parseNodes() {
        var tok;
        var buf = [];
        while (tok = this.nextToken()) {
          if (tok.type === lexer.TOKEN_DATA) {
            var data = tok.value;
            var nextToken = this.peekToken();
            var nextVal = nextToken && nextToken.value;
            if (this.dropLeadingWhitespace) {
              data = data.replace(/^\s*/, "");
              this.dropLeadingWhitespace = false;
            }
            if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
              data = data.replace(/\s*$/, "");
            }
            buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
          } else if (tok.type === lexer.TOKEN_BLOCK_START) {
            this.dropLeadingWhitespace = false;
            var n2 = this.parseStatement();
            if (!n2) {
              break;
            }
            buf.push(n2);
          } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
            var e = this.parseExpression();
            this.dropLeadingWhitespace = false;
            this.advanceAfterVariableEnd();
            buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
          } else if (tok.type === lexer.TOKEN_COMMENT) {
            this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
          } else {
            this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
          }
        }
        return buf;
      };
      _proto.parse = function parse() {
        return new nodes.NodeList(0, 0, this.parseNodes());
      };
      _proto.parseAsRoot = function parseAsRoot() {
        return new nodes.Root(0, 0, this.parseNodes());
      };
      return Parser2;
    })(Obj);
    module2.exports = {
      parse: function parse(src, extensions2, opts) {
        var p = new Parser(lexer.lex(src, opts));
        if (extensions2 !== void 0) {
          p.extensions = extensions2;
        }
        return p.parseAsRoot();
      },
      Parser
    };
  }
});

// node_modules/nunjucks/src/transformer.js
var require_transformer = __commonJS({
  "node_modules/nunjucks/src/transformer.js"(exports2, module2) {
    "use strict";
    var nodes = require_nodes();
    var lib2 = require_lib2();
    var sym = 0;
    function gensym() {
      return "hole_" + sym++;
    }
    function mapCOW(arr, func) {
      var res = null;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = func(arr[i2]);
        if (item !== arr[i2]) {
          if (!res) {
            res = arr.slice();
          }
          res[i2] = item;
        }
      }
      return res || arr;
    }
    function walk(ast, func, depthFirst) {
      if (!(ast instanceof nodes.Node)) {
        return ast;
      }
      if (!depthFirst) {
        var astT = func(ast);
        if (astT && astT !== ast) {
          return astT;
        }
      }
      if (ast instanceof nodes.NodeList) {
        var children = mapCOW(ast.children, function(node) {
          return walk(node, func, depthFirst);
        });
        if (children !== ast.children) {
          ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
        }
      } else if (ast instanceof nodes.CallExtension) {
        var args = walk(ast.args, func, depthFirst);
        var contentArgs = mapCOW(ast.contentArgs, function(node) {
          return walk(node, func, depthFirst);
        });
        if (args !== ast.args || contentArgs !== ast.contentArgs) {
          ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
        }
      } else {
        var props = ast.fields.map(function(field) {
          return ast[field];
        });
        var propsT = mapCOW(props, function(prop) {
          return walk(prop, func, depthFirst);
        });
        if (propsT !== props) {
          ast = new nodes[ast.typename](ast.lineno, ast.colno);
          propsT.forEach(function(prop, i2) {
            ast[ast.fields[i2]] = prop;
          });
        }
      }
      return depthFirst ? func(ast) || ast : ast;
    }
    function depthWalk(ast, func) {
      return walk(ast, func, true);
    }
    function _liftFilters(node, asyncFilters, prop) {
      var children = [];
      var walked = depthWalk(prop ? node[prop] : node, function(descNode) {
        var symbol;
        if (descNode instanceof nodes.Block) {
          return descNode;
        } else if (descNode instanceof nodes.Filter && lib2.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
          symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
          children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
        }
        return symbol;
      });
      if (prop) {
        node[prop] = walked;
      } else {
        node = walked;
      }
      if (children.length) {
        children.push(node);
        return new nodes.NodeList(node.lineno, node.colno, children);
      } else {
        return node;
      }
    }
    function liftFilters(ast, asyncFilters) {
      return depthWalk(ast, function(node) {
        if (node instanceof nodes.Output) {
          return _liftFilters(node, asyncFilters);
        } else if (node instanceof nodes.Set) {
          return _liftFilters(node, asyncFilters, "value");
        } else if (node instanceof nodes.For) {
          return _liftFilters(node, asyncFilters, "arr");
        } else if (node instanceof nodes.If) {
          return _liftFilters(node, asyncFilters, "cond");
        } else if (node instanceof nodes.CallExtension) {
          return _liftFilters(node, asyncFilters, "args");
        } else {
          return void 0;
        }
      });
    }
    function liftSuper(ast) {
      return walk(ast, function(blockNode) {
        if (!(blockNode instanceof nodes.Block)) {
          return;
        }
        var hasSuper = false;
        var symbol = gensym();
        blockNode.body = walk(blockNode.body, function(node) {
          if (node instanceof nodes.FunCall && node.name.value === "super") {
            hasSuper = true;
            return new nodes.Symbol(node.lineno, node.colno, symbol);
          }
        });
        if (hasSuper) {
          blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
        }
      });
    }
    function convertStatements(ast) {
      return depthWalk(ast, function(node) {
        if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
          return void 0;
        }
        var async = false;
        walk(node, function(child) {
          if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
            async = true;
            return child;
          }
          return void 0;
        });
        if (async) {
          if (node instanceof nodes.If) {
            return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
          } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
            return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
          }
        }
        return void 0;
      });
    }
    function cps(ast, asyncFilters) {
      return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
    }
    function transform(ast, asyncFilters) {
      return cps(ast, asyncFilters || []);
    }
    module2.exports = {
      transform
    };
  }
});

// node_modules/nunjucks/src/runtime.js
var require_runtime = __commonJS({
  "node_modules/nunjucks/src/runtime.js"(exports2, module2) {
    "use strict";
    var lib2 = require_lib2();
    var arrayFrom = Array.from;
    var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
    var Frame = /* @__PURE__ */ (function() {
      function Frame2(parent, isolateWrites) {
        this.variables = /* @__PURE__ */ Object.create(null);
        this.parent = parent;
        this.topLevel = false;
        this.isolateWrites = isolateWrites;
      }
      var _proto = Frame2.prototype;
      _proto.set = function set2(name, val, resolveUp) {
        var parts = name.split(".");
        var obj = this.variables;
        var frame = this;
        if (resolveUp) {
          if (frame = this.resolve(parts[0], true)) {
            frame.set(name, val);
            return;
          }
        }
        for (var i2 = 0; i2 < parts.length - 1; i2++) {
          var id = parts[i2];
          if (!obj[id]) {
            obj[id] = {};
          }
          obj = obj[id];
        }
        obj[parts[parts.length - 1]] = val;
      };
      _proto.get = function get(name) {
        var val = this.variables[name];
        if (val !== void 0) {
          return val;
        }
        return null;
      };
      _proto.lookup = function lookup(name) {
        var p = this.parent;
        var val = this.variables[name];
        if (val !== void 0) {
          return val;
        }
        return p && p.lookup(name);
      };
      _proto.resolve = function resolve4(name, forWrite) {
        var p = forWrite && this.isolateWrites ? void 0 : this.parent;
        var val = this.variables[name];
        if (val !== void 0) {
          return this;
        }
        return p && p.resolve(name);
      };
      _proto.push = function push(isolateWrites) {
        return new Frame2(this, isolateWrites);
      };
      _proto.pop = function pop() {
        return this.parent;
      };
      return Frame2;
    })();
    function makeMacro(argNames, kwargNames, func) {
      return function macro() {
        for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
          macroArgs[_key] = arguments[_key];
        }
        var argCount = numArgs(macroArgs);
        var args;
        var kwargs = getKeywordArgs(macroArgs);
        if (argCount > argNames.length) {
          args = macroArgs.slice(0, argNames.length);
          macroArgs.slice(args.length, argCount).forEach(function(val, i3) {
            if (i3 < kwargNames.length) {
              kwargs[kwargNames[i3]] = val;
            }
          });
          args.push(kwargs);
        } else if (argCount < argNames.length) {
          args = macroArgs.slice(0, argCount);
          for (var i2 = argCount; i2 < argNames.length; i2++) {
            var arg = argNames[i2];
            args.push(kwargs[arg]);
            delete kwargs[arg];
          }
          args.push(kwargs);
        } else {
          args = macroArgs;
        }
        return func.apply(this, args);
      };
    }
    function makeKeywordArgs(obj) {
      obj.__keywords = true;
      return obj;
    }
    function isKeywordArgs(obj) {
      return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
    }
    function getKeywordArgs(args) {
      var len = args.length;
      if (len) {
        var lastArg = args[len - 1];
        if (isKeywordArgs(lastArg)) {
          return lastArg;
        }
      }
      return {};
    }
    function numArgs(args) {
      var len = args.length;
      if (len === 0) {
        return 0;
      }
      var lastArg = args[len - 1];
      if (isKeywordArgs(lastArg)) {
        return len - 1;
      } else {
        return len;
      }
    }
    function SafeString(val) {
      if (typeof val !== "string") {
        return val;
      }
      this.val = val;
      this.length = val.length;
    }
    SafeString.prototype = Object.create(String.prototype, {
      length: {
        writable: true,
        configurable: true,
        value: 0
      }
    });
    SafeString.prototype.valueOf = function valueOf() {
      return this.val;
    };
    SafeString.prototype.toString = function toString4() {
      return this.val;
    };
    function copySafeness(dest, target) {
      if (dest instanceof SafeString) {
        return new SafeString(target);
      }
      return target.toString();
    }
    function markSafe(val) {
      var type = typeof val;
      if (type === "string") {
        return new SafeString(val);
      } else if (type !== "function") {
        return val;
      } else {
        return function wrapSafe(args) {
          var ret = val.apply(this, arguments);
          if (typeof ret === "string") {
            return new SafeString(ret);
          }
          return ret;
        };
      }
    }
    function suppressValue(val, autoescape) {
      val = val !== void 0 && val !== null ? val : "";
      if (autoescape && !(val instanceof SafeString)) {
        val = lib2.escape(val.toString());
      }
      return val;
    }
    function ensureDefined(val, lineno, colno) {
      if (val === null || val === void 0) {
        throw new lib2.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
      }
      return val;
    }
    function memberLookup(obj, val) {
      if (obj === void 0 || obj === null) {
        return void 0;
      }
      if (typeof obj[val] === "function") {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return obj[val].apply(obj, args);
        };
      }
      return obj[val];
    }
    function callWrap(obj, name, context, args) {
      if (!obj) {
        throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
      } else if (typeof obj !== "function") {
        throw new Error("Unable to call `" + name + "`, which is not a function");
      }
      return obj.apply(context, args);
    }
    function contextOrFrameLookup(context, frame, name) {
      var val = frame.lookup(name);
      return val !== void 0 ? val : context.lookup(name);
    }
    function handleError(error, lineno, colno) {
      if (error.lineno) {
        return error;
      } else {
        return new lib2.TemplateError(error, lineno, colno);
      }
    }
    function asyncEach(arr, dimen, iter, cb) {
      if (lib2.isArray(arr)) {
        var len = arr.length;
        lib2.asyncIter(arr, function iterCallback(item, i2, next) {
          switch (dimen) {
            case 1:
              iter(item, i2, len, next);
              break;
            case 2:
              iter(item[0], item[1], i2, len, next);
              break;
            case 3:
              iter(item[0], item[1], item[2], i2, len, next);
              break;
            default:
              item.push(i2, len, next);
              iter.apply(this, item);
          }
        }, cb);
      } else {
        lib2.asyncFor(arr, function iterCallback(key, val, i2, len2, next) {
          iter(key, val, i2, len2, next);
        }, cb);
      }
    }
    function asyncAll(arr, dimen, func, cb) {
      var finished7 = 0;
      var len;
      var outputArr;
      function done(i3, output) {
        finished7++;
        outputArr[i3] = output;
        if (finished7 === len) {
          cb(null, outputArr.join(""));
        }
      }
      if (lib2.isArray(arr)) {
        len = arr.length;
        outputArr = new Array(len);
        if (len === 0) {
          cb(null, "");
        } else {
          for (var i2 = 0; i2 < arr.length; i2++) {
            var item = arr[i2];
            switch (dimen) {
              case 1:
                func(item, i2, len, done);
                break;
              case 2:
                func(item[0], item[1], i2, len, done);
                break;
              case 3:
                func(item[0], item[1], item[2], i2, len, done);
                break;
              default:
                item.push(i2, len, done);
                func.apply(this, item);
            }
          }
        }
      } else {
        var keys = lib2.keys(arr || {});
        len = keys.length;
        outputArr = new Array(len);
        if (len === 0) {
          cb(null, "");
        } else {
          for (var _i = 0; _i < keys.length; _i++) {
            var k = keys[_i];
            func(k, arr[k], _i, len, done);
          }
        }
      }
    }
    function fromIterator(arr) {
      if (typeof arr !== "object" || arr === null || lib2.isArray(arr)) {
        return arr;
      } else if (supportsIterators && Symbol.iterator in arr) {
        return arrayFrom(arr);
      } else {
        return arr;
      }
    }
    module2.exports = {
      Frame,
      makeMacro,
      makeKeywordArgs,
      numArgs,
      suppressValue,
      ensureDefined,
      memberLookup,
      contextOrFrameLookup,
      callWrap,
      handleError,
      isArray: lib2.isArray,
      keys: lib2.keys,
      SafeString,
      copySafeness,
      markSafe,
      asyncEach,
      asyncAll,
      inOperator: lib2.inOperator,
      fromIterator
    };
  }
});

// node_modules/nunjucks/src/compiler.js
var require_compiler = __commonJS({
  "node_modules/nunjucks/src/compiler.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var parser = require_parser();
    var transformer = require_transformer();
    var nodes = require_nodes();
    var _require = require_lib2();
    var TemplateError = _require.TemplateError;
    var _require2 = require_runtime();
    var Frame = _require2.Frame;
    var _require3 = require_object();
    var Obj = _require3.Obj;
    var compareOps = {
      "==": "==",
      "===": "===",
      "!=": "!=",
      "!==": "!==",
      "<": "<",
      ">": ">",
      "<=": "<=",
      ">=": ">="
    };
    var Compiler = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Compiler2, _Obj);
      function Compiler2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto = Compiler2.prototype;
      _proto.init = function init(templateName, throwOnUndefined) {
        this.templateName = templateName;
        this.codebuf = [];
        this.lastId = 0;
        this.buffer = null;
        this.bufferStack = [];
        this._scopeClosers = "";
        this.inBlock = false;
        this.throwOnUndefined = throwOnUndefined;
      };
      _proto.fail = function fail(msg, lineno, colno) {
        if (lineno !== void 0) {
          lineno += 1;
        }
        if (colno !== void 0) {
          colno += 1;
        }
        throw new TemplateError(msg, lineno, colno);
      };
      _proto._pushBuffer = function _pushBuffer() {
        var id = this._tmpid();
        this.bufferStack.push(this.buffer);
        this.buffer = id;
        this._emit("var " + this.buffer + ' = "";');
        return id;
      };
      _proto._popBuffer = function _popBuffer() {
        this.buffer = this.bufferStack.pop();
      };
      _proto._emit = function _emit(code2) {
        this.codebuf.push(code2);
      };
      _proto._emitLine = function _emitLine(code2) {
        this._emit(code2 + "\n");
      };
      _proto._emitLines = function _emitLines() {
        var _this = this;
        for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
          lines[_key] = arguments[_key];
        }
        lines.forEach(function(line) {
          return _this._emitLine(line);
        });
      };
      _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
        this.buffer = "output";
        this._scopeClosers = "";
        this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");
        this._emitLine("var lineno = " + node.lineno + ";");
        this._emitLine("var colno = " + node.colno + ";");
        this._emitLine("var " + this.buffer + ' = "";');
        this._emitLine("try {");
      };
      _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
        if (!noReturn) {
          this._emitLine("cb(null, " + this.buffer + ");");
        }
        this._closeScopeLevels();
        this._emitLine("} catch (e) {");
        this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
        this._emitLine("}");
        this._emitLine("}");
        this.buffer = null;
      };
      _proto._addScopeLevel = function _addScopeLevel() {
        this._scopeClosers += "})";
      };
      _proto._closeScopeLevels = function _closeScopeLevels() {
        this._emitLine(this._scopeClosers + ";");
        this._scopeClosers = "";
      };
      _proto._withScopedSyntax = function _withScopedSyntax(func) {
        var _scopeClosers = this._scopeClosers;
        this._scopeClosers = "";
        func.call(this);
        this._closeScopeLevels();
        this._scopeClosers = _scopeClosers;
      };
      _proto._makeCallback = function _makeCallback(res) {
        var err = this._tmpid();
        return "function(" + err + (res ? "," + res : "") + ") {\nif(" + err + ") { cb(" + err + "); return; }";
      };
      _proto._tmpid = function _tmpid() {
        this.lastId++;
        return "t_" + this.lastId;
      };
      _proto._templateName = function _templateName() {
        return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
      };
      _proto._compileChildren = function _compileChildren(node, frame) {
        var _this2 = this;
        node.children.forEach(function(child) {
          _this2.compile(child, frame);
        });
      };
      _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
        var _this3 = this;
        if (startChar) {
          this._emit(startChar);
        }
        node.children.forEach(function(child, i2) {
          if (i2 > 0) {
            _this3._emit(",");
          }
          _this3.compile(child, frame);
        });
        if (endChar) {
          this._emit(endChar);
        }
      };
      _proto._compileExpression = function _compileExpression(node, frame) {
        this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
        this.compile(node, frame);
      };
      _proto.assertType = function assertType(node) {
        for (var _len2 = arguments.length, types2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          types2[_key2 - 1] = arguments[_key2];
        }
        if (!types2.some(function(t) {
          return node instanceof t;
        })) {
          this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
        }
      };
      _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
        var _this4 = this;
        var args = node.args;
        var contentArgs = node.contentArgs;
        var autoescape = typeof node.autoescape === "boolean" ? node.autoescape : true;
        if (!async) {
          this._emit(this.buffer + " += runtime.suppressValue(");
        }
        this._emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
        this._emit("context");
        if (args || contentArgs) {
          this._emit(",");
        }
        if (args) {
          if (!(args instanceof nodes.NodeList)) {
            this.fail("compileCallExtension: arguments must be a NodeList, use `parser.parseSignature`");
          }
          args.children.forEach(function(arg, i2) {
            _this4._compileExpression(arg, frame);
            if (i2 !== args.children.length - 1 || contentArgs.length) {
              _this4._emit(",");
            }
          });
        }
        if (contentArgs.length) {
          contentArgs.forEach(function(arg, i2) {
            if (i2 > 0) {
              _this4._emit(",");
            }
            if (arg) {
              _this4._emitLine("function(cb) {");
              _this4._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
              var id = _this4._pushBuffer();
              _this4._withScopedSyntax(function() {
                _this4.compile(arg, frame);
                _this4._emitLine("cb(null, " + id + ");");
              });
              _this4._popBuffer();
              _this4._emitLine("return " + id + ";");
              _this4._emitLine("}");
            } else {
              _this4._emit("null");
            }
          });
        }
        if (async) {
          var res = this._tmpid();
          this._emitLine(", " + this._makeCallback(res));
          this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");
          this._addScopeLevel();
        } else {
          this._emit(")");
          this._emit(", " + autoescape + " && env.opts.autoescape);\n");
        }
      };
      _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
        this.compileCallExtension(node, frame, true);
      };
      _proto.compileNodeList = function compileNodeList(node, frame) {
        this._compileChildren(node, frame);
      };
      _proto.compileLiteral = function compileLiteral(node) {
        if (typeof node.value === "string") {
          var val = node.value.replace(/\\/g, "\\\\");
          val = val.replace(/"/g, '\\"');
          val = val.replace(/\n/g, "\\n");
          val = val.replace(/\r/g, "\\r");
          val = val.replace(/\t/g, "\\t");
          val = val.replace(/\u2028/g, "\\u2028");
          this._emit('"' + val + '"');
        } else if (node.value === null) {
          this._emit("null");
        } else {
          this._emit(node.value.toString());
        }
      };
      _proto.compileSymbol = function compileSymbol(node, frame) {
        var name = node.value;
        var v = frame.lookup(name);
        if (v) {
          this._emit(v);
        } else {
          this._emit('runtime.contextOrFrameLookup(context, frame, "' + name + '")');
        }
      };
      _proto.compileGroup = function compileGroup(node, frame) {
        this._compileAggregate(node, frame, "(", ")");
      };
      _proto.compileArray = function compileArray(node, frame) {
        this._compileAggregate(node, frame, "[", "]");
      };
      _proto.compileDict = function compileDict(node, frame) {
        this._compileAggregate(node, frame, "{", "}");
      };
      _proto.compilePair = function compilePair(node, frame) {
        var key = node.key;
        var val = node.value;
        if (key instanceof nodes.Symbol) {
          key = new nodes.Literal(key.lineno, key.colno, key.value);
        } else if (!(key instanceof nodes.Literal && typeof key.value === "string")) {
          this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
        }
        this.compile(key, frame);
        this._emit(": ");
        this._compileExpression(val, frame);
      };
      _proto.compileInlineIf = function compileInlineIf(node, frame) {
        this._emit("(");
        this.compile(node.cond, frame);
        this._emit("?");
        this.compile(node.body, frame);
        this._emit(":");
        if (node.else_ !== null) {
          this.compile(node.else_, frame);
        } else {
          this._emit('""');
        }
        this._emit(")");
      };
      _proto.compileIn = function compileIn(node, frame) {
        this._emit("runtime.inOperator(");
        this.compile(node.left, frame);
        this._emit(",");
        this.compile(node.right, frame);
        this._emit(")");
      };
      _proto.compileIs = function compileIs(node, frame) {
        var right = node.right.name ? node.right.name.value : node.right.value;
        this._emit('env.getTest("' + right + '").call(context, ');
        this.compile(node.left, frame);
        if (node.right.args) {
          this._emit(",");
          this.compile(node.right.args, frame);
        }
        this._emit(") === true");
      };
      _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
        this.compile(node.left, frame);
        this._emit(str);
        this.compile(node.right, frame);
      };
      _proto.compileOr = function compileOr(node, frame) {
        return this._binOpEmitter(node, frame, " || ");
      };
      _proto.compileAnd = function compileAnd(node, frame) {
        return this._binOpEmitter(node, frame, " && ");
      };
      _proto.compileAdd = function compileAdd(node, frame) {
        return this._binOpEmitter(node, frame, " + ");
      };
      _proto.compileConcat = function compileConcat(node, frame) {
        return this._binOpEmitter(node, frame, ' + "" + ');
      };
      _proto.compileSub = function compileSub(node, frame) {
        return this._binOpEmitter(node, frame, " - ");
      };
      _proto.compileMul = function compileMul(node, frame) {
        return this._binOpEmitter(node, frame, " * ");
      };
      _proto.compileDiv = function compileDiv(node, frame) {
        return this._binOpEmitter(node, frame, " / ");
      };
      _proto.compileMod = function compileMod(node, frame) {
        return this._binOpEmitter(node, frame, " % ");
      };
      _proto.compileNot = function compileNot(node, frame) {
        this._emit("!");
        this.compile(node.target, frame);
      };
      _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
        this._emit("Math.floor(");
        this.compile(node.left, frame);
        this._emit(" / ");
        this.compile(node.right, frame);
        this._emit(")");
      };
      _proto.compilePow = function compilePow(node, frame) {
        this._emit("Math.pow(");
        this.compile(node.left, frame);
        this._emit(", ");
        this.compile(node.right, frame);
        this._emit(")");
      };
      _proto.compileNeg = function compileNeg(node, frame) {
        this._emit("-");
        this.compile(node.target, frame);
      };
      _proto.compilePos = function compilePos(node, frame) {
        this._emit("+");
        this.compile(node.target, frame);
      };
      _proto.compileCompare = function compileCompare(node, frame) {
        var _this5 = this;
        this.compile(node.expr, frame);
        node.ops.forEach(function(op) {
          _this5._emit(" " + compareOps[op.type] + " ");
          _this5.compile(op.expr, frame);
        });
      };
      _proto.compileLookupVal = function compileLookupVal(node, frame) {
        this._emit("runtime.memberLookup((");
        this._compileExpression(node.target, frame);
        this._emit("),");
        this._compileExpression(node.val, frame);
        this._emit(")");
      };
      _proto._getNodeName = function _getNodeName(node) {
        switch (node.typename) {
          case "Symbol":
            return node.value;
          case "FunCall":
            return "the return value of (" + this._getNodeName(node.name) + ")";
          case "LookupVal":
            return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';
          case "Literal":
            return node.value.toString();
          default:
            return "--expression--";
        }
      };
      _proto.compileFunCall = function compileFunCall(node, frame) {
        this._emit("(lineno = " + node.lineno + ", colno = " + node.colno + ", ");
        this._emit("runtime.callWrap(");
        this._compileExpression(node.name, frame);
        this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');
        this._compileAggregate(node.args, frame, "[", "])");
        this._emit(")");
      };
      _proto.compileFilter = function compileFilter(node, frame) {
        var name = node.name;
        this.assertType(name, nodes.Symbol);
        this._emit('env.getFilter("' + name.value + '").call(context, ');
        this._compileAggregate(node.args, frame);
        this._emit(")");
      };
      _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
        var name = node.name;
        var symbol = node.symbol.value;
        this.assertType(name, nodes.Symbol);
        frame.set(symbol, symbol);
        this._emit('env.getFilter("' + name.value + '").call(context, ');
        this._compileAggregate(node.args, frame);
        this._emitLine(", " + this._makeCallback(symbol));
        this._addScopeLevel();
      };
      _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
        this._emit("runtime.makeKeywordArgs(");
        this.compileDict(node, frame);
        this._emit(")");
      };
      _proto.compileSet = function compileSet(node, frame) {
        var _this6 = this;
        var ids = [];
        node.targets.forEach(function(target) {
          var name = target.value;
          var id = frame.lookup(name);
          if (id === null || id === void 0) {
            id = _this6._tmpid();
            _this6._emitLine("var " + id + ";");
          }
          ids.push(id);
        });
        if (node.value) {
          this._emit(ids.join(" = ") + " = ");
          this._compileExpression(node.value, frame);
          this._emitLine(";");
        } else {
          this._emit(ids.join(" = ") + " = ");
          this.compile(node.body, frame);
          this._emitLine(";");
        }
        node.targets.forEach(function(target, i2) {
          var id = ids[i2];
          var name = target.value;
          _this6._emitLine('frame.set("' + name + '", ' + id + ", true);");
          _this6._emitLine("if(frame.topLevel) {");
          _this6._emitLine('context.setVariable("' + name + '", ' + id + ");");
          _this6._emitLine("}");
          if (name.charAt(0) !== "_") {
            _this6._emitLine("if(frame.topLevel) {");
            _this6._emitLine('context.addExport("' + name + '", ' + id + ");");
            _this6._emitLine("}");
          }
        });
      };
      _proto.compileSwitch = function compileSwitch(node, frame) {
        var _this7 = this;
        this._emit("switch (");
        this.compile(node.expr, frame);
        this._emit(") {");
        node.cases.forEach(function(c3, i2) {
          _this7._emit("case ");
          _this7.compile(c3.cond, frame);
          _this7._emit(": ");
          _this7.compile(c3.body, frame);
          if (c3.body.children.length) {
            _this7._emitLine("break;");
          }
        });
        if (node.default) {
          this._emit("default:");
          this.compile(node.default, frame);
        }
        this._emit("}");
      };
      _proto.compileIf = function compileIf(node, frame, async) {
        var _this8 = this;
        this._emit("if(");
        this._compileExpression(node.cond, frame);
        this._emitLine(") {");
        this._withScopedSyntax(function() {
          _this8.compile(node.body, frame);
          if (async) {
            _this8._emit("cb()");
          }
        });
        if (node.else_) {
          this._emitLine("}\nelse {");
          this._withScopedSyntax(function() {
            _this8.compile(node.else_, frame);
            if (async) {
              _this8._emit("cb()");
            }
          });
        } else if (async) {
          this._emitLine("}\nelse {");
          this._emit("cb()");
        }
        this._emitLine("}");
      };
      _proto.compileIfAsync = function compileIfAsync(node, frame) {
        this._emit("(function(cb) {");
        this.compileIf(node, frame, true);
        this._emit("})(" + this._makeCallback());
        this._addScopeLevel();
      };
      _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i2, len) {
        var _this9 = this;
        var bindings = [{
          name: "index",
          val: i2 + " + 1"
        }, {
          name: "index0",
          val: i2
        }, {
          name: "revindex",
          val: len + " - " + i2
        }, {
          name: "revindex0",
          val: len + " - " + i2 + " - 1"
        }, {
          name: "first",
          val: i2 + " === 0"
        }, {
          name: "last",
          val: i2 + " === " + len + " - 1"
        }, {
          name: "length",
          val: len
        }];
        bindings.forEach(function(b) {
          _this9._emitLine('frame.set("loop.' + b.name + '", ' + b.val + ");");
        });
      };
      _proto.compileFor = function compileFor(node, frame) {
        var _this10 = this;
        var i2 = this._tmpid();
        var len = this._tmpid();
        var arr = this._tmpid();
        frame = frame.push();
        this._emitLine("frame = frame.push();");
        this._emit("var " + arr + " = ");
        this._compileExpression(node.arr, frame);
        this._emitLine(";");
        this._emit("if(" + arr + ") {");
        this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
        if (node.name instanceof nodes.Array) {
          this._emitLine("var " + i2 + ";");
          this._emitLine("if(runtime.isArray(" + arr + ")) {");
          this._emitLine("var " + len + " = " + arr + ".length;");
          this._emitLine("for(" + i2 + "=0; " + i2 + " < " + arr + ".length; " + i2 + "++) {");
          node.name.children.forEach(function(child, u2) {
            var tid = _this10._tmpid();
            _this10._emitLine("var " + tid + " = " + arr + "[" + i2 + "][" + u2 + "];");
            _this10._emitLine('frame.set("' + child + '", ' + arr + "[" + i2 + "][" + u2 + "]);");
            frame.set(node.name.children[u2].value, tid);
          });
          this._emitLoopBindings(node, arr, i2, len);
          this._withScopedSyntax(function() {
            _this10.compile(node.body, frame);
          });
          this._emitLine("}");
          this._emitLine("} else {");
          var _node$name$children = node.name.children, key = _node$name$children[0], val = _node$name$children[1];
          var k = this._tmpid();
          var v = this._tmpid();
          frame.set(key.value, k);
          frame.set(val.value, v);
          this._emitLine(i2 + " = -1;");
          this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");
          this._emitLine("for(var " + k + " in " + arr + ") {");
          this._emitLine(i2 + "++;");
          this._emitLine("var " + v + " = " + arr + "[" + k + "];");
          this._emitLine('frame.set("' + key.value + '", ' + k + ");");
          this._emitLine('frame.set("' + val.value + '", ' + v + ");");
          this._emitLoopBindings(node, arr, i2, len);
          this._withScopedSyntax(function() {
            _this10.compile(node.body, frame);
          });
          this._emitLine("}");
          this._emitLine("}");
        } else {
          var _v = this._tmpid();
          frame.set(node.name.value, _v);
          this._emitLine("var " + len + " = " + arr + ".length;");
          this._emitLine("for(var " + i2 + "=0; " + i2 + " < " + arr + ".length; " + i2 + "++) {");
          this._emitLine("var " + _v + " = " + arr + "[" + i2 + "];");
          this._emitLine('frame.set("' + node.name.value + '", ' + _v + ");");
          this._emitLoopBindings(node, arr, i2, len);
          this._withScopedSyntax(function() {
            _this10.compile(node.body, frame);
          });
          this._emitLine("}");
        }
        this._emitLine("}");
        if (node.else_) {
          this._emitLine("if (!" + len + ") {");
          this.compile(node.else_, frame);
          this._emitLine("}");
        }
        this._emitLine("frame = frame.pop();");
      };
      _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
        var _this11 = this;
        var i2 = this._tmpid();
        var len = this._tmpid();
        var arr = this._tmpid();
        var asyncMethod = parallel ? "asyncAll" : "asyncEach";
        frame = frame.push();
        this._emitLine("frame = frame.push();");
        this._emit("var " + arr + " = runtime.fromIterator(");
        this._compileExpression(node.arr, frame);
        this._emitLine(");");
        if (node.name instanceof nodes.Array) {
          var arrayLen = node.name.children.length;
          this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");
          node.name.children.forEach(function(name) {
            _this11._emit(name.value + ",");
          });
          this._emit(i2 + "," + len + ",next) {");
          node.name.children.forEach(function(name) {
            var id2 = name.value;
            frame.set(id2, id2);
            _this11._emitLine('frame.set("' + id2 + '", ' + id2 + ");");
          });
        } else {
          var id = node.name.value;
          this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i2 + ", " + len + ",next) {");
          this._emitLine('frame.set("' + id + '", ' + id + ");");
          frame.set(id, id);
        }
        this._emitLoopBindings(node, arr, i2, len);
        this._withScopedSyntax(function() {
          var buf;
          if (parallel) {
            buf = _this11._pushBuffer();
          }
          _this11.compile(node.body, frame);
          _this11._emitLine("next(" + i2 + (buf ? "," + buf : "") + ");");
          if (parallel) {
            _this11._popBuffer();
          }
        });
        var output = this._tmpid();
        this._emitLine("}, " + this._makeCallback(output));
        this._addScopeLevel();
        if (parallel) {
          this._emitLine(this.buffer + " += " + output + ";");
        }
        if (node.else_) {
          this._emitLine("if (!" + arr + ".length) {");
          this.compile(node.else_, frame);
          this._emitLine("}");
        }
        this._emitLine("frame = frame.pop();");
      };
      _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
        this._compileAsyncLoop(node, frame);
      };
      _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
        this._compileAsyncLoop(node, frame, true);
      };
      _proto._compileMacro = function _compileMacro(node, frame) {
        var _this12 = this;
        var args = [];
        var kwargs = null;
        var funcId = "macro_" + this._tmpid();
        var keepFrame = frame !== void 0;
        node.args.children.forEach(function(arg, i2) {
          if (i2 === node.args.children.length - 1 && arg instanceof nodes.Dict) {
            kwargs = arg;
          } else {
            _this12.assertType(arg, nodes.Symbol);
            args.push(arg);
          }
        });
        var realNames = [].concat(args.map(function(n2) {
          return "l_" + n2.value;
        }), ["kwargs"]);
        var argNames = args.map(function(n2) {
          return '"' + n2.value + '"';
        });
        var kwargNames = (kwargs && kwargs.children || []).map(function(n2) {
          return '"' + n2.key.value + '"';
        });
        var currFrame;
        if (keepFrame) {
          currFrame = frame.push(true);
        } else {
          currFrame = new Frame();
        }
        this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(", ") + "], ", "[" + kwargNames.join(", ") + "], ", "function (" + realNames.join(", ") + ") {", "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
        args.forEach(function(arg) {
          _this12._emitLine('frame.set("' + arg.value + '", l_' + arg.value + ");");
          currFrame.set(arg.value, "l_" + arg.value);
        });
        if (kwargs) {
          kwargs.children.forEach(function(pair) {
            var name = pair.key.value;
            _this12._emit('frame.set("' + name + '", ');
            _this12._emit('Object.prototype.hasOwnProperty.call(kwargs, "' + name + '")');
            _this12._emit(' ? kwargs["' + name + '"] : ');
            _this12._compileExpression(pair.value, currFrame);
            _this12._emit(");");
          });
        }
        var bufferId = this._pushBuffer();
        this._withScopedSyntax(function() {
          _this12.compile(node.body, currFrame);
        });
        this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
        this._emitLine("return new runtime.SafeString(" + bufferId + ");");
        this._emitLine("});");
        this._popBuffer();
        return funcId;
      };
      _proto.compileMacro = function compileMacro(node, frame) {
        var funcId = this._compileMacro(node);
        var name = node.name.value;
        frame.set(name, funcId);
        if (frame.parent) {
          this._emitLine('frame.set("' + name + '", ' + funcId + ");");
        } else {
          if (node.name.value.charAt(0) !== "_") {
            this._emitLine('context.addExport("' + name + '");');
          }
          this._emitLine('context.setVariable("' + name + '", ' + funcId + ");");
        }
      };
      _proto.compileCaller = function compileCaller(node, frame) {
        this._emit("(function (){");
        var funcId = this._compileMacro(node, frame);
        this._emit("return " + funcId + ";})()");
      };
      _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
        var parentTemplateId = this._tmpid();
        var parentName = this._templateName();
        var cb = this._makeCallback(parentTemplateId);
        var eagerCompileArg = eagerCompile ? "true" : "false";
        var ignoreMissingArg = ignoreMissing ? "true" : "false";
        this._emit("env.getTemplate(");
        this._compileExpression(node.template, frame);
        this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);
        return parentTemplateId;
      };
      _proto.compileImport = function compileImport(node, frame) {
        var target = node.target.value;
        var id = this._compileGetTemplate(node, frame, false, false);
        this._addScopeLevel();
        this._emitLine(id + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
        this._addScopeLevel();
        frame.set(target, id);
        if (frame.parent) {
          this._emitLine('frame.set("' + target + '", ' + id + ");");
        } else {
          this._emitLine('context.setVariable("' + target + '", ' + id + ");");
        }
      };
      _proto.compileFromImport = function compileFromImport(node, frame) {
        var _this13 = this;
        var importedId = this._compileGetTemplate(node, frame, false, false);
        this._addScopeLevel();
        this._emitLine(importedId + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
        this._addScopeLevel();
        node.names.children.forEach(function(nameNode) {
          var name;
          var alias;
          var id = _this13._tmpid();
          if (nameNode instanceof nodes.Pair) {
            name = nameNode.key.value;
            alias = nameNode.value.value;
          } else {
            name = nameNode.value;
            alias = name;
          }
          _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ', "' + name + '")) {');
          _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");
          _this13._emitLine("} else {");
          _this13._emitLine(`cb(new Error("cannot import '` + name + `'")); return;`);
          _this13._emitLine("}");
          frame.set(alias, id);
          if (frame.parent) {
            _this13._emitLine('frame.set("' + alias + '", ' + id + ");");
          } else {
            _this13._emitLine('context.setVariable("' + alias + '", ' + id + ");");
          }
        });
      };
      _proto.compileBlock = function compileBlock(node) {
        var id = this._tmpid();
        if (!this.inBlock) {
          this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
        }
        this._emit('context.getBlock("' + node.name.value + '")');
        if (!this.inBlock) {
          this._emit(")");
        }
        this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
        this._emitLine(this.buffer + " += " + id + ";");
        this._addScopeLevel();
      };
      _proto.compileSuper = function compileSuper(node, frame) {
        var name = node.blockName.value;
        var id = node.symbol.value;
        var cb = this._makeCallback(id);
        this._emitLine('context.getSuper(env, "' + name + '", b_' + name + ", frame, runtime, " + cb);
        this._emitLine(id + " = runtime.markSafe(" + id + ");");
        this._addScopeLevel();
        frame.set(id, id);
      };
      _proto.compileExtends = function compileExtends(node, frame) {
        var k = this._tmpid();
        var parentTemplateId = this._compileGetTemplate(node, frame, true, false);
        this._emitLine("parentTemplate = " + parentTemplateId);
        this._emitLine("for(var " + k + " in parentTemplate.blocks) {");
        this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");
        this._emitLine("}");
        this._addScopeLevel();
      };
      _proto.compileInclude = function compileInclude(node, frame) {
        this._emitLine("var tasks = [];");
        this._emitLine("tasks.push(");
        this._emitLine("function(callback) {");
        var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);
        this._emitLine("callback(null," + id + ");});");
        this._emitLine("});");
        var id2 = this._tmpid();
        this._emitLine("tasks.push(");
        this._emitLine("function(template, callback){");
        this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
        this._emitLine("callback(null," + id2 + ");});");
        this._emitLine("});");
        this._emitLine("tasks.push(");
        this._emitLine("function(result, callback){");
        this._emitLine(this.buffer + " += result;");
        this._emitLine("callback(null);");
        this._emitLine("});");
        this._emitLine("env.waterfall(tasks, function(){");
        this._addScopeLevel();
      };
      _proto.compileTemplateData = function compileTemplateData(node, frame) {
        this.compileLiteral(node, frame);
      };
      _proto.compileCapture = function compileCapture(node, frame) {
        var _this14 = this;
        var buffer = this.buffer;
        this.buffer = "output";
        this._emitLine("(function() {");
        this._emitLine('var output = "";');
        this._withScopedSyntax(function() {
          _this14.compile(node.body, frame);
        });
        this._emitLine("return output;");
        this._emitLine("})()");
        this.buffer = buffer;
      };
      _proto.compileOutput = function compileOutput(node, frame) {
        var _this15 = this;
        var children = node.children;
        children.forEach(function(child) {
          if (child instanceof nodes.TemplateData) {
            if (child.value) {
              _this15._emit(_this15.buffer + " += ");
              _this15.compileLiteral(child, frame);
              _this15._emitLine(";");
            }
          } else {
            _this15._emit(_this15.buffer + " += runtime.suppressValue(");
            if (_this15.throwOnUndefined) {
              _this15._emit("runtime.ensureDefined(");
            }
            _this15.compile(child, frame);
            if (_this15.throwOnUndefined) {
              _this15._emit("," + node.lineno + "," + node.colno + ")");
            }
            _this15._emit(", env.opts.autoescape);\n");
          }
        });
      };
      _proto.compileRoot = function compileRoot(node, frame) {
        var _this16 = this;
        if (frame) {
          this.fail("compileRoot: root node can't have frame");
        }
        frame = new Frame();
        this._emitFuncBegin(node, "root");
        this._emitLine("var parentTemplate = null;");
        this._compileChildren(node, frame);
        this._emitLine("if(parentTemplate) {");
        this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
        this._emitLine("} else {");
        this._emitLine("cb(null, " + this.buffer + ");");
        this._emitLine("}");
        this._emitFuncEnd(true);
        this.inBlock = true;
        var blockNames = [];
        var blocks = node.findAll(nodes.Block);
        blocks.forEach(function(block2, i2) {
          var name = block2.name.value;
          if (blockNames.indexOf(name) !== -1) {
            throw new Error('Block "' + name + '" defined more than once.');
          }
          blockNames.push(name);
          _this16._emitFuncBegin(block2, "b_" + name);
          var tmpFrame = new Frame();
          _this16._emitLine("var frame = frame.push(true);");
          _this16.compile(block2.body, tmpFrame);
          _this16._emitFuncEnd();
        });
        this._emitLine("return {");
        blocks.forEach(function(block2, i2) {
          var blockName = "b_" + block2.name.value;
          _this16._emitLine(blockName + ": " + blockName + ",");
        });
        this._emitLine("root: root\n};");
      };
      _proto.compile = function compile2(node, frame) {
        var _compile = this["compile" + node.typename];
        if (_compile) {
          _compile.call(this, node, frame);
        } else {
          this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
        }
      };
      _proto.getCode = function getCode() {
        return this.codebuf.join("");
      };
      return Compiler2;
    })(Obj);
    module2.exports = {
      compile: function compile2(src, asyncFilters, extensions2, name, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var c3 = new Compiler(name, opts.throwOnUndefined);
        var preprocessors = (extensions2 || []).map(function(ext2) {
          return ext2.preprocess;
        }).filter(function(f) {
          return !!f;
        });
        var processedSrc = preprocessors.reduce(function(s, processor) {
          return processor(s);
        }, src);
        c3.compile(transformer.transform(parser.parse(processedSrc, extensions2, opts), asyncFilters, name));
        return c3.getCode();
      },
      Compiler
    };
  }
});

// node_modules/nunjucks/src/filters.js
var require_filters = __commonJS({
  "node_modules/nunjucks/src/filters.js"(exports2, module2) {
    "use strict";
    var lib2 = require_lib2();
    var r = require_runtime();
    var _exports = module2.exports = {};
    function normalize4(value, defaultValue) {
      if (value === null || value === void 0 || value === false) {
        return defaultValue;
      }
      return value;
    }
    _exports.abs = Math.abs;
    function isNaN2(num) {
      return num !== num;
    }
    function batch(arr, linecount, fillWith) {
      var i2;
      var res = [];
      var tmp = [];
      for (i2 = 0; i2 < arr.length; i2++) {
        if (i2 % linecount === 0 && tmp.length) {
          res.push(tmp);
          tmp = [];
        }
        tmp.push(arr[i2]);
      }
      if (tmp.length) {
        if (fillWith) {
          for (i2 = tmp.length; i2 < linecount; i2++) {
            tmp.push(fillWith);
          }
        }
        res.push(tmp);
      }
      return res;
    }
    _exports.batch = batch;
    function capitalize(str) {
      str = normalize4(str, "");
      var ret = str.toLowerCase();
      return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
    }
    _exports.capitalize = capitalize;
    function center(str, width) {
      str = normalize4(str, "");
      width = width || 80;
      if (str.length >= width) {
        return str;
      }
      var spaces = width - str.length;
      var pre = lib2.repeat(" ", spaces / 2 - spaces % 2);
      var post = lib2.repeat(" ", spaces / 2);
      return r.copySafeness(str, pre + str + post);
    }
    _exports.center = center;
    function default_(val, def, bool) {
      if (bool) {
        return val || def;
      } else {
        return val !== void 0 ? val : def;
      }
    }
    _exports["default"] = default_;
    function dictsort(val, caseSensitive, by) {
      if (!lib2.isObject(val)) {
        throw new lib2.TemplateError("dictsort filter: val must be an object");
      }
      var array = [];
      for (var k in val) {
        array.push([k, val[k]]);
      }
      var si;
      if (by === void 0 || by === "key") {
        si = 0;
      } else if (by === "value") {
        si = 1;
      } else {
        throw new lib2.TemplateError("dictsort filter: You can only sort by either key or value");
      }
      array.sort(function(t1, t2) {
        var a2 = t1[si];
        var b = t2[si];
        if (!caseSensitive) {
          if (lib2.isString(a2)) {
            a2 = a2.toUpperCase();
          }
          if (lib2.isString(b)) {
            b = b.toUpperCase();
          }
        }
        return a2 > b ? 1 : a2 === b ? 0 : -1;
      });
      return array;
    }
    _exports.dictsort = dictsort;
    function dump(obj, spaces) {
      return JSON.stringify(obj, null, spaces);
    }
    _exports.dump = dump;
    function escape4(str) {
      if (str instanceof r.SafeString) {
        return str;
      }
      str = str === null || str === void 0 ? "" : str;
      return r.markSafe(lib2.escape(str.toString()));
    }
    _exports.escape = escape4;
    function safe(str) {
      if (str instanceof r.SafeString) {
        return str;
      }
      str = str === null || str === void 0 ? "" : str;
      return r.markSafe(str.toString());
    }
    _exports.safe = safe;
    function first(arr) {
      return arr[0];
    }
    _exports.first = first;
    function forceescape(str) {
      str = str === null || str === void 0 ? "" : str;
      return r.markSafe(lib2.escape(str.toString()));
    }
    _exports.forceescape = forceescape;
    function groupby(arr, attr) {
      return lib2.groupBy(arr, attr, this.env.opts.throwOnUndefined);
    }
    _exports.groupby = groupby;
    function indent(str, width, indentfirst) {
      str = normalize4(str, "");
      if (str === "") {
        return "";
      }
      width = width || 4;
      var lines = str.split("\n");
      var sp = lib2.repeat(" ", width);
      var res = lines.map(function(l, i2) {
        return i2 === 0 && !indentfirst ? l : "" + sp + l;
      }).join("\n");
      return r.copySafeness(str, res);
    }
    _exports.indent = indent;
    function join8(arr, del, attr) {
      del = del || "";
      if (attr) {
        arr = lib2.map(arr, function(v) {
          return v[attr];
        });
      }
      return arr.join(del);
    }
    _exports.join = join8;
    function last(arr) {
      return arr[arr.length - 1];
    }
    _exports.last = last;
    function lengthFilter(val) {
      var value = normalize4(val, "");
      if (value !== void 0) {
        if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
          return value.size;
        }
        if (lib2.isObject(value) && !(value instanceof r.SafeString)) {
          return lib2.keys(value).length;
        }
        return value.length;
      }
      return 0;
    }
    _exports.length = lengthFilter;
    function list2(val) {
      if (lib2.isString(val)) {
        return val.split("");
      } else if (lib2.isObject(val)) {
        return lib2._entries(val || {}).map(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return {
            key,
            value
          };
        });
      } else if (lib2.isArray(val)) {
        return val;
      } else {
        throw new lib2.TemplateError("list filter: type not iterable");
      }
    }
    _exports.list = list2;
    function lower(str) {
      str = normalize4(str, "");
      return str.toLowerCase();
    }
    _exports.lower = lower;
    function nl2br(str) {
      if (str === null || str === void 0) {
        return "";
      }
      return r.copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
    }
    _exports.nl2br = nl2br;
    function random(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    _exports.random = random;
    function getSelectOrReject(expectedTestResult) {
      function filter3(arr, testName, secondArg) {
        if (testName === void 0) {
          testName = "truthy";
        }
        var context = this;
        var test3 = context.env.getTest(testName);
        return lib2.toArray(arr).filter(function examineTestResult(item) {
          return test3.call(context, item, secondArg) === expectedTestResult;
        });
      }
      return filter3;
    }
    _exports.reject = getSelectOrReject(false);
    function rejectattr(arr, attr) {
      return arr.filter(function(item) {
        return !item[attr];
      });
    }
    _exports.rejectattr = rejectattr;
    _exports.select = getSelectOrReject(true);
    function selectattr(arr, attr) {
      return arr.filter(function(item) {
        return !!item[attr];
      });
    }
    _exports.selectattr = selectattr;
    function replace2(str, old, new_, maxCount) {
      var originalStr = str;
      if (old instanceof RegExp) {
        return str.replace(old, new_);
      }
      if (typeof maxCount === "undefined") {
        maxCount = -1;
      }
      var res = "";
      if (typeof old === "number") {
        old = "" + old;
      } else if (typeof old !== "string") {
        return str;
      }
      if (typeof str === "number") {
        str = "" + str;
      }
      if (typeof str !== "string" && !(str instanceof r.SafeString)) {
        return str;
      }
      if (old === "") {
        res = new_ + str.split("").join(new_) + new_;
        return r.copySafeness(str, res);
      }
      var nextIndex = str.indexOf(old);
      if (maxCount === 0 || nextIndex === -1) {
        return str;
      }
      var pos = 0;
      var count2 = 0;
      while (nextIndex > -1 && (maxCount === -1 || count2 < maxCount)) {
        res += str.substring(pos, nextIndex) + new_;
        pos = nextIndex + old.length;
        count2++;
        nextIndex = str.indexOf(old, pos);
      }
      if (pos < str.length) {
        res += str.substring(pos);
      }
      return r.copySafeness(originalStr, res);
    }
    _exports.replace = replace2;
    function reverse(val) {
      var arr;
      if (lib2.isString(val)) {
        arr = list2(val);
      } else {
        arr = lib2.map(val, function(v) {
          return v;
        });
      }
      arr.reverse();
      if (lib2.isString(val)) {
        return r.copySafeness(val, arr.join(""));
      }
      return arr;
    }
    _exports.reverse = reverse;
    function round(val, precision, method) {
      precision = precision || 0;
      var factor = Math.pow(10, precision);
      var rounder;
      if (method === "ceil") {
        rounder = Math.ceil;
      } else if (method === "floor") {
        rounder = Math.floor;
      } else {
        rounder = Math.round;
      }
      return rounder(val * factor) / factor;
    }
    _exports.round = round;
    function slice(arr, slices, fillWith) {
      var sliceLength = Math.floor(arr.length / slices);
      var extra = arr.length % slices;
      var res = [];
      var offset = 0;
      for (var i2 = 0; i2 < slices; i2++) {
        var start = offset + i2 * sliceLength;
        if (i2 < extra) {
          offset++;
        }
        var end = offset + (i2 + 1) * sliceLength;
        var currSlice = arr.slice(start, end);
        if (fillWith && i2 >= extra) {
          currSlice.push(fillWith);
        }
        res.push(currSlice);
      }
      return res;
    }
    _exports.slice = slice;
    function sum(arr, attr, start) {
      if (start === void 0) {
        start = 0;
      }
      if (attr) {
        arr = lib2.map(arr, function(v) {
          return v[attr];
        });
      }
      return start + arr.reduce(function(a2, b) {
        return a2 + b;
      }, 0);
    }
    _exports.sum = sum;
    _exports.sort = r.makeMacro(["value", "reverse", "case_sensitive", "attribute"], [], function sortFilter(arr, reversed, caseSens, attr) {
      var _this = this;
      var array = lib2.map(arr, function(v) {
        return v;
      });
      var getAttribute = lib2.getAttrGetter(attr);
      array.sort(function(a2, b) {
        var x = attr ? getAttribute(a2) : a2;
        var y = attr ? getAttribute(b) : b;
        if (_this.env.opts.throwOnUndefined && attr && (x === void 0 || y === void 0)) {
          throw new TypeError('sort: attribute "' + attr + '" resolved to undefined');
        }
        if (!caseSens && lib2.isString(x) && lib2.isString(y)) {
          x = x.toLowerCase();
          y = y.toLowerCase();
        }
        if (x < y) {
          return reversed ? 1 : -1;
        } else if (x > y) {
          return reversed ? -1 : 1;
        } else {
          return 0;
        }
      });
      return array;
    });
    function string(obj) {
      return r.copySafeness(obj, obj);
    }
    _exports.string = string;
    function striptags(input, preserveLinebreaks) {
      input = normalize4(input, "");
      var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
      var trimmedInput = trim2(input.replace(tags, ""));
      var res = "";
      if (preserveLinebreaks) {
        res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
      } else {
        res = trimmedInput.replace(/\s+/gi, " ");
      }
      return r.copySafeness(input, res);
    }
    _exports.striptags = striptags;
    function title(str) {
      str = normalize4(str, "");
      var words = str.split(" ").map(function(word) {
        return capitalize(word);
      });
      return r.copySafeness(str, words.join(" "));
    }
    _exports.title = title;
    function trim2(str) {
      return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
    }
    _exports.trim = trim2;
    function truncate(input, length, killwords, end) {
      var orig = input;
      input = normalize4(input, "");
      length = length || 255;
      if (input.length <= length) {
        return input;
      }
      if (killwords) {
        input = input.substring(0, length);
      } else {
        var idx = input.lastIndexOf(" ", length);
        if (idx === -1) {
          idx = length;
        }
        input = input.substring(0, idx);
      }
      input += end !== void 0 && end !== null ? end : "...";
      return r.copySafeness(orig, input);
    }
    _exports.truncate = truncate;
    function upper(str) {
      str = normalize4(str, "");
      return str.toUpperCase();
    }
    _exports.upper = upper;
    function urlencode(obj) {
      var enc = encodeURIComponent;
      if (lib2.isString(obj)) {
        return enc(obj);
      } else {
        var keyvals = lib2.isArray(obj) ? obj : lib2._entries(obj);
        return keyvals.map(function(_ref2) {
          var k = _ref2[0], v = _ref2[1];
          return enc(k) + "=" + enc(v);
        }).join("&");
      }
    }
    _exports.urlencode = urlencode;
    var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
    var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
    var httpHttpsRe = /^https?:\/\/.*$/;
    var wwwRe = /^www\./;
    var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
    function urlize(str, length, nofollow) {
      if (isNaN2(length)) {
        length = Infinity;
      }
      var noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
      var words = str.split(/(\s+)/).filter(function(word) {
        return word && word.length;
      }).map(function(word) {
        var matches = word.match(puncRe);
        var possibleUrl = matches ? matches[1] : word;
        var shortUrl = possibleUrl.substr(0, length);
        if (httpHttpsRe.test(possibleUrl)) {
          return '<a href="' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
        }
        if (wwwRe.test(possibleUrl)) {
          return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
        }
        if (emailRe.test(possibleUrl)) {
          return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + "</a>";
        }
        if (tldRe.test(possibleUrl)) {
          return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
        }
        return word;
      });
      return words.join("");
    }
    _exports.urlize = urlize;
    function wordcount(str) {
      str = normalize4(str, "");
      var words = str ? str.match(/\w+/g) : null;
      return words ? words.length : null;
    }
    _exports.wordcount = wordcount;
    function float(val, def) {
      var res = parseFloat(val);
      return isNaN2(res) ? def : res;
    }
    _exports.float = float;
    var intFilter = r.makeMacro(["value", "default", "base"], [], function doInt(value, defaultValue, base) {
      if (base === void 0) {
        base = 10;
      }
      var res = parseInt(value, base);
      return isNaN2(res) ? defaultValue : res;
    });
    _exports.int = intFilter;
    _exports.d = _exports.default;
    _exports.e = _exports.escape;
  }
});

// node_modules/nunjucks/src/loader.js
var require_loader = __commonJS({
  "node_modules/nunjucks/src/loader.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var path15 = require("path");
    var _require = require_object();
    var EmitterObj = _require.EmitterObj;
    module2.exports = /* @__PURE__ */ (function(_EmitterObj) {
      _inheritsLoose(Loader, _EmitterObj);
      function Loader() {
        return _EmitterObj.apply(this, arguments) || this;
      }
      var _proto = Loader.prototype;
      _proto.resolve = function resolve4(from, to) {
        return path15.resolve(path15.dirname(from), to);
      };
      _proto.isRelative = function isRelative(filename) {
        return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
      };
      return Loader;
    })(EmitterObj);
  }
});

// node_modules/nunjucks/src/precompiled-loader.js
var require_precompiled_loader = __commonJS({
  "node_modules/nunjucks/src/precompiled-loader.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var Loader = require_loader();
    var PrecompiledLoader = /* @__PURE__ */ (function(_Loader) {
      _inheritsLoose(PrecompiledLoader2, _Loader);
      function PrecompiledLoader2(compiledTemplates) {
        var _this;
        _this = _Loader.call(this) || this;
        _this.precompiled = compiledTemplates || {};
        return _this;
      }
      var _proto = PrecompiledLoader2.prototype;
      _proto.getSource = function getSource(name) {
        if (this.precompiled[name]) {
          return {
            src: {
              type: "code",
              obj: this.precompiled[name]
            },
            path: name
          };
        }
        return null;
      };
      return PrecompiledLoader2;
    })(Loader);
    module2.exports = {
      PrecompiledLoader
    };
  }
});

// node_modules/nunjucks/src/node-loaders.js
var require_node_loaders = __commonJS({
  "node_modules/nunjucks/src/node-loaders.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var fs9 = require("fs");
    var path15 = require("path");
    var Loader = require_loader();
    var _require = require_precompiled_loader();
    var PrecompiledLoader = _require.PrecompiledLoader;
    var chokidar;
    var FileSystemLoader = /* @__PURE__ */ (function(_Loader) {
      _inheritsLoose(FileSystemLoader2, _Loader);
      function FileSystemLoader2(searchPaths, opts) {
        var _this;
        _this = _Loader.call(this) || this;
        if (typeof opts === "boolean") {
          console.log("[nunjucks] Warning: you passed a boolean as the second argument to FileSystemLoader, but it now takes an options object. See http://mozilla.github.io/nunjucks/api.html#filesystemloader");
        }
        opts = opts || {};
        _this.pathsToNames = {};
        _this.noCache = !!opts.noCache;
        if (searchPaths) {
          searchPaths = Array.isArray(searchPaths) ? searchPaths : [searchPaths];
          _this.searchPaths = searchPaths.map(path15.normalize);
        } else {
          _this.searchPaths = ["."];
        }
        if (opts.watch) {
          try {
            chokidar = require("chokidar");
          } catch (e) {
            throw new Error("watch requires chokidar to be installed");
          }
          var paths = _this.searchPaths.filter(fs9.existsSync);
          var watcher = chokidar.watch(paths);
          watcher.on("all", function(event, fullname) {
            fullname = path15.resolve(fullname);
            if (event === "change" && fullname in _this.pathsToNames) {
              _this.emit("update", _this.pathsToNames[fullname], fullname);
            }
          });
          watcher.on("error", function(error) {
            console.log("Watcher error: " + error);
          });
        }
        return _this;
      }
      var _proto = FileSystemLoader2.prototype;
      _proto.getSource = function getSource(name) {
        var fullpath = null;
        var paths = this.searchPaths;
        for (var i2 = 0; i2 < paths.length; i2++) {
          var basePath = path15.resolve(paths[i2]);
          var p = path15.resolve(paths[i2], name);
          if (p.indexOf(basePath) === 0 && fs9.existsSync(p)) {
            fullpath = p;
            break;
          }
        }
        if (!fullpath) {
          return null;
        }
        this.pathsToNames[fullpath] = name;
        var source = {
          src: fs9.readFileSync(fullpath, "utf-8"),
          path: fullpath,
          noCache: this.noCache
        };
        this.emit("load", name, source);
        return source;
      };
      return FileSystemLoader2;
    })(Loader);
    var NodeResolveLoader = /* @__PURE__ */ (function(_Loader2) {
      _inheritsLoose(NodeResolveLoader2, _Loader2);
      function NodeResolveLoader2(opts) {
        var _this2;
        _this2 = _Loader2.call(this) || this;
        opts = opts || {};
        _this2.pathsToNames = {};
        _this2.noCache = !!opts.noCache;
        if (opts.watch) {
          try {
            chokidar = require("chokidar");
          } catch (e) {
            throw new Error("watch requires chokidar to be installed");
          }
          _this2.watcher = chokidar.watch();
          _this2.watcher.on("change", function(fullname) {
            _this2.emit("update", _this2.pathsToNames[fullname], fullname);
          });
          _this2.watcher.on("error", function(error) {
            console.log("Watcher error: " + error);
          });
          _this2.on("load", function(name, source) {
            _this2.watcher.add(source.path);
          });
        }
        return _this2;
      }
      var _proto2 = NodeResolveLoader2.prototype;
      _proto2.getSource = function getSource(name) {
        if (/^\.?\.?(\/|\\)/.test(name)) {
          return null;
        }
        if (/^[A-Z]:/.test(name)) {
          return null;
        }
        var fullpath;
        try {
          fullpath = require.resolve(name);
        } catch (e) {
          return null;
        }
        this.pathsToNames[fullpath] = name;
        var source = {
          src: fs9.readFileSync(fullpath, "utf-8"),
          path: fullpath,
          noCache: this.noCache
        };
        this.emit("load", name, source);
        return source;
      };
      return NodeResolveLoader2;
    })(Loader);
    module2.exports = {
      FileSystemLoader,
      PrecompiledLoader,
      NodeResolveLoader
    };
  }
});

// node_modules/nunjucks/src/loaders.js
var require_loaders = __commonJS({
  "node_modules/nunjucks/src/loaders.js"(exports2, module2) {
    "use strict";
    module2.exports = require_node_loaders();
  }
});

// node_modules/nunjucks/src/tests.js
var require_tests = __commonJS({
  "node_modules/nunjucks/src/tests.js"(exports2) {
    "use strict";
    var SafeString = require_runtime().SafeString;
    function callable(value) {
      return typeof value === "function";
    }
    exports2.callable = callable;
    function defined(value) {
      return value !== void 0;
    }
    exports2.defined = defined;
    function divisibleby(one, two) {
      return one % two === 0;
    }
    exports2.divisibleby = divisibleby;
    function escaped(value) {
      return value instanceof SafeString;
    }
    exports2.escaped = escaped;
    function equalto(one, two) {
      return one === two;
    }
    exports2.equalto = equalto;
    exports2.eq = exports2.equalto;
    exports2.sameas = exports2.equalto;
    function even(value) {
      return value % 2 === 0;
    }
    exports2.even = even;
    function falsy(value) {
      return !value;
    }
    exports2.falsy = falsy;
    function ge(one, two) {
      return one >= two;
    }
    exports2.ge = ge;
    function greaterthan(one, two) {
      return one > two;
    }
    exports2.greaterthan = greaterthan;
    exports2.gt = exports2.greaterthan;
    function le(one, two) {
      return one <= two;
    }
    exports2.le = le;
    function lessthan(one, two) {
      return one < two;
    }
    exports2.lessthan = lessthan;
    exports2.lt = exports2.lessthan;
    function lower(value) {
      return value.toLowerCase() === value;
    }
    exports2.lower = lower;
    function ne(one, two) {
      return one !== two;
    }
    exports2.ne = ne;
    function nullTest(value) {
      return value === null;
    }
    exports2.null = nullTest;
    function number(value) {
      return typeof value === "number";
    }
    exports2.number = number;
    function odd(value) {
      return value % 2 === 1;
    }
    exports2.odd = odd;
    function string(value) {
      return typeof value === "string";
    }
    exports2.string = string;
    function truthy(value) {
      return !!value;
    }
    exports2.truthy = truthy;
    function undefinedTest(value) {
      return value === void 0;
    }
    exports2.undefined = undefinedTest;
    function upper(value) {
      return value.toUpperCase() === value;
    }
    exports2.upper = upper;
    function iterable(value) {
      if (typeof Symbol !== "undefined") {
        return !!value[Symbol.iterator];
      } else {
        return Array.isArray(value) || typeof value === "string";
      }
    }
    exports2.iterable = iterable;
    function mapping(value) {
      var bool = value !== null && value !== void 0 && typeof value === "object" && !Array.isArray(value);
      if (Set) {
        return bool && !(value instanceof Set);
      } else {
        return bool;
      }
    }
    exports2.mapping = mapping;
  }
});

// node_modules/nunjucks/src/globals.js
var require_globals = __commonJS({
  "node_modules/nunjucks/src/globals.js"(exports2, module2) {
    "use strict";
    function _cycler(items) {
      var index = -1;
      return {
        current: null,
        reset: function reset2() {
          index = -1;
          this.current = null;
        },
        next: function next() {
          index++;
          if (index >= items.length) {
            index = 0;
          }
          this.current = items[index];
          return this.current;
        }
      };
    }
    function _joiner(sep2) {
      sep2 = sep2 || ",";
      var first = true;
      return function() {
        var val = first ? "" : sep2;
        first = false;
        return val;
      };
    }
    function globals() {
      return {
        range: function range2(start, stop, step) {
          if (typeof stop === "undefined") {
            stop = start;
            start = 0;
            step = 1;
          } else if (!step) {
            step = 1;
          }
          var arr = [];
          if (step > 0) {
            for (var i2 = start; i2 < stop; i2 += step) {
              arr.push(i2);
            }
          } else {
            for (var _i = start; _i > stop; _i += step) {
              arr.push(_i);
            }
          }
          return arr;
        },
        cycler: function cycler() {
          return _cycler(Array.prototype.slice.call(arguments));
        },
        joiner: function joiner(sep2) {
          return _joiner(sep2);
        }
      };
    }
    module2.exports = globals;
  }
});

// node_modules/nunjucks/src/express-app.js
var require_express_app = __commonJS({
  "node_modules/nunjucks/src/express-app.js"(exports2, module2) {
    "use strict";
    var path15 = require("path");
    module2.exports = function express(env2, app) {
      function NunjucksView(name, opts) {
        this.name = name;
        this.path = name;
        this.defaultEngine = opts.defaultEngine;
        this.ext = path15.extname(name);
        if (!this.ext && !this.defaultEngine) {
          throw new Error("No default engine was specified and no extension was provided.");
        }
        if (!this.ext) {
          this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
        }
      }
      NunjucksView.prototype.render = function render(opts, cb) {
        env2.render(this.name, opts, cb);
      };
      app.set("view", NunjucksView);
      app.set("nunjucksEnv", env2);
      return env2;
    };
  }
});

// node_modules/nunjucks/src/environment.js
var require_environment = __commonJS({
  "node_modules/nunjucks/src/environment.js"(exports2, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o2, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p2) {
        o3.__proto__ = p2;
        return o3;
      };
      return _setPrototypeOf(o2, p);
    }
    var asap2 = require_asap();
    var _waterfall = require_a_sync_waterfall();
    var lib2 = require_lib2();
    var compiler = require_compiler();
    var filters = require_filters();
    var _require = require_loaders();
    var FileSystemLoader = _require.FileSystemLoader;
    var WebLoader = _require.WebLoader;
    var PrecompiledLoader = _require.PrecompiledLoader;
    var tests = require_tests();
    var globals = require_globals();
    var _require2 = require_object();
    var Obj = _require2.Obj;
    var EmitterObj = _require2.EmitterObj;
    var globalRuntime = require_runtime();
    var handleError = globalRuntime.handleError;
    var Frame = globalRuntime.Frame;
    var expressApp = require_express_app();
    function callbackAsap(cb, err, res) {
      asap2(function() {
        cb(err, res);
      });
    }
    var noopTmplSrc = {
      type: "code",
      obj: {
        root: function root(env2, context, frame, runtime, cb) {
          try {
            cb(null, "");
          } catch (e) {
            cb(handleError(e, null, null));
          }
        }
      }
    };
    var Environment = /* @__PURE__ */ (function(_EmitterObj) {
      _inheritsLoose(Environment2, _EmitterObj);
      function Environment2() {
        return _EmitterObj.apply(this, arguments) || this;
      }
      var _proto = Environment2.prototype;
      _proto.init = function init(loaders, opts) {
        var _this = this;
        opts = this.opts = opts || {};
        this.opts.dev = !!opts.dev;
        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
        this.opts.throwOnUndefined = !!opts.throwOnUndefined;
        this.opts.trimBlocks = !!opts.trimBlocks;
        this.opts.lstripBlocks = !!opts.lstripBlocks;
        this.loaders = [];
        if (!loaders) {
          if (FileSystemLoader) {
            this.loaders = [new FileSystemLoader("views")];
          } else if (WebLoader) {
            this.loaders = [new WebLoader("/views")];
          }
        } else {
          this.loaders = lib2.isArray(loaders) ? loaders : [loaders];
        }
        if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
          this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
        }
        this._initLoaders();
        this.globals = globals();
        this.filters = {};
        this.tests = {};
        this.asyncFilters = [];
        this.extensions = {};
        this.extensionsList = [];
        lib2._entries(filters).forEach(function(_ref) {
          var name = _ref[0], filter3 = _ref[1];
          return _this.addFilter(name, filter3);
        });
        lib2._entries(tests).forEach(function(_ref2) {
          var name = _ref2[0], test3 = _ref2[1];
          return _this.addTest(name, test3);
        });
      };
      _proto._initLoaders = function _initLoaders() {
        var _this2 = this;
        this.loaders.forEach(function(loader) {
          loader.cache = {};
          if (typeof loader.on === "function") {
            loader.on("update", function(name, fullname) {
              loader.cache[name] = null;
              _this2.emit("update", name, fullname, loader);
            });
            loader.on("load", function(name, source) {
              _this2.emit("load", name, source, loader);
            });
          }
        });
      };
      _proto.invalidateCache = function invalidateCache() {
        this.loaders.forEach(function(loader) {
          loader.cache = {};
        });
      };
      _proto.addExtension = function addExtension(name, extension) {
        extension.__name = name;
        this.extensions[name] = extension;
        this.extensionsList.push(extension);
        return this;
      };
      _proto.removeExtension = function removeExtension(name) {
        var extension = this.getExtension(name);
        if (!extension) {
          return;
        }
        this.extensionsList = lib2.without(this.extensionsList, extension);
        delete this.extensions[name];
      };
      _proto.getExtension = function getExtension(name) {
        return this.extensions[name];
      };
      _proto.hasExtension = function hasExtension(name) {
        return !!this.extensions[name];
      };
      _proto.addGlobal = function addGlobal(name, value) {
        this.globals[name] = value;
        return this;
      };
      _proto.getGlobal = function getGlobal(name) {
        if (typeof this.globals[name] === "undefined") {
          throw new Error("global not found: " + name);
        }
        return this.globals[name];
      };
      _proto.addFilter = function addFilter(name, func, async) {
        var wrapped = func;
        if (async) {
          this.asyncFilters.push(name);
        }
        this.filters[name] = wrapped;
        return this;
      };
      _proto.getFilter = function getFilter(name) {
        if (!this.filters[name]) {
          throw new Error("filter not found: " + name);
        }
        return this.filters[name];
      };
      _proto.addTest = function addTest(name, func) {
        this.tests[name] = func;
        return this;
      };
      _proto.getTest = function getTest(name) {
        if (!this.tests[name]) {
          throw new Error("test not found: " + name);
        }
        return this.tests[name];
      };
      _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
        var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
        return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
      };
      _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
        var _this3 = this;
        var that = this;
        var tmpl = null;
        if (name && name.raw) {
          name = name.raw;
        }
        if (lib2.isFunction(parentName)) {
          cb = parentName;
          parentName = null;
          eagerCompile = eagerCompile || false;
        }
        if (lib2.isFunction(eagerCompile)) {
          cb = eagerCompile;
          eagerCompile = false;
        }
        if (name instanceof Template) {
          tmpl = name;
        } else if (typeof name !== "string") {
          throw new Error("template names must be a string: " + name);
        } else {
          for (var i2 = 0; i2 < this.loaders.length; i2++) {
            var loader = this.loaders[i2];
            tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];
            if (tmpl) {
              break;
            }
          }
        }
        if (tmpl) {
          if (eagerCompile) {
            tmpl.compile();
          }
          if (cb) {
            cb(null, tmpl);
            return void 0;
          } else {
            return tmpl;
          }
        }
        var syncResult;
        var createTemplate = function createTemplate2(err, info) {
          if (!info && !err && !ignoreMissing) {
            err = new Error("template not found: " + name);
          }
          if (err) {
            if (cb) {
              cb(err);
              return;
            } else {
              throw err;
            }
          }
          var newTmpl;
          if (!info) {
            newTmpl = new Template(noopTmplSrc, _this3, "", eagerCompile);
          } else {
            newTmpl = new Template(info.src, _this3, info.path, eagerCompile);
            if (!info.noCache) {
              info.loader.cache[name] = newTmpl;
            }
          }
          if (cb) {
            cb(null, newTmpl);
          } else {
            syncResult = newTmpl;
          }
        };
        lib2.asyncIter(this.loaders, function(loader2, i3, next, done) {
          function handle(err, src) {
            if (err) {
              done(err);
            } else if (src) {
              src.loader = loader2;
              done(null, src);
            } else {
              next();
            }
          }
          name = that.resolveTemplate(loader2, parentName, name);
          if (loader2.async) {
            loader2.getSource(name, handle);
          } else {
            handle(null, loader2.getSource(name));
          }
        }, createTemplate);
        return syncResult;
      };
      _proto.express = function express(app) {
        return expressApp(this, app);
      };
      _proto.render = function render(name, ctx, cb) {
        if (lib2.isFunction(ctx)) {
          cb = ctx;
          ctx = null;
        }
        var syncResult = null;
        this.getTemplate(name, function(err, tmpl) {
          if (err && cb) {
            callbackAsap(cb, err);
          } else if (err) {
            throw err;
          } else {
            syncResult = tmpl.render(ctx, cb);
          }
        });
        return syncResult;
      };
      _proto.renderString = function renderString(src, ctx, opts, cb) {
        if (lib2.isFunction(opts)) {
          cb = opts;
          opts = {};
        }
        opts = opts || {};
        var tmpl = new Template(src, this, opts.path);
        return tmpl.render(ctx, cb);
      };
      _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
        return _waterfall(tasks, callback, forceAsync);
      };
      return Environment2;
    })(EmitterObj);
    var Context = /* @__PURE__ */ (function(_Obj) {
      _inheritsLoose(Context2, _Obj);
      function Context2() {
        return _Obj.apply(this, arguments) || this;
      }
      var _proto2 = Context2.prototype;
      _proto2.init = function init(ctx, blocks, env2) {
        var _this4 = this;
        this.env = env2 || new Environment();
        this.ctx = lib2.extend({}, ctx);
        this.blocks = {};
        this.exported = [];
        lib2.keys(blocks).forEach(function(name) {
          _this4.addBlock(name, blocks[name]);
        });
      };
      _proto2.lookup = function lookup(name) {
        if (name in this.env.globals && !(name in this.ctx)) {
          return this.env.globals[name];
        } else {
          return this.ctx[name];
        }
      };
      _proto2.setVariable = function setVariable(name, val) {
        this.ctx[name] = val;
      };
      _proto2.getVariables = function getVariables() {
        return this.ctx;
      };
      _proto2.addBlock = function addBlock(name, block2) {
        this.blocks[name] = this.blocks[name] || [];
        this.blocks[name].push(block2);
        return this;
      };
      _proto2.getBlock = function getBlock(name) {
        if (!this.blocks[name]) {
          throw new Error('unknown block "' + name + '"');
        }
        return this.blocks[name][0];
      };
      _proto2.getSuper = function getSuper(env2, name, block2, frame, runtime, cb) {
        var idx = lib2.indexOf(this.blocks[name] || [], block2);
        var blk = this.blocks[name][idx + 1];
        var context = this;
        if (idx === -1 || !blk) {
          throw new Error('no super block available for "' + name + '"');
        }
        blk(env2, context, frame, runtime, cb);
      };
      _proto2.addExport = function addExport(name) {
        this.exported.push(name);
      };
      _proto2.getExported = function getExported() {
        var _this5 = this;
        var exported = {};
        this.exported.forEach(function(name) {
          exported[name] = _this5.ctx[name];
        });
        return exported;
      };
      return Context2;
    })(Obj);
    var Template = /* @__PURE__ */ (function(_Obj2) {
      _inheritsLoose(Template2, _Obj2);
      function Template2() {
        return _Obj2.apply(this, arguments) || this;
      }
      var _proto3 = Template2.prototype;
      _proto3.init = function init(src, env2, path15, eagerCompile) {
        this.env = env2 || new Environment();
        if (lib2.isObject(src)) {
          switch (src.type) {
            case "code":
              this.tmplProps = src.obj;
              break;
            case "string":
              this.tmplStr = src.obj;
              break;
            default:
              throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
          }
        } else if (lib2.isString(src)) {
          this.tmplStr = src;
        } else {
          throw new Error("src must be a string or an object describing the source");
        }
        this.path = path15;
        if (eagerCompile) {
          try {
            this._compile();
          } catch (err) {
            throw lib2._prettifyError(this.path, this.env.opts.dev, err);
          }
        } else {
          this.compiled = false;
        }
      };
      _proto3.render = function render(ctx, parentFrame, cb) {
        var _this6 = this;
        if (typeof ctx === "function") {
          cb = ctx;
          ctx = {};
        } else if (typeof parentFrame === "function") {
          cb = parentFrame;
          parentFrame = null;
        }
        var forceAsync = !parentFrame;
        try {
          this.compile();
        } catch (e) {
          var err = lib2._prettifyError(this.path, this.env.opts.dev, e);
          if (cb) {
            return callbackAsap(cb, err);
          } else {
            throw err;
          }
        }
        var context = new Context(ctx || {}, this.blocks, this.env);
        var frame = parentFrame ? parentFrame.push(true) : new Frame();
        frame.topLevel = true;
        var syncResult = null;
        var didError = false;
        this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err2, res) {
          if (didError && cb && typeof res !== "undefined") {
            return;
          }
          if (err2) {
            err2 = lib2._prettifyError(_this6.path, _this6.env.opts.dev, err2);
            didError = true;
          }
          if (cb) {
            if (forceAsync) {
              callbackAsap(cb, err2, res);
            } else {
              cb(err2, res);
            }
          } else {
            if (err2) {
              throw err2;
            }
            syncResult = res;
          }
        });
        return syncResult;
      };
      _proto3.getExported = function getExported(ctx, parentFrame, cb) {
        if (typeof ctx === "function") {
          cb = ctx;
          ctx = {};
        }
        if (typeof parentFrame === "function") {
          cb = parentFrame;
          parentFrame = null;
        }
        try {
          this.compile();
        } catch (e) {
          if (cb) {
            return cb(e);
          } else {
            throw e;
          }
        }
        var frame = parentFrame ? parentFrame.push() : new Frame();
        frame.topLevel = true;
        var context = new Context(ctx || {}, this.blocks, this.env);
        this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err) {
          if (err) {
            cb(err, null);
          } else {
            cb(null, context.getExported());
          }
        });
      };
      _proto3.compile = function compile2() {
        if (!this.compiled) {
          this._compile();
        }
      };
      _proto3._compile = function _compile() {
        var props;
        if (this.tmplProps) {
          props = this.tmplProps;
        } else {
          var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
          var func = new Function(source);
          props = func();
        }
        this.blocks = this._getBlocks(props);
        this.rootRenderFunc = props.root;
        this.compiled = true;
      };
      _proto3._getBlocks = function _getBlocks(props) {
        var blocks = {};
        lib2.keys(props).forEach(function(k) {
          if (k.slice(0, 2) === "b_") {
            blocks[k.slice(2)] = props[k];
          }
        });
        return blocks;
      };
      return Template2;
    })(Obj);
    module2.exports = {
      Environment,
      Template
    };
  }
});

// node_modules/nunjucks/src/precompile-global.js
var require_precompile_global = __commonJS({
  "node_modules/nunjucks/src/precompile-global.js"(exports2, module2) {
    "use strict";
    function precompileGlobal(templates, opts) {
      var out = "";
      opts = opts || {};
      for (var i2 = 0; i2 < templates.length; i2++) {
        var name = JSON.stringify(templates[i2].name);
        var template = templates[i2].template;
        out += "(function() {(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})[" + name + "] = (function() {\n" + template + "\n})();\n";
        if (opts.asFunction) {
          out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
        }
        out += "})();\n";
      }
      return out;
    }
    module2.exports = precompileGlobal;
  }
});

// node_modules/nunjucks/src/precompile.js
var require_precompile = __commonJS({
  "node_modules/nunjucks/src/precompile.js"(exports2, module2) {
    "use strict";
    var fs9 = require("fs");
    var path15 = require("path");
    var _require = require_lib2();
    var _prettifyError = _require._prettifyError;
    var compiler = require_compiler();
    var _require2 = require_environment();
    var Environment = _require2.Environment;
    var precompileGlobal = require_precompile_global();
    function match3(filename, patterns) {
      if (!Array.isArray(patterns)) {
        return false;
      }
      return patterns.some(function(pattern) {
        return filename.match(pattern);
      });
    }
    function precompileString(str, opts) {
      opts = opts || {};
      opts.isString = true;
      var env2 = opts.env || new Environment([]);
      var wrapper = opts.wrapper || precompileGlobal;
      if (!opts.name) {
        throw new Error('the "name" option is required when compiling a string');
      }
      return wrapper([_precompile(str, opts.name, env2)], opts);
    }
    function precompile(input, opts) {
      opts = opts || {};
      var env2 = opts.env || new Environment([]);
      var wrapper = opts.wrapper || precompileGlobal;
      if (opts.isString) {
        return precompileString(input, opts);
      }
      var pathStats = fs9.existsSync(input) && fs9.statSync(input);
      var precompiled = [];
      var templates = [];
      function addTemplates(dir) {
        fs9.readdirSync(dir).forEach(function(file) {
          var filepath = path15.join(dir, file);
          var subpath = filepath.substr(path15.join(input, "/").length);
          var stat = fs9.statSync(filepath);
          if (stat && stat.isDirectory()) {
            subpath += "/";
            if (!match3(subpath, opts.exclude)) {
              addTemplates(filepath);
            }
          } else if (match3(subpath, opts.include)) {
            templates.push(filepath);
          }
        });
      }
      if (pathStats.isFile()) {
        precompiled.push(_precompile(fs9.readFileSync(input, "utf-8"), opts.name || input, env2));
      } else if (pathStats.isDirectory()) {
        addTemplates(input);
        for (var i2 = 0; i2 < templates.length; i2++) {
          var name = templates[i2].replace(path15.join(input, "/"), "");
          try {
            precompiled.push(_precompile(fs9.readFileSync(templates[i2], "utf-8"), name, env2));
          } catch (e) {
            if (opts.force) {
              console.error(e);
            } else {
              throw e;
            }
          }
        }
      }
      return wrapper(precompiled, opts);
    }
    function _precompile(str, name, env2) {
      env2 = env2 || new Environment([]);
      var asyncFilters = env2.asyncFilters;
      var extensions2 = env2.extensionsList;
      var template;
      name = name.replace(/\\/g, "/");
      try {
        template = compiler.compile(str, asyncFilters, extensions2, name, env2.opts);
      } catch (err) {
        throw _prettifyError(name, false, err);
      }
      return {
        name,
        template
      };
    }
    module2.exports = {
      precompile,
      precompileString
    };
  }
});

// node_modules/nunjucks/src/jinja-compat.js
var require_jinja_compat = __commonJS({
  "node_modules/nunjucks/src/jinja-compat.js"(exports2, module2) {
    "use strict";
    function installCompat() {
      "use strict";
      var runtime = this.runtime;
      var lib2 = this.lib;
      var Compiler = this.compiler.Compiler;
      var Parser = this.parser.Parser;
      var nodes = this.nodes;
      var lexer = this.lexer;
      var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
      var orig_memberLookup = runtime.memberLookup;
      var orig_Compiler_assertType;
      var orig_Parser_parseAggregate;
      if (Compiler) {
        orig_Compiler_assertType = Compiler.prototype.assertType;
      }
      if (Parser) {
        orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
      }
      function uninstall() {
        runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
        runtime.memberLookup = orig_memberLookup;
        if (Compiler) {
          Compiler.prototype.assertType = orig_Compiler_assertType;
        }
        if (Parser) {
          Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
        }
      }
      runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
        var val = orig_contextOrFrameLookup.apply(this, arguments);
        if (val !== void 0) {
          return val;
        }
        switch (key) {
          case "True":
            return true;
          case "False":
            return false;
          case "None":
            return null;
          default:
            return void 0;
        }
      };
      function getTokensState(tokens) {
        return {
          index: tokens.index,
          lineno: tokens.lineno,
          colno: tokens.colno
        };
      }
      if (process.env.BUILD_TYPE !== "SLIM" && nodes && Compiler && Parser) {
        var Slice = nodes.Node.extend("Slice", {
          fields: ["start", "stop", "step"],
          init: function init(lineno, colno, start, stop, step) {
            start = start || new nodes.Literal(lineno, colno, null);
            stop = stop || new nodes.Literal(lineno, colno, null);
            step = step || new nodes.Literal(lineno, colno, 1);
            this.parent(lineno, colno, start, stop, step);
          }
        });
        Compiler.prototype.assertType = function assertType(node) {
          if (node instanceof Slice) {
            return;
          }
          orig_Compiler_assertType.apply(this, arguments);
        };
        Compiler.prototype.compileSlice = function compileSlice(node, frame) {
          this._emit("(");
          this._compileExpression(node.start, frame);
          this._emit("),(");
          this._compileExpression(node.stop, frame);
          this._emit("),(");
          this._compileExpression(node.step, frame);
          this._emit(")");
        };
        Parser.prototype.parseAggregate = function parseAggregate() {
          var _this = this;
          var origState = getTokensState(this.tokens);
          origState.colno--;
          origState.index--;
          try {
            return orig_Parser_parseAggregate.apply(this);
          } catch (e) {
            var errState = getTokensState(this.tokens);
            var rethrow = function rethrow2() {
              lib2._assign(_this.tokens, errState);
              return e;
            };
            lib2._assign(this.tokens, origState);
            this.peeked = false;
            var tok = this.peekToken();
            if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
              throw rethrow();
            } else {
              this.nextToken();
            }
            var node = new Slice(tok.lineno, tok.colno);
            var isSlice = false;
            for (var i2 = 0; i2 <= node.fields.length; i2++) {
              if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                break;
              }
              if (i2 === node.fields.length) {
                if (isSlice) {
                  this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                } else {
                  break;
                }
              }
              if (this.skip(lexer.TOKEN_COLON)) {
                isSlice = true;
              } else {
                var field = node.fields[i2];
                node[field] = this.parseExpression();
                isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
              }
            }
            if (!isSlice) {
              throw rethrow();
            }
            return new nodes.Array(tok.lineno, tok.colno, [node]);
          }
        };
      }
      function sliceLookup(obj, start, stop, step) {
        obj = obj || [];
        if (start === null) {
          start = step < 0 ? obj.length - 1 : 0;
        }
        if (stop === null) {
          stop = step < 0 ? -1 : obj.length;
        } else if (stop < 0) {
          stop += obj.length;
        }
        if (start < 0) {
          start += obj.length;
        }
        var results = [];
        for (var i2 = start; ; i2 += step) {
          if (i2 < 0 || i2 > obj.length) {
            break;
          }
          if (step > 0 && i2 >= stop) {
            break;
          }
          if (step < 0 && i2 <= stop) {
            break;
          }
          results.push(runtime.memberLookup(obj, i2));
        }
        return results;
      }
      function hasOwnProp(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      var ARRAY_MEMBERS = {
        pop: function pop(index) {
          if (index === void 0) {
            return this.pop();
          }
          if (index >= this.length || index < 0) {
            throw new Error("KeyError");
          }
          return this.splice(index, 1);
        },
        append: function append2(element) {
          return this.push(element);
        },
        remove: function remove(element) {
          for (var i2 = 0; i2 < this.length; i2++) {
            if (this[i2] === element) {
              return this.splice(i2, 1);
            }
          }
          throw new Error("ValueError");
        },
        count: function count2(element) {
          var count3 = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            if (this[i2] === element) {
              count3++;
            }
          }
          return count3;
        },
        index: function index(element) {
          var i2;
          if ((i2 = this.indexOf(element)) === -1) {
            throw new Error("ValueError");
          }
          return i2;
        },
        find: function find(element) {
          return this.indexOf(element);
        },
        insert: function insert(index, elem) {
          return this.splice(index, 0, elem);
        }
      };
      var OBJECT_MEMBERS = {
        items: function items() {
          return lib2._entries(this);
        },
        values: function values() {
          return lib2._values(this);
        },
        keys: function keys() {
          return lib2.keys(this);
        },
        get: function get(key, def) {
          var output = this[key];
          if (output === void 0) {
            output = def;
          }
          return output;
        },
        has_key: function has_key(key) {
          return hasOwnProp(this, key);
        },
        pop: function pop(key, def) {
          var output = this[key];
          if (output === void 0 && def !== void 0) {
            output = def;
          } else if (output === void 0) {
            throw new Error("KeyError");
          } else {
            delete this[key];
          }
          return output;
        },
        popitem: function popitem() {
          var keys = lib2.keys(this);
          if (!keys.length) {
            throw new Error("KeyError");
          }
          var k = keys[0];
          var val = this[k];
          delete this[k];
          return [k, val];
        },
        setdefault: function setdefault(key, def) {
          if (def === void 0) {
            def = null;
          }
          if (!(key in this)) {
            this[key] = def;
          }
          return this[key];
        },
        update: function update(kwargs) {
          lib2._assign(this, kwargs);
          return null;
        }
      };
      OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
      OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
      OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
      runtime.memberLookup = function memberLookup(obj, val, autoescape) {
        if (arguments.length === 4) {
          return sliceLookup.apply(this, arguments);
        }
        obj = obj || {};
        if (lib2.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
          return ARRAY_MEMBERS[val].bind(obj);
        }
        if (lib2.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
          return OBJECT_MEMBERS[val].bind(obj);
        }
        return orig_memberLookup.apply(this, arguments);
      };
      return uninstall;
    }
    module2.exports = installCompat;
  }
});

// node_modules/nunjucks/index.js
var require_nunjucks = __commonJS({
  "node_modules/nunjucks/index.js"(exports2, module2) {
    "use strict";
    var lib2 = require_lib2();
    var _require = require_environment();
    var Environment = _require.Environment;
    var Template = _require.Template;
    var Loader = require_loader();
    var loaders = require_loaders();
    var precompile = require_precompile();
    var compiler = require_compiler();
    var parser = require_parser();
    var lexer = require_lexer();
    var runtime = require_runtime();
    var nodes = require_nodes();
    var installJinjaCompat = require_jinja_compat();
    var e;
    function configure2(templatesPath, opts) {
      opts = opts || {};
      if (lib2.isObject(templatesPath)) {
        opts = templatesPath;
        templatesPath = null;
      }
      var TemplateLoader;
      if (loaders.FileSystemLoader) {
        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
          watch: opts.watch,
          noCache: opts.noCache
        });
      } else if (loaders.WebLoader) {
        TemplateLoader = new loaders.WebLoader(templatesPath, {
          useCache: opts.web && opts.web.useCache,
          async: opts.web && opts.web.async
        });
      }
      e = new Environment(TemplateLoader, opts);
      if (opts && opts.express) {
        e.express(opts.express);
      }
      return e;
    }
    module2.exports = {
      Environment,
      Template,
      Loader,
      FileSystemLoader: loaders.FileSystemLoader,
      NodeResolveLoader: loaders.NodeResolveLoader,
      PrecompiledLoader: loaders.PrecompiledLoader,
      WebLoader: loaders.WebLoader,
      compiler,
      parser,
      lexer,
      runtime,
      lib: lib2,
      nodes,
      installJinjaCompat,
      configure: configure2,
      reset: function reset2() {
        e = void 0;
      },
      compile: function compile2(src, env2, path15, eagerCompile) {
        if (!e) {
          configure2();
        }
        return new Template(src, env2, path15, eagerCompile);
      },
      render: function render(name, ctx, cb) {
        if (!e) {
          configure2();
        }
        return e.render(name, ctx, cb);
      },
      renderString: function renderString(src, ctx, cb) {
        if (!e) {
          configure2();
        }
        return e.renderString(src, ctx, cb);
      },
      precompile: precompile ? precompile.precompile : void 0,
      precompileString: precompile ? precompile.precompileString : void 0
    };
  }
});

// node_modules/node-dir/lib/paths.js
var require_paths = __commonJS({
  "node_modules/node-dir/lib/paths.js"(exports2) {
    var fs9 = require("fs");
    var path15 = require("path");
    exports2.promiseFiles = function promiseFiles(dir, type, options) {
      type = type || "file";
      var processor = function(res, rej) {
        var cb = function(err, data) {
          if (err) return rej(err);
          res(data);
        };
        exports2.files(dir, type, cb, options);
      };
      return new Promise(processor);
    };
    exports2.files = function files(dir, type, callback, options) {
      var ofType = typeof type;
      if (ofType == "object") {
        options = options || type;
        type = "file";
        callback = function() {
        };
      } else if (ofType !== "string") {
        callback = type;
        type = "file";
      }
      options = options || {};
      var pending, results = {
        files: [],
        dirs: []
      };
      var done = function() {
        if (type === "combine") {
          results = results.files.concat(results.dirs);
        } else if (!type || options.ignoreType || ["all", "combine"].indexOf(type) >= 0) {
          results = results;
        } else {
          results = results[type + "s"];
        }
        if (options.sync) return;
        callback(null, results);
      };
      var getStatHandler = function(statPath, name, lstatCalled) {
        return function(err, stat) {
          if (err) {
            if (!lstatCalled) {
              return fs9.lstat(statPath, getStatHandler(statPath, name, true));
            }
            return callback(err);
          }
          var pushVal = options.shortName ? name : statPath;
          if (stat && stat.isDirectory() && stat.mode !== 17115) {
            if (type !== "file") {
              results.dirs.push(pushVal);
            }
            if (options.recursive == null || options.recursive) {
              var subloop = function(err2, res) {
                if (err2) {
                  return callback(err2);
                }
                if (type === "combine") {
                  results.files = results.files.concat(res);
                } else if (type === "all") {
                  results.files = results.files.concat(res.files);
                  results.dirs = results.dirs.concat(res.dirs);
                } else if (type === "file") {
                  results.files = results.files.concat(res.files);
                } else {
                  results.dirs = results.dirs.concat(res.dirs);
                }
                if (!--pending) {
                  done();
                }
              };
              var newOptions = Object.assign({}, options);
              newOptions.ignoreType = true;
              var moreResults = files(statPath, type, subloop, newOptions);
              if (options.sync) {
                subloop(null, moreResults);
              }
            } else if (!--pending) {
              done();
            }
          } else {
            if (type !== "dir") {
              results.files.push(pushVal);
            }
            if (!--pending) {
              done();
            }
          }
        };
      };
      var bufdir = Buffer.from(dir);
      const onDirRead = function(err, list2) {
        if (err) return callback(err);
        pending = list2.length;
        if (!pending) return done();
        for (var file, i2 = 0, l = list2.length; i2 < l; i2++) {
          var fname = list2[i2].toString();
          file = path15.join(dir, fname);
          var buffile = Buffer.concat([bufdir, Buffer.from(path15.sep), list2[i2]]);
          if (options.sync) {
            var res = fs9.statSync(buffile);
            getStatHandler(file, fname)(null, res);
          } else {
            fs9.stat(buffile, getStatHandler(file, fname));
          }
        }
        return results;
      };
      const onStat = function(err, stat) {
        if (err) return callback(err);
        if (stat && stat.mode === 17115) return done();
        if (options.sync) {
          const list2 = fs9.readdirSync(bufdir, { encoding: "buffer" });
          return onDirRead(null, list2);
        } else {
          fs9.readdir(bufdir, { encoding: "buffer" }, onDirRead);
        }
      };
      if (options.sync) {
        const stat = fs9.statSync(bufdir);
        return onStat(null, stat);
      } else {
        fs9.stat(bufdir, onStat);
      }
    };
    exports2.paths = function paths(dir, combine, callback) {
      var type;
      if (typeof combine === "function") {
        callback = combine;
        combine = false;
      }
      exports2.files(dir, "all", function(err, results) {
        if (err) return callback(err);
        if (combine) {
          callback(null, results.files.concat(results.dirs));
        } else {
          callback(null, results);
        }
      });
    };
    exports2.subdirs = function subdirs(dir, callback, type, options) {
      options = options || {};
      const iCallback = function(err, subdirs2) {
        if (err) return callback(err);
        if (type == "combine") {
          subdirs2 = subdirs2.files.concat(subdirs2.dirs);
        }
        if (options.sync) return subdirs2;
        callback(null, subdirs2);
      };
      const res = exports2.files(dir, "dir", iCallback, options);
      if (options && options.sync) {
        return iCallback(null, res);
      }
    };
  }
});

// node_modules/node-dir/lib/readfiles.js
var require_readfiles = __commonJS({
  "node_modules/node-dir/lib/readfiles.js"(exports2, module2) {
    var fs9 = require("fs");
    var path15 = require("path");
    function extend2(target, source, modify) {
      var result = target ? modify ? target : extend2({}, target, true) : {};
      if (!source) return result;
      for (var key in source) {
        if (source.hasOwnProperty(key) && source[key] !== void 0) {
          result[key] = source[key];
        }
      }
      return result;
    }
    function matches(str, match3) {
      if (Array.isArray(match3)) return match3.indexOf(str) > -1;
      return match3.test(str);
    }
    function readFiles(dir, options, callback, complete) {
      if (typeof options === "function") {
        complete = callback;
        callback = options;
        options = {};
      }
      if (typeof options === "string") options = {
        encoding: options
      };
      options = extend2({
        recursive: true,
        encoding: "utf8",
        doneOnErr: true
      }, options);
      var files = [];
      var done = function(err) {
        if (typeof complete === "function") {
          if (err) return complete(err);
          complete(null, files);
        }
      };
      fs9.readdir(dir, function(err, list2) {
        if (err) {
          if (options.doneOnErr === true) {
            if (err.code === "EACCES") return done();
            return done(err);
          }
        }
        var i2 = 0;
        if (options.reverse === true || typeof options.sort == "string" && /reverse|desc/i.test(options.sort)) {
          list2 = list2.reverse();
        } else if (options.sort !== false) list2 = list2.sort();
        (function next() {
          var filename = list2[i2++];
          if (!filename) return done(null, files);
          var file = path15.join(dir, filename);
          fs9.stat(file, function(err2, stat) {
            if (err2 && options.doneOnErr === true) return done(err2);
            if (stat && stat.isDirectory()) {
              if (options.recursive) {
                if (options.matchDir && !matches(filename, options.matchDir)) return next();
                if (options.excludeDir && matches(filename, options.excludeDir)) return next();
                readFiles(file, options, callback, function(err3, sfiles) {
                  if (err3 && options.doneOnErr === true) return done(err3);
                  files = files.concat(sfiles);
                  next();
                });
              } else next();
            } else if (stat && stat.isFile()) {
              if (options.match && !matches(filename, options.match)) return next();
              if (options.exclude && matches(filename, options.exclude)) return next();
              if (options.filter && !options.filter(filename)) return next();
              if (options.shortName) files.push(filename);
              else files.push(file);
              fs9.readFile(file, options.encoding, function(err3, data) {
                if (err3) {
                  if (err3.code === "EACCES") return next();
                  if (options.doneOnErr === true) {
                    return done(err3);
                  }
                }
                if (callback.length > 3)
                  if (options.shortName) callback(null, data, filename, next);
                  else callback(null, data, file, next);
                else callback(null, data, next);
              });
            } else {
              next();
            }
          });
        })();
      });
    }
    module2.exports = readFiles;
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i2 = 0; i2 < xs.length; i2++) {
        var x = fn(xs[i2], i2);
        if (isArray2(x)) res.push.apply(res, x);
        else res.push(x);
      }
      return res;
    };
    var isArray2 = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced2;
    function balanced2(a2, b, str) {
      if (a2 instanceof RegExp) a2 = maybeMatch2(a2, str);
      if (b instanceof RegExp) b = maybeMatch2(b, str);
      var r = range2(a2, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a2.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch2(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced2.range = range2;
    function range2(a2, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a2);
      var bi = str.indexOf(b, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a2 === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a2, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced2 = require_balanced_match();
    module2.exports = expandTop;
    var escSlash2 = "\0SLASH" + Math.random() + "\0";
    var escOpen2 = "\0OPEN" + Math.random() + "\0";
    var escClose2 = "\0CLOSE" + Math.random() + "\0";
    var escComma2 = "\0COMMA" + Math.random() + "\0";
    var escPeriod2 = "\0PERIOD" + Math.random() + "\0";
    function numeric2(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces2(str) {
      return str.split("\\\\").join(escSlash2).split("\\{").join(escOpen2).split("\\}").join(escClose2).split("\\,").join(escComma2).split("\\.").join(escPeriod2);
    }
    function unescapeBraces2(str) {
      return str.split(escSlash2).join("\\").split(escOpen2).join("{").split(escClose2).join("}").split(escComma2).join(",").split(escPeriod2).join(".");
    }
    function parseCommaParts2(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced2("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts2(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces2(str), true).map(unescapeBraces2);
    }
    function embrace2(str) {
      return "{" + str + "}";
    }
    function isPadded2(el) {
      return /^-?0\d/.test(el);
    }
    function lte2(i2, y) {
      return i2 <= y;
    }
    function gte2(i2, y) {
      return i2 >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced2("{", "}", str);
      if (!m || /\$$/.test(m.pre)) return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,(?!,).*\}/)) {
          str = m.pre + "{" + m.body + escClose2 + m.post;
          return expand2(str);
        }
        return [str];
      }
      var n2;
      if (isSequence) {
        n2 = m.body.split(/\.\./);
      } else {
        n2 = parseCommaParts2(m.body);
        if (n2.length === 1) {
          n2 = expand2(n2[0], false).map(embrace2);
          if (n2.length === 1) {
            var post = m.post.length ? expand2(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n2[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric2(n2[0]);
        var y = numeric2(n2[1]);
        var width = Math.max(n2[0].length, n2[1].length);
        var incr = n2.length == 3 ? Math.abs(numeric2(n2[2])) : 1;
        var test3 = lte2;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test3 = gte2;
        }
        var pad = n2.some(isPadded2);
        N = [];
        for (var i2 = x; test3(i2, y); i2 += incr) {
          var c3;
          if (isAlphaSequence) {
            c3 = String.fromCharCode(i2);
            if (c3 === "\\")
              c3 = "";
          } else {
            c3 = String(i2);
            if (pad) {
              var need = width - c3.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i2 < 0)
                  c3 = "-" + z + c3.slice(1);
                else
                  c3 = z + c3;
              }
            }
          }
          N.push(c3);
        }
      } else {
        N = concatMap(n2, function(el) {
          return expand2(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch2;
    minimatch2.Minimatch = Minimatch2;
    var path15 = (function() {
      try {
        return require("path");
      } catch (e) {
      }
    })() || {
      sep: "/"
    };
    minimatch2.sep = path15.sep;
    var GLOBSTAR2 = minimatch2.GLOBSTAR = Minimatch2.GLOBSTAR = {};
    var expand2 = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark3 = "[^/]";
    var star3 = qmark3 + "*?";
    var twoStarDot2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot2 = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials2 = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set2, c3) {
        set2[c3] = true;
        return set2;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch2.filter = filter3;
    function filter3(pattern, options) {
      options = options || {};
      return function(p, i2, list2) {
        return minimatch2(p, pattern, options);
      };
    }
    function ext2(a2, b) {
      b = b || {};
      var t = {};
      Object.keys(a2).forEach(function(k) {
        t[k] = a2[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch2.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch2;
      }
      var orig = minimatch2;
      var m = function minimatch3(p, pattern, options) {
        return orig(p, pattern, ext2(def, options));
      };
      m.Minimatch = function Minimatch3(pattern, options) {
        return new orig.Minimatch(pattern, ext2(def, options));
      };
      m.Minimatch.defaults = function defaults3(options) {
        return orig.defaults(ext2(def, options)).Minimatch;
      };
      m.filter = function filter4(pattern, options) {
        return orig.filter(pattern, ext2(def, options));
      };
      m.defaults = function defaults3(options) {
        return orig.defaults(ext2(def, options));
      };
      m.makeRe = function makeRe3(pattern, options) {
        return orig.makeRe(pattern, ext2(def, options));
      };
      m.braceExpand = function braceExpand3(pattern, options) {
        return orig.braceExpand(pattern, ext2(def, options));
      };
      m.match = function(list2, pattern, options) {
        return orig.match(list2, pattern, ext2(def, options));
      };
      return m;
    };
    Minimatch2.defaults = function(def) {
      return minimatch2.defaults(def).Minimatch;
    };
    function minimatch2(p, pattern, options) {
      assertValidPattern2(pattern);
      if (!options) options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch2(pattern, options).match(p);
    }
    function Minimatch2(pattern, options) {
      if (!(this instanceof Minimatch2)) {
        return new Minimatch2(pattern, options);
      }
      assertValidPattern2(pattern);
      if (!options) options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path15.sep !== "/") {
        pattern = pattern.split(path15.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch2.prototype.debug = function() {
    };
    Minimatch2.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set2 = this.globSet = this.braceExpand();
      if (options.debug) this.debug = function debug() {
        console.error.apply(console, arguments);
      };
      this.debug(this.pattern, set2);
      set2 = this.globParts = set2.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set2);
      set2 = set2.map(function(s, si, set3) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set2);
      set2 = set2.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set2);
      this.set = set2;
    }
    Minimatch2.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate) return;
      for (var i2 = 0, l = pattern.length; i2 < l && pattern.charAt(i2) === "!"; i2++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset) this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch2.braceExpand = function(pattern, options) {
      return braceExpand2(pattern, options);
    };
    Minimatch2.prototype.braceExpand = braceExpand2;
    function braceExpand2(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch2) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern2(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand2(pattern);
    }
    var MAX_PATTERN_LENGTH2 = 1024 * 64;
    var assertValidPattern2 = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH2) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch2.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern2(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR2;
        else
          pattern = "*";
      }
      if (pattern === "") return "";
      var re = "";
      var hasMagic2 = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star3;
              hasMagic2 = true;
              break;
            case "?":
              re += qmark3;
              hasMagic2 = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i2 = 0, len = pattern.length, c3; i2 < len && (c3 = pattern.charAt(i2)); i2++) {
        this.debug("%s	%s %s %j", pattern, i2, re, c3);
        if (escaping && reSpecials2[c3]) {
          re += "\\" + c3;
          escaping = false;
          continue;
        }
        switch (c3) {
          /* istanbul ignore next */
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re, c3);
            if (inClass) {
              this.debug("  in class");
              if (c3 === "!" && i2 === classStart + 1) c3 = "^";
              re += c3;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c3;
            if (options.noext) clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i2 - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic2 = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          // these are mostly the same in regexp and glob
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c3;
              continue;
            }
            inClass = true;
            classStart = i2;
            reClassStart = re.length;
            re += c3;
            continue;
          case "]":
            if (i2 === classStart + 1 || !inClass) {
              re += "\\" + c3;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i2);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic2 = hasMagic2 || sp[1];
              inClass = false;
              continue;
            }
            hasMagic2 = true;
            inClass = false;
            re += c3;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials2[c3] && !(c3 === "^" && inClass)) {
              re += "\\";
            }
            re += c3;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic2 = hasMagic2 || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star3 : pl.type === "?" ? qmark3 : "\\" + pl.type;
        hasMagic2 = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart2 = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart2 = true;
      }
      for (var n2 = negativeLists.length - 1; n2 > -1; n2--) {
        var nl = negativeLists[n2];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i2 = 0; i2 < openParensBefore; i2++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic2) {
        re = "(?=.)" + re;
      }
      if (addPatternStart2) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic2];
      }
      if (!hasMagic2) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch2.makeRe = function(pattern, options) {
      return new Minimatch2(pattern, options || {}).makeRe();
    };
    Minimatch2.prototype.makeRe = makeRe2;
    function makeRe2() {
      if (this.regexp || this.regexp === false) return this.regexp;
      var set2 = this.set;
      if (!set2.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star3 : options.dot ? twoStarDot2 : twoStarNoDot2;
      var flags = options.nocase ? "i" : "";
      var re = set2.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR2 ? twoStar : typeof p === "string" ? regExpEscape3(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate) re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch2.match = function(list2, pattern, options) {
      options = options || {};
      var mm = new Minimatch2(pattern, options);
      list2 = list2.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    Minimatch2.prototype.match = function match3(f, partial) {
      if (typeof partial === "undefined") partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment) return false;
      if (this.empty) return f === "";
      if (f === "/" && partial) return true;
      var options = this.options;
      if (path15.sep !== "/") {
        f = f.split(path15.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set2 = this.set;
      this.debug(this.pattern, "set", set2);
      var filename;
      var i2;
      for (i2 = f.length - 1; i2 >= 0; i2--) {
        filename = f[i2];
        if (filename) break;
      }
      for (i2 = 0; i2 < set2.length; i2++) {
        var pattern = set2[i2];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) return true;
          return !this.negate;
        }
      }
      if (options.flipNegate) return false;
      return this.negate;
    };
    Minimatch2.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) return false;
        if (p === GLOBSTAR2) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl) return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit) return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape3(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/node-dir/lib/readfilesstream.js
var require_readfilesstream = __commonJS({
  "node_modules/node-dir/lib/readfilesstream.js"(exports2, module2) {
    var fs9 = require("fs");
    var mm = require_minimatch();
    var path15 = require("path");
    function extend2(target, source, modify) {
      var result = target ? modify ? target : extend2({}, target, true) : {};
      if (!source) return result;
      for (var key in source) {
        if (source.hasOwnProperty(key) && source[key] !== void 0) {
          result[key] = source[key];
        }
      }
      return result;
    }
    function matches(str, match3) {
      if (Array.isArray(match3)) {
        var l = match3.length;
        for (var s = 0; s < l; s++) {
          if (mm(str, match3[s])) {
            return true;
          }
        }
        return false;
      }
      return match3.test(str);
    }
    function readFilesStream(dir, options, callback, complete) {
      if (typeof options === "function") {
        complete = callback;
        callback = options;
        options = {};
      }
      if (typeof options === "string") options = {
        encoding: options
      };
      options = extend2({
        recursive: true,
        encoding: "utf8",
        doneOnErr: true
      }, options);
      var files = [];
      var done = function(err) {
        if (typeof complete === "function") {
          if (err) return complete(err);
          complete(null, files);
        }
      };
      fs9.readdir(dir, function(err, list2) {
        if (err) {
          if (options.doneOnErr === true) {
            if (err.code === "EACCES") return done();
            return done(err);
          }
        }
        var i2 = 0;
        if (options.reverse === true || typeof options.sort == "string" && /reverse|desc/i.test(options.sort)) {
          list2 = list2.reverse();
        } else if (options.sort !== false) list2 = list2.sort();
        (function next() {
          var filename = list2[i2++];
          if (!filename) return done(null, files);
          var file = path15.join(dir, filename);
          fs9.stat(file, function(err2, stat) {
            if (err2 && options.doneOnErr === true) return done(err2);
            if (stat && stat.isDirectory()) {
              if (options.recursive) {
                if (options.matchDir && !matches(filename, options.matchDir)) return next();
                if (options.excludeDir && matches(filename, options.excludeDir)) return next();
                readFilesStream(file, options, callback, function(err3, sfiles) {
                  if (err3 && options.doneOnErr === true) return done(err3);
                  files = files.concat(sfiles);
                  next();
                });
              } else next();
            } else if (stat && stat.isFile()) {
              if (options.match && !matches(filename, options.match)) return next();
              if (options.exclude && matches(filename, options.exclude)) return next();
              if (options.filter && !options.filter(filename)) return next();
              if (options.shortName) files.push(filename);
              else files.push(file);
              var stream5 = fs9.createReadStream(file);
              if (options.encoding !== null) {
                stream5.setEncoding(options.encoding);
              }
              stream5.on("error", function(err3) {
                if (options.doneOnErr === true) return done(err3);
                next();
              });
              if (callback.length > 3)
                if (options.shortName) callback(null, stream5, filename, next);
                else callback(null, stream5, file, next);
              else callback(null, stream5, next);
            } else {
              next();
            }
          });
        })();
      });
    }
    module2.exports = readFilesStream;
  }
});

// node_modules/node-dir/index.js
var require_node_dir = __commonJS({
  "node_modules/node-dir/index.js"(exports2) {
    var dirpaths = require_paths();
    Object.assign(exports2, dirpaths);
    exports2.readFiles = require_readfiles();
    exports2.readFilesStream = require_readfilesstream();
  }
});

// node_modules/antlr4ts/Decorators.js
var require_Decorators = __commonJS({
  "node_modules/antlr4ts/Decorators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SuppressWarnings = exports2.Override = exports2.Nullable = exports2.NotNull = void 0;
    function NotNull(target, propertyKey, propertyDescriptor) {
    }
    exports2.NotNull = NotNull;
    function Nullable(target, propertyKey, propertyDescriptor) {
    }
    exports2.Nullable = Nullable;
    function Override(target, propertyKey, propertyDescriptor) {
    }
    exports2.Override = Override;
    function SuppressWarnings(options) {
      return (target, propertyKey, descriptor) => {
      };
    }
    exports2.SuppressWarnings = SuppressWarnings;
  }
});

// node_modules/antlr4ts/atn/Transition.js
var require_Transition = __commonJS({
  "node_modules/antlr4ts/atn/Transition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition = class Transition {
      constructor(target) {
        if (target == null) {
          throw new Error("target cannot be null.");
        }
        this.target = target;
      }
      /**
       * Determines if the transition is an "epsilon" transition.
       *
       * The default implementation returns `false`.
       *
       * @returns `true` if traversing this transition in the ATN does not
       * consume an input symbol; otherwise, `false` if traversing this
       * transition consumes (matches) an input symbol.
       */
      get isEpsilon() {
        return false;
      }
      get label() {
        return void 0;
      }
    };
    Transition.serializationNames = [
      "INVALID",
      "EPSILON",
      "RANGE",
      "RULE",
      "PREDICATE",
      "ATOM",
      "ACTION",
      "SET",
      "NOT_SET",
      "WILDCARD",
      "PRECEDENCE"
    ];
    __decorate([
      Decorators_1.NotNull
    ], Transition.prototype, "target", void 0);
    Transition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], Transition);
    exports2.Transition = Transition;
  }
});

// node_modules/antlr4ts/atn/ActionTransition.js
var require_ActionTransition = __commonJS({
  "node_modules/antlr4ts/atn/ActionTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActionTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var ActionTransition = class ActionTransition extends Transition_1.Transition {
      constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 6;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "toString", null);
    ActionTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ActionTransition);
    exports2.ActionTransition = ActionTransition;
  }
});

// node_modules/antlr4ts/misc/MurmurHash.js
var require_MurmurHash = __commonJS({
  "node_modules/antlr4ts/misc/MurmurHash.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MurmurHash = void 0;
    var MurmurHash;
    (function(MurmurHash2) {
      const DEFAULT_SEED = 0;
      function initialize(seed = DEFAULT_SEED) {
        return seed;
      }
      MurmurHash2.initialize = initialize;
      function update(hash, value) {
        const c1 = 3432918353;
        const c22 = 461845907;
        const r1 = 15;
        const r2 = 13;
        const m = 5;
        const n2 = 3864292196;
        if (value == null) {
          value = 0;
        } else if (typeof value === "string") {
          value = hashString(value);
        } else if (typeof value === "object") {
          value = value.hashCode();
        }
        let k = value;
        k = Math.imul(k, c1);
        k = k << r1 | k >>> 32 - r1;
        k = Math.imul(k, c22);
        hash = hash ^ k;
        hash = hash << r2 | hash >>> 32 - r2;
        hash = Math.imul(hash, m) + n2;
        return hash & 4294967295;
      }
      MurmurHash2.update = update;
      function finish(hash, numberOfWords) {
        hash = hash ^ numberOfWords * 4;
        hash = hash ^ hash >>> 16;
        hash = Math.imul(hash, 2246822507);
        hash = hash ^ hash >>> 13;
        hash = Math.imul(hash, 3266489909);
        hash = hash ^ hash >>> 16;
        return hash;
      }
      MurmurHash2.finish = finish;
      function hashCode(data, seed = DEFAULT_SEED) {
        let hash = initialize(seed);
        let length = 0;
        for (let value of data) {
          hash = update(hash, value);
          length++;
        }
        hash = finish(hash, length);
        return hash;
      }
      MurmurHash2.hashCode = hashCode;
      function hashString(str) {
        let len = str.length;
        if (len === 0) {
          return 0;
        }
        let hash = 0;
        for (let i2 = 0; i2 < len; i2++) {
          let c3 = str.charCodeAt(i2);
          hash = (hash << 5 >>> 0) - hash + c3;
          hash |= 0;
        }
        return hash;
      }
    })(MurmurHash = exports2.MurmurHash || (exports2.MurmurHash = {}));
  }
});

// node_modules/antlr4ts/misc/ObjectEqualityComparator.js
var require_ObjectEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ObjectEqualityComparator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator = class {
      /**
       * {@inheritDoc}
       *
       * This implementation returns
       * `obj.`{@link Object#hashCode hashCode()}.
       */
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return obj.hashCode();
      }
      /**
       * {@inheritDoc}
       *
       * This implementation relies on object equality. If both objects are
       * `undefined` or `null`, this method returns `true`. Otherwise if only
       * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
       * this method returns the result of
       * `a.`{@link Object#equals equals}`(b)`.
       */
      equals(a2, b) {
        if (a2 == null) {
          return b == null;
        }
        return a2.equals(b);
      }
    };
    ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "equals", null);
    exports2.ObjectEqualityComparator = ObjectEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/DefaultEqualityComparator.js
var require_DefaultEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/DefaultEqualityComparator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var DefaultEqualityComparator = class {
      /**
       * {@inheritDoc}
       *
       * This implementation returns
       * `obj.`{@link Object#hashCode hashCode()}.
       */
      hashCode(obj) {
        if (obj == null) {
          return 0;
        } else if (typeof obj === "string" || typeof obj === "number") {
          return MurmurHash_1.MurmurHash.hashCode([obj]);
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
        }
      }
      /**
       * {@inheritDoc}
       *
       * This implementation relies on object equality. If both objects are
       * `undefined` or `null`, this method returns `true`. Otherwise if only
       * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
       * this method returns the result of
       * `a.`{@link Object#equals equals}`(b)`.
       */
      equals(a2, b) {
        if (a2 == null) {
          return b == null;
        } else if (typeof a2 === "string" || typeof a2 === "number") {
          return a2 === b;
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a2, b);
        }
      }
    };
    DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "equals", null);
    exports2.DefaultEqualityComparator = DefaultEqualityComparator;
  }
});

// node_modules/antlr4ts/misc/Array2DHashSet.js
var require_Array2DHashSet = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashSet.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Array2DHashSet = void 0;
    var assert = require("assert");
    var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var INITAL_CAPACITY = 16;
    var LOAD_FACTOR = 0.75;
    var Array2DHashSet = class _Array2DHashSet {
      constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
        if (comparatorOrSet instanceof _Array2DHashSet) {
          this.comparator = comparatorOrSet.comparator;
          this.buckets = comparatorOrSet.buckets.slice(0);
          for (let i2 = 0; i2 < this.buckets.length; i2++) {
            let bucket = this.buckets[i2];
            if (bucket) {
              this.buckets[i2] = bucket.slice(0);
            }
          }
          this.n = comparatorOrSet.n;
          this.threshold = comparatorOrSet.threshold;
        } else {
          this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
          this.buckets = this.createBuckets(initialCapacity);
        }
      }
      /**
       * Add `o` to set if not there; return existing value if already
       * there. This method performs the same operation as {@link #add} aside from
       * the return value.
       */
      getOrAdd(o2) {
        if (this.n > this.threshold) {
          this.expand();
        }
        return this.getOrAddImpl(o2);
      }
      getOrAddImpl(o2) {
        let b = this.getBucket(o2);
        let bucket = this.buckets[b];
        if (!bucket) {
          bucket = [o2];
          this.buckets[b] = bucket;
          this.n++;
          return o2;
        }
        for (let existing of bucket) {
          if (this.comparator.equals(existing, o2)) {
            return existing;
          }
        }
        bucket.push(o2);
        this.n++;
        return o2;
      }
      get(o2) {
        if (o2 == null) {
          return o2;
        }
        let b = this.getBucket(o2);
        let bucket = this.buckets[b];
        if (!bucket) {
          return void 0;
        }
        for (let e of bucket) {
          if (this.comparator.equals(e, o2)) {
            return e;
          }
        }
        return void 0;
      }
      getBucket(o2) {
        let hash = this.comparator.hashCode(o2);
        let b = hash & this.buckets.length - 1;
        return b;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o2 of bucket) {
            if (o2 == null) {
              break;
            }
            hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o2));
          }
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
        return hash;
      }
      equals(o2) {
        if (o2 === this) {
          return true;
        }
        if (!(o2 instanceof _Array2DHashSet)) {
          return false;
        }
        if (o2.size !== this.size) {
          return false;
        }
        let same = this.containsAll(o2);
        return same;
      }
      expand() {
        let old = this.buckets;
        let newCapacity = this.buckets.length * 2;
        let newTable = this.createBuckets(newCapacity);
        this.buckets = newTable;
        this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
        let oldSize = this.size;
        for (let bucket of old) {
          if (!bucket) {
            continue;
          }
          for (let o2 of bucket) {
            let b = this.getBucket(o2);
            let newBucket = this.buckets[b];
            if (!newBucket) {
              newBucket = [];
              this.buckets[b] = newBucket;
            }
            newBucket.push(o2);
          }
        }
        assert(this.n === oldSize);
      }
      add(t) {
        let existing = this.getOrAdd(t);
        return existing === t;
      }
      get size() {
        return this.n;
      }
      get isEmpty() {
        return this.n === 0;
      }
      contains(o2) {
        return this.containsFast(this.asElementType(o2));
      }
      containsFast(obj) {
        if (obj == null) {
          return false;
        }
        return this.get(obj) != null;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      toArray() {
        const a2 = new Array(this.size);
        let i2 = 0;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o2 of bucket) {
            if (o2 == null) {
              break;
            }
            a2[i2++] = o2;
          }
        }
        return a2;
      }
      containsAll(collection) {
        if (collection instanceof _Array2DHashSet) {
          let s = collection;
          for (let bucket of s.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o2 of bucket) {
              if (o2 == null) {
                break;
              }
              if (!this.containsFast(this.asElementType(o2))) {
                return false;
              }
            }
          }
        } else {
          for (let o2 of collection) {
            if (!this.containsFast(this.asElementType(o2))) {
              return false;
            }
          }
        }
        return true;
      }
      addAll(c3) {
        let changed = false;
        for (let o2 of c3) {
          let existing = this.getOrAdd(o2);
          if (existing !== o2) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.buckets = this.createBuckets(INITAL_CAPACITY);
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
      }
      toString() {
        if (this.size === 0) {
          return "{}";
        }
        let buf = "{";
        let first = true;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o2 of bucket) {
            if (o2 == null) {
              break;
            }
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += o2.toString();
          }
        }
        buf += "}";
        return buf;
      }
      toTableString() {
        let buf = "";
        for (let bucket of this.buckets) {
          if (bucket == null) {
            buf += "null\n";
            continue;
          }
          buf += "[";
          let first = true;
          for (let o2 of bucket) {
            if (first) {
              first = false;
            } else {
              buf += " ";
            }
            if (o2 == null) {
              buf += "_";
            } else {
              buf += o2.toString();
            }
          }
          buf += "]\n";
        }
        return buf;
      }
      /**
       * Return `o` as an instance of the element type `T`. If
       * `o` is non-undefined but known to not be an instance of `T`, this
       * method returns `undefined`. The base implementation does not perform any
       * type checks; override this method to provide strong type checks for the
       * {@link #contains} and {@link #remove} methods to ensure the arguments to
       * the {@link EqualityComparator} for the set always have the expected
       * types.
       *
       * @param o the object to try and cast to the element type of the set
       * @returns `o` if it could be an instance of `T`, otherwise
       * `undefined`.
       */
      asElementType(o2) {
        return o2;
      }
      /**
       * Return an array of `T[]` with length `capacity`.
       *
       * @param capacity the length of the array to return
       * @returns the newly constructed array
       */
      createBuckets(capacity) {
        return new Array(capacity);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], Array2DHashSet.prototype, "comparator", void 0);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "add", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "contains", null);
    __decorate([
      __param(0, Decorators_1.Nullable)
    ], Array2DHashSet.prototype, "containsFast", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toString", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "asElementType", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "createBuckets", null);
    exports2.Array2DHashSet = Array2DHashSet;
  }
});

// node_modules/antlr4ts/misc/Array2DHashMap.js
var require_Array2DHashMap = __commonJS({
  "node_modules/antlr4ts/misc/Array2DHashMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Array2DHashMap = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var MapKeyEqualityComparator = class {
      constructor(keyComparator) {
        this.keyComparator = keyComparator;
      }
      hashCode(obj) {
        return this.keyComparator.hashCode(obj.key);
      }
      equals(a2, b) {
        return this.keyComparator.equals(a2.key, b.key);
      }
    };
    var Array2DHashMap = class _Array2DHashMap {
      constructor(keyComparer) {
        if (keyComparer instanceof _Array2DHashMap) {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
        } else {
          this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
        }
      }
      clear() {
        this.backingStore.clear();
      }
      containsKey(key) {
        return this.backingStore.contains({ key });
      }
      get(key) {
        let bucket = this.backingStore.get({ key });
        if (!bucket) {
          return void 0;
        }
        return bucket.value;
      }
      get isEmpty() {
        return this.backingStore.isEmpty;
      }
      put(key, value) {
        let element = this.backingStore.get({ key, value });
        let result;
        if (!element) {
          this.backingStore.add({ key, value });
        } else {
          result = element.value;
          element.value = value;
        }
        return result;
      }
      putIfAbsent(key, value) {
        let element = this.backingStore.get({ key, value });
        let result;
        if (!element) {
          this.backingStore.add({ key, value });
        } else {
          result = element.value;
        }
        return result;
      }
      get size() {
        return this.backingStore.size;
      }
      hashCode() {
        return this.backingStore.hashCode();
      }
      equals(o2) {
        if (!(o2 instanceof _Array2DHashMap)) {
          return false;
        }
        return this.backingStore.equals(o2.backingStore);
      }
    };
    exports2.Array2DHashMap = Array2DHashMap;
  }
});

// node_modules/antlr4ts/misc/ArrayEqualityComparator.js
var require_ArrayEqualityComparator = __commonJS({
  "node_modules/antlr4ts/misc/ArrayEqualityComparator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ArrayEqualityComparator = class {
      /**
       * {@inheritDoc}
       *
       * This implementation returns
       * `obj.`{@link Object#hashCode hashCode()}.
       */
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return MurmurHash_1.MurmurHash.hashCode(obj, 0);
      }
      /**
       * {@inheritDoc}
       *
       * This implementation relies on object equality. If both objects are
       * `undefined`, this method returns `true`. Otherwise if only
       * `a` is `undefined`, this method returns `false`. Otherwise,
       * this method returns the result of
       * `a.`{@link Object#equals equals}`(b)`.
       */
      equals(a2, b) {
        if (a2 == null) {
          return b == null;
        } else if (b == null) {
          return false;
        }
        if (a2.length !== b.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.length; i2++) {
          if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a2[i2], b[i2])) {
            return false;
          }
        }
        return true;
      }
    };
    ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "equals", null);
    exports2.ArrayEqualityComparator = ArrayEqualityComparator;
  }
});

// node_modules/antlr4ts/atn/ATNState.js
var require_ATNState = __commonJS({
  "node_modules/antlr4ts/atn/ATNState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATNState = void 0;
    var Decorators_1 = require_Decorators();
    var ATNState = class _ATNState {
      constructor() {
        this.stateNumber = _ATNState.INVALID_STATE_NUMBER;
        this.ruleIndex = 0;
        this.epsilonOnlyTransitions = false;
        this.transitions = [];
        this.optimizedTransitions = this.transitions;
      }
      /**
       * Gets the state number.
       *
       * @returns the state number
       */
      getStateNumber() {
        return this.stateNumber;
      }
      /**
       * For all states except {@link RuleStopState}, this returns the state
       * number. Returns -1 for stop states.
       *
       * @returns -1 for {@link RuleStopState}, otherwise the state number
       */
      get nonStopStateNumber() {
        return this.getStateNumber();
      }
      hashCode() {
        return this.stateNumber;
      }
      equals(o2) {
        if (o2 instanceof _ATNState) {
          return this.stateNumber === o2.stateNumber;
        }
        return false;
      }
      get isNonGreedyExitState() {
        return false;
      }
      toString() {
        return String(this.stateNumber);
      }
      getTransitions() {
        return this.transitions.slice(0);
      }
      get numberOfTransitions() {
        return this.transitions.length;
      }
      addTransition(e, index) {
        if (this.transitions.length === 0) {
          this.epsilonOnlyTransitions = e.isEpsilon;
        } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
          this.epsilonOnlyTransitions = false;
          throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
        }
        this.transitions.splice(index !== void 0 ? index : this.transitions.length, 0, e);
      }
      transition(i2) {
        return this.transitions[i2];
      }
      setTransition(i2, e) {
        this.transitions[i2] = e;
      }
      removeTransition(index) {
        return this.transitions.splice(index, 1)[0];
      }
      get onlyHasEpsilonTransitions() {
        return this.epsilonOnlyTransitions;
      }
      setRuleIndex(ruleIndex) {
        this.ruleIndex = ruleIndex;
      }
      get isOptimized() {
        return this.optimizedTransitions !== this.transitions;
      }
      get numberOfOptimizedTransitions() {
        return this.optimizedTransitions.length;
      }
      getOptimizedTransition(i2) {
        return this.optimizedTransitions[i2];
      }
      addOptimizedTransition(e) {
        if (!this.isOptimized) {
          this.optimizedTransitions = new Array();
        }
        this.optimizedTransitions.push(e);
      }
      setOptimizedTransition(i2, e) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions[i2] = e;
      }
      removeOptimizedTransition(i2) {
        if (!this.isOptimized) {
          throw new Error("This ATNState is not optimized.");
        }
        this.optimizedTransitions.splice(i2, 1);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNState.prototype, "toString", null);
    exports2.ATNState = ATNState;
    (function(ATNState2) {
      ATNState2.INVALID_STATE_NUMBER = -1;
    })(ATNState = exports2.ATNState || (exports2.ATNState = {}));
  }
});

// node_modules/antlr4ts/atn/DecisionState.js
var require_DecisionState = __commonJS({
  "node_modules/antlr4ts/atn/DecisionState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecisionState = void 0;
    var ATNState_1 = require_ATNState();
    var DecisionState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.decision = -1;
        this.nonGreedy = false;
        this.sll = false;
      }
    };
    exports2.DecisionState = DecisionState;
  }
});

// node_modules/antlr4ts/misc/Arrays.js
var require_Arrays = __commonJS({
  "node_modules/antlr4ts/misc/Arrays.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Arrays = void 0;
    var Arrays;
    (function(Arrays2) {
      function binarySearch(array, key, fromIndex, toIndex) {
        return binarySearch0(array, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array.length, key);
      }
      Arrays2.binarySearch = binarySearch;
      function binarySearch0(array, fromIndex, toIndex, key) {
        let low = fromIndex;
        let high = toIndex - 1;
        while (low <= high) {
          let mid = low + high >>> 1;
          let midVal = array[mid];
          if (midVal < key) {
            low = mid + 1;
          } else if (midVal > key) {
            high = mid - 1;
          } else {
            return mid;
          }
        }
        return -(low + 1);
      }
      function toString4(array) {
        let result = "[";
        let first = true;
        for (let element of array) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          if (element === null) {
            result += "null";
          } else if (element === void 0) {
            result += "undefined";
          } else {
            result += element;
          }
        }
        result += "]";
        return result;
      }
      Arrays2.toString = toString4;
    })(Arrays = exports2.Arrays || (exports2.Arrays = {}));
  }
});

// node_modules/antlr4ts/atn/PredictionContextCache.js
var require_PredictionContextCache = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContextCache.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PredictionContextCache = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var PredictionContextCache = class _PredictionContextCache {
      constructor(enableCache = true) {
        this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.enableCache = enableCache;
      }
      getAsCached(context) {
        if (!this.enableCache) {
          return context;
        }
        let result = this.contexts.get(context);
        if (!result) {
          result = context;
          this.contexts.put(context, context);
        }
        return result;
      }
      getChild(context, invokingState) {
        if (!this.enableCache) {
          return context.getChild(invokingState);
        }
        let operands = new _PredictionContextCache.PredictionContextAndInt(context, invokingState);
        let result = this.childContexts.get(operands);
        if (!result) {
          result = context.getChild(invokingState);
          result = this.getAsCached(result);
          this.childContexts.put(operands, result);
        }
        return result;
      }
      join(x, y) {
        if (!this.enableCache) {
          return PredictionContext_1.PredictionContext.join(x, y, this);
        }
        let operands = new _PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
        let result = this.joinContexts.get(operands);
        if (result) {
          return result;
        }
        result = PredictionContext_1.PredictionContext.join(x, y, this);
        result = this.getAsCached(result);
        this.joinContexts.put(operands, result);
        return result;
      }
    };
    exports2.PredictionContextCache = PredictionContextCache;
    PredictionContextCache.UNCACHED = new PredictionContextCache(false);
    (function(PredictionContextCache2) {
      class PredictionContextAndInt {
        constructor(obj, value) {
          this.obj = obj;
          this.value = value;
        }
        equals(obj) {
          if (!(obj instanceof PredictionContextAndInt)) {
            return false;
          } else if (obj === this) {
            return true;
          }
          let other = obj;
          return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
        }
        hashCode() {
          let hashCode = 5;
          hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
          hashCode = 7 * hashCode + this.value;
          return hashCode;
        }
      }
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PredictionContextAndInt.prototype, "hashCode", null);
      PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
      class IdentityCommutativePredictionContextOperands {
        constructor(x, y) {
          assert(x != null);
          assert(y != null);
          this._x = x;
          this._y = y;
        }
        get x() {
          return this._x;
        }
        get y() {
          return this._y;
        }
        equals(o2) {
          if (!(o2 instanceof IdentityCommutativePredictionContextOperands)) {
            return false;
          } else if (this === o2) {
            return true;
          }
          let other = o2;
          return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
        }
        hashCode() {
          return this._x.hashCode() ^ this._y.hashCode();
        }
      }
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
      PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
    })(PredictionContextCache = exports2.PredictionContextCache || (exports2.PredictionContextCache = {}));
  }
});

// node_modules/antlr4ts/atn/PredictionContext.js
var require_PredictionContext = __commonJS({
  "node_modules/antlr4ts/atn/PredictionContext.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SingletonPredictionContext = exports2.PredictionContext = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var assert = require("assert");
    var INITIAL_HASH = 1;
    var PredictionContext = class _PredictionContext {
      constructor(cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
      }
      static calculateEmptyHashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.finish(hash, 0);
        return hash;
      }
      static calculateSingleHashCode(parent, returnState) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        hash = MurmurHash_1.MurmurHash.update(hash, parent);
        hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        hash = MurmurHash_1.MurmurHash.finish(hash, 2);
        return hash;
      }
      static calculateHashCode(parents, returnStates) {
        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
        for (let parent of parents) {
          hash = MurmurHash_1.MurmurHash.update(hash, parent);
        }
        for (let returnState of returnStates) {
          hash = MurmurHash_1.MurmurHash.update(hash, returnState);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
        return hash;
      }
      static fromRuleContext(atn, outerContext, fullContext = true) {
        if (outerContext.isEmpty) {
          return fullContext ? _PredictionContext.EMPTY_FULL : _PredictionContext.EMPTY_LOCAL;
        }
        let parent;
        if (outerContext._parent) {
          parent = _PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
        } else {
          parent = fullContext ? _PredictionContext.EMPTY_FULL : _PredictionContext.EMPTY_LOCAL;
        }
        let state = atn.states[outerContext.invokingState];
        let transition = state.transition(0);
        return parent.getChild(transition.followState.stateNumber);
      }
      static addEmptyContext(context) {
        return context.addEmptyContext();
      }
      static removeEmptyContext(context) {
        return context.removeEmptyContext();
      }
      static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
        if (context0 === context1) {
          return context0;
        }
        if (context0.isEmpty) {
          return _PredictionContext.isEmptyLocal(context0) ? context0 : _PredictionContext.addEmptyContext(context1);
        } else if (context1.isEmpty) {
          return _PredictionContext.isEmptyLocal(context1) ? context1 : _PredictionContext.addEmptyContext(context0);
        }
        let context0size = context0.size;
        let context1size = context1.size;
        if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
          let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
          if (merged === context0.getParent(0)) {
            return context0;
          } else if (merged === context1.getParent(0)) {
            return context1;
          } else {
            return merged.getChild(context0.getReturnState(0));
          }
        }
        let count2 = 0;
        let parentsList = new Array(context0size + context1size);
        let returnStatesList = new Array(parentsList.length);
        let leftIndex = 0;
        let rightIndex = 0;
        let canReturnLeft = true;
        let canReturnRight = true;
        while (leftIndex < context0size && rightIndex < context1size) {
          if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
            parentsList[count2] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
            returnStatesList[count2] = context0.getReturnState(leftIndex);
            canReturnLeft = canReturnLeft && parentsList[count2] === context0.getParent(leftIndex);
            canReturnRight = canReturnRight && parentsList[count2] === context1.getParent(rightIndex);
            leftIndex++;
            rightIndex++;
          } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
            parentsList[count2] = context0.getParent(leftIndex);
            returnStatesList[count2] = context0.getReturnState(leftIndex);
            canReturnRight = false;
            leftIndex++;
          } else {
            assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
            parentsList[count2] = context1.getParent(rightIndex);
            returnStatesList[count2] = context1.getReturnState(rightIndex);
            canReturnLeft = false;
            rightIndex++;
          }
          count2++;
        }
        while (leftIndex < context0size) {
          parentsList[count2] = context0.getParent(leftIndex);
          returnStatesList[count2] = context0.getReturnState(leftIndex);
          leftIndex++;
          canReturnRight = false;
          count2++;
        }
        while (rightIndex < context1size) {
          parentsList[count2] = context1.getParent(rightIndex);
          returnStatesList[count2] = context1.getReturnState(rightIndex);
          rightIndex++;
          canReturnLeft = false;
          count2++;
        }
        if (canReturnLeft) {
          return context0;
        } else if (canReturnRight) {
          return context1;
        }
        if (count2 < parentsList.length) {
          parentsList = parentsList.slice(0, count2);
          returnStatesList = returnStatesList.slice(0, count2);
        }
        if (parentsList.length === 0) {
          return _PredictionContext.EMPTY_FULL;
        } else if (parentsList.length === 1) {
          return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
        } else {
          return new ArrayPredictionContext(parentsList, returnStatesList);
        }
      }
      static isEmptyLocal(context) {
        return context === _PredictionContext.EMPTY_LOCAL;
      }
      static getCachedContext(context, contextCache, visited) {
        if (context.isEmpty) {
          return context;
        }
        let existing = visited.get(context);
        if (existing) {
          return existing;
        }
        existing = contextCache.get(context);
        if (existing) {
          visited.put(context, existing);
          return existing;
        }
        let changed = false;
        let parents = new Array(context.size);
        for (let i2 = 0; i2 < parents.length; i2++) {
          let parent = _PredictionContext.getCachedContext(context.getParent(i2), contextCache, visited);
          if (changed || parent !== context.getParent(i2)) {
            if (!changed) {
              parents = new Array(context.size);
              for (let j = 0; j < context.size; j++) {
                parents[j] = context.getParent(j);
              }
              changed = true;
            }
            parents[i2] = parent;
          }
        }
        if (!changed) {
          existing = contextCache.putIfAbsent(context, context);
          visited.put(context, existing != null ? existing : context);
          return context;
        }
        let updated;
        if (parents.length === 1) {
          updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
        } else {
          let returnStates = new Array(context.size);
          for (let i2 = 0; i2 < context.size; i2++) {
            returnStates[i2] = context.getReturnState(i2);
          }
          updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
        }
        existing = contextCache.putIfAbsent(updated, updated);
        visited.put(updated, existing || updated);
        visited.put(context, existing || updated);
        return updated;
      }
      appendSingleContext(returnContext, contextCache) {
        return this.appendContext(_PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
      }
      getChild(returnState) {
        return new SingletonPredictionContext(this, returnState);
      }
      hashCode() {
        return this.cachedHashCode;
      }
      toStrings(recognizer, currentState, stop = _PredictionContext.EMPTY_FULL) {
        let result = [];
        outer: for (let perm = 0; ; perm++) {
          let offset = 0;
          let last = true;
          let p = this;
          let stateNumber = currentState;
          let localBuffer = "";
          localBuffer += "[";
          while (!p.isEmpty && p !== stop) {
            let index = 0;
            if (p.size > 0) {
              let bits = 1;
              while (1 << bits >>> 0 < p.size) {
                bits++;
              }
              let mask = (1 << bits >>> 0) - 1;
              index = perm >> offset & mask;
              last = last && index >= p.size - 1;
              if (index >= p.size) {
                continue outer;
              }
              offset += bits;
            }
            if (recognizer) {
              if (localBuffer.length > 1) {
                localBuffer += " ";
              }
              let atn = recognizer.atn;
              let s = atn.states[stateNumber];
              let ruleName = recognizer.ruleNames[s.ruleIndex];
              localBuffer += ruleName;
            } else if (p.getReturnState(index) !== _PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (!p.isEmpty) {
                if (localBuffer.length > 1) {
                  localBuffer += " ";
                }
                localBuffer += p.getReturnState(index);
              }
            }
            stateNumber = p.getReturnState(index);
            p = p.getParent(index);
          }
          localBuffer += "]";
          result.push(localBuffer);
          if (last) {
            break;
          }
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredictionContext.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "join", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], PredictionContext, "getCachedContext", null);
    exports2.PredictionContext = PredictionContext;
    var EmptyPredictionContext = class extends PredictionContext {
      constructor(fullContext) {
        super(PredictionContext.calculateEmptyHashCode());
        this.fullContext = fullContext;
      }
      get isFullContext() {
        return this.fullContext;
      }
      addEmptyContext() {
        return this;
      }
      removeEmptyContext() {
        throw new Error("Cannot remove the empty context from itself.");
      }
      getParent(index) {
        throw new Error("index out of bounds");
      }
      getReturnState(index) {
        throw new Error("index out of bounds");
      }
      findReturnState(returnState) {
        return -1;
      }
      get size() {
        return 0;
      }
      appendSingleContext(returnContext, contextCache) {
        return contextCache.getChild(this, returnContext);
      }
      appendContext(suffix, contextCache) {
        return suffix;
      }
      get isEmpty() {
        return true;
      }
      get hasEmpty() {
        return true;
      }
      equals(o2) {
        return this === o2;
      }
      toStrings(recognizer, currentState, stop) {
        return ["[]"];
      }
    };
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendSingleContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], EmptyPredictionContext.prototype, "toStrings", null);
    var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
      constructor(parents, returnStates, hashCode) {
        super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
        assert(parents.length === returnStates.length);
        assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
        this.parents = parents;
        this.returnStates = returnStates;
      }
      getParent(index) {
        return this.parents[index];
      }
      getReturnState(index) {
        return this.returnStates[index];
      }
      findReturnState(returnState) {
        return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
      }
      get size() {
        return this.returnStates.length;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      addEmptyContext() {
        if (this.hasEmpty) {
          return this;
        }
        let parents2 = this.parents.slice(0);
        let returnStates2 = this.returnStates.slice(0);
        parents2.push(PredictionContext.EMPTY_FULL);
        returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
        return new ArrayPredictionContext2(parents2, returnStates2);
      }
      removeEmptyContext() {
        if (!this.hasEmpty) {
          return this;
        }
        if (this.returnStates.length === 2) {
          return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
        } else {
          let parents2 = this.parents.slice(0, this.parents.length - 1);
          let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
          return new ArrayPredictionContext2(parents2, returnStates2);
        }
      }
      appendContext(suffix, contextCache) {
        return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
      }
      static appendContextImpl(context, suffix, visited) {
        if (suffix.isEmpty) {
          if (PredictionContext.isEmptyLocal(suffix)) {
            if (context.hasEmpty) {
              return PredictionContext.EMPTY_LOCAL;
            }
            throw new Error("what to do here?");
          }
          return context;
        }
        if (suffix.size !== 1) {
          throw new Error("Appending a tree suffix is not yet supported.");
        }
        let result = visited.get(context);
        if (!result) {
          if (context.isEmpty) {
            result = suffix;
          } else {
            let parentCount = context.size;
            if (context.hasEmpty) {
              parentCount--;
            }
            let updatedParents = new Array(parentCount);
            let updatedReturnStates = new Array(parentCount);
            for (let i2 = 0; i2 < parentCount; i2++) {
              updatedReturnStates[i2] = context.getReturnState(i2);
            }
            for (let i2 = 0; i2 < parentCount; i2++) {
              updatedParents[i2] = ArrayPredictionContext2.appendContextImpl(context.getParent(i2), suffix, visited);
            }
            if (updatedParents.length === 1) {
              result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
            } else {
              assert(updatedParents.length > 1);
              result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
            }
            if (context.hasEmpty) {
              result = PredictionContext.join(result, suffix);
            }
          }
          visited.put(context, result);
        }
        return result;
      }
      equals(o2) {
        if (this === o2) {
          return true;
        } else if (!(o2 instanceof ArrayPredictionContext2)) {
          return false;
        }
        if (this.hashCode() !== o2.hashCode()) {
          return false;
        }
        let other = o2;
        return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
      }
      equalsImpl(other, visited) {
        let selfWorkList = [];
        let otherWorkList = [];
        selfWorkList.push(this);
        otherWorkList.push(other);
        while (true) {
          let currentSelf = selfWorkList.pop();
          let currentOther = otherWorkList.pop();
          if (!currentSelf || !currentOther) {
            break;
          }
          let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
          if (!visited.add(operands)) {
            continue;
          }
          let selfSize = operands.x.size;
          if (selfSize === 0) {
            if (!operands.x.equals(operands.y)) {
              return false;
            }
            continue;
          }
          let otherSize = operands.y.size;
          if (selfSize !== otherSize) {
            return false;
          }
          for (let i2 = 0; i2 < selfSize; i2++) {
            if (operands.x.getReturnState(i2) !== operands.y.getReturnState(i2)) {
              return false;
            }
            let selfParent = operands.x.getParent(i2);
            let otherParent = operands.y.getParent(i2);
            if (selfParent.hashCode() !== otherParent.hashCode()) {
              return false;
            }
            if (selfParent !== otherParent) {
              selfWorkList.push(selfParent);
              otherWorkList.push(otherParent);
            }
          }
        }
        return true;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "parents", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ArrayPredictionContext.prototype, "returnStates", void 0);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], ArrayPredictionContext.prototype, "equals", null);
    ArrayPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ArrayPredictionContext);
    var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
      constructor(parent, returnState) {
        super(PredictionContext.calculateSingleHashCode(parent, returnState));
        this.parent = parent;
        this.returnState = returnState;
      }
      getParent(index) {
        return this.parent;
      }
      getReturnState(index) {
        return this.returnState;
      }
      findReturnState(returnState) {
        return this.returnState === returnState ? 0 : -1;
      }
      get size() {
        return 1;
      }
      get isEmpty() {
        return false;
      }
      get hasEmpty() {
        return false;
      }
      appendContext(suffix, contextCache) {
        return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
      }
      addEmptyContext() {
        let parents = [this.parent, PredictionContext.EMPTY_FULL];
        let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
        return new ArrayPredictionContext(parents, returnStates);
      }
      removeEmptyContext() {
        return this;
      }
      equals(o2) {
        if (o2 === this) {
          return true;
        } else if (!(o2 instanceof SingletonPredictionContext2)) {
          return false;
        }
        let other = o2;
        if (this.hashCode() !== other.hashCode()) {
          return false;
        }
        return this.returnState === other.returnState && this.parent.equals(other.parent);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SingletonPredictionContext.prototype, "parent", void 0);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getParent", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "getReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "findReturnState", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "hasEmpty", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "appendContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "addEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
    __decorate([
      Decorators_1.Override
    ], SingletonPredictionContext.prototype, "equals", null);
    SingletonPredictionContext = __decorate([
      __param(0, Decorators_1.NotNull)
    ], SingletonPredictionContext);
    exports2.SingletonPredictionContext = SingletonPredictionContext;
    (function(PredictionContext2) {
      PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
      PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
      PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
      PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
      class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(IdentityEqualityComparator.INSTANCE);
        }
      }
      PredictionContext2.IdentityHashMap = IdentityHashMap;
      class IdentityEqualityComparator {
        IdentityEqualityComparator() {
        }
        hashCode(obj) {
          return obj.hashCode();
        }
        equals(a2, b) {
          return a2 === b;
        }
      }
      IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], IdentityEqualityComparator.prototype, "equals", null);
      PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
    })(PredictionContext = exports2.PredictionContext || (exports2.PredictionContext = {}));
  }
});

// node_modules/antlr4ts/misc/Utils.js
var require_Utils = __commonJS({
  "node_modules/antlr4ts/misc/Utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toCharArray = exports2.toMap = exports2.equals = exports2.join = exports2.escapeWhitespace = void 0;
    function escapeWhitespace(s, escapeSpaces) {
      return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
    }
    exports2.escapeWhitespace = escapeWhitespace;
    function join8(collection, separator) {
      let buf = "";
      let first = true;
      for (let current of collection) {
        if (first) {
          first = false;
        } else {
          buf += separator;
        }
        buf += current;
      }
      return buf;
    }
    exports2.join = join8;
    function equals(x, y) {
      if (x === y) {
        return true;
      }
      if (x === void 0 || y === void 0) {
        return false;
      }
      return x.equals(y);
    }
    exports2.equals = equals;
    function toMap(keys) {
      let m = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < keys.length; i2++) {
        m.set(keys[i2], i2);
      }
      return m;
    }
    exports2.toMap = toMap;
    function toCharArray(str) {
      if (typeof str === "string") {
        let result = new Uint16Array(str.length);
        for (let i2 = 0; i2 < str.length; i2++) {
          result[i2] = str.charCodeAt(i2);
        }
        return result;
      } else {
        return str.toCharArray();
      }
    }
    exports2.toCharArray = toCharArray;
  }
});

// node_modules/antlr4ts/atn/SemanticContext.js
var require_SemanticContext = __commonJS({
  "node_modules/antlr4ts/atn/SemanticContext.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticContext = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var Utils = require_Utils();
    function max(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison < 0) {
          result = current;
        }
      }
      return result;
    }
    function min(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison > 0) {
          result = current;
        }
      }
      return result;
    }
    var SemanticContext = class _SemanticContext {
      /**
       * The default {@link SemanticContext}, which is semantically equivalent to
       * a predicate of the form `{true}?`.
       */
      static get NONE() {
        if (_SemanticContext._NONE === void 0) {
          _SemanticContext._NONE = new _SemanticContext.Predicate();
        }
        return _SemanticContext._NONE;
      }
      /**
       * Evaluate the precedence predicates for the context and reduce the result.
       *
       * @param parser The parser instance.
       * @param parserCallStack
       * @returns The simplified semantic context after precedence predicates are
       * evaluated, which will be one of the following values.
       *
       * * {@link #NONE}: if the predicate simplifies to `true` after
       *   precedence predicates are evaluated.
       * * `undefined`: if the predicate simplifies to `false` after
       *   precedence predicates are evaluated.
       * * `this`: if the semantic context is not changed as a result of
       *   precedence predicate evaluation.
       * * A non-`undefined` {@link SemanticContext}: the new simplified
       *   semantic context after precedence predicates are evaluated.
       */
      evalPrecedence(parser, parserCallStack) {
        return this;
      }
      static and(a2, b) {
        if (!a2 || a2 === _SemanticContext.NONE) {
          return b;
        }
        if (b === _SemanticContext.NONE) {
          return a2;
        }
        let result = new _SemanticContext.AND(a2, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
      /**
       *
       *  @see ParserATNSimulator#getPredsForAmbigAlts
       */
      static or(a2, b) {
        if (!a2) {
          return b;
        }
        if (a2 === _SemanticContext.NONE || b === _SemanticContext.NONE) {
          return _SemanticContext.NONE;
        }
        let result = new _SemanticContext.OR(a2, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
    };
    exports2.SemanticContext = SemanticContext;
    (function(SemanticContext2) {
      const AND_HASHCODE = 40363613;
      const OR_HASHCODE = 486279973;
      function filterPrecedencePredicates(collection) {
        let result = [];
        for (let i2 = 0; i2 < collection.length; i2++) {
          let context = collection[i2];
          if (context instanceof SemanticContext2.PrecedencePredicate) {
            result.push(context);
            collection.splice(i2, 1);
            i2--;
          }
        }
        return result;
      }
      class Predicate extends SemanticContext2 {
        constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
          super();
          this.ruleIndex = ruleIndex;
          this.predIndex = predIndex;
          this.isCtxDependent = isCtxDependent;
        }
        eval(parser, parserCallStack) {
          let localctx = this.isCtxDependent ? parserCallStack : void 0;
          return parser.sempred(localctx, this.ruleIndex, this.predIndex);
        }
        hashCode() {
          let hashCode = MurmurHash_1.MurmurHash.initialize();
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof Predicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
        }
        toString() {
          return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "toString", null);
      SemanticContext2.Predicate = Predicate;
      class PrecedencePredicate extends SemanticContext2 {
        constructor(precedence) {
          super();
          this.precedence = precedence;
        }
        eval(parser, parserCallStack) {
          return parser.precpred(parserCallStack, this.precedence);
        }
        evalPrecedence(parser, parserCallStack) {
          if (parser.precpred(parserCallStack, this.precedence)) {
            return SemanticContext2.NONE;
          } else {
            return void 0;
          }
        }
        compareTo(o2) {
          return this.precedence - o2.precedence;
        }
        hashCode() {
          let hashCode = 1;
          hashCode = 31 * hashCode + this.precedence;
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof PrecedencePredicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.precedence === obj.precedence;
        }
        toString() {
          return "{" + this.precedence + ">=prec}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "compareTo", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "toString", null);
      SemanticContext2.PrecedencePredicate = PrecedencePredicate;
      class Operator extends SemanticContext2 {
      }
      SemanticContext2.Operator = Operator;
      let AND = class AND2 extends Operator {
        constructor(a2, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a2 instanceof AND2) {
            operands.addAll(a2.opnds);
          } else {
            operands.add(a2);
          }
          if (b instanceof AND2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = min(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof AND2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
        }
        /**
         * {@inheritDoc}
         *
         * The evaluation of predicates by this context is short-circuiting, but
         * unordered.
         */
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (!opnd.eval(parser, parserCallStack)) {
              return false;
            }
          }
          return true;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated == null) {
              return void 0;
            } else if (evaluated !== SemanticContext2.NONE) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return SemanticContext2.NONE;
          }
          let result = operands[0];
          for (let i2 = 1; i2 < operands.length; i2++) {
            result = SemanticContext2.and(result, operands[i2]);
          }
          return result;
        }
        toString() {
          return Utils.join(this.opnds, "&&");
        }
      };
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "toString", null);
      AND = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], AND);
      SemanticContext2.AND = AND;
      let OR = class OR2 extends Operator {
        constructor(a2, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a2 instanceof OR2) {
            operands.addAll(a2.opnds);
          } else {
            operands.add(a2);
          }
          if (b instanceof OR2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = max(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof OR2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
        }
        /**
         * {@inheritDoc}
         *
         * The evaluation of predicates by this context is short-circuiting, but
         * unordered.
         */
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (opnd.eval(parser, parserCallStack)) {
              return true;
            }
          }
          return false;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated === SemanticContext2.NONE) {
              return SemanticContext2.NONE;
            } else if (evaluated) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return void 0;
          }
          let result = operands[0];
          for (let i2 = 1; i2 < operands.length; i2++) {
            result = SemanticContext2.or(result, operands[i2]);
          }
          return result;
        }
        toString() {
          return Utils.join(this.opnds, "||");
        }
      };
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "toString", null);
      OR = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], OR);
      SemanticContext2.OR = OR;
    })(SemanticContext = exports2.SemanticContext || (exports2.SemanticContext = {}));
  }
});

// node_modules/antlr4ts/atn/ATNConfig.js
var require_ATNConfig = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfig.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATNConfig = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DecisionState_1 = require_DecisionState();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var SUPPRESS_PRECEDENCE_FILTER = 2147483648;
    var ATNConfig = class ATNConfig2 {
      constructor(state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          assert((altOrConfig & 16777215) === altOrConfig);
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig;
          this._context = context;
        } else {
          this._state = state;
          this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
          this._context = context;
        }
      }
      static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, alt, context);
          }
        } else if (lexerActionExecutor != null) {
          return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
        } else {
          return new ATNConfig2(state, alt, context);
        }
      }
      /** Gets the ATN state associated with this configuration */
      get state() {
        return this._state;
      }
      /** What alt (or lexer rule) is predicted by this configuration */
      get alt() {
        return this.altAndOuterContextDepth & 16777215;
      }
      get context() {
        return this._context;
      }
      set context(context) {
        this._context = context;
      }
      get reachesIntoOuterContext() {
        return this.outerContextDepth !== 0;
      }
      /**
       * We cannot execute predicates dependent upon local context unless
       * we know for sure we are in the correct context. Because there is
       * no way to do this efficiently, we simply cannot evaluate
       * dependent predicates unless we are in the rule that initially
       * invokes the ATN simulator.
       *
       * closure() tracks the depth of how far we dip into the outer context:
       * depth &gt; 0.  Note that it may not be totally accurate depth since I
       * don't ever decrement. TODO: make it a boolean then
       */
      get outerContextDepth() {
        return this.altAndOuterContextDepth >>> 24 & 127;
      }
      set outerContextDepth(outerContextDepth) {
        assert(outerContextDepth >= 0);
        outerContextDepth = Math.min(outerContextDepth, 127);
        this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
      }
      get lexerActionExecutor() {
        return void 0;
      }
      get semanticContext() {
        return SemanticContext_1.SemanticContext.NONE;
      }
      get hasPassedThroughNonGreedyDecision() {
        return false;
      }
      clone() {
        return this.transform(this.state, false);
      }
      transform(state, checkNonGreedy, arg2) {
        if (arg2 == null) {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
          return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
        } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
          return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
        } else {
          return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
        }
      }
      transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
        let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          if (lexerActionExecutor != null || passedThroughNonGreedy) {
            return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
          } else {
            return new SemanticContextATNConfig(semanticContext, state, this, context);
          }
        } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
          return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
        } else {
          return new ATNConfig2(state, this, context);
        }
      }
      static checkNonGreedyDecision(source, target) {
        return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
      }
      appendContext(context, contextCache) {
        if (typeof context === "number") {
          let appendedContext = this.context.appendSingleContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        } else {
          let appendedContext = this.context.appendContext(context, contextCache);
          let result = this.transform(this.state, false, appendedContext);
          return result;
        }
      }
      /**
       * Determines if this `ATNConfig` fully contains another `ATNConfig`.
       *
       * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores
       * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which
       * are all in the same "location" but have different contexts. These `ATNConfig` instances are again merged when
       * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a
       * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.
       *
       * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:
       *
       * * The configurations are in the same state (`state`)
       * * The configurations predict the same alternative (`alt`)
       * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)
       * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_
       *
       * This method implements a conservative approximation of containment. As a result, when this method returns `true`
       * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized
       * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic
       * contexts, no assumptions can be made about the relationship between the configurations when this method returns
       * `false`.
       *
       * @param subconfig The sub configuration.
       * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.
       */
      contains(subconfig) {
        if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
          return false;
        }
        let leftWorkList = [];
        let rightWorkList = [];
        leftWorkList.push(this.context);
        rightWorkList.push(subconfig.context);
        while (true) {
          let left = leftWorkList.pop();
          let right = rightWorkList.pop();
          if (!left || !right) {
            break;
          }
          if (left === right) {
            return true;
          }
          if (left.size < right.size) {
            return false;
          }
          if (right.isEmpty) {
            return left.hasEmpty;
          } else {
            for (let i2 = 0; i2 < right.size; i2++) {
              let index = left.findReturnState(right.getReturnState(i2));
              if (index < 0) {
                return false;
              }
              leftWorkList.push(left.getParent(index));
              rightWorkList.push(right.getParent(i2));
            }
          }
        }
        return false;
      }
      get isPrecedenceFilterSuppressed() {
        return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
      }
      set isPrecedenceFilterSuppressed(value) {
        if (value) {
          this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
        } else {
          this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
        }
      }
      /** An ATN configuration is equal to another if both have
       *  the same state, they predict the same alternative, and
       *  syntactic/semantic contexts are the same.
       */
      equals(o2) {
        if (this === o2) {
          return true;
        } else if (!(o2 instanceof ATNConfig2)) {
          return false;
        }
        return this.state.stateNumber === o2.state.stateNumber && this.alt === o2.alt && this.reachesIntoOuterContext === o2.reachesIntoOuterContext && this.context.equals(o2.context) && this.semanticContext.equals(o2.semanticContext) && this.isPrecedenceFilterSuppressed === o2.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o2.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o2.lexerActionExecutor);
      }
      hashCode() {
        let hashCode = MurmurHash_1.MurmurHash.initialize(7);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
        return hashCode;
      }
      /**
       * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a
       * **.dot** file and then rendered to an image using Graphviz.
       *
       * @returns A Graphviz graph representing the current `ATNConfig`.
       *
       * @see http://www.graphviz.org/
       */
      toDotString() {
        let builder = "";
        builder += "digraph G {\n";
        builder += "rankdir=LR;\n";
        let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
        let workList = [];
        function getOrAddContext(context) {
          let newNumber = visited.size;
          let result = visited.putIfAbsent(context, newNumber);
          if (result != null) {
            return result;
          }
          workList.push(context);
          return newNumber;
        }
        workList.push(this.context);
        visited.put(this.context, 0);
        while (true) {
          let current = workList.pop();
          if (!current) {
            break;
          }
          for (let i2 = 0; i2 < current.size; i2++) {
            builder += "  s" + getOrAddContext(current);
            builder += "->";
            builder += "s" + getOrAddContext(current.getParent(i2));
            builder += '[label="' + current.getReturnState(i2) + '"];\n';
          }
        }
        builder += "}\n";
        return builder.toString();
      }
      toString(recog, showAlt, showContext) {
        if (showContext == null) {
          showContext = showAlt != null;
        }
        if (showAlt == null) {
          showAlt = true;
        }
        let buf = "";
        let contexts;
        if (showContext) {
          contexts = this.context.toStrings(recog, this.state.stateNumber);
        } else {
          contexts = ["?"];
        }
        let first = true;
        for (let contextDesc of contexts) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          buf += "(";
          buf += this.state;
          if (showAlt) {
            buf += ",";
            buf += this.alt;
          }
          if (this.context) {
            buf += ",";
            buf += contextDesc;
          }
          if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            buf += ",";
            buf += this.semanticContext;
          }
          if (this.reachesIntoOuterContext) {
            buf += ",up=" + this.outerContextDepth;
          }
          buf += ")";
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_state", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "_context", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "state", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNConfig.prototype, "context", null);
    __decorate([
      Decorators_1.NotNull
    ], ATNConfig.prototype, "semanticContext", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "clone", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig.prototype, "transformImpl", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfig.prototype, "hashCode", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ATNConfig, "create", null);
    ATNConfig = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ATNConfig);
    exports2.ATNConfig = ATNConfig;
    var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
      constructor(semanticContext, state, altOrConfig, context) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
        }
        this._semanticContext = semanticContext;
      }
      get semanticContext() {
        return this._semanticContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
    __decorate([
      Decorators_1.Override
    ], SemanticContextATNConfig.prototype, "semanticContext", null);
    SemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], SemanticContextATNConfig);
    var ActionATNConfig = class ActionATNConfig extends ATNConfig {
      constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(state, altOrConfig, context);
        } else {
          super(state, altOrConfig, context);
          if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
            throw new Error("Not supported");
          }
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionATNConfig);
    var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
      constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
        if (typeof altOrConfig === "number") {
          super(semanticContext, state, altOrConfig, context);
        } else {
          super(semanticContext, state, altOrConfig, context);
        }
        this._lexerActionExecutor = lexerActionExecutor;
        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
      }
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
      get hasPassedThroughNonGreedyDecision() {
        return this.passedThroughNonGreedyDecision;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
    __decorate([
      Decorators_1.Override
    ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
    ActionSemanticContextATNConfig = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ActionSemanticContextATNConfig);
  }
});

// node_modules/antlr4ts/misc/BitSet.js
var require_BitSet = __commonJS({
  "node_modules/antlr4ts/misc/BitSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BitSet = void 0;
    var util3 = require("util");
    var MurmurHash_1 = require_MurmurHash();
    var EMPTY_DATA = new Uint16Array(0);
    function getIndex(bitNumber) {
      return bitNumber >>> 4;
    }
    function unIndex(n2) {
      return n2 * 16;
    }
    function findLSBSet(word) {
      let bit = 1;
      for (let i2 = 0; i2 < 16; i2++) {
        if ((word & bit) !== 0) {
          return i2;
        }
        bit = bit << 1 >>> 0;
      }
      throw new RangeError("No specified bit found");
    }
    function findMSBSet(word) {
      let bit = 1 << 15 >>> 0;
      for (let i2 = 15; i2 >= 0; i2--) {
        if ((word & bit) !== 0) {
          return i2;
        }
        bit = bit >>> 1;
      }
      throw new RangeError("No specified bit found");
    }
    function bitsFor(fromBit, toBit) {
      fromBit &= 15;
      toBit &= 15;
      if (fromBit === toBit) {
        return 1 << fromBit >>> 0;
      }
      return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
    }
    var POP_CNT = new Uint8Array(65536);
    for (let i2 = 0; i2 < 16; i2++) {
      const stride = 1 << i2 >>> 0;
      let index = 0;
      while (index < POP_CNT.length) {
        index += stride;
        for (let j = 0; j < stride; j++) {
          POP_CNT[index]++;
          index++;
        }
      }
    }
    var BitSet = class _BitSet {
      /*
      ** constructor implementation
      */
      constructor(arg) {
        if (!arg) {
          this.data = EMPTY_DATA;
        } else if (typeof arg === "number") {
          if (arg < 0) {
            throw new RangeError("nbits cannot be negative");
          } else {
            this.data = new Uint16Array(getIndex(arg - 1) + 1);
          }
        } else {
          if (arg instanceof _BitSet) {
            this.data = arg.data.slice(0);
          } else {
            let max = -1;
            for (let v of arg) {
              if (max < v) {
                max = v;
              }
            }
            this.data = new Uint16Array(getIndex(max - 1) + 1);
            for (let v of arg) {
              this.set(v);
            }
          }
        }
      }
      /**
       * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that
       * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding
       * bit in the bit set argument also had the value `true`.
       */
      and(set2) {
        const data = this.data;
        const other = set2.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i2 = 0; i2 < words; i2++) {
          let value = data[i2] &= other[i2];
          if (value !== 0) {
            lastWord = i2;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      /**
       * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.
       */
      andNot(set2) {
        const data = this.data;
        const other = set2.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1;
        for (let i2 = 0; i2 < words; i2++) {
          let value = data[i2] &= other[i2] ^ 65535;
          if (value !== 0) {
            lastWord = i2;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
          this.data = data.slice(0, lastWord + 1);
        }
      }
      /**
       * Returns the number of bits set to `true` in this `BitSet`.
       */
      cardinality() {
        if (this.isEmpty) {
          return 0;
        }
        const data = this.data;
        const length = data.length;
        let result = 0;
        for (let i2 = 0; i2 < length; i2++) {
          result += POP_CNT[data[i2]];
        }
        return result;
      }
      clear(fromIndex, toIndex) {
        if (fromIndex == null) {
          this.data.fill(0);
        } else if (toIndex == null) {
          this.set(fromIndex, false);
        } else {
          this.set(fromIndex, toIndex, false);
        }
      }
      flip(fromIndex, toIndex) {
        if (toIndex == null) {
          toIndex = fromIndex;
        }
        if (fromIndex < 0 || toIndex < fromIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        const lastWord = getIndex(toIndex);
        if (word === lastWord) {
          this.data[word] ^= bitsFor(fromIndex, toIndex);
        } else {
          this.data[word++] ^= bitsFor(fromIndex, 15);
          while (word < lastWord) {
            this.data[word++] ^= 65535;
          }
          this.data[word++] ^= bitsFor(0, toIndex);
        }
      }
      get(fromIndex, toIndex) {
        if (toIndex === void 0) {
          return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
        } else {
          let result = new _BitSet(toIndex + 1);
          for (let i2 = fromIndex; i2 <= toIndex; i2++) {
            result.set(i2, this.get(i2));
          }
          return result;
        }
      }
      /**
       * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.
       *
       * @param set `BitSet` to intersect with
       */
      intersects(set2) {
        let smallerLength = Math.min(this.length(), set2.length());
        if (smallerLength === 0) {
          return false;
        }
        let bound = getIndex(smallerLength - 1);
        for (let i2 = 0; i2 <= bound; i2++) {
          if ((this.data[i2] & set2.data[i2]) !== 0) {
            return true;
          }
        }
        return false;
      }
      /**
       * Returns true if this `BitSet` contains no bits that are set to `true`.
       */
      get isEmpty() {
        return this.length() === 0;
      }
      /**
       * Returns the "logical size" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns
       * zero if the `BitSet` contains no set bits.
       */
      length() {
        if (!this.data.length) {
          return 0;
        }
        return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
      }
      /**
       * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,
       * If no such bit exists then `-1` is returned.
       *
       * @param fromIndex the index to start checking from (inclusive)
       *
       * @throws RangeError if the specified index is negative
       */
      nextClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let ignore = 65535 ^ bitsFor(fromIndex, 15);
        if ((data[word] | ignore) === 65535) {
          word++;
          ignore = 0;
          for (; word < length; word++) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word === length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet((data[word] | ignore) ^ 65535);
      }
      /**
       * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
       * If no such bit exists then `-1` is returned.
       *
       * To iterate over the `true` bits in a `BitSet`, use the following loop:
       *
       * ```
       * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
       *   // operate on index i here
       * }
       * ```
       *
       * @param fromIndex the index to start checking from (inclusive)
       *
       * @throws RangeError if the specified index is negative
       */
      nextSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
          return -1;
        }
        let mask = bitsFor(fromIndex, 15);
        if ((data[word] & mask) === 0) {
          word++;
          mask = 65535;
          for (; word < length; word++) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word >= length) {
            return -1;
          }
        }
        return unIndex(word) + findLSBSet(data[word] & mask);
      }
      /**
       * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
       * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
       * set argument has the value `true`.
       */
      or(set2) {
        const data = this.data;
        const other = set2.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i2 = 0; i2 < minWords; i2++) {
          let value = dest[i2] = data[i2] | other[i2];
          if (value !== 0) {
            lastWord = i2;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i2 = minWords; i2 < words; i2++) {
          let value = dest[i2] = longer[i2];
          if (value !== 0) {
            lastWord = i2;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord);
        }
      }
      /**
       * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting
       * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
       *
       * @param fromIndex the index to start checking from (inclusive)
       *
       * @throws RangeError if the specified index is less than `-1`
       */
      previousClearBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let ignore = 65535 ^ bitsFor(0, fromIndex);
        if ((data[word] | ignore) === 65535) {
          ignore = 0;
          word--;
          for (; word >= 0; word--) {
            if (data[word] !== 65535) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet((data[word] | ignore) ^ 65535);
      }
      /**
       * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.
       * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
       *
       * To iterate over the `true` bits in a `BitSet`, use the following loop:
       *
       * ```
       * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {
       *   // operate on index i here
       * }
       * ```
       *
       * @param fromIndex the index to start checking from (inclusive)
       *
       * @throws RangeError if the specified index is less than `-1`
       */
      previousSetBit(fromIndex) {
        if (fromIndex < 0) {
          throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
          word = length - 1;
        }
        let mask = bitsFor(0, fromIndex);
        if ((data[word] & mask) === 0) {
          word--;
          mask = 65535;
          for (; word >= 0; word--) {
            if (data[word] !== 0) {
              break;
            }
          }
          if (word < 0) {
            return -1;
          }
        }
        return unIndex(word) + findMSBSet(data[word] & mask);
      }
      set(fromIndex, toIndex, value) {
        if (toIndex === void 0) {
          toIndex = fromIndex;
          value = true;
        } else if (typeof toIndex === "boolean") {
          value = toIndex;
          toIndex = fromIndex;
        }
        if (value === void 0) {
          value = true;
        }
        if (fromIndex < 0 || fromIndex > toIndex) {
          throw new RangeError();
        }
        let word = getIndex(fromIndex);
        let lastWord = getIndex(toIndex);
        if (value && lastWord >= this.data.length) {
          let temp = new Uint16Array(lastWord + 1);
          this.data.forEach((value2, index) => temp[index] = value2);
          this.data = temp;
        } else if (!value) {
          if (word >= this.data.length) {
            return;
          }
          if (lastWord >= this.data.length) {
            lastWord = this.data.length - 1;
            toIndex = this.data.length * 16 - 1;
          }
        }
        if (word === lastWord) {
          this._setBits(word, value, bitsFor(fromIndex, toIndex));
        } else {
          this._setBits(word++, value, bitsFor(fromIndex, 15));
          while (word < lastWord) {
            this.data[word++] = value ? 65535 : 0;
          }
          this._setBits(word, value, bitsFor(0, toIndex));
        }
      }
      _setBits(word, value, mask) {
        if (value) {
          this.data[word] |= mask;
        } else {
          this.data[word] &= 65535 ^ mask;
        }
      }
      /**
       * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element
       * in the set is the size - 1st element.
       */
      get size() {
        return this.data.byteLength * 8;
      }
      /**
       * Returns a new byte array containing all the bits in this bit set.
       *
       * More precisely, if
       * `let bytes = s.toByteArray();`
       * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all
       * `n < 8 * bytes.length`.
       */
      // toByteArray(): Int8Array {
      // 	throw new Error("NOT IMPLEMENTED");
      // }
      /**
       * Returns a new integer array containing all the bits in this bit set.
       *
       * More precisely, if
       * `let integers = s.toIntegerArray();`
       * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all
       * `n < 32 * integers.length`.
       */
      // toIntegerArray(): Int32Array {
      // 	throw new Error("NOT IMPLEMENTED");
      // }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
      }
      /**
       * Compares this object against the specified object. The result is `true` if and only if the argument is not
       * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That
       * is, for every nonnegative index `k`,
       *
       * ```
       * ((BitSet)obj).get(k) == this.get(k)
       * ```
       *
       * must be true. The current sizes of the two bit sets are not compared.
       */
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _BitSet)) {
          return false;
        }
        const len = this.length();
        if (len !== obj.length()) {
          return false;
        }
        if (len === 0) {
          return true;
        }
        let bound = getIndex(len - 1);
        for (let i2 = 0; i2 <= bound; i2++) {
          if (this.data[i2] !== obj.data[i2]) {
            return false;
          }
        }
        return true;
      }
      /**
       * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the
       * set state, the decimal representation of that index is included in the result. Such indices are listed in order
       * from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual
       * mathematical notation for a set of integers.
       *
       * Example:
       *
       *     BitSet drPepper = new BitSet();
       *
       * Now `drPepper.toString()` returns `"{}"`.
       *
       *     drPepper.set(2);
       *
       * Now `drPepper.toString()` returns `"{2}"`.
       *
       *     drPepper.set(4);
       *     drPepper.set(10);
       *
       * Now `drPepper.toString()` returns `"{2, 4, 10}"`.
       */
      toString() {
        let result = "{";
        let first = true;
        for (let i2 = this.nextSetBit(0); i2 >= 0; i2 = this.nextSetBit(i2 + 1)) {
          if (first) {
            first = false;
          } else {
            result += ", ";
          }
          result += i2;
        }
        result += "}";
        return result;
      }
      // static valueOf(bytes: Int8Array): BitSet;
      // static valueOf(buffer: ArrayBuffer): BitSet;
      // static valueOf(integers: Int32Array): BitSet;
      // static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {
      // 	throw new Error("NOT IMPLEMENTED");
      // }
      /**
       * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in
       * it has the value `true` if and only if one of the following statements holds:
       *
       * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.
       * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.
       */
      xor(set2) {
        const data = this.data;
        const other = set2.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        for (let i2 = 0; i2 < minWords; i2++) {
          let value = dest[i2] = data[i2] ^ other[i2];
          if (value !== 0) {
            lastWord = i2;
          }
        }
        const longer = data.length > other.length ? data : other;
        for (let i2 = minWords; i2 < words; i2++) {
          let value = dest[i2] = longer[i2];
          if (value !== 0) {
            lastWord = i2;
          }
        }
        if (lastWord === -1) {
          this.data = EMPTY_DATA;
        } else if (dest.length === lastWord + 1) {
          this.data = dest;
        } else {
          this.data = dest.slice(0, lastWord + 1);
        }
      }
      clone() {
        return new _BitSet(this);
      }
      [Symbol.iterator]() {
        return new BitSetIterator(this.data);
      }
      // Overrides formatting for nodejs assert etc.
      [util3.inspect.custom]() {
        return "BitSet " + this.toString();
      }
    };
    exports2.BitSet = BitSet;
    var BitSetIterator = class {
      constructor(data) {
        this.data = data;
        this.index = 0;
        this.mask = 65535;
      }
      next() {
        while (this.index < this.data.length) {
          const bits = this.data[this.index] & this.mask;
          if (bits !== 0) {
            const bitNumber = unIndex(this.index) + findLSBSet(bits);
            this.mask = bitsFor(bitNumber + 1, 15);
            return { done: false, value: bitNumber };
          }
          this.index++;
          this.mask = 65535;
        }
        return { done: true, value: -1 };
      }
      [Symbol.iterator]() {
        return this;
      }
    };
  }
});

// node_modules/antlr4ts/atn/ATNConfigSet.js
var require_ATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/ATNConfigSet.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATNConfigSet = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var SemanticContext_1 = require_SemanticContext();
    var assert = require("assert");
    var Utils = require_Utils();
    var KeyTypeEqualityComparer = class {
      hashCode(key) {
        return key.state ^ key.alt;
      }
      equals(a2, b) {
        return a2.state === b.state && a2.alt === b.alt;
      }
    };
    KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
    function NewKeyedConfigMap(map) {
      if (map) {
        return new Array2DHashMap_1.Array2DHashMap(map);
      } else {
        return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
      }
    }
    var ATNConfigSet = class _ATNConfigSet {
      constructor(set2, readonly) {
        this._uniqueAlt = 0;
        this._hasSemanticContext = false;
        this._dipsIntoOuterContext = false;
        this.outermostConfigSet = false;
        this.cachedHashCode = -1;
        if (!set2) {
          this.mergedConfigs = NewKeyedConfigMap();
          this.unmerged = [];
          this.configs = [];
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        } else {
          if (readonly) {
            this.mergedConfigs = void 0;
            this.unmerged = void 0;
          } else if (!set2.isReadOnly) {
            this.mergedConfigs = NewKeyedConfigMap(set2.mergedConfigs);
            this.unmerged = set2.unmerged.slice(0);
          } else {
            this.mergedConfigs = NewKeyedConfigMap();
            this.unmerged = [];
          }
          this.configs = set2.configs.slice(0);
          this._dipsIntoOuterContext = set2._dipsIntoOuterContext;
          this._hasSemanticContext = set2._hasSemanticContext;
          this.outermostConfigSet = set2.outermostConfigSet;
          if (readonly || !set2.isReadOnly) {
            this._uniqueAlt = set2._uniqueAlt;
            this._conflictInfo = set2._conflictInfo;
          }
        }
      }
      /**
       * Get the set of all alternatives represented by configurations in this
       * set.
       */
      getRepresentedAlternatives() {
        if (this._conflictInfo != null) {
          return this._conflictInfo.conflictedAlts.clone();
        }
        let alts = new BitSet_1.BitSet();
        for (let config2 of this) {
          alts.set(config2.alt);
        }
        return alts;
      }
      get isReadOnly() {
        return this.mergedConfigs == null;
      }
      get isOutermostConfigSet() {
        return this.outermostConfigSet;
      }
      set isOutermostConfigSet(outermostConfigSet) {
        if (this.outermostConfigSet && !outermostConfigSet) {
          throw new Error("IllegalStateException");
        }
        assert(!outermostConfigSet || !this._dipsIntoOuterContext);
        this.outermostConfigSet = outermostConfigSet;
      }
      getStates() {
        let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        for (let c3 of this.configs) {
          states.add(c3.state);
        }
        return states;
      }
      optimizeConfigs(interpreter) {
        if (this.configs.length === 0) {
          return;
        }
        for (let config2 of this.configs) {
          config2.context = interpreter.atn.getCachedContext(config2.context);
        }
      }
      clone(readonly) {
        let copy = new _ATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this.configs);
        }
        return copy;
      }
      get size() {
        return this.configs.length;
      }
      get isEmpty() {
        return this.configs.length === 0;
      }
      contains(o2) {
        if (!(o2 instanceof ATNConfig_1.ATNConfig)) {
          return false;
        }
        if (this.mergedConfigs && this.unmerged) {
          let config2 = o2;
          let configKey = this.getKey(config2);
          let mergedConfig = this.mergedConfigs.get(configKey);
          if (mergedConfig != null && this.canMerge(config2, configKey, mergedConfig)) {
            return mergedConfig.contains(config2);
          }
          for (let c3 of this.unmerged) {
            if (c3.contains(o2)) {
              return true;
            }
          }
        } else {
          for (let c3 of this.configs) {
            if (c3.contains(o2)) {
              return true;
            }
          }
        }
        return false;
      }
      *[Symbol.iterator]() {
        yield* this.configs;
      }
      toArray() {
        return this.configs;
      }
      add(e, contextCache) {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let addKey;
        let key = this.getKey(e);
        let mergedConfig = this.mergedConfigs.get(key);
        addKey = mergedConfig == null;
        if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
          mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
          if (e.isPrecedenceFilterSuppressed) {
            mergedConfig.isPrecedenceFilterSuppressed = true;
          }
          let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
          this.updatePropertiesForMergedConfig(e);
          if (mergedConfig.context === joined) {
            return false;
          }
          mergedConfig.context = joined;
          return true;
        }
        for (let i2 = 0; i2 < this.unmerged.length; i2++) {
          let unmergedConfig = this.unmerged[i2];
          if (this.canMerge(e, key, unmergedConfig)) {
            unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
            if (e.isPrecedenceFilterSuppressed) {
              unmergedConfig.isPrecedenceFilterSuppressed = true;
            }
            let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
            this.updatePropertiesForMergedConfig(e);
            if (unmergedConfig.context === joined) {
              return false;
            }
            unmergedConfig.context = joined;
            if (addKey) {
              this.mergedConfigs.put(key, unmergedConfig);
              this.unmerged.splice(i2, 1);
            }
            return true;
          }
        }
        this.configs.push(e);
        if (addKey) {
          this.mergedConfigs.put(key, e);
        } else {
          this.unmerged.push(e);
        }
        this.updatePropertiesForAddedConfig(e);
        return true;
      }
      updatePropertiesForMergedConfig(config2) {
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config2.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      updatePropertiesForAddedConfig(config2) {
        if (this.configs.length === 1) {
          this._uniqueAlt = config2.alt;
        } else if (this._uniqueAlt !== config2.alt) {
          this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config2.semanticContext);
        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config2.reachesIntoOuterContext;
        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
      }
      canMerge(left, leftKey, right) {
        if (left.state.stateNumber !== right.state.stateNumber) {
          return false;
        }
        if (leftKey.alt !== right.alt) {
          return false;
        }
        return left.semanticContext.equals(right.semanticContext);
      }
      getKey(e) {
        return { state: e.state.stateNumber, alt: e.alt };
      }
      containsAll(c3) {
        for (let o2 of c3) {
          if (!(o2 instanceof ATNConfig_1.ATNConfig)) {
            return false;
          }
          if (!this.contains(o2)) {
            return false;
          }
        }
        return true;
      }
      addAll(c3, contextCache) {
        this.ensureWritable();
        let changed = false;
        for (let group of c3) {
          if (this.add(group, contextCache)) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.ensureWritable();
        if (!this.mergedConfigs || !this.unmerged) {
          throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
        }
        this.mergedConfigs.clear();
        this.unmerged.length = 0;
        this.configs.length = 0;
        this._dipsIntoOuterContext = false;
        this._hasSemanticContext = false;
        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        this._conflictInfo = void 0;
      }
      equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof _ATNConfigSet)) {
          return false;
        }
        return this.outermostConfigSet === obj.outermostConfigSet && Utils.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
      }
      hashCode() {
        if (this.isReadOnly && this.cachedHashCode !== -1) {
          return this.cachedHashCode;
        }
        let hashCode = 1;
        hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
        hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
        if (this.isReadOnly) {
          this.cachedHashCode = hashCode;
        }
        return hashCode;
      }
      toString(showContext) {
        if (showContext == null) {
          showContext = false;
        }
        let buf = "";
        let sortedConfigs = this.configs.slice(0);
        sortedConfigs.sort((o1, o2) => {
          if (o1.alt !== o2.alt) {
            return o1.alt - o2.alt;
          } else if (o1.state.stateNumber !== o2.state.stateNumber) {
            return o1.state.stateNumber - o2.state.stateNumber;
          } else {
            return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
          }
        });
        buf += "[";
        for (let i2 = 0; i2 < sortedConfigs.length; i2++) {
          if (i2 > 0) {
            buf += ", ";
          }
          buf += sortedConfigs[i2].toString(void 0, true, showContext);
        }
        buf += "]";
        if (this._hasSemanticContext) {
          buf += ",hasSemanticContext=" + this._hasSemanticContext;
        }
        if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          buf += ",uniqueAlt=" + this._uniqueAlt;
        }
        if (this._conflictInfo != null) {
          buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
          if (!this._conflictInfo.isExact) {
            buf += "*";
          }
        }
        if (this._dipsIntoOuterContext) {
          buf += ",dipsIntoOuterContext";
        }
        return buf.toString();
      }
      get uniqueAlt() {
        return this._uniqueAlt;
      }
      get hasSemanticContext() {
        return this._hasSemanticContext;
      }
      set hasSemanticContext(value) {
        this.ensureWritable();
        this._hasSemanticContext = value;
      }
      get conflictInfo() {
        return this._conflictInfo;
      }
      set conflictInfo(conflictInfo) {
        this.ensureWritable();
        this._conflictInfo = conflictInfo;
      }
      get conflictingAlts() {
        if (this._conflictInfo == null) {
          return void 0;
        }
        return this._conflictInfo.conflictedAlts;
      }
      get isExactConflict() {
        if (this._conflictInfo == null) {
          return false;
        }
        return this._conflictInfo.isExact;
      }
      get dipsIntoOuterContext() {
        return this._dipsIntoOuterContext;
      }
      get(index) {
        return this.configs[index];
      }
      ensureWritable() {
        if (this.isReadOnly) {
          throw new Error("This ATNConfigSet is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ATNConfigSet.prototype, "hashCode", null);
    exports2.ATNConfigSet = ATNConfigSet;
  }
});

// node_modules/antlr4ts/dfa/DFAState.js
var require_DFAState = __commonJS({
  "node_modules/antlr4ts/dfa/DFAState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DFAState = void 0;
    var ATN_1 = require_ATN();
    var BitSet_1 = require_BitSet();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var assert = require("assert");
    var DFAState = class _DFAState {
      /**
       * Constructs a new `DFAState`.
       *
       * @param configs The set of ATN configurations defining this state.
       */
      constructor(configs) {
        this.stateNumber = -1;
        this.configs = configs;
        this.edges = /* @__PURE__ */ new Map();
        this.contextEdges = /* @__PURE__ */ new Map();
      }
      get isContextSensitive() {
        return !!this.contextSymbols;
      }
      isContextSymbol(symbol) {
        if (!this.isContextSensitive) {
          return false;
        }
        return this.contextSymbols.get(symbol);
      }
      setContextSymbol(symbol) {
        assert(this.isContextSensitive);
        this.contextSymbols.set(symbol);
      }
      setContextSensitive(atn) {
        assert(!this.configs.isOutermostConfigSet);
        if (this.isContextSensitive) {
          return;
        }
        if (!this.contextSymbols) {
          this.contextSymbols = new BitSet_1.BitSet();
        }
      }
      get acceptStateInfo() {
        return this._acceptStateInfo;
      }
      set acceptStateInfo(acceptStateInfo) {
        this._acceptStateInfo = acceptStateInfo;
      }
      get isAcceptState() {
        return !!this._acceptStateInfo;
      }
      get prediction() {
        if (!this._acceptStateInfo) {
          return ATN_1.ATN.INVALID_ALT_NUMBER;
        }
        return this._acceptStateInfo.prediction;
      }
      get lexerActionExecutor() {
        if (!this._acceptStateInfo) {
          return void 0;
        }
        return this._acceptStateInfo.lexerActionExecutor;
      }
      getTarget(symbol) {
        return this.edges.get(symbol);
      }
      setTarget(symbol, target) {
        this.edges.set(symbol, target);
      }
      getEdgeMap() {
        return this.edges;
      }
      getContextTarget(invokingState) {
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        return this.contextEdges.get(invokingState);
      }
      setContextTarget(invokingState, target) {
        if (!this.isContextSensitive) {
          throw new Error("The state is not context sensitive.");
        }
        if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          invokingState = -1;
        }
        this.contextEdges.set(invokingState, target);
      }
      getContextEdgeMap() {
        let map = new Map(this.contextEdges);
        let existing = map.get(-1);
        if (existing !== void 0) {
          if (map.size === 1) {
            let result = /* @__PURE__ */ new Map();
            result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
            return result;
          } else {
            map.delete(-1);
            map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
          }
        }
        return map;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize(7);
        hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
        hash = MurmurHash_1.MurmurHash.finish(hash, 1);
        return hash;
      }
      /**
       * Two {@link DFAState} instances are equal if their ATN configuration sets
       * are the same. This method is used to see if a state already exists.
       *
       * Because the number of alternatives and number of ATN configurations are
       * finite, there is a finite number of DFA states that can be processed.
       * This is necessary to show that the algorithm terminates.
       *
       * Cannot test the DFA state numbers here because in
       * {@link ParserATNSimulator#addDFAState} we need to know if any other state
       * exists that has this exact set of ATN configurations. The
       * {@link #stateNumber} is irrelevant.
       */
      equals(o2) {
        if (this === o2) {
          return true;
        }
        if (!(o2 instanceof _DFAState)) {
          return false;
        }
        let other = o2;
        let sameSet = this.configs.equals(other.configs);
        return sameSet;
      }
      toString() {
        let buf = "";
        buf += this.stateNumber + ":" + this.configs;
        if (this.isAcceptState) {
          buf += "=>";
          if (this.predicates) {
            buf += this.predicates;
          } else {
            buf += this.prediction;
          }
        }
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "configs", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "edges", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFAState.prototype, "contextEdges", void 0);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], DFAState.prototype, "toString", null);
    exports2.DFAState = DFAState;
    (function(DFAState2) {
      let PredPrediction = class PredPrediction {
        constructor(pred, alt) {
          this.alt = alt;
          this.pred = pred;
        }
        toString() {
          return "(" + this.pred + ", " + this.alt + ")";
        }
      };
      __decorate([
        Decorators_1.NotNull
      ], PredPrediction.prototype, "pred", void 0);
      __decorate([
        Decorators_1.Override
      ], PredPrediction.prototype, "toString", null);
      PredPrediction = __decorate([
        __param(0, Decorators_1.NotNull)
      ], PredPrediction);
      DFAState2.PredPrediction = PredPrediction;
    })(DFAState = exports2.DFAState || (exports2.DFAState = {}));
  }
});

// node_modules/antlr4ts/atn/ATNSimulator.js
var require_ATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ATNSimulator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATNSimulator = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFAState_1 = require_DFAState();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var ATNSimulator = class ATNSimulator2 {
      constructor(atn) {
        this.atn = atn;
      }
      static get ERROR() {
        if (!ATNSimulator2._ERROR) {
          ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        return ATNSimulator2._ERROR;
      }
      /**
       * Clear the DFA cache used by the current instance. Since the DFA cache may
       * be shared by multiple ATN simulators, this method may affect the
       * performance (but not accuracy) of other parsers which are being used
       * concurrently.
       *
       * @ if the current instance does not
       * support clearing the DFA.
       *
       * @since 4.3
       */
      clearDFA() {
        this.atn.clearDFA();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATNSimulator, "ERROR", null);
    ATNSimulator = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNSimulator);
    exports2.ATNSimulator = ATNSimulator;
    /* @__PURE__ */ (function(ATNSimulator2) {
      const RULE_VARIANT_DELIMITER = "$";
      const RULE_LF_VARIANT_MARKER = "$lf$";
      const RULE_NOLF_VARIANT_MARKER = "$nolf$";
    })(ATNSimulator = exports2.ATNSimulator || (exports2.ATNSimulator = {}));
    exports2.ATNSimulator = ATNSimulator;
  }
});

// node_modules/antlr4ts/ConsoleErrorListener.js
var require_ConsoleErrorListener = __commonJS({
  "node_modules/antlr4ts/ConsoleErrorListener.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConsoleErrorListener = void 0;
    var ConsoleErrorListener = class {
      /**
       * {@inheritDoc}
       *
       * This implementation prints messages to {@link System#err} containing the
       * values of `line`, `charPositionInLine`, and `msg` using
       * the following format.
       *
       * <pre>
       * line *line*:*charPositionInLine* *msg*
       * </pre>
       */
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        console.error(`line ${line}:${charPositionInLine} ${msg}`);
      }
    };
    exports2.ConsoleErrorListener = ConsoleErrorListener;
    ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
  }
});

// node_modules/antlr4ts/ProxyErrorListener.js
var require_ProxyErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyErrorListener.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var ProxyErrorListener = class {
      constructor(delegates) {
        this.delegates = delegates;
        if (!delegates) {
          throw new Error("Invalid delegates");
        }
      }
      getDelegates() {
        return this.delegates;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        this.delegates.forEach((listener) => {
          if (listener.syntaxError) {
            listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ProxyErrorListener.prototype, "syntaxError", null);
    exports2.ProxyErrorListener = ProxyErrorListener;
  }
});

// node_modules/antlr4ts/IntStream.js
var require_IntStream = __commonJS({
  "node_modules/antlr4ts/IntStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntStream = void 0;
    var IntStream;
    (function(IntStream2) {
      IntStream2.EOF = -1;
      IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
    })(IntStream = exports2.IntStream || (exports2.IntStream = {}));
  }
});

// node_modules/antlr4ts/Token.js
var require_Token = __commonJS({
  "node_modules/antlr4ts/Token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Token = void 0;
    var IntStream_1 = require_IntStream();
    var Token2;
    (function(Token3) {
      Token3.INVALID_TYPE = 0;
      Token3.EPSILON = -2;
      Token3.MIN_USER_TOKEN_TYPE = 1;
      Token3.EOF = IntStream_1.IntStream.EOF;
      Token3.DEFAULT_CHANNEL = 0;
      Token3.HIDDEN_CHANNEL = 1;
      Token3.MIN_USER_CHANNEL_VALUE = 2;
    })(Token2 = exports2.Token || (exports2.Token = {}));
  }
});

// node_modules/antlr4ts/Recognizer.js
var require_Recognizer = __commonJS({
  "node_modules/antlr4ts/Recognizer.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Recognizer = void 0;
    var ConsoleErrorListener_1 = require_ConsoleErrorListener();
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Utils = require_Utils();
    var Recognizer = class _Recognizer {
      constructor() {
        this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
        this._stateNumber = -1;
      }
      /**
       * Get a map from token names to token types.
       *
       * Used for XPath and tree pattern compilation.
       */
      getTokenTypeMap() {
        let vocabulary = this.vocabulary;
        let result = _Recognizer.tokenTypeMapCache.get(vocabulary);
        if (result == null) {
          let intermediateResult = /* @__PURE__ */ new Map();
          for (let i2 = 0; i2 <= this.atn.maxTokenType; i2++) {
            let literalName = vocabulary.getLiteralName(i2);
            if (literalName != null) {
              intermediateResult.set(literalName, i2);
            }
            let symbolicName = vocabulary.getSymbolicName(i2);
            if (symbolicName != null) {
              intermediateResult.set(symbolicName, i2);
            }
          }
          intermediateResult.set("EOF", Token_1.Token.EOF);
          result = intermediateResult;
          _Recognizer.tokenTypeMapCache.set(vocabulary, result);
        }
        return result;
      }
      /**
       * Get a map from rule names to rule indexes.
       *
       * Used for XPath and tree pattern compilation.
       */
      getRuleIndexMap() {
        let ruleNames = this.ruleNames;
        if (ruleNames == null) {
          throw new Error("The current recognizer does not provide a list of rule names.");
        }
        let result = _Recognizer.ruleIndexMapCache.get(ruleNames);
        if (result == null) {
          result = Utils.toMap(ruleNames);
          _Recognizer.ruleIndexMapCache.set(ruleNames, result);
        }
        return result;
      }
      getTokenType(tokenName) {
        let ttype = this.getTokenTypeMap().get(tokenName);
        if (ttype != null) {
          return ttype;
        }
        return Token_1.Token.INVALID_TYPE;
      }
      /**
       * If this recognizer was generated, it will have a serialized ATN
       * representation of the grammar.
       *
       * For interpreters, we don't know their serialized ATN despite having
       * created the interpreter from it.
       */
      get serializedATN() {
        throw new Error("there is no serialized ATN");
      }
      /**
       * Get the {@link ATN} used by the recognizer for prediction.
       *
       * @returns The {@link ATN} used by the recognizer for prediction.
       */
      get atn() {
        return this._interp.atn;
      }
      /**
       * Get the ATN interpreter used by the recognizer for prediction.
       *
       * @returns The ATN interpreter used by the recognizer for prediction.
       */
      get interpreter() {
        return this._interp;
      }
      /**
       * Set the ATN interpreter used by the recognizer for prediction.
       *
       * @param interpreter The ATN interpreter used by the recognizer for
       * prediction.
       */
      set interpreter(interpreter) {
        this._interp = interpreter;
      }
      /** If profiling during the parse/lex, this will return DecisionInfo records
       *  for each decision in recognizer in a ParseInfo object.
       *
       * @since 4.3
       */
      get parseInfo() {
        return Promise.resolve(void 0);
      }
      /** What is the error header, normally line/character position information? */
      getErrorHeader(e) {
        let token = e.getOffendingToken();
        if (!token) {
          return "";
        }
        let line = token.line;
        let charPositionInLine = token.charPositionInLine;
        return "line " + line + ":" + charPositionInLine;
      }
      /**
       * @exception NullPointerException if `listener` is `undefined`.
       */
      addErrorListener(listener) {
        if (!listener) {
          throw new TypeError("listener must not be null");
        }
        this._listeners.push(listener);
      }
      removeErrorListener(listener) {
        let position = this._listeners.indexOf(listener);
        if (position !== -1) {
          this._listeners.splice(position, 1);
        }
      }
      removeErrorListeners() {
        this._listeners.length = 0;
      }
      getErrorListeners() {
        return this._listeners.slice(0);
      }
      getErrorListenerDispatch() {
        return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
      }
      // subclass needs to override these if there are sempreds or actions
      // that the ATN interp needs to execute
      sempred(_localctx, ruleIndex, actionIndex) {
        return true;
      }
      precpred(localctx, precedence) {
        return true;
      }
      action(_localctx, ruleIndex, actionIndex) {
      }
      get state() {
        return this._stateNumber;
      }
      /** Indicate that the recognizer has changed internal state that is
       *  consistent with the ATN state passed in.  This way we always know
       *  where we are in the ATN as the parser goes along. The rule
       *  context objects form a stack that lets us see the stack of
       *  invoking rules. Combine this and we have complete ATN
       *  configuration information.
       */
      set state(atnState) {
        this._stateNumber = atnState;
      }
    };
    Recognizer.EOF = -1;
    Recognizer.tokenTypeMapCache = /* @__PURE__ */ new WeakMap();
    Recognizer.ruleIndexMapCache = /* @__PURE__ */ new WeakMap();
    __decorate([
      Decorators_1.SuppressWarnings("serial"),
      Decorators_1.NotNull
    ], Recognizer.prototype, "_listeners", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getTokenTypeMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getRuleIndexMap", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "serializedATN", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "atn", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "interpreter", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "getErrorHeader", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "addErrorListener", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Recognizer.prototype, "removeErrorListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Recognizer.prototype, "getErrorListeners", null);
    exports2.Recognizer = Recognizer;
  }
});

// node_modules/antlr4ts/VocabularyImpl.js
var require_VocabularyImpl = __commonJS({
  "node_modules/antlr4ts/VocabularyImpl.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VocabularyImpl = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var VocabularyImpl = class {
      /**
       * Constructs a new instance of {@link VocabularyImpl} from the specified
       * literal, symbolic, and display token names.
       *
       * @param literalNames The literal names assigned to tokens, or an empty array
       * if no literal names are assigned.
       * @param symbolicNames The symbolic names assigned to tokens, or
       * an empty array if no symbolic names are assigned.
       * @param displayNames The display names assigned to tokens, or an empty array
       * to use the values in `literalNames` and `symbolicNames` as
       * the source of display names, as described in
       * {@link #getDisplayName(int)}.
       *
       * @see #getLiteralName(int)
       * @see #getSymbolicName(int)
       * @see #getDisplayName(int)
       */
      constructor(literalNames, symbolicNames, displayNames) {
        this.literalNames = literalNames;
        this.symbolicNames = symbolicNames;
        this.displayNames = displayNames;
        this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
      }
      get maxTokenType() {
        return this._maxTokenType;
      }
      getLiteralName(tokenType) {
        if (tokenType >= 0 && tokenType < this.literalNames.length) {
          return this.literalNames[tokenType];
        }
        return void 0;
      }
      getSymbolicName(tokenType) {
        if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
          return this.symbolicNames[tokenType];
        }
        if (tokenType === Token_1.Token.EOF) {
          return "EOF";
        }
        return void 0;
      }
      getDisplayName(tokenType) {
        if (tokenType >= 0 && tokenType < this.displayNames.length) {
          let displayName = this.displayNames[tokenType];
          if (displayName) {
            return displayName;
          }
        }
        let literalName = this.getLiteralName(tokenType);
        if (literalName) {
          return literalName;
        }
        let symbolicName = this.getSymbolicName(tokenType);
        if (symbolicName) {
          return symbolicName;
        }
        return String(tokenType);
      }
    };
    VocabularyImpl.EMPTY_VOCABULARY = new VocabularyImpl([], [], []);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl.prototype, "literalNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl.prototype, "symbolicNames", void 0);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl.prototype, "displayNames", void 0);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl.prototype, "maxTokenType", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl.prototype, "getLiteralName", null);
    __decorate([
      Decorators_1.Override
    ], VocabularyImpl.prototype, "getSymbolicName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], VocabularyImpl.prototype, "getDisplayName", null);
    __decorate([
      Decorators_1.NotNull
    ], VocabularyImpl, "EMPTY_VOCABULARY", void 0);
    exports2.VocabularyImpl = VocabularyImpl;
  }
});

// node_modules/antlr4ts/dfa/DFASerializer.js
var require_DFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/DFASerializer.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DFASerializer = void 0;
    var ATNSimulator_1 = require_ATNSimulator();
    var Decorators_1 = require_Decorators();
    var PredictionContext_1 = require_PredictionContext();
    var Recognizer_1 = require_Recognizer();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFASerializer = class {
      constructor(dfa, vocabulary, ruleNames, atn) {
        if (vocabulary instanceof Recognizer_1.Recognizer) {
          ruleNames = vocabulary.ruleNames;
          atn = vocabulary.atn;
          vocabulary = vocabulary.vocabulary;
        } else if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        this.dfa = dfa;
        this.vocabulary = vocabulary;
        this.ruleNames = ruleNames;
        this.atn = atn;
      }
      toString() {
        if (!this.dfa.s0) {
          return "";
        }
        let buf = "";
        if (this.dfa.states) {
          let states = new Array(...this.dfa.states.toArray());
          states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
          for (let s of states) {
            let edges = s.getEdgeMap();
            let edgeKeys = [...edges.keys()].sort((a2, b) => a2 - b);
            let contextEdges = s.getContextEdgeMap();
            let contextEdgeKeys = [...contextEdges.keys()].sort((a2, b) => a2 - b);
            for (let entry of edgeKeys) {
              let value = edges.get(entry);
              if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
                continue;
              }
              let contextSymbol = false;
              buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
              if (s.isContextSymbol(entry)) {
                buf += "!";
                contextSymbol = true;
              }
              let t = value;
              if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                buf += this.getStateString(t) + "\n";
              } else if (contextSymbol) {
                buf += "ctx\n";
              }
            }
            if (s.isContextSensitive) {
              for (let entry of contextEdgeKeys) {
                buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
              }
            }
          }
        }
        let output = buf;
        if (output.length === 0) {
          return "";
        }
        return output;
      }
      getContextLabel(i2) {
        if (i2 === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          return "ctx:EMPTY_FULL";
        } else if (i2 === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
          return "ctx:EMPTY_LOCAL";
        }
        if (this.atn && i2 > 0 && i2 <= this.atn.states.length) {
          let state = this.atn.states[i2];
          let ruleIndex = state.ruleIndex;
          if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
            return "ctx:" + String(i2) + "(" + this.ruleNames[ruleIndex] + ")";
          }
        }
        return "ctx:" + String(i2);
      }
      getEdgeLabel(i2) {
        return this.vocabulary.getDisplayName(i2);
      }
      getStateString(s) {
        if (s === ATNSimulator_1.ATNSimulator.ERROR) {
          return "ERROR";
        }
        let n2 = s.stateNumber;
        let stateStr = "s" + n2;
        if (s.isAcceptState) {
          if (s.predicates) {
            stateStr = ":s" + n2 + "=>" + s.predicates;
          } else {
            stateStr = ":s" + n2 + "=>" + s.prediction;
          }
        }
        if (s.isContextSensitive) {
          stateStr += "*";
          for (let config2 of s.configs) {
            if (config2.reachesIntoOuterContext) {
              stateStr += "*";
              break;
            }
          }
        }
        return stateStr;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "dfa", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFASerializer.prototype, "vocabulary", void 0);
    __decorate([
      Decorators_1.Override
    ], DFASerializer.prototype, "toString", null);
    exports2.DFASerializer = DFASerializer;
  }
});

// node_modules/antlr4ts/dfa/LexerDFASerializer.js
var require_LexerDFASerializer = __commonJS({
  "node_modules/antlr4ts/dfa/LexerDFASerializer.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerDFASerializer = void 0;
    var DFASerializer_1 = require_DFASerializer();
    var Decorators_1 = require_Decorators();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
      constructor(dfa) {
        super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
      }
      getEdgeLabel(i2) {
        return "'" + String.fromCodePoint(i2) + "'";
      }
    };
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], LexerDFASerializer.prototype, "getEdgeLabel", null);
    LexerDFASerializer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerDFASerializer);
    exports2.LexerDFASerializer = LexerDFASerializer;
  }
});

// node_modules/antlr4ts/atn/ATNStateType.js
var require_ATNStateType = __commonJS({
  "node_modules/antlr4ts/atn/ATNStateType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATNStateType = void 0;
    var ATNStateType;
    (function(ATNStateType2) {
      ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
      ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
      ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
      ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
      ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
      ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
      ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
      ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
      ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
      ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
      ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
      ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
      ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
    })(ATNStateType = exports2.ATNStateType || (exports2.ATNStateType = {}));
  }
});

// node_modules/antlr4ts/atn/StarLoopEntryState.js
var require_StarLoopEntryState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopEntryState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StarLoopEntryState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var StarLoopEntryState = class extends DecisionState_1.DecisionState {
      constructor() {
        super(...arguments);
        this.precedenceRuleDecision = false;
        this.precedenceLoopbackStates = new BitSet_1.BitSet();
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopEntryState.prototype, "stateType", null);
    exports2.StarLoopEntryState = StarLoopEntryState;
  }
});

// node_modules/antlr4ts/dfa/DFA.js
var require_DFA = __commonJS({
  "node_modules/antlr4ts/dfa/DFA.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DFA = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var DFASerializer_1 = require_DFASerializer();
    var DFAState_1 = require_DFAState();
    var LexerDFASerializer_1 = require_LexerDFASerializer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var DFA = class DFA {
      constructor(atnStartState, decision = 0) {
        this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.nextStateNumber = 0;
        if (!atnStartState.atn) {
          throw new Error("The ATNState must be associated with an ATN");
        }
        this.atnStartState = atnStartState;
        this.atn = atnStartState.atn;
        this.decision = decision;
        let isPrecedenceDfa = false;
        if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
          if (atnStartState.precedenceRuleDecision) {
            isPrecedenceDfa = true;
            this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
            this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          }
        }
        this.precedenceDfa = isPrecedenceDfa;
      }
      /**
       * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
       * start state {@link #s0} which is not stored in {@link #states}. The
       * {@link DFAState#edges} array for this start state contains outgoing edges
       * supplying individual start states corresponding to specific precedence
       * values.
       *
       * @returns `true` if this is a precedence DFA; otherwise,
       * `false`.
       * @see Parser.precedence
       */
      get isPrecedenceDfa() {
        return this.precedenceDfa;
      }
      /**
       * Get the start state for a specific precedence value.
       *
       * @param precedence The current precedence.
       * @returns The start state corresponding to the specified precedence, or
       * `undefined` if no start state exists for the specified precedence.
       *
       * @ if this is not a precedence DFA.
       * @see `isPrecedenceDfa`
       */
      getPrecedenceStartState(precedence, fullContext) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (fullContext) {
          return this.s0full.getTarget(precedence);
        } else {
          return this.s0.getTarget(precedence);
        }
      }
      /**
       * Set the start state for a specific precedence value.
       *
       * @param precedence The current precedence.
       * @param startState The start state corresponding to the specified
       * precedence.
       *
       * @ if this is not a precedence DFA.
       * @see `isPrecedenceDfa`
       */
      setPrecedenceStartState(precedence, fullContext, startState) {
        if (!this.isPrecedenceDfa) {
          throw new Error("Only precedence DFAs may contain a precedence start state.");
        }
        if (precedence < 0) {
          return;
        }
        if (fullContext) {
          this.s0full.setTarget(precedence, startState);
        } else {
          this.s0.setTarget(precedence, startState);
        }
      }
      get isEmpty() {
        if (this.isPrecedenceDfa) {
          return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
        }
        return this.s0 == null && this.s0full == null;
      }
      get isContextSensitive() {
        if (this.isPrecedenceDfa) {
          return this.s0full.getEdgeMap().size > 0;
        }
        return this.s0full != null;
      }
      addState(state) {
        state.stateNumber = this.nextStateNumber++;
        return this.states.getOrAdd(state);
      }
      toString(vocabulary, ruleNames) {
        if (!vocabulary) {
          vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        }
        if (!this.s0) {
          return "";
        }
        let serializer;
        if (ruleNames) {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
        } else {
          serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
        }
        return serializer.toString();
      }
      toLexerString() {
        if (!this.s0) {
          return "";
        }
        let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
        return serializer.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atnStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], DFA.prototype, "atn", void 0);
    DFA = __decorate([
      __param(0, Decorators_1.NotNull)
    ], DFA);
    exports2.DFA = DFA;
  }
});

// node_modules/antlr4ts/misc/IntegerList.js
var require_IntegerList = __commonJS({
  "node_modules/antlr4ts/misc/IntegerList.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntegerList = void 0;
    var Arrays_1 = require_Arrays();
    var Decorators_1 = require_Decorators();
    var EMPTY_DATA = new Int32Array(0);
    var INITIAL_SIZE = 4;
    var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
    var IntegerList = class _IntegerList {
      constructor(arg) {
        if (!arg) {
          this._data = EMPTY_DATA;
          this._size = 0;
        } else if (arg instanceof _IntegerList) {
          this._data = arg._data.slice(0);
          this._size = arg._size;
        } else if (typeof arg === "number") {
          if (arg === 0) {
            this._data = EMPTY_DATA;
            this._size = 0;
          } else {
            this._data = new Int32Array(arg);
            this._size = 0;
          }
        } else {
          this._data = EMPTY_DATA;
          this._size = 0;
          for (let value of arg) {
            this.add(value);
          }
        }
      }
      add(value) {
        if (this._data.length === this._size) {
          this.ensureCapacity(this._size + 1);
        }
        this._data[this._size] = value;
        this._size++;
      }
      addAll(list2) {
        if (Array.isArray(list2)) {
          this.ensureCapacity(this._size + list2.length);
          this._data.subarray(this._size, this._size + list2.length).set(list2);
          this._size += list2.length;
        } else if (list2 instanceof _IntegerList) {
          this.ensureCapacity(this._size + list2._size);
          this._data.subarray(this._size, this._size + list2.size).set(list2._data);
          this._size += list2._size;
        } else {
          this.ensureCapacity(this._size + list2.size);
          let current = 0;
          for (let xi of list2) {
            this._data[this._size + current] = xi;
            current++;
          }
          this._size += list2.size;
        }
      }
      get(index) {
        if (index < 0 || index >= this._size) {
          throw RangeError();
        }
        return this._data[index];
      }
      contains(value) {
        for (let i2 = 0; i2 < this._size; i2++) {
          if (this._data[i2] === value) {
            return true;
          }
        }
        return false;
      }
      set(index, value) {
        if (index < 0 || index >= this._size) {
          throw RangeError();
        }
        let previous = this._data[index];
        this._data[index] = value;
        return previous;
      }
      removeAt(index) {
        let value = this.get(index);
        this._data.copyWithin(index, index + 1, this._size);
        this._data[this._size - 1] = 0;
        this._size--;
        return value;
      }
      removeRange(fromIndex, toIndex) {
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw RangeError();
        }
        if (fromIndex > toIndex) {
          throw RangeError();
        }
        this._data.copyWithin(toIndex, fromIndex, this._size);
        this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
        this._size -= toIndex - fromIndex;
      }
      get isEmpty() {
        return this._size === 0;
      }
      get size() {
        return this._size;
      }
      trimToSize() {
        if (this._data.length === this._size) {
          return;
        }
        this._data = this._data.slice(0, this._size);
      }
      clear() {
        this._data.fill(0, 0, this._size);
        this._size = 0;
      }
      toArray() {
        if (this._size === 0) {
          return [];
        }
        return Array.from(this._data.subarray(0, this._size));
      }
      sort() {
        this._data.subarray(0, this._size).sort();
      }
      /**
       * Compares the specified object with this list for equality.  Returns
       * `true` if and only if the specified object is also an {@link IntegerList},
       * both lists have the same size, and all corresponding pairs of elements in
       * the two lists are equal.  In other words, two lists are defined to be
       * equal if they contain the same elements in the same order.
       *
       * This implementation first checks if the specified object is this
       * list. If so, it returns `true`; if not, it checks if the
       * specified object is an {@link IntegerList}. If not, it returns `false`;
       * if so, it checks the size of both lists. If the lists are not the same size,
       * it returns `false`; otherwise it iterates over both lists, comparing
       * corresponding pairs of elements.  If any comparison returns `false`,
       * this method returns `false`.
       *
       * @param o the object to be compared for equality with this list
       * @returns `true` if the specified object is equal to this list
       */
      equals(o2) {
        if (o2 === this) {
          return true;
        }
        if (!(o2 instanceof _IntegerList)) {
          return false;
        }
        if (this._size !== o2._size) {
          return false;
        }
        for (let i2 = 0; i2 < this._size; i2++) {
          if (this._data[i2] !== o2._data[i2]) {
            return false;
          }
        }
        return true;
      }
      /**
       * Returns the hash code value for this list.
       *
       * This implementation uses exactly the code that is used to define the
       * list hash function in the documentation for the {@link List#hashCode}
       * method.
       *
       * @returns the hash code value for this list
       */
      hashCode() {
        let hashCode = 1;
        for (let i2 = 0; i2 < this._size; i2++) {
          hashCode = 31 * hashCode + this._data[i2];
        }
        return hashCode;
      }
      /**
       * Returns a string representation of this list.
       */
      toString() {
        return this._data.toString();
      }
      binarySearch(key, fromIndex, toIndex) {
        if (fromIndex === void 0) {
          fromIndex = 0;
        }
        if (toIndex === void 0) {
          toIndex = this._size;
        }
        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
          throw new RangeError();
        }
        if (fromIndex > toIndex) {
          throw new RangeError();
        }
        return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
      }
      ensureCapacity(capacity) {
        if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
          throw new RangeError();
        }
        let newLength;
        if (this._data.length === 0) {
          newLength = INITIAL_SIZE;
        } else {
          newLength = this._data.length;
        }
        while (newLength < capacity) {
          newLength = newLength * 2;
          if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
            newLength = MAX_ARRAY_SIZE;
          }
        }
        let tmp = new Int32Array(newLength);
        tmp.set(this._data);
        this._data = tmp;
      }
      /** Convert the list to a UTF-16 encoded char array. If all values are less
       *  than the 0xFFFF 16-bit code point limit then this is just a char array
       *  of 16-bit char as usual. For values in the supplementary range, encode
       * them as two UTF-16 code units.
       */
      toCharArray() {
        let resultArray = new Uint16Array(this._size);
        let resultIdx = 0;
        let calculatedPreciseResultSize = false;
        for (let i2 = 0; i2 < this._size; i2++) {
          let codePoint = this._data[i2];
          if (codePoint >= 0 && codePoint < 65536) {
            resultArray[resultIdx] = codePoint;
            resultIdx++;
            continue;
          }
          if (!calculatedPreciseResultSize) {
            let newResultArray = new Uint16Array(this.charArraySize());
            newResultArray.set(resultArray, 0);
            resultArray = newResultArray;
            calculatedPreciseResultSize = true;
          }
          let pair = String.fromCodePoint(codePoint);
          resultArray[resultIdx] = pair.charCodeAt(0);
          resultArray[resultIdx + 1] = pair.charCodeAt(1);
          resultIdx += 2;
        }
        return resultArray;
      }
      charArraySize() {
        let result = 0;
        for (let i2 = 0; i2 < this._size; i2++) {
          result += this._data[i2] >= 65536 ? 2 : 1;
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], IntegerList.prototype, "_data", void 0);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntegerList.prototype, "toString", null);
    exports2.IntegerList = IntegerList;
  }
});

// node_modules/antlr4ts/misc/Interval.js
var require_Interval = __commonJS({
  "node_modules/antlr4ts/misc/Interval.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Interval = void 0;
    var Decorators_1 = require_Decorators();
    var INTERVAL_POOL_MAX_VALUE = 1e3;
    var Interval = class _Interval {
      /**
       * @param a The start of the interval
       * @param b The end of the interval (inclusive)
       */
      constructor(a2, b) {
        this.a = a2;
        this.b = b;
      }
      static get INVALID() {
        return _Interval._INVALID;
      }
      /** Interval objects are used readonly so share all with the
       *  same single value a==b up to some max size.  Use an array as a perfect hash.
       *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
       *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
       *  have a..a (set with 1 element).
       */
      static of(a2, b) {
        if (a2 !== b || a2 < 0 || a2 > INTERVAL_POOL_MAX_VALUE) {
          return new _Interval(a2, b);
        }
        if (_Interval.cache[a2] == null) {
          _Interval.cache[a2] = new _Interval(a2, a2);
        }
        return _Interval.cache[a2];
      }
      /** return number of elements between a and b inclusively. x..x is length 1.
       *  if b &lt; a, then length is 0.  9..10 has length 2.
       */
      get length() {
        if (this.b < this.a) {
          return 0;
        }
        return this.b - this.a + 1;
      }
      equals(o2) {
        if (o2 === this) {
          return true;
        } else if (!(o2 instanceof _Interval)) {
          return false;
        }
        return this.a === o2.a && this.b === o2.b;
      }
      hashCode() {
        let hash = 23;
        hash = hash * 31 + this.a;
        hash = hash * 31 + this.b;
        return hash;
      }
      /** Does this start completely before other? Disjoint */
      startsBeforeDisjoint(other) {
        return this.a < other.a && this.b < other.a;
      }
      /** Does this start at or before other? Nondisjoint */
      startsBeforeNonDisjoint(other) {
        return this.a <= other.a && this.b >= other.a;
      }
      /** Does this.a start after other.b? May or may not be disjoint */
      startsAfter(other) {
        return this.a > other.a;
      }
      /** Does this start completely after other? Disjoint */
      startsAfterDisjoint(other) {
        return this.a > other.b;
      }
      /** Does this start after other? NonDisjoint */
      startsAfterNonDisjoint(other) {
        return this.a > other.a && this.a <= other.b;
      }
      /** Are both ranges disjoint? I.e., no overlap? */
      disjoint(other) {
        return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
      }
      /** Are two intervals adjacent such as 0..41 and 42..42? */
      adjacent(other) {
        return this.a === other.b + 1 || this.b === other.a - 1;
      }
      properlyContains(other) {
        return other.a >= this.a && other.b <= this.b;
      }
      /** Return the interval computed from combining this and other */
      union(other) {
        return _Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
      }
      /** Return the interval in common between this and o */
      intersection(other) {
        return _Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
      }
      /** Return the interval with elements from `this` not in `other`;
       *  `other` must not be totally enclosed (properly contained)
       *  within `this`, which would result in two disjoint intervals
       *  instead of the single one returned by this method.
       */
      differenceNotProperlyContained(other) {
        let diff;
        if (other.startsBeforeNonDisjoint(this)) {
          diff = _Interval.of(Math.max(this.a, other.b + 1), this.b);
        } else if (other.startsAfterNonDisjoint(this)) {
          diff = _Interval.of(this.a, other.a - 1);
        }
        return diff;
      }
      toString() {
        return this.a + ".." + this.b;
      }
    };
    Interval._INVALID = new Interval(-1, -2);
    Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Interval.prototype, "toString", null);
    exports2.Interval = Interval;
  }
});

// node_modules/antlr4ts/CommonToken.js
var require_CommonToken = __commonJS({
  "node_modules/antlr4ts/CommonToken.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommonToken = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonToken = class CommonToken2 {
      constructor(type, text2, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
        this._line = 0;
        this._charPositionInLine = -1;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this.index = -1;
        this._text = text2;
        this._type = type;
        this.source = source;
        this._channel = channel;
        this.start = start;
        this.stop = stop;
        if (source.source != null) {
          this._line = source.source.line;
          this._charPositionInLine = source.source.charPositionInLine;
        }
      }
      /**
       * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
       *
       * If `oldToken` is also a {@link CommonToken} instance, the newly
       * constructed token will share a reference to the {@link #text} field and
       * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will
       * be assigned the result of calling {@link #getText}, and {@link #source}
       * will be constructed from the result of {@link Token#getTokenSource} and
       * {@link Token#getInputStream}.
       *
       * @param oldToken The token to copy.
       */
      static fromToken(oldToken) {
        let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
        result._line = oldToken.line;
        result.index = oldToken.tokenIndex;
        result._charPositionInLine = oldToken.charPositionInLine;
        if (oldToken instanceof CommonToken2) {
          result._text = oldToken._text;
          result.source = oldToken.source;
        } else {
          result._text = oldToken.text;
          result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };
        }
        return result;
      }
      get type() {
        return this._type;
      }
      // @Override
      set type(type) {
        this._type = type;
      }
      get line() {
        return this._line;
      }
      // @Override
      set line(line) {
        this._line = line;
      }
      get text() {
        if (this._text != null) {
          return this._text;
        }
        let input = this.inputStream;
        if (input == null) {
          return void 0;
        }
        let n2 = input.size;
        if (this.start < n2 && this.stop < n2) {
          return input.getText(Interval_1.Interval.of(this.start, this.stop));
        } else {
          return "<EOF>";
        }
      }
      /**
       * Explicitly set the text for this token. If {code text} is not
       * `undefined`, then {@link #getText} will return this value rather than
       * extracting the text from the input.
       *
       * @param text The explicit text of the token, or `undefined` if the text
       * should be obtained from the input along with the start and stop indexes
       * of the token.
       */
      // @Override
      set text(text2) {
        this._text = text2;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      // @Override
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      get channel() {
        return this._channel;
      }
      // @Override
      set channel(channel) {
        this._channel = channel;
      }
      get startIndex() {
        return this.start;
      }
      set startIndex(start) {
        this.start = start;
      }
      get stopIndex() {
        return this.stop;
      }
      set stopIndex(stop) {
        this.stop = stop;
      }
      get tokenIndex() {
        return this.index;
      }
      // @Override
      set tokenIndex(index) {
        this.index = index;
      }
      get tokenSource() {
        return this.source.source;
      }
      get inputStream() {
        return this.source.stream;
      }
      toString(recognizer) {
        let channelStr = "";
        if (this._channel > 0) {
          channelStr = ",channel=" + this._channel;
        }
        let txt = this.text;
        if (txt != null) {
          txt = txt.replace(/\n/g, "\\n");
          txt = txt.replace(/\r/g, "\\r");
          txt = txt.replace(/\t/g, "\\t");
        } else {
          txt = "<no text>";
        }
        let typeString = String(this._type);
        if (recognizer) {
          typeString = recognizer.vocabulary.getDisplayName(this._type);
        }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
      }
    };
    CommonToken.EMPTY_SOURCE = { source: void 0, stream: void 0 };
    __decorate([
      Decorators_1.NotNull
    ], CommonToken.prototype, "source", void 0);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], CommonToken.prototype, "toString", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonToken, "fromToken", null);
    CommonToken = __decorate([
      __param(2, Decorators_1.NotNull)
    ], CommonToken);
    exports2.CommonToken = CommonToken;
  }
});

// node_modules/antlr4ts/CommonTokenFactory.js
var require_CommonTokenFactory = __commonJS({
  "node_modules/antlr4ts/CommonTokenFactory.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommonTokenFactory = void 0;
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CommonTokenFactory = class {
      /**
       * Constructs a {@link CommonTokenFactory} with the specified value for
       * {@link #copyText}.
       *
       * When `copyText` is `false`, the {@link #DEFAULT} instance
       * should be used instead of constructing a new instance.
       *
       * @param copyText The value for {@link #copyText}.
       */
      constructor(copyText = false) {
        this.copyText = copyText;
      }
      create(source, type, text2, channel, start, stop, line, charPositionInLine) {
        let t = new CommonToken_1.CommonToken(type, text2, source, channel, start, stop);
        t.line = line;
        t.charPositionInLine = charPositionInLine;
        if (text2 == null && this.copyText && source.stream != null) {
          t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
        }
        return t;
      }
      createSimple(type, text2) {
        return new CommonToken_1.CommonToken(type, text2);
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "create", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenFactory.prototype, "createSimple", null);
    exports2.CommonTokenFactory = CommonTokenFactory;
    (function(CommonTokenFactory2) {
      CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
    })(CommonTokenFactory = exports2.CommonTokenFactory || (exports2.CommonTokenFactory = {}));
  }
});

// node_modules/antlr4ts/misc/IntegerStack.js
var require_IntegerStack = __commonJS({
  "node_modules/antlr4ts/misc/IntegerStack.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntegerStack = void 0;
    var IntegerList_1 = require_IntegerList();
    var IntegerStack = class extends IntegerList_1.IntegerList {
      constructor(arg) {
        super(arg);
      }
      push(value) {
        this.add(value);
      }
      pop() {
        return this.removeAt(this.size - 1);
      }
      peek() {
        return this.get(this.size - 1);
      }
    };
    exports2.IntegerStack = IntegerStack;
  }
});

// node_modules/antlr4ts/dfa/AcceptStateInfo.js
var require_AcceptStateInfo = __commonJS({
  "node_modules/antlr4ts/dfa/AcceptStateInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AcceptStateInfo = void 0;
    var AcceptStateInfo = class {
      constructor(prediction, lexerActionExecutor) {
        this._prediction = prediction;
        this._lexerActionExecutor = lexerActionExecutor;
      }
      /**
       * Gets the prediction made by this accept state. Note that this value
       * assumes the predicates, if any, in the {@link DFAState} evaluate to
       * `true`. If predicate evaluation is enabled, the final prediction of
       * the accept state will be determined by the result of predicate
       * evaluation.
       */
      get prediction() {
        return this._prediction;
      }
      /**
       * Gets the {@link LexerActionExecutor} which can be used to execute actions
       * and/or commands after the lexer matches a token.
       */
      get lexerActionExecutor() {
        return this._lexerActionExecutor;
      }
    };
    exports2.AcceptStateInfo = AcceptStateInfo;
  }
});

// node_modules/antlr4ts/atn/LexerIndexedCustomAction.js
var require_LexerIndexedCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerIndexedCustomAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerIndexedCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
      /**
       * Constructs a new indexed custom action by associating a character offset
       * with a {@link LexerAction}.
       *
       * Note: This class is only required for lexer actions for which
       * {@link LexerAction#isPositionDependent} returns `true`.
       *
       * @param offset The offset into the input {@link CharStream}, relative to
       * the token start index, at which the specified lexer action should be
       * executed.
       * @param action The lexer action to execute at a particular offset in the
       * input {@link CharStream}.
       */
      constructor(offset, action) {
        this._offset = offset;
        this._action = action;
      }
      /**
       * Gets the location in the input {@link CharStream} at which the lexer
       * action should be executed. The value is interpreted as an offset relative
       * to the token start index.
       *
       * @returns The location in the input {@link CharStream} at which the lexer
       * action should be executed.
       */
      get offset() {
        return this._offset;
      }
      /**
       * Gets the lexer action to execute.
       *
       * @returns A {@link LexerAction} object which executes the lexer action.
       */
      get action() {
        return this._action;
      }
      /**
       * {@inheritDoc}
       *
       * @returns This method returns the result of calling {@link #getActionType}
       * on the {@link LexerAction} returned by {@link #getAction}.
       */
      get actionType() {
        return this._action.actionType;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `true`.
       */
      get isPositionDependent() {
        return true;
      }
      /**
       * {@inheritDoc}
       *
       * This method calls {@link #execute} on the result of {@link #getAction}
       * using the provided `lexer`.
       */
      execute(lexer) {
        this._action.execute(lexer);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
        hash = MurmurHash_1.MurmurHash.update(hash, this._action);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerIndexedCustomAction2)) {
          return false;
        }
        return this._offset === obj._offset && this._action.equals(obj._action);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerIndexedCustomAction.prototype, "action", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerIndexedCustomAction.prototype, "equals", null);
    LexerIndexedCustomAction = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerIndexedCustomAction);
    exports2.LexerIndexedCustomAction = LexerIndexedCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerActionExecutor.js
var require_LexerActionExecutor = __commonJS({
  "node_modules/antlr4ts/atn/LexerActionExecutor.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerActionExecutor = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerActionExecutor = class LexerActionExecutor2 {
      /**
       * Constructs an executor for a sequence of {@link LexerAction} actions.
       * @param lexerActions The lexer actions to execute.
       */
      constructor(lexerActions) {
        this._lexerActions = lexerActions;
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let lexerAction of lexerActions) {
          hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
        }
        this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
      }
      /**
       * Creates a {@link LexerActionExecutor} which executes the actions for
       * the input `lexerActionExecutor` followed by a specified
       * `lexerAction`.
       *
       * @param lexerActionExecutor The executor for actions already traversed by
       * the lexer while matching a token within a particular
       * {@link ATNConfig}. If this is `undefined`, the method behaves as though
       * it were an empty executor.
       * @param lexerAction The lexer action to execute after the actions
       * specified in `lexerActionExecutor`.
       *
       * @returns A {@link LexerActionExecutor} for executing the combine actions
       * of `lexerActionExecutor` and `lexerAction`.
       */
      static append(lexerActionExecutor, lexerAction) {
        if (!lexerActionExecutor) {
          return new LexerActionExecutor2([lexerAction]);
        }
        let lexerActions = lexerActionExecutor._lexerActions.slice(0);
        lexerActions.push(lexerAction);
        return new LexerActionExecutor2(lexerActions);
      }
      /**
       * Creates a {@link LexerActionExecutor} which encodes the current offset
       * for position-dependent lexer actions.
       *
       * Normally, when the executor encounters lexer actions where
       * {@link LexerAction#isPositionDependent} returns `true`, it calls
       * {@link IntStream#seek} on the input {@link CharStream} to set the input
       * position to the *end* of the current token. This behavior provides
       * for efficient DFA representation of lexer actions which appear at the end
       * of a lexer rule, even when the lexer rule matches a variable number of
       * characters.
       *
       * Prior to traversing a match transition in the ATN, the current offset
       * from the token start index is assigned to all position-dependent lexer
       * actions which have not already been assigned a fixed offset. By storing
       * the offsets relative to the token start index, the DFA representation of
       * lexer actions which appear in the middle of tokens remains efficient due
       * to sharing among tokens of the same length, regardless of their absolute
       * position in the input stream.
       *
       * If the current executor already has offsets assigned to all
       * position-dependent lexer actions, the method returns `this`.
       *
       * @param offset The current offset to assign to all position-dependent
       * lexer actions which do not already have offsets assigned.
       *
       * @returns A {@link LexerActionExecutor} which stores input stream offsets
       * for all position-dependent lexer actions.
       */
      fixOffsetBeforeMatch(offset) {
        let updatedLexerActions;
        for (let i2 = 0; i2 < this._lexerActions.length; i2++) {
          if (this._lexerActions[i2].isPositionDependent && !(this._lexerActions[i2] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
            if (!updatedLexerActions) {
              updatedLexerActions = this._lexerActions.slice(0);
            }
            updatedLexerActions[i2] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i2]);
          }
        }
        if (!updatedLexerActions) {
          return this;
        }
        return new LexerActionExecutor2(updatedLexerActions);
      }
      /**
       * Gets the lexer actions to be executed by this executor.
       * @returns The lexer actions to be executed by this executor.
       */
      get lexerActions() {
        return this._lexerActions;
      }
      /**
       * Execute the actions encapsulated by this executor within the context of a
       * particular {@link Lexer}.
       *
       * This method calls {@link IntStream#seek} to set the position of the
       * `input` {@link CharStream} prior to calling
       * {@link LexerAction#execute} on a position-dependent action. Before the
       * method returns, the input position will be restored to the same position
       * it was in when the method was invoked.
       *
       * @param lexer The lexer instance.
       * @param input The input stream which is the source for the current token.
       * When this method is called, the current {@link IntStream#index} for
       * `input` should be the start of the following token, i.e. 1
       * character past the end of the current token.
       * @param startIndex The token start index. This value may be passed to
       * {@link IntStream#seek} to set the `input` position to the beginning
       * of the token.
       */
      execute(lexer, input, startIndex) {
        let requiresSeek = false;
        let stopIndex = input.index;
        try {
          for (let lexerAction of this._lexerActions) {
            if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
              let offset = lexerAction.offset;
              input.seek(startIndex + offset);
              lexerAction = lexerAction.action;
              requiresSeek = startIndex + offset !== stopIndex;
            } else if (lexerAction.isPositionDependent) {
              input.seek(stopIndex);
              requiresSeek = false;
            }
            lexerAction.execute(lexer);
          }
        } finally {
          if (requiresSeek) {
            input.seek(stopIndex);
          }
        }
      }
      hashCode() {
        return this.cachedHashCode;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof LexerActionExecutor2)) {
          return false;
        }
        return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "_lexerActions", void 0);
    __decorate([
      Decorators_1.NotNull
    ], LexerActionExecutor.prototype, "lexerActions", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerActionExecutor.prototype, "equals", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], LexerActionExecutor, "append", null);
    LexerActionExecutor = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerActionExecutor);
    exports2.LexerActionExecutor = LexerActionExecutor;
  }
});

// node_modules/antlr4ts/RecognitionException.js
var require_RecognitionException = __commonJS({
  "node_modules/antlr4ts/RecognitionException.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognitionException = void 0;
    var RecognitionException = class extends Error {
      constructor(recognizer, input, ctx, message) {
        super(message);
        this._offendingState = -1;
        this._recognizer = recognizer;
        this.input = input;
        this.ctx = ctx;
        if (recognizer) {
          this._offendingState = recognizer.state;
        }
      }
      /**
       * Get the ATN state number the parser was in at the time the error
       * occurred. For {@link NoViableAltException} and
       * {@link LexerNoViableAltException} exceptions, this is the
       * {@link DecisionState} number. For others, it is the state whose outgoing
       * edge we couldn't match.
       *
       * If the state number is not known, this method returns -1.
       */
      get offendingState() {
        return this._offendingState;
      }
      setOffendingState(offendingState) {
        this._offendingState = offendingState;
      }
      /**
       * Gets the set of input symbols which could potentially follow the
       * previously matched symbol at the time this exception was thrown.
       *
       * If the set of expected tokens is not known and could not be computed,
       * this method returns `undefined`.
       *
       * @returns The set of token types that could potentially follow the current
       * state in the ATN, or `undefined` if the information is not available.
       */
      get expectedTokens() {
        if (this._recognizer) {
          return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
        }
        return void 0;
      }
      /**
       * Gets the {@link RuleContext} at the time this exception was thrown.
       *
       * If the context is not available, this method returns `undefined`.
       *
       * @returns The {@link RuleContext} at the time this exception was thrown.
       * If the context is not available, this method returns `undefined`.
       */
      get context() {
        return this.ctx;
      }
      /**
       * Gets the input stream which is the symbol source for the recognizer where
       * this exception was thrown.
       *
       * If the input stream is not available, this method returns `undefined`.
       *
       * @returns The input stream which is the symbol source for the recognizer
       * where this exception was thrown, or `undefined` if the stream is not
       * available.
       */
      get inputStream() {
        return this.input;
      }
      getOffendingToken(recognizer) {
        if (recognizer && recognizer !== this._recognizer) {
          return void 0;
        }
        return this.offendingToken;
      }
      setOffendingToken(recognizer, offendingToken) {
        if (recognizer === this._recognizer) {
          this.offendingToken = offendingToken;
        }
      }
      /**
       * Gets the {@link Recognizer} where this exception occurred.
       *
       * If the recognizer is not available, this method returns `undefined`.
       *
       * @returns The recognizer where this exception occurred, or `undefined` if
       * the recognizer is not available.
       */
      get recognizer() {
        return this._recognizer;
      }
    };
    exports2.RecognitionException = RecognitionException;
  }
});

// node_modules/antlr4ts/LexerNoViableAltException.js
var require_LexerNoViableAltException = __commonJS({
  "node_modules/antlr4ts/LexerNoViableAltException.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerNoViableAltException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var Utils = require_Utils();
    var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
      constructor(lexer, input, startIndex, deadEndConfigs) {
        super(lexer, input);
        this._startIndex = startIndex;
        this._deadEndConfigs = deadEndConfigs;
      }
      get startIndex() {
        return this._startIndex;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
      get inputStream() {
        return super.inputStream;
      }
      toString() {
        let symbol = "";
        if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
          symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
          symbol = Utils.escapeWhitespace(symbol, false);
        }
        return `LexerNoViableAltException('${symbol}')`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], LexerNoViableAltException.prototype, "toString", null);
    LexerNoViableAltException = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerNoViableAltException);
    exports2.LexerNoViableAltException = LexerNoViableAltException;
  }
});

// node_modules/antlr4ts/atn/OrderedATNConfigSet.js
var require_OrderedATNConfigSet = __commonJS({
  "node_modules/antlr4ts/atn/OrderedATNConfigSet.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OrderedATNConfigSet = void 0;
    var ATNConfigSet_1 = require_ATNConfigSet();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet = class _OrderedATNConfigSet extends ATNConfigSet_1.ATNConfigSet {
      constructor(set2, readonly) {
        if (set2 != null && readonly != null) {
          super(set2, readonly);
        } else {
          super();
        }
      }
      clone(readonly) {
        let copy = new _OrderedATNConfigSet(this, readonly);
        if (!readonly && this.isReadOnly) {
          copy.addAll(this);
        }
        return copy;
      }
      getKey(e) {
        return { state: 0, alt: e.hashCode() };
      }
      canMerge(left, leftKey, right) {
        return left.equals(right);
      }
    };
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "clone", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "getKey", null);
    __decorate([
      Decorators_1.Override
    ], OrderedATNConfigSet.prototype, "canMerge", null);
    exports2.OrderedATNConfigSet = OrderedATNConfigSet;
  }
});

// node_modules/antlr4ts/atn/RuleStopState.js
var require_RuleStopState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStopState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleStopState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStopState = class extends ATNState_1.ATNState {
      get nonStopStateNumber() {
        return -1;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_STOP;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "nonStopStateNumber", null);
    __decorate([
      Decorators_1.Override
    ], RuleStopState.prototype, "stateType", null);
    exports2.RuleStopState = RuleStopState;
  }
});

// node_modules/antlr4ts/atn/LexerATNSimulator.js
var require_LexerATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/LexerATNSimulator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var DFAState_1 = require_DFAState();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Lexer_1 = require_Lexer();
    var LexerActionExecutor_1 = require_LexerActionExecutor();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var Token_1 = require_Token();
    var assert = require("assert");
    var LexerATNSimulator = class LexerATNSimulator2 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, recog) {
        super(atn);
        this.optimize_tail_calls = true;
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
        this.prevAccept = new LexerATNSimulator2.SimState();
        this.recog = recog;
      }
      copyState(simulator) {
        this._charPositionInLine = simulator.charPositionInLine;
        this._line = simulator._line;
        this.mode = simulator.mode;
        this.startIndex = simulator.startIndex;
      }
      match(input, mode) {
        this.mode = mode;
        let mark = input.mark();
        try {
          this.startIndex = input.index;
          this.prevAccept.reset();
          let s0 = this.atn.modeToDFA[mode].s0;
          if (s0 == null) {
            return this.matchATN(input);
          } else {
            return this.execATN(input, s0);
          }
        } finally {
          input.release(mark);
        }
      }
      reset() {
        this.prevAccept.reset();
        this.startIndex = -1;
        this._line = 1;
        this._charPositionInLine = 0;
        this.mode = Lexer_1.Lexer.DEFAULT_MODE;
      }
      matchATN(input) {
        let startState = this.atn.modeToStartState[this.mode];
        if (LexerATNSimulator2.debug) {
          console.log(`matchATN mode ${this.mode} start: ${startState}`);
        }
        let old_mode = this.mode;
        let s0_closure = this.computeStartState(input, startState);
        let suppressEdge = s0_closure.hasSemanticContext;
        if (suppressEdge) {
          s0_closure.hasSemanticContext = false;
        }
        let next = this.addDFAState(s0_closure);
        if (!suppressEdge) {
          let dfa = this.atn.modeToDFA[this.mode];
          if (!dfa.s0) {
            dfa.s0 = next;
          } else {
            next = dfa.s0;
          }
        }
        let predict = this.execATN(input, next);
        if (LexerATNSimulator2.debug) {
          console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
        }
        return predict;
      }
      execATN(input, ds0) {
        if (LexerATNSimulator2.debug) {
          console.log(`start state closure=${ds0.configs}`);
        }
        if (ds0.isAcceptState) {
          this.captureSimState(this.prevAccept, input, ds0);
        }
        let t = input.LA(1);
        let s = ds0;
        while (true) {
          if (LexerATNSimulator2.debug) {
            console.log(`execATN loop starting closure: ${s.configs}`);
          }
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            target = this.computeTargetState(input, s, t);
          }
          if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            break;
          }
          if (t !== IntStream_1.IntStream.EOF) {
            this.consume(input);
          }
          if (target.isAcceptState) {
            this.captureSimState(this.prevAccept, input, target);
            if (t === IntStream_1.IntStream.EOF) {
              break;
            }
          }
          t = input.LA(1);
          s = target;
        }
        return this.failOrAccept(this.prevAccept, input, s.configs, t);
      }
      /**
       * Get an existing target state for an edge in the DFA. If the target state
       * for the edge has not yet been computed or is otherwise not available,
       * this method returns `undefined`.
       *
       * @param s The current DFA state
       * @param t The next input symbol
       * @returns The existing target DFA state for the given input symbol
       * `t`, or `undefined` if the target state for this edge is not
       * already cached
       */
      getExistingTargetState(s, t) {
        let target = s.getTarget(t);
        if (LexerATNSimulator2.debug && target != null) {
          console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
        }
        return target;
      }
      /**
       * Compute a target state for an edge in the DFA, and attempt to add the
       * computed state and corresponding edge to the DFA.
       *
       * @param input The input stream
       * @param s The current DFA state
       * @param t The next input symbol
       *
       * @returns The computed target DFA state for the given input symbol
       * `t`. If `t` does not lead to a valid DFA state, this method
       * returns {@link #ERROR}.
       */
      computeTargetState(input, s, t) {
        let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        this.getReachableConfigSet(input, s.configs, reach, t);
        if (reach.isEmpty) {
          if (!reach.hasSemanticContext) {
            this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          }
          return ATNSimulator_1.ATNSimulator.ERROR;
        }
        return this.addDFAEdge(s, t, reach);
      }
      failOrAccept(prevAccept, input, reach, t) {
        if (prevAccept.dfaState != null) {
          let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
          this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
          return prevAccept.dfaState.prediction;
        } else {
          if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
            return Token_1.Token.EOF;
          }
          throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
        }
      }
      /** Given a starting configuration set, figure out all ATN configurations
       *  we can reach upon input `t`. Parameter `reach` is a return
       *  parameter.
       */
      getReachableConfigSet(input, closure, reach, t) {
        let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c3 of closure) {
          let currentAltReachedAcceptState = c3.alt === skipAlt;
          if (currentAltReachedAcceptState && c3.hasPassedThroughNonGreedyDecision) {
            continue;
          }
          if (LexerATNSimulator2.debug) {
            console.log(`testing ${this.getTokenName(t)} at ${c3.toString(this.recog, true)}`);
          }
          let n2 = c3.state.numberOfOptimizedTransitions;
          for (let ti = 0; ti < n2; ti++) {
            let trans = c3.state.getOptimizedTransition(ti);
            let target = this.getReachableTarget(trans, t);
            if (target != null) {
              let lexerActionExecutor = c3.lexerActionExecutor;
              let config2;
              if (lexerActionExecutor != null) {
                lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                config2 = c3.transform(target, true, lexerActionExecutor);
              } else {
                assert(c3.lexerActionExecutor == null);
                config2 = c3.transform(target, true);
              }
              let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
              if (this.closure(input, config2, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                skipAlt = c3.alt;
                break;
              }
            }
          }
        }
      }
      accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
        if (LexerATNSimulator2.debug) {
          console.log(`ACTION ${lexerActionExecutor}`);
        }
        input.seek(index);
        this._line = line;
        this._charPositionInLine = charPos;
        if (lexerActionExecutor != null && this.recog != null) {
          lexerActionExecutor.execute(this.recog, input, startIndex);
        }
      }
      getReachableTarget(trans, t) {
        if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
          return trans.target;
        }
        return void 0;
      }
      computeStartState(input, p) {
        let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
        let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
        for (let i2 = 0; i2 < p.numberOfTransitions; i2++) {
          let target = p.transition(i2).target;
          let c3 = ATNConfig_1.ATNConfig.create(target, i2 + 1, initialContext);
          this.closure(input, c3, configs, false, false, false);
        }
        return configs;
      }
      /**
       * Since the alternatives within any lexer decision are ordered by
       * preference, this method stops pursuing the closure as soon as an accept
       * state is reached. After the first accept state is reached by depth-first
       * search from `config`, all other (potentially reachable) states for
       * this rule would have a lower priority.
       *
       * @returns `true` if an accept state is reached, otherwise
       * `false`.
       */
      closure(input, config2, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
        if (LexerATNSimulator2.debug) {
          console.log("closure(" + config2.toString(this.recog, true) + ")");
        }
        if (config2.state instanceof RuleStopState_1.RuleStopState) {
          if (LexerATNSimulator2.debug) {
            if (this.recog != null) {
              console.log(`closure at ${this.recog.ruleNames[config2.state.ruleIndex]} rule stop ${config2}`);
            } else {
              console.log(`closure at rule stop ${config2}`);
            }
          }
          let context = config2.context;
          if (context.isEmpty) {
            configs.add(config2);
            return true;
          } else if (context.hasEmpty) {
            configs.add(config2.transform(config2.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
            currentAltReachedAcceptState = true;
          }
          for (let i2 = 0; i2 < context.size; i2++) {
            let returnStateNumber = context.getReturnState(i2);
            if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              continue;
            }
            let newContext = context.getParent(i2);
            let returnState = this.atn.states[returnStateNumber];
            let c3 = config2.transform(returnState, false, newContext);
            currentAltReachedAcceptState = this.closure(input, c3, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
          return currentAltReachedAcceptState;
        }
        if (!config2.state.onlyHasEpsilonTransitions) {
          if (!currentAltReachedAcceptState || !config2.hasPassedThroughNonGreedyDecision) {
            configs.add(config2);
          }
        }
        let p = config2.state;
        for (let i2 = 0; i2 < p.numberOfOptimizedTransitions; i2++) {
          let t = p.getOptimizedTransition(i2);
          let c3 = this.getEpsilonTarget(input, config2, t, configs, speculative, treatEofAsEpsilon);
          if (c3 != null) {
            currentAltReachedAcceptState = this.closure(input, c3, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
        }
        return currentAltReachedAcceptState;
      }
      // side-effect: can alter configs.hasSemanticContext
      getEpsilonTarget(input, config2, t, configs, speculative, treatEofAsEpsilon) {
        let c3;
        switch (t.serializationType) {
          case 3:
            let ruleTransition = t;
            if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config2.context.hasEmpty) {
              c3 = config2.transform(t.target, true);
            } else {
              let newContext = config2.context.getChild(ruleTransition.followState.stateNumber);
              c3 = config2.transform(t.target, true, newContext);
            }
            break;
          case 10:
            throw new Error("Precedence predicates are not supported in lexers.");
          case 4:
            let pt = t;
            if (LexerATNSimulator2.debug) {
              console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
            }
            configs.hasSemanticContext = true;
            if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
              c3 = config2.transform(t.target, true);
            } else {
              c3 = void 0;
            }
            break;
          case 6:
            if (config2.context.hasEmpty) {
              let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config2.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
              c3 = config2.transform(t.target, true, lexerActionExecutor);
              break;
            } else {
              c3 = config2.transform(t.target, true);
              break;
            }
          case 1:
            c3 = config2.transform(t.target, true);
            break;
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                c3 = config2.transform(t.target, false);
                break;
              }
            }
            c3 = void 0;
            break;
          default:
            c3 = void 0;
            break;
        }
        return c3;
      }
      /**
       * Evaluate a predicate specified in the lexer.
       *
       * If `speculative` is `true`, this method was called before
       * {@link #consume} for the matched character. This method should call
       * {@link #consume} before evaluating the predicate to ensure position
       * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},
       * and {@link Lexer#getCharPositionInLine}, properly reflect the current
       * lexer state. This method should restore `input` and the simulator
       * to the original state before returning (i.e. undo the actions made by the
       * call to {@link #consume}.
       *
       * @param input The input stream.
       * @param ruleIndex The rule containing the predicate.
       * @param predIndex The index of the predicate within the rule.
       * @param speculative `true` if the current index in `input` is
       * one character before the predicate's location.
       *
       * @returns `true` if the specified predicate evaluates to
       * `true`.
       */
      evaluatePredicate(input, ruleIndex, predIndex, speculative) {
        if (this.recog == null) {
          return true;
        }
        if (!speculative) {
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        }
        let savedCharPositionInLine = this._charPositionInLine;
        let savedLine = this._line;
        let index = input.index;
        let marker = input.mark();
        try {
          this.consume(input);
          return this.recog.sempred(void 0, ruleIndex, predIndex);
        } finally {
          this._charPositionInLine = savedCharPositionInLine;
          this._line = savedLine;
          input.seek(index);
          input.release(marker);
        }
      }
      captureSimState(settings, input, dfaState) {
        settings.index = input.index;
        settings.line = this._line;
        settings.charPos = this._charPositionInLine;
        settings.dfaState = dfaState;
      }
      addDFAEdge(p, t, q) {
        if (q instanceof ATNConfigSet_1.ATNConfigSet) {
          let suppressEdge = q.hasSemanticContext;
          if (suppressEdge) {
            q.hasSemanticContext = false;
          }
          let to = this.addDFAState(q);
          if (suppressEdge) {
            return to;
          }
          this.addDFAEdge(p, t, to);
          return to;
        } else {
          if (LexerATNSimulator2.debug) {
            console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
          }
          if (p != null) {
            p.setTarget(t, q);
          }
        }
      }
      /** Add a new DFA state if there isn't one with this set of
       * 	configurations already. This method also detects the first
       * 	configuration containing an ATN rule stop state. Later, when
       * 	traversing the DFA, we will know which rule to accept.
       */
      addDFAState(configs) {
        assert(!configs.hasSemanticContext);
        let proposed = new DFAState_1.DFAState(configs);
        let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
        if (existing != null) {
          return existing;
        }
        configs.optimizeConfigs(this);
        let newState = new DFAState_1.DFAState(configs.clone(true));
        let firstConfigWithRuleStopState;
        for (let c3 of configs) {
          if (c3.state instanceof RuleStopState_1.RuleStopState) {
            firstConfigWithRuleStopState = c3;
            break;
          }
        }
        if (firstConfigWithRuleStopState != null) {
          let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
          let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
        }
        return this.atn.modeToDFA[this.mode].addState(newState);
      }
      getDFA(mode) {
        return this.atn.modeToDFA[mode];
      }
      /** Get the text matched so far for the current token.
       */
      getText(input) {
        return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
      }
      get line() {
        return this._line;
      }
      set line(line) {
        this._line = line;
      }
      get charPositionInLine() {
        return this._charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this._charPositionInLine = charPositionInLine;
      }
      consume(input) {
        let curChar = input.LA(1);
        if (curChar === "\n".charCodeAt(0)) {
          this._line++;
          this._charPositionInLine = 0;
        } else {
          this._charPositionInLine++;
        }
        input.consume();
      }
      getTokenName(t) {
        if (t === -1) {
          return "EOF";
        }
        return "'" + String.fromCharCode(t) + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator.prototype, "prevAccept", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "copyState", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "match", null);
    __decorate([
      Decorators_1.Override
    ], LexerATNSimulator.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "matchATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "getReachableConfigSet", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "accept", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "computeStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "getEpsilonTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "evaluatePredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "captureSimState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator.prototype, "getDFA", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "getText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator.prototype, "consume", null);
    __decorate([
      Decorators_1.NotNull
    ], LexerATNSimulator.prototype, "getTokenName", null);
    LexerATNSimulator = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LexerATNSimulator);
    exports2.LexerATNSimulator = LexerATNSimulator;
    (function(LexerATNSimulator2) {
      LexerATNSimulator2.debug = false;
      LexerATNSimulator2.dfa_debug = false;
      class SimState {
        constructor() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
        }
        reset() {
          this.index = -1;
          this.line = 0;
          this.charPos = -1;
          this.dfaState = void 0;
        }
      }
      LexerATNSimulator2.SimState = SimState;
    })(LexerATNSimulator = exports2.LexerATNSimulator || (exports2.LexerATNSimulator = {}));
    exports2.LexerATNSimulator = LexerATNSimulator;
  }
});

// node_modules/antlr4ts/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/antlr4ts/Lexer.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Lexer = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var IntegerStack_1 = require_IntegerStack();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var Decorators_1 = require_Decorators();
    var Recognizer_1 = require_Recognizer();
    var Token_1 = require_Token();
    var Lexer = class _Lexer extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        this._tokenStartCharIndex = -1;
        this._tokenStartLine = 0;
        this._tokenStartCharPositionInLine = 0;
        this._hitEOF = false;
        this._channel = 0;
        this._type = 0;
        this._modeStack = new IntegerStack_1.IntegerStack();
        this._mode = _Lexer.DEFAULT_MODE;
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: input };
      }
      static get DEFAULT_TOKEN_CHANNEL() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      static get HIDDEN() {
        return Token_1.Token.HIDDEN_CHANNEL;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this._input.seek(0);
        }
        this._token = void 0;
        this._type = Token_1.Token.INVALID_TYPE;
        this._channel = Token_1.Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = -1;
        this._tokenStartCharPositionInLine = -1;
        this._tokenStartLine = -1;
        this._text = void 0;
        this._hitEOF = false;
        this._mode = _Lexer.DEFAULT_MODE;
        this._modeStack.clear();
        this.interpreter.reset();
      }
      /** Return a token from this source; i.e., match a token on the char
       *  stream.
       */
      nextToken() {
        if (this._input == null) {
          throw new Error("nextToken requires a non-null input stream.");
        }
        let tokenStartMarker = this._input.mark();
        try {
          outer: while (true) {
            if (this._hitEOF) {
              return this.emitEOF();
            }
            this._token = void 0;
            this._channel = Token_1.Token.DEFAULT_CHANNEL;
            this._tokenStartCharIndex = this._input.index;
            this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
            this._tokenStartLine = this.interpreter.line;
            this._text = void 0;
            do {
              this._type = Token_1.Token.INVALID_TYPE;
              let ttype;
              try {
                ttype = this.interpreter.match(this._input, this._mode);
              } catch (e) {
                if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                  this.notifyListeners(e);
                  this.recover(e);
                  ttype = _Lexer.SKIP;
                } else {
                  throw e;
                }
              }
              if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                this._hitEOF = true;
              }
              if (this._type === Token_1.Token.INVALID_TYPE) {
                this._type = ttype;
              }
              if (this._type === _Lexer.SKIP) {
                continue outer;
              }
            } while (this._type === _Lexer.MORE);
            if (this._token == null) {
              return this.emit();
            }
            return this._token;
          }
        } finally {
          this._input.release(tokenStartMarker);
        }
      }
      /** Instruct the lexer to skip creating a token for current lexer rule
       *  and look for another token.  nextToken() knows to keep looking when
       *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
       *  if token==undefined at end of any token rule, it creates one for you
       *  and emits it.
       */
      skip() {
        this._type = _Lexer.SKIP;
      }
      more() {
        this._type = _Lexer.MORE;
      }
      mode(m) {
        this._mode = m;
      }
      pushMode(m) {
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("pushMode " + m);
        }
        this._modeStack.push(this._mode);
        this.mode(m);
      }
      popMode() {
        if (this._modeStack.isEmpty) {
          throw new Error("EmptyStackException");
        }
        if (LexerATNSimulator_1.LexerATNSimulator.debug) {
          console.log("popMode back to " + this._modeStack.peek());
        }
        this.mode(this._modeStack.pop());
        return this._mode;
      }
      get tokenFactory() {
        return this._factory;
      }
      // @Override
      set tokenFactory(factory2) {
        this._factory = factory2;
      }
      get inputStream() {
        return this._input;
      }
      /** Set the char stream and reset the lexer */
      set inputStream(input) {
        this.reset(false);
        this._input = input;
        this._tokenFactorySourcePair = { source: this, stream: this._input };
      }
      get sourceName() {
        return this._input.sourceName;
      }
      emit(token) {
        if (!token) {
          token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
        }
        this._token = token;
        return token;
      }
      emitEOF() {
        let cpos = this.charPositionInLine;
        let line = this.line;
        let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
        this.emit(eof);
        return eof;
      }
      get line() {
        return this.interpreter.line;
      }
      set line(line) {
        this.interpreter.line = line;
      }
      get charPositionInLine() {
        return this.interpreter.charPositionInLine;
      }
      set charPositionInLine(charPositionInLine) {
        this.interpreter.charPositionInLine = charPositionInLine;
      }
      /** What is the index of the current character of lookahead? */
      get charIndex() {
        return this._input.index;
      }
      /** Return the text matched so far for the current token or any
       *  text override.
       */
      get text() {
        if (this._text != null) {
          return this._text;
        }
        return this.interpreter.getText(this._input);
      }
      /** Set the complete text of this token; it wipes any previous
       *  changes to the text.
       */
      set text(text2) {
        this._text = text2;
      }
      /** Override if emitting multiple tokens. */
      get token() {
        return this._token;
      }
      set token(_token) {
        this._token = _token;
      }
      set type(ttype) {
        this._type = ttype;
      }
      get type() {
        return this._type;
      }
      set channel(channel) {
        this._channel = channel;
      }
      get channel() {
        return this._channel;
      }
      /** Return a list of all Token objects in input char stream.
       *  Forces load of all tokens. Does not include EOF token.
       */
      getAllTokens() {
        let tokens = [];
        let t = this.nextToken();
        while (t.type !== Token_1.Token.EOF) {
          tokens.push(t);
          t = this.nextToken();
        }
        return tokens;
      }
      notifyListeners(e) {
        let text2 = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
        let msg = "token recognition error at: '" + this.getErrorDisplay(text2) + "'";
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
        }
      }
      getErrorDisplay(s) {
        if (typeof s === "number") {
          switch (s) {
            case Token_1.Token.EOF:
              return "<EOF>";
            case 10:
              return "\\n";
            case 9:
              return "\\t";
            case 13:
              return "\\r";
          }
          return String.fromCharCode(s);
        }
        return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
      }
      getCharErrorDisplay(c3) {
        let s = this.getErrorDisplay(c3);
        return "'" + s + "'";
      }
      recover(re) {
        if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
          if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
            this.interpreter.consume(this._input);
          }
        } else {
          this._input.consume();
        }
      }
    };
    Lexer.DEFAULT_MODE = 0;
    Lexer.MORE = -2;
    Lexer.SKIP = -3;
    Lexer.MIN_CHAR_VALUE = 0;
    Lexer.MAX_CHAR_VALUE = 1114111;
    __decorate([
      Decorators_1.Override
    ], Lexer.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], Lexer.prototype, "tokenFactory", null);
    __decorate([
      Decorators_1.Override
    ], Lexer.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], Lexer.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], Lexer.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], Lexer.prototype, "charPositionInLine", null);
    exports2.Lexer = Lexer;
  }
});

// node_modules/antlr4ts/misc/IntervalSet.js
var require_IntervalSet = __commonJS({
  "node_modules/antlr4ts/misc/IntervalSet.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IntervalSet = void 0;
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var IntervalSet = class _IntervalSet {
      constructor(intervals) {
        this.readonly = false;
        if (intervals != null) {
          this._intervals = intervals.slice(0);
        } else {
          this._intervals = [];
        }
      }
      static get COMPLETE_CHAR_SET() {
        if (_IntervalSet._COMPLETE_CHAR_SET === void 0) {
          _IntervalSet._COMPLETE_CHAR_SET = _IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
          _IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
        }
        return _IntervalSet._COMPLETE_CHAR_SET;
      }
      static get EMPTY_SET() {
        if (_IntervalSet._EMPTY_SET == null) {
          _IntervalSet._EMPTY_SET = new _IntervalSet();
          _IntervalSet._EMPTY_SET.setReadonly(true);
        }
        return _IntervalSet._EMPTY_SET;
      }
      /**
       * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element
       * a.
       */
      static of(a2, b = a2) {
        let s = new _IntervalSet();
        s.add(a2, b);
        return s;
      }
      clear() {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this._intervals.length = 0;
      }
      /** Add interval; i.e., add all integers from a to b to set.
       *  If b&lt;a, do nothing.
       *  Keep list in sorted order (by left range value).
       *  If overlap, combine ranges.  For example,
       *  If this is {1..5, 10..20}, adding 6..7 yields
       *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
       */
      add(a2, b = a2) {
        this.addRange(Interval_1.Interval.of(a2, b));
      }
      // copy on write so we can cache a..a intervals and sets of that
      addRange(addition) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        if (addition.b < addition.a) {
          return;
        }
        for (let i2 = 0; i2 < this._intervals.length; i2++) {
          let r = this._intervals[i2];
          if (addition.equals(r)) {
            return;
          }
          if (addition.adjacent(r) || !addition.disjoint(r)) {
            let bigger = addition.union(r);
            this._intervals[i2] = bigger;
            while (i2 < this._intervals.length - 1) {
              i2++;
              let next = this._intervals[i2];
              if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                break;
              }
              this._intervals.splice(i2, 1);
              i2--;
              this._intervals[i2] = bigger.union(next);
            }
            return;
          }
          if (addition.startsBeforeDisjoint(r)) {
            this._intervals.splice(i2, 0, addition);
            return;
          }
        }
        this._intervals.push(addition);
      }
      /** combine all sets in the array returned the or'd value */
      static or(sets) {
        let r = new _IntervalSet();
        for (let s of sets) {
          r.addAll(s);
        }
        return r;
      }
      addAll(set2) {
        if (set2 == null) {
          return this;
        }
        if (set2 instanceof _IntervalSet) {
          let other = set2;
          let n2 = other._intervals.length;
          for (let i2 = 0; i2 < n2; i2++) {
            let I = other._intervals[i2];
            this.add(I.a, I.b);
          }
        } else {
          for (let value of set2.toArray()) {
            this.add(value);
          }
        }
        return this;
      }
      complementRange(minElement, maxElement) {
        return this.complement(_IntervalSet.of(minElement, maxElement));
      }
      /** {@inheritDoc} */
      complement(vocabulary) {
        if (vocabulary.isNil) {
          return _IntervalSet.EMPTY_SET;
        }
        let vocabularyIS;
        if (vocabulary instanceof _IntervalSet) {
          vocabularyIS = vocabulary;
        } else {
          vocabularyIS = new _IntervalSet();
          vocabularyIS.addAll(vocabulary);
        }
        return vocabularyIS.subtract(this);
      }
      subtract(a2) {
        if (a2 == null || a2.isNil) {
          return new _IntervalSet(this._intervals);
        }
        if (a2 instanceof _IntervalSet) {
          return _IntervalSet.subtract(this, a2);
        }
        let other = new _IntervalSet();
        other.addAll(a2);
        return _IntervalSet.subtract(this, other);
      }
      /**
       * Compute the set difference between two interval sets. The specific
       * operation is `left - right`.
       */
      static subtract(left, right) {
        if (left.isNil) {
          return new _IntervalSet();
        }
        let result = new _IntervalSet(left._intervals);
        if (right.isNil) {
          return result;
        }
        let resultI = 0;
        let rightI = 0;
        while (resultI < result._intervals.length && rightI < right._intervals.length) {
          let resultInterval = result._intervals[resultI];
          let rightInterval = right._intervals[rightI];
          if (rightInterval.b < resultInterval.a) {
            rightI++;
            continue;
          }
          if (rightInterval.a > resultInterval.b) {
            resultI++;
            continue;
          }
          let beforeCurrent;
          let afterCurrent;
          if (rightInterval.a > resultInterval.a) {
            beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
          }
          if (rightInterval.b < resultInterval.b) {
            afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
          }
          if (beforeCurrent) {
            if (afterCurrent) {
              result._intervals[resultI] = beforeCurrent;
              result._intervals.splice(resultI + 1, 0, afterCurrent);
              resultI++;
              rightI++;
              continue;
            } else {
              result._intervals[resultI] = beforeCurrent;
              resultI++;
              continue;
            }
          } else {
            if (afterCurrent) {
              result._intervals[resultI] = afterCurrent;
              rightI++;
              continue;
            } else {
              result._intervals.splice(resultI, 1);
              continue;
            }
          }
        }
        return result;
      }
      or(a2) {
        let o2 = new _IntervalSet();
        o2.addAll(this);
        o2.addAll(a2);
        return o2;
      }
      /** {@inheritDoc} */
      and(other) {
        if (other.isNil) {
          return new _IntervalSet();
        }
        let myIntervals = this._intervals;
        let theirIntervals = other._intervals;
        let intersection;
        let mySize = myIntervals.length;
        let theirSize = theirIntervals.length;
        let i2 = 0;
        let j = 0;
        while (i2 < mySize && j < theirSize) {
          let mine = myIntervals[i2];
          let theirs = theirIntervals[j];
          if (mine.startsBeforeDisjoint(theirs)) {
            i2++;
          } else if (theirs.startsBeforeDisjoint(mine)) {
            j++;
          } else if (mine.properlyContains(theirs)) {
            if (!intersection) {
              intersection = new _IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            j++;
          } else if (theirs.properlyContains(mine)) {
            if (!intersection) {
              intersection = new _IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            i2++;
          } else if (!mine.disjoint(theirs)) {
            if (!intersection) {
              intersection = new _IntervalSet();
            }
            intersection.addRange(mine.intersection(theirs));
            if (mine.startsAfterNonDisjoint(theirs)) {
              j++;
            } else if (theirs.startsAfterNonDisjoint(mine)) {
              i2++;
            }
          }
        }
        if (!intersection) {
          return new _IntervalSet();
        }
        return intersection;
      }
      /** {@inheritDoc} */
      contains(el) {
        let n2 = this._intervals.length;
        let l = 0;
        let r = n2 - 1;
        while (l <= r) {
          let m = l + r >> 1;
          let I = this._intervals[m];
          let a2 = I.a;
          let b = I.b;
          if (b < el) {
            l = m + 1;
          } else if (a2 > el) {
            r = m - 1;
          } else {
            return true;
          }
        }
        return false;
      }
      /** {@inheritDoc} */
      get isNil() {
        return this._intervals == null || this._intervals.length === 0;
      }
      /**
       * Returns the maximum value contained in the set if not isNil.
       *
       * @return the maximum value contained in the set.
       * @throws RangeError if set is empty
       */
      get maxElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        let last = this._intervals[this._intervals.length - 1];
        return last.b;
      }
      /**
       * Returns the minimum value contained in the set if not isNil.
       *
       * @return the minimum value contained in the set.
       * @throws RangeError if set is empty
       */
      get minElement() {
        if (this.isNil) {
          throw new RangeError("set is empty");
        }
        return this._intervals[0].a;
      }
      /** Return a list of Interval objects. */
      get intervals() {
        return this._intervals;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let I of this._intervals) {
          hash = MurmurHash_1.MurmurHash.update(hash, I.a);
          hash = MurmurHash_1.MurmurHash.update(hash, I.b);
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
        return hash;
      }
      /** Are two IntervalSets equal?  Because all intervals are sorted
       *  and disjoint, equals is a simple linear walk over both lists
       *  to make sure they are the same.  Interval.equals() is used
       *  by the List.equals() method to check the ranges.
       */
      equals(o2) {
        if (o2 == null || !(o2 instanceof _IntervalSet)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o2._intervals);
      }
      toString(elemAreChar = false) {
        let buf = "";
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a2 = I.a;
          let b = I.b;
          if (a2 === b) {
            if (a2 === Token_1.Token.EOF) {
              buf += "<EOF>";
            } else if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a2) + "'";
            } else {
              buf += a2;
            }
          } else {
            if (elemAreChar) {
              buf += "'" + String.fromCodePoint(a2) + "'..'" + String.fromCodePoint(b) + "'";
            } else {
              buf += a2 + ".." + b;
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      toStringVocabulary(vocabulary) {
        if (this._intervals == null || this._intervals.length === 0) {
          return "{}";
        }
        let buf = "";
        if (this.size > 1) {
          buf += "{";
        }
        let first = true;
        for (let I of this._intervals) {
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          let a2 = I.a;
          let b = I.b;
          if (a2 === b) {
            buf += this.elementName(vocabulary, a2);
          } else {
            for (let i2 = a2; i2 <= b; i2++) {
              if (i2 > a2) {
                buf += ", ";
              }
              buf += this.elementName(vocabulary, i2);
            }
          }
        }
        if (this.size > 1) {
          buf += "}";
        }
        return buf;
      }
      elementName(vocabulary, a2) {
        if (a2 === Token_1.Token.EOF) {
          return "<EOF>";
        } else if (a2 === Token_1.Token.EPSILON) {
          return "<EPSILON>";
        } else {
          return vocabulary.getDisplayName(a2);
        }
      }
      get size() {
        let n2 = 0;
        let numIntervals = this._intervals.length;
        if (numIntervals === 1) {
          let firstInterval = this._intervals[0];
          return firstInterval.b - firstInterval.a + 1;
        }
        for (let i2 = 0; i2 < numIntervals; i2++) {
          let I = this._intervals[i2];
          n2 += I.b - I.a + 1;
        }
        return n2;
      }
      toIntegerList() {
        let values = new IntegerList_1.IntegerList(this.size);
        let n2 = this._intervals.length;
        for (let i2 = 0; i2 < n2; i2++) {
          let I = this._intervals[i2];
          let a2 = I.a;
          let b = I.b;
          for (let v = a2; v <= b; v++) {
            values.add(v);
          }
        }
        return values;
      }
      toSet() {
        let s = /* @__PURE__ */ new Set();
        for (let I of this._intervals) {
          let a2 = I.a;
          let b = I.b;
          for (let v = a2; v <= b; v++) {
            s.add(v);
          }
        }
        return s;
      }
      toArray() {
        let values = new Array();
        let n2 = this._intervals.length;
        for (let i2 = 0; i2 < n2; i2++) {
          let I = this._intervals[i2];
          let a2 = I.a;
          let b = I.b;
          for (let v = a2; v <= b; v++) {
            values.push(v);
          }
        }
        return values;
      }
      remove(el) {
        if (this.readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        let n2 = this._intervals.length;
        for (let i2 = 0; i2 < n2; i2++) {
          let I = this._intervals[i2];
          let a2 = I.a;
          let b = I.b;
          if (el < a2) {
            break;
          }
          if (el === a2 && el === b) {
            this._intervals.splice(i2, 1);
            break;
          }
          if (el === a2) {
            this._intervals[i2] = Interval_1.Interval.of(I.a + 1, I.b);
            break;
          }
          if (el === b) {
            this._intervals[i2] = Interval_1.Interval.of(I.a, I.b - 1);
            break;
          }
          if (el > a2 && el < b) {
            let oldb = I.b;
            this._intervals[i2] = Interval_1.Interval.of(I.a, el - 1);
            this.add(el + 1, oldb);
          }
        }
      }
      get isReadonly() {
        return this.readonly;
      }
      setReadonly(readonly) {
        if (this.readonly && !readonly) {
          throw new Error("can't alter readonly IntervalSet");
        }
        this.readonly = readonly;
      }
    };
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "complement", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "subtract", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "or", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "and", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "contains", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "isNil", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "equals", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "toStringVocabulary", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], IntervalSet.prototype, "elementName", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], IntervalSet.prototype, "remove", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "of", null);
    __decorate([
      Decorators_1.NotNull
    ], IntervalSet, "subtract", null);
    exports2.IntervalSet = IntervalSet;
  }
});

// node_modules/antlr4ts/atn/BasicState.js
var require_BasicState = __commonJS({
  "node_modules/antlr4ts/atn/BasicState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BasicState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BASIC;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicState.prototype, "stateType", null);
    exports2.BasicState = BasicState;
  }
});

// node_modules/antlr4ts/atn/InvalidState.js
var require_InvalidState = __commonJS({
  "node_modules/antlr4ts/atn/InvalidState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InvalidState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BasicState_1 = require_BasicState();
    var Decorators_1 = require_Decorators();
    var InvalidState = class extends BasicState_1.BasicState {
      get stateType() {
        return ATNStateType_1.ATNStateType.INVALID_TYPE;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InvalidState.prototype, "stateType", null);
    exports2.InvalidState = InvalidState;
  }
});

// node_modules/antlr4ts/atn/AbstractPredicateTransition.js
var require_AbstractPredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/AbstractPredicateTransition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractPredicateTransition = void 0;
    var Transition_1 = require_Transition();
    var AbstractPredicateTransition = class extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
    };
    exports2.AbstractPredicateTransition = AbstractPredicateTransition;
  }
});

// node_modules/antlr4ts/atn/SetTransition.js
var require_SetTransition = __commonJS({
  "node_modules/antlr4ts/atn/SetTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var Transition_1 = require_Transition();
    var SetTransition = class SetTransition extends Transition_1.Transition {
      // TODO (sam): should we really allow undefined here?
      constructor(target, set2) {
        super(target);
        if (set2 == null) {
          set2 = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
        }
        this.set = set2;
      }
      get serializationType() {
        return 7;
      }
      get label() {
        return this.set;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.set.contains(symbol);
      }
      toString() {
        return this.set.toString();
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], SetTransition.prototype, "set", void 0);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], SetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], SetTransition.prototype, "toString", null);
    SetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], SetTransition);
    exports2.SetTransition = SetTransition;
  }
});

// node_modules/antlr4ts/atn/NotSetTransition.js
var require_NotSetTransition = __commonJS({
  "node_modules/antlr4ts/atn/NotSetTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotSetTransition = void 0;
    var Decorators_1 = require_Decorators();
    var SetTransition_1 = require_SetTransition();
    var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
      constructor(target, set2) {
        super(target, set2);
      }
      get serializationType() {
        return 8;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
      }
      toString() {
        return "~" + super.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], NotSetTransition.prototype, "toString", null);
    NotSetTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.Nullable)
    ], NotSetTransition);
    exports2.NotSetTransition = NotSetTransition;
  }
});

// node_modules/antlr4ts/atn/RuleTransition.js
var require_RuleTransition = __commonJS({
  "node_modules/antlr4ts/atn/RuleTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RuleTransition = class RuleTransition extends Transition_1.Transition {
      constructor(ruleStart, ruleIndex, precedence, followState) {
        super(ruleStart);
        this.tailCall = false;
        this.optimizedTailCall = false;
        this.ruleIndex = ruleIndex;
        this.precedence = precedence;
        this.followState = followState;
      }
      get serializationType() {
        return 3;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTransition.prototype, "followState", void 0);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], RuleTransition.prototype, "matches", null);
    RuleTransition = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], RuleTransition);
    exports2.RuleTransition = RuleTransition;
  }
});

// node_modules/antlr4ts/atn/WildcardTransition.js
var require_WildcardTransition = __commonJS({
  "node_modules/antlr4ts/atn/WildcardTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WildcardTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var WildcardTransition = class WildcardTransition extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
      get serializationType() {
        return 9;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
      }
      toString() {
        return ".";
      }
    };
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], WildcardTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], WildcardTransition.prototype, "toString", null);
    WildcardTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], WildcardTransition);
    exports2.WildcardTransition = WildcardTransition;
  }
});

// node_modules/antlr4ts/atn/LL1Analyzer.js
var require_LL1Analyzer = __commonJS({
  "node_modules/antlr4ts/atn/LL1Analyzer.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LL1Analyzer = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATNConfig_1 = require_ATNConfig();
    var BitSet_1 = require_BitSet();
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var Token_1 = require_Token();
    var WildcardTransition_1 = require_WildcardTransition();
    var LL1Analyzer = class LL1Analyzer2 {
      constructor(atn) {
        this.atn = atn;
      }
      /**
       * Calculates the SLL(1) expected lookahead set for each outgoing transition
       * of an {@link ATNState}. The returned array has one element for each
       * outgoing transition in `s`. If the closure from transition
       * *i* leads to a semantic predicate before matching a symbol, the
       * element at index *i* of the result will be `undefined`.
       *
       * @param s the ATN state
       * @returns the expected symbols for each outgoing transition of `s`.
       */
      getDecisionLookahead(s) {
        if (s == null) {
          return void 0;
        }
        let look = new Array(s.numberOfTransitions);
        for (let alt = 0; alt < s.numberOfTransitions; alt++) {
          let current = new IntervalSet_1.IntervalSet();
          look[alt] = current;
          let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          let seeThruPreds = false;
          this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
          if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
            current = void 0;
            look[alt] = current;
          }
        }
        return look;
      }
      LOOK(s, ctx, stopState) {
        if (stopState === void 0) {
          if (s.atn == null) {
            throw new Error("Illegal state");
          }
          stopState = s.atn.ruleToStopState[s.ruleIndex];
        } else if (stopState === null) {
          stopState = void 0;
        }
        let r = new IntervalSet_1.IntervalSet();
        let seeThruPreds = true;
        let addEOF = true;
        this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
        return r;
      }
      /**
       * Compute set of tokens that can follow `s` in the ATN in the
       * specified `ctx`.
       * <p/>
       * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and
       * `stopState` or the end of the rule containing `s` is reached,
       * {@link Token#EPSILON} is added to the result set. If `ctx` is not
       * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`
       * and `stopState` or the end of the outermost rule is reached,
       * {@link Token#EOF} is added to the result set.
       *
       * @param s the ATN state.
       * @param stopState the ATN state to stop at. This can be a
       * {@link BlockEndState} to detect epsilon paths through a closure.
       * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if
       * the outer context should not be used.
       * @param look The result lookahead set.
       * @param lookBusy A set used for preventing epsilon closures in the ATN
       * from causing a stack overflow. Outside code should pass
       * `new HashSet<ATNConfig>` for this argument.
       * @param calledRuleStack A set used for preventing left recursion in the
       * ATN from causing a stack overflow. Outside code should pass
       * `new BitSet()` for this argument.
       * @param seeThruPreds `true` to true semantic predicates as
       * implicitly `true` and "see through them", otherwise `false`
       * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the
       * result if one is encountered.
       * @param addEOF Add {@link Token#EOF} to the result if the end of the
       * outermost context is reached. This parameter has no effect if `ctx`
       * is {@link PredictionContext#EMPTY_LOCAL}.
       */
      _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
        let c3 = ATNConfig_1.ATNConfig.create(s, 0, ctx);
        if (!lookBusy.add(c3)) {
          return;
        }
        if (s === stopState) {
          if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            look.add(Token_1.Token.EPSILON);
            return;
          } else if (ctx.isEmpty) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
        }
        if (s instanceof RuleStopState_1.RuleStopState) {
          if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
            if (addEOF) {
              look.add(Token_1.Token.EOF);
            }
            return;
          }
          let removed = calledRuleStack.get(s.ruleIndex);
          try {
            calledRuleStack.clear(s.ruleIndex);
            for (let i2 = 0; i2 < ctx.size; i2++) {
              if (ctx.getReturnState(i2) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                continue;
              }
              let returnState = this.atn.states[ctx.getReturnState(i2)];
              this._LOOK(returnState, stopState, ctx.getParent(i2), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            }
          } finally {
            if (removed) {
              calledRuleStack.set(s.ruleIndex);
            }
          }
        }
        let n2 = s.numberOfTransitions;
        for (let i2 = 0; i2 < n2; i2++) {
          let t = s.transition(i2);
          if (t instanceof RuleTransition_1.RuleTransition) {
            if (calledRuleStack.get(t.ruleIndex)) {
              continue;
            }
            let newContext = ctx.getChild(t.followState.stateNumber);
            try {
              calledRuleStack.set(t.ruleIndex);
              this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
              calledRuleStack.clear(t.ruleIndex);
            }
          } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
            if (seeThruPreds) {
              this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
              look.add(LL1Analyzer2.HIT_PRED);
            }
          } else if (t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else if (t instanceof WildcardTransition_1.WildcardTransition) {
            look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
          } else {
            let set2 = t.label;
            if (set2 != null) {
              if (t instanceof NotSetTransition_1.NotSetTransition) {
                set2 = set2.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
              }
              look.addAll(set2);
            }
          }
        }
      }
    };
    LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
    __decorate([
      Decorators_1.NotNull
    ], LL1Analyzer.prototype, "atn", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "LOOK", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], LL1Analyzer.prototype, "_LOOK", null);
    LL1Analyzer = __decorate([
      __param(0, Decorators_1.NotNull)
    ], LL1Analyzer);
    exports2.LL1Analyzer = LL1Analyzer;
  }
});

// node_modules/antlr4ts/atn/ATN.js
var require_ATN = __commonJS({
  "node_modules/antlr4ts/atn/ATN.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATN = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var DFA_1 = require_DFA();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LL1Analyzer_1 = require_LL1Analyzer();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var assert = require("assert");
    var ATN = class ATN {
      /** Used for runtime deserialization of ATNs from strings */
      constructor(grammarType, maxTokenType) {
        this.states = [];
        this.decisionToState = [];
        this.modeNameToStartState = /* @__PURE__ */ new Map();
        this.modeToStartState = [];
        this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        this.decisionToDFA = [];
        this.modeToDFA = [];
        this.LL1Table = /* @__PURE__ */ new Map();
        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
      }
      clearDFA() {
        this.decisionToDFA = new Array(this.decisionToState.length);
        for (let i2 = 0; i2 < this.decisionToDFA.length; i2++) {
          this.decisionToDFA[i2] = new DFA_1.DFA(this.decisionToState[i2], i2);
        }
        this.modeToDFA = new Array(this.modeToStartState.length);
        for (let i2 = 0; i2 < this.modeToDFA.length; i2++) {
          this.modeToDFA[i2] = new DFA_1.DFA(this.modeToStartState[i2]);
        }
        this.contextCache.clear();
        this.LL1Table.clear();
      }
      get contextCacheSize() {
        return this.contextCache.size;
      }
      getCachedContext(context) {
        return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
      }
      getDecisionToDFA() {
        assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
        return this.decisionToDFA;
      }
      nextTokens(s, ctx) {
        if (ctx) {
          let anal = new LL1Analyzer_1.LL1Analyzer(this);
          let next = anal.LOOK(s, ctx);
          return next;
        } else {
          if (s.nextTokenWithinRule) {
            return s.nextTokenWithinRule;
          }
          s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          s.nextTokenWithinRule.setReadonly(true);
          return s.nextTokenWithinRule;
        }
      }
      addState(state) {
        state.atn = this;
        state.stateNumber = this.states.length;
        this.states.push(state);
      }
      removeState(state) {
        let invalidState = new InvalidState_1.InvalidState();
        invalidState.atn = this;
        invalidState.stateNumber = state.stateNumber;
        this.states[state.stateNumber] = invalidState;
      }
      defineMode(name, s) {
        this.modeNameToStartState.set(name, s);
        this.modeToStartState.push(s);
        this.modeToDFA.push(new DFA_1.DFA(s));
        this.defineDecisionState(s);
      }
      defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length - 1;
        this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
        return s.decision;
      }
      getDecisionState(decision) {
        if (this.decisionToState.length > 0) {
          return this.decisionToState[decision];
        }
        return void 0;
      }
      get numberOfDecisions() {
        return this.decisionToState.length;
      }
      /**
       * Computes the set of input symbols which could follow ATN state number
       * `stateNumber` in the specified full `context`. This method
       * considers the complete parser context, but does not evaluate semantic
       * predicates (i.e. all predicates encountered during the calculation are
       * assumed true). If a path in the ATN exists from the starting state to the
       * {@link RuleStopState} of the outermost context without matching any
       * symbols, {@link Token#EOF} is added to the returned set.
       *
       * If `context` is `undefined`, it is treated as
       * {@link ParserRuleContext#EMPTY}.
       *
       * Note that this does NOT give you the set of all tokens that could
       * appear at a given token position in the input phrase.  In other words, it
       * does not answer:
       *
       * > Given a specific partial input phrase, return the set of all
       * > tokens that can follow the last token in the input phrase.
       *
       * The big difference is that with just the input, the parser could land
       * right in the middle of a lookahead decision. Getting all
       * *possible* tokens given a partial input stream is a separate
       * computation. See https://github.com/antlr/antlr4/issues/1428
       *
       * For this function, we are specifying an ATN state and call stack to
       * compute what token(s) can come next and specifically: outside of a
       * lookahead decision. That is what you want for error reporting and
       * recovery upon parse error.
       *
       * @param stateNumber the ATN state number
       * @param context the full parse context
       * @returns The set of potentially valid input symbols which could follow the
       * specified state in the specified context.
       * @ if the ATN does not contain a state with
       * number `stateNumber`
       */
      getExpectedTokens(stateNumber, context) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
          throw new RangeError("Invalid state number.");
        }
        let ctx = context;
        let s = this.states[stateNumber];
        let following = this.nextTokens(s);
        if (!following.contains(Token_1.Token.EPSILON)) {
          return following;
        }
        let expected = new IntervalSet_1.IntervalSet();
        expected.addAll(following);
        expected.remove(Token_1.Token.EPSILON);
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = this.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = this.nextTokens(rt.followState);
          expected.addAll(following);
          expected.remove(Token_1.Token.EPSILON);
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON)) {
          expected.add(Token_1.Token.EOF);
        }
        return expected;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "states", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "decisionToState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "modeNameToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "modeToStartState", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "decisionToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "modeToDFA", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "nextTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN.prototype, "removeState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ATN.prototype, "defineMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN.prototype, "defineDecisionState", null);
    __decorate([
      Decorators_1.NotNull
    ], ATN.prototype, "getExpectedTokens", null);
    ATN = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATN);
    exports2.ATN = ATN;
    (function(ATN2) {
      ATN2.INVALID_ALT_NUMBER = 0;
    })(ATN = exports2.ATN || (exports2.ATN = {}));
    exports2.ATN = ATN;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializationOptions.js
var require_ATNDeserializationOptions = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializationOptions.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATNDeserializationOptions = void 0;
    var Decorators_1 = require_Decorators();
    var ATNDeserializationOptions = class _ATNDeserializationOptions {
      constructor(options) {
        this.readOnly = false;
        if (options) {
          this.verifyATN = options.verifyATN;
          this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
          this.optimize = options.optimize;
        } else {
          this.verifyATN = true;
          this.generateRuleBypassTransitions = false;
          this.optimize = true;
        }
      }
      static get defaultOptions() {
        if (_ATNDeserializationOptions._defaultOptions == null) {
          _ATNDeserializationOptions._defaultOptions = new _ATNDeserializationOptions();
          _ATNDeserializationOptions._defaultOptions.makeReadOnly();
        }
        return _ATNDeserializationOptions._defaultOptions;
      }
      get isReadOnly() {
        return this.readOnly;
      }
      makeReadOnly() {
        this.readOnly = true;
      }
      get isVerifyATN() {
        return this.verifyATN;
      }
      set isVerifyATN(verifyATN) {
        this.throwIfReadOnly();
        this.verifyATN = verifyATN;
      }
      get isGenerateRuleBypassTransitions() {
        return this.generateRuleBypassTransitions;
      }
      set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
        this.throwIfReadOnly();
        this.generateRuleBypassTransitions = generateRuleBypassTransitions;
      }
      get isOptimize() {
        return this.optimize;
      }
      set isOptimize(optimize) {
        this.throwIfReadOnly();
        this.optimize = optimize;
      }
      throwIfReadOnly() {
        if (this.isReadOnly) {
          throw new Error("The object is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializationOptions, "defaultOptions", null);
    exports2.ATNDeserializationOptions = ATNDeserializationOptions;
  }
});

// node_modules/antlr4ts/atn/AtomTransition.js
var require_AtomTransition = __commonJS({
  "node_modules/antlr4ts/atn/AtomTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AtomTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var AtomTransition = class AtomTransition extends Transition_1.Transition {
      constructor(target, label) {
        super(target);
        this._label = label;
      }
      get serializationType() {
        return 5;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this._label);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this._label === symbol;
      }
      toString() {
        return String(this.label);
      }
    };
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "toString", null);
    AtomTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], AtomTransition);
    exports2.AtomTransition = AtomTransition;
  }
});

// node_modules/antlr4ts/atn/BlockStartState.js
var require_BlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BlockStartState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BlockStartState = void 0;
    var DecisionState_1 = require_DecisionState();
    var BlockStartState = class extends DecisionState_1.DecisionState {
    };
    exports2.BlockStartState = BlockStartState;
  }
});

// node_modules/antlr4ts/atn/BasicBlockStartState.js
var require_BasicBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/BasicBlockStartState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicBlockStartState.prototype, "stateType", null);
    exports2.BasicBlockStartState = BasicBlockStartState;
  }
});

// node_modules/antlr4ts/atn/BlockEndState.js
var require_BlockEndState = __commonJS({
  "node_modules/antlr4ts/atn/BlockEndState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BlockEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BlockEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BlockEndState.prototype, "stateType", null);
    exports2.BlockEndState = BlockEndState;
  }
});

// node_modules/antlr4ts/atn/EpsilonTransition.js
var require_EpsilonTransition = __commonJS({
  "node_modules/antlr4ts/atn/EpsilonTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EpsilonTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
      constructor(target, outermostPrecedenceReturn = -1) {
        super(target);
        this._outermostPrecedenceReturn = outermostPrecedenceReturn;
      }
      /**
       * @returns the rule index of a precedence rule for which this transition is
       * returning from, where the precedence value is 0; otherwise, -1.
       *
       * @see ATNConfig.isPrecedenceFilterSuppressed
       * @see ParserATNSimulator#applyPrecedenceFilter(ATNConfigSet, ParserRuleContext, PredictionContextCache)
       * @since 4.4.1
       */
      get outermostPrecedenceReturn() {
        return this._outermostPrecedenceReturn;
      }
      get serializationType() {
        return 1;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "epsilon";
      }
    };
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], EpsilonTransition.prototype, "toString", null);
    EpsilonTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], EpsilonTransition);
    exports2.EpsilonTransition = EpsilonTransition;
  }
});

// node_modules/antlr4ts/atn/LexerChannelAction.js
var require_LexerChannelAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerChannelAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerChannelAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerChannelAction = class _LexerChannelAction {
      /**
       * Constructs a new `channel` action with the specified channel value.
       * @param channel The channel value to pass to {@link Lexer#setChannel}.
       */
      constructor(channel) {
        this._channel = channel;
      }
      /**
       * Gets the channel to use for the {@link Token} created by the lexer.
       *
       * @returns The channel to use for the {@link Token} created by the lexer.
       */
      get channel() {
        return this._channel;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#CHANNEL}.
       */
      get actionType() {
        return 0;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#setChannel} with the
       * value provided by {@link #getChannel}.
       */
      execute(lexer) {
        lexer.channel = this._channel;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerChannelAction)) {
          return false;
        }
        return this._channel === obj._channel;
      }
      toString() {
        return `channel(${this._channel})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerChannelAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "toString", null);
    exports2.LexerChannelAction = LexerChannelAction;
  }
});

// node_modules/antlr4ts/atn/LexerCustomAction.js
var require_LexerCustomAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerCustomAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerCustomAction = class _LexerCustomAction {
      /**
       * Constructs a custom lexer action with the specified rule and action
       * indexes.
       *
       * @param ruleIndex The rule index to use for calls to
       * {@link Recognizer#action}.
       * @param actionIndex The action index to use for calls to
       * {@link Recognizer#action}.
       */
      constructor(ruleIndex, actionIndex) {
        this._ruleIndex = ruleIndex;
        this._actionIndex = actionIndex;
      }
      /**
       * Gets the rule index to use for calls to {@link Recognizer#action}.
       *
       * @returns The rule index for the custom action.
       */
      get ruleIndex() {
        return this._ruleIndex;
      }
      /**
       * Gets the action index to use for calls to {@link Recognizer#action}.
       *
       * @returns The action index for the custom action.
       */
      get actionIndex() {
        return this._actionIndex;
      }
      /**
       * {@inheritDoc}
       *
       * @returns This method returns {@link LexerActionType#CUSTOM}.
       */
      get actionType() {
        return 1;
      }
      /**
       * Gets whether the lexer action is position-dependent. Position-dependent
       * actions may have different semantics depending on the {@link CharStream}
       * index at the time the action is executed.
       *
       * Custom actions are position-dependent since they may represent a
       * user-defined embedded action which makes calls to methods like
       * {@link Lexer#getText}.
       *
       * @returns This method returns `true`.
       */
      get isPositionDependent() {
        return true;
      }
      /**
       * {@inheritDoc}
       *
       * Custom actions are implemented by calling {@link Lexer#action} with the
       * appropriate rule and action indexes.
       */
      execute(lexer) {
        lexer.action(void 0, this._ruleIndex, this._actionIndex);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
        hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
        return MurmurHash_1.MurmurHash.finish(hash, 3);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerCustomAction)) {
          return false;
        }
        return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "equals", null);
    exports2.LexerCustomAction = LexerCustomAction;
  }
});

// node_modules/antlr4ts/atn/LexerModeAction.js
var require_LexerModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerModeAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerModeAction = class _LexerModeAction {
      /**
       * Constructs a new `mode` action with the specified mode value.
       * @param mode The mode value to pass to {@link Lexer#mode}.
       */
      constructor(mode) {
        this._mode = mode;
      }
      /**
       * Get the lexer mode this action should transition the lexer to.
       *
       * @returns The lexer mode for this `mode` command.
       */
      get mode() {
        return this._mode;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#MODE}.
       */
      get actionType() {
        return 2;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#mode} with the
       * value provided by {@link #getMode}.
       */
      execute(lexer) {
        lexer.mode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `mode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "toString", null);
    exports2.LexerModeAction = LexerModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerMoreAction.js
var require_LexerMoreAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerMoreAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerMoreAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerMoreAction = class {
      /**
       * Constructs the singleton instance of the lexer `more` command.
       */
      constructor() {
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#MORE}.
       */
      get actionType() {
        return 3;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#more}.
       */
      execute(lexer) {
        lexer.more();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "more";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerMoreAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "toString", null);
    exports2.LexerMoreAction = LexerMoreAction;
    (function(LexerMoreAction2) {
      LexerMoreAction2.INSTANCE = new LexerMoreAction2();
    })(LexerMoreAction = exports2.LexerMoreAction || (exports2.LexerMoreAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPopModeAction.js
var require_LexerPopModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPopModeAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerPopModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPopModeAction = class {
      /**
       * Constructs the singleton instance of the lexer `popMode` command.
       */
      constructor() {
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#POP_MODE}.
       */
      get actionType() {
        return 4;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#popMode}.
       */
      execute(lexer) {
        lexer.popMode();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "popMode";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPopModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "toString", null);
    exports2.LexerPopModeAction = LexerPopModeAction;
    (function(LexerPopModeAction2) {
      LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
    })(LexerPopModeAction = exports2.LexerPopModeAction || (exports2.LexerPopModeAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerPushModeAction.js
var require_LexerPushModeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerPushModeAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerPushModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPushModeAction = class _LexerPushModeAction {
      /**
       * Constructs a new `pushMode` action with the specified mode value.
       * @param mode The mode value to pass to {@link Lexer#pushMode}.
       */
      constructor(mode) {
        this._mode = mode;
      }
      /**
       * Get the lexer mode this action should transition the lexer to.
       *
       * @returns The lexer mode for this `pushMode` command.
       */
      get mode() {
        return this._mode;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#PUSH_MODE}.
       */
      get actionType() {
        return 5;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#pushMode} with the
       * value provided by {@link #getMode}.
       */
      execute(lexer) {
        lexer.pushMode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerPushModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `pushMode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPushModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "toString", null);
    exports2.LexerPushModeAction = LexerPushModeAction;
  }
});

// node_modules/antlr4ts/atn/LexerSkipAction.js
var require_LexerSkipAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerSkipAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerSkipAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerSkipAction = class {
      /**
       * Constructs the singleton instance of the lexer `skip` command.
       */
      constructor() {
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#SKIP}.
       */
      get actionType() {
        return 6;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#skip}.
       */
      execute(lexer) {
        lexer.skip();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "skip";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerSkipAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "toString", null);
    exports2.LexerSkipAction = LexerSkipAction;
    (function(LexerSkipAction2) {
      LexerSkipAction2.INSTANCE = new LexerSkipAction2();
    })(LexerSkipAction = exports2.LexerSkipAction || (exports2.LexerSkipAction = {}));
  }
});

// node_modules/antlr4ts/atn/LexerTypeAction.js
var require_LexerTypeAction = __commonJS({
  "node_modules/antlr4ts/atn/LexerTypeAction.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerTypeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerTypeAction = class _LexerTypeAction {
      /**
       * Constructs a new `type` action with the specified token type value.
       * @param type The type to assign to the token using `Lexer.type`.
       */
      constructor(type) {
        this._type = type;
      }
      /**
       * Gets the type to assign to a token created by the lexer.
       * @returns The type to assign to a token created by the lexer.
       */
      get type() {
        return this._type;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#TYPE}.
       */
      get actionType() {
        return 7;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by setting `Lexer.type` with the
       * value provided by `type`.
       */
      execute(lexer) {
        lexer.type = this._type;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._type);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerTypeAction)) {
          return false;
        }
        return this._type === obj._type;
      }
      toString() {
        return `type(${this._type})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerTypeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "toString", null);
    exports2.LexerTypeAction = LexerTypeAction;
  }
});

// node_modules/antlr4ts/atn/LoopEndState.js
var require_LoopEndState = __commonJS({
  "node_modules/antlr4ts/atn/LoopEndState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LoopEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var LoopEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.LOOP_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LoopEndState.prototype, "stateType", null);
    exports2.LoopEndState = LoopEndState;
  }
});

// node_modules/antlr4ts/atn/ConflictInfo.js
var require_ConflictInfo = __commonJS({
  "node_modules/antlr4ts/atn/ConflictInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConflictInfo = void 0;
    var Decorators_1 = require_Decorators();
    var Utils = require_Utils();
    var ConflictInfo = class _ConflictInfo {
      constructor(conflictedAlts, exact) {
        this._conflictedAlts = conflictedAlts;
        this.exact = exact;
      }
      /**
       * Gets the set of conflicting alternatives for the configuration set.
       */
      get conflictedAlts() {
        return this._conflictedAlts;
      }
      /**
       * Gets whether or not the configuration conflict is an exact conflict.
       * An exact conflict occurs when the prediction algorithm determines that
       * the represented alternatives for a particular configuration set cannot be
       * further reduced by consuming additional input. After reaching an exact
       * conflict during an SLL prediction, only switch to full-context prediction
       * could reduce the set of viable alternatives. In LL prediction, an exact
       * conflict indicates a true ambiguity in the input.
       *
       * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,
       * accept states are conflicting but not exact are treated as non-accept
       * states.
       */
      get isExact() {
        return this.exact;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _ConflictInfo)) {
          return false;
        }
        return this.isExact === obj.isExact && Utils.equals(this.conflictedAlts, obj.conflictedAlts);
      }
      hashCode() {
        return this.conflictedAlts.hashCode();
      }
    };
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "hashCode", null);
    exports2.ConflictInfo = ConflictInfo;
  }
});

// node_modules/antlr4ts/atn/PredicateTransition.js
var require_PredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PredicateTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, ruleIndex, predIndex, isCtxDependent) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 4;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
      }
      toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], PredicateTransition.prototype, "toString", null);
    PredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PredicateTransition);
    exports2.PredicateTransition = PredicateTransition;
  }
});

// node_modules/antlr4ts/FailedPredicateException.js
var require_FailedPredicateException = __commonJS({
  "node_modules/antlr4ts/FailedPredicateException.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FailedPredicateException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var PredicateTransition_1 = require_PredicateTransition();
    var FailedPredicateException = class FailedPredicateException2 extends RecognitionException_1.RecognitionException {
      constructor(recognizer, predicate, message) {
        super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException2.formatMessage(predicate, message));
        let s = recognizer.interpreter.atn.states[recognizer.state];
        let trans = s.transition(0);
        if (trans instanceof PredicateTransition_1.PredicateTransition) {
          this._ruleIndex = trans.ruleIndex;
          this._predicateIndex = trans.predIndex;
        } else {
          this._ruleIndex = 0;
          this._predicateIndex = 0;
        }
        this._predicate = predicate;
        super.setOffendingToken(recognizer, recognizer.currentToken);
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
      get predicateIndex() {
        return this._predicateIndex;
      }
      get predicate() {
        return this._predicate;
      }
      static formatMessage(predicate, message) {
        if (message) {
          return message;
        }
        return `failed predicate: {${predicate}}?`;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], FailedPredicateException, "formatMessage", null);
    FailedPredicateException = __decorate([
      __param(0, Decorators_1.NotNull)
    ], FailedPredicateException);
    exports2.FailedPredicateException = FailedPredicateException;
  }
});

// node_modules/antlr4ts/InputMismatchException.js
var require_InputMismatchException = __commonJS({
  "node_modules/antlr4ts/InputMismatchException.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InputMismatchException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
      constructor(recognizer, state, context) {
        if (context === void 0) {
          context = recognizer.context;
        }
        super(recognizer, recognizer.inputStream, context);
        if (state !== void 0) {
          this.setOffendingState(state);
        }
        this.setOffendingToken(recognizer, recognizer.currentToken);
      }
    };
    InputMismatchException = __decorate([
      __param(0, Decorators_1.NotNull)
    ], InputMismatchException);
    exports2.InputMismatchException = InputMismatchException;
  }
});

// node_modules/antlr4ts/DefaultErrorStrategy.js
var require_DefaultErrorStrategy = __commonJS({
  "node_modules/antlr4ts/DefaultErrorStrategy.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DefaultErrorStrategy = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var IntervalSet_1 = require_IntervalSet();
    var NoViableAltException_1 = require_NoViableAltException();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var Decorators_1 = require_Decorators();
    var DefaultErrorStrategy = class {
      constructor() {
        this.errorRecoveryMode = false;
        this.lastErrorIndex = -1;
        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation simply calls {@link #endErrorCondition} to
       * ensure that the handler is not in error recovery mode.
       */
      reset(recognizer) {
        this.endErrorCondition(recognizer);
      }
      /**
       * This method is called to enter error recovery mode when a recognition
       * exception is reported.
       *
       * @param recognizer the parser instance
       */
      beginErrorCondition(recognizer) {
        this.errorRecoveryMode = true;
      }
      /**
       * {@inheritDoc}
       */
      inErrorRecoveryMode(recognizer) {
        return this.errorRecoveryMode;
      }
      /**
       * This method is called to leave error recovery mode after recovering from
       * a recognition exception.
       *
       * @param recognizer
       */
      endErrorCondition(recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = void 0;
        this.lastErrorIndex = -1;
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation simply calls {@link #endErrorCondition}.
       */
      reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation returns immediately if the handler is already
       * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}
       * and dispatches the reporting task based on the runtime type of `e`
       * according to the following table.
       *
       * * {@link NoViableAltException}: Dispatches the call to
       *   {@link #reportNoViableAlternative}
       * * {@link InputMismatchException}: Dispatches the call to
       *   {@link #reportInputMismatch}
       * * {@link FailedPredicateException}: Dispatches the call to
       *   {@link #reportFailedPredicate}
       * * All other types: calls {@link Parser#notifyErrorListeners} to report
       *   the exception
       */
      reportError(recognizer, e) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        if (e instanceof NoViableAltException_1.NoViableAltException) {
          this.reportNoViableAlternative(recognizer, e);
        } else if (e instanceof InputMismatchException_1.InputMismatchException) {
          this.reportInputMismatch(recognizer, e);
        } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
          this.reportFailedPredicate(recognizer, e);
        } else {
          console.error(`unknown recognition error type: ${e}`);
          this.notifyErrorListeners(recognizer, e.toString(), e);
        }
      }
      notifyErrorListeners(recognizer, message, e) {
        let offendingToken = e.getOffendingToken(recognizer);
        if (offendingToken === void 0) {
          offendingToken = null;
        }
        recognizer.notifyErrorListeners(message, offendingToken, e);
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation resynchronizes the parser by consuming tokens
       * until we find one in the resynchronization set--loosely the set of tokens
       * that can follow the current rule.
       */
      recover(recognizer, e) {
        if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
          recognizer.consume();
        }
        this.lastErrorIndex = recognizer.inputStream.index;
        if (!this.lastErrorStates) {
          this.lastErrorStates = new IntervalSet_1.IntervalSet();
        }
        this.lastErrorStates.add(recognizer.state);
        let followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
      }
      /**
       * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure
       * that the current lookahead symbol is consistent with what were expecting
       * at this point in the ATN. You can call this anytime but ANTLR only
       * generates code to check before subrules/loops and each iteration.
       *
       * Implements Jim Idle's magic sync mechanism in closures and optional
       * subrules. E.g.,
       *
       * ```antlr
       * a : sync ( stuff sync )* ;
       * sync : {consume to what can follow sync} ;
       * ```
       *
       * At the start of a sub rule upon error, {@link #sync} performs single
       * token deletion, if possible. If it can't do that, it bails on the current
       * rule and uses the default error recovery, which consumes until the
       * resynchronization set of the current rule.
       *
       * If the sub rule is optional (`(...)?`, `(...)*`, or block
       * with an empty alternative), then the expected set includes what follows
       * the subrule.
       *
       * During loop iteration, it consumes until it sees a token that can start a
       * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
       * stay in the loop as long as possible.
       *
       * **ORIGINS**
       *
       * Previous versions of ANTLR did a poor job of their recovery within loops.
       * A single mismatch token or missing token would force the parser to bail
       * out of the entire rules surrounding the loop. So, for rule
       *
       * ```antlr
       * classDef : 'class' ID '{' member* '}'
       * ```
       *
       * input with an extra token between members would force the parser to
       * consume until it found the next class definition rather than the next
       * member definition of the current class.
       *
       * This functionality cost a little bit of effort because the parser has to
       * compare token set at the start of the loop and at each iteration. If for
       * some reason speed is suffering for you, you can turn off this
       * functionality by simply overriding this method as a blank { }.
       */
      sync(recognizer) {
        let s = recognizer.interpreter.atn.states[recognizer.state];
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        let tokens = recognizer.inputStream;
        let la = tokens.LA(1);
        let nextTokens = recognizer.atn.nextTokens(s);
        if (nextTokens.contains(la)) {
          this.nextTokensContext = void 0;
          this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
          return;
        }
        if (nextTokens.contains(Token_1.Token.EPSILON)) {
          if (this.nextTokensContext === void 0) {
            this.nextTokensContext = recognizer.context;
            this.nextTokensState = recognizer.state;
          }
          return;
        }
        switch (s.stateType) {
          case ATNStateType_1.ATNStateType.BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            if (this.singleTokenDeletion(recognizer)) {
              return;
            }
            throw new InputMismatchException_1.InputMismatchException(recognizer);
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            this.reportUnwantedToken(recognizer);
            let expecting = recognizer.getExpectedTokens();
            let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
            break;
          default:
            break;
        }
      }
      /**
       * This is called by {@link #reportError} when the exception is a
       * {@link NoViableAltException}.
       *
       * @see #reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportNoViableAlternative(recognizer, e) {
        let tokens = recognizer.inputStream;
        let input;
        if (tokens) {
          if (e.startToken.type === Token_1.Token.EOF) {
            input = "<EOF>";
          } else {
            input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
          }
        } else {
          input = "<unknown input>";
        }
        let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        this.notifyErrorListeners(recognizer, msg, e);
      }
      /**
       * This is called by {@link #reportError} when the exception is an
       * {@link InputMismatchException}.
       *
       * @see #reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportInputMismatch(recognizer, e) {
        let expected = e.expectedTokens;
        let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
        let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      /**
       * This is called by {@link #reportError} when the exception is a
       * {@link FailedPredicateException}.
       *
       * @see #reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportFailedPredicate(recognizer, e) {
        let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
        let msg = "rule " + ruleName + " " + e.message;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      /**
       * This method is called to report a syntax error which requires the removal
       * of a token from the input stream. At the time this method is called, the
       * erroneous symbol is current `LT(1)` symbol and has not yet been
       * removed from the input stream. When this method returns,
       * `recognizer` is in error recovery mode.
       *
       * This method is called when {@link #singleTokenDeletion} identifies
       * single-token deletion as a viable recovery strategy for a mismatched
       * input error.
       *
       * The default implementation simply returns if the handler is already in
       * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
       * enter error recovery mode, followed by calling
       * {@link Parser#notifyErrorListeners}.
       *
       * @param recognizer the parser instance
       */
      reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let tokenName = this.getTokenErrorDisplay(t);
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      /**
       * This method is called to report a syntax error which requires the
       * insertion of a missing token into the input stream. At the time this
       * method is called, the missing token has not yet been inserted. When this
       * method returns, `recognizer` is in error recovery mode.
       *
       * This method is called when {@link #singleTokenInsertion} identifies
       * single-token insertion as a viable recovery strategy for a mismatched
       * input error.
       *
       * The default implementation simply returns if the handler is already in
       * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
       * enter error recovery mode, followed by calling
       * {@link Parser#notifyErrorListeners}.
       *
       * @param recognizer the parser instance
       */
      reportMissingToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation attempts to recover from the mismatched input
       * by using single token insertion and deletion as described below. If the
       * recovery attempt fails, this method
       * {@link InputMismatchException}.
       *
       * **EXTRA TOKEN** (single token deletion)
       *
       * `LA(1)` is not what we are looking for. If `LA(2)` has the
       * right token, however, then assume `LA(1)` is some extra spurious
       * token and delete it. Then consume and return the next token (which was
       * the `LA(2)` token) as the successful result of the match operation.
       *
       * This recovery strategy is implemented by {@link #singleTokenDeletion}.
       *
       * **MISSING TOKEN** (single token insertion)
       *
       * If current token (at `LA(1)`) is consistent with what could come
       * after the expected `LA(1)` token, then assume the token is missing
       * and use the parser's {@link TokenFactory} to create it on the fly. The
       * "insertion" is performed by returning the created token as the successful
       * result of the match operation.
       *
       * This recovery strategy is implemented by {@link #singleTokenInsertion}.
       *
       * **EXAMPLE**
       *
       * For example, Input `i=(3;` is clearly missing the `')'`. When
       * the parser returns from the nested call to `expr`, it will have
       * call chain:
       *
       * ```
       * stat  expr  atom
       * ```
       *
       * and it will be trying to match the `')'` at this point in the
       * derivation:
       *
       * ```
       * => ID '=' '(' INT ')' ('+' atom)* ';'
       *                    ^
       * ```
       *
       * The attempt to match `')'` will fail when it sees `';'` and
       * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`
       * is in the set of tokens that can follow the `')'` token reference
       * in rule `atom`. It can assume that you forgot the `')'`.
       */
      recoverInline(recognizer) {
        let matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol) {
          recognizer.consume();
          return matchedSymbol;
        }
        if (this.singleTokenInsertion(recognizer)) {
          return this.getMissingSymbol(recognizer);
        }
        if (this.nextTokensContext === void 0) {
          throw new InputMismatchException_1.InputMismatchException(recognizer);
        } else {
          throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
        }
      }
      /**
       * This method implements the single-token insertion inline error recovery
       * strategy. It is called by {@link #recoverInline} if the single-token
       * deletion strategy fails to recover from the mismatched input. If this
       * method returns `true`, `recognizer` will be in error recovery
       * mode.
       *
       * This method determines whether or not single-token insertion is viable by
       * checking if the `LA(1)` input symbol could be successfully matched
       * if it were instead the `LA(2)` symbol. If this method returns
       * `true`, the caller is responsible for creating and inserting a
       * token with the correct type to produce this behavior.
       *
       * @param recognizer the parser instance
       * @returns `true` if single-token insertion is a viable recovery
       * strategy for the current mismatched input, otherwise `false`
       */
      singleTokenInsertion(recognizer) {
        let currentSymbolType = recognizer.inputStream.LA(1);
        let currentState = recognizer.interpreter.atn.states[recognizer.state];
        let next = currentState.transition(0).target;
        let atn = recognizer.interpreter.atn;
        let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
        if (expectingAtLL2.contains(currentSymbolType)) {
          this.reportMissingToken(recognizer);
          return true;
        }
        return false;
      }
      /**
       * This method implements the single-token deletion inline error recovery
       * strategy. It is called by {@link #recoverInline} to attempt to recover
       * from mismatched input. If this method returns `undefined`, the parser and error
       * handler state will not have changed. If this method returns non-`undefined`,
       * `recognizer` will *not* be in error recovery mode since the
       * returned token was a successful match.
       *
       * If the single-token deletion is successful, this method calls
       * {@link #reportUnwantedToken} to report the error, followed by
       * {@link Parser#consume} to actually "delete" the extraneous token. Then,
       * before returning {@link #reportMatch} is called to signal a successful
       * match.
       *
       * @param recognizer the parser instance
       * @returns the successfully matched {@link Token} instance if single-token
       * deletion successfully recovers from the mismatched input, otherwise
       * `undefined`
       */
      singleTokenDeletion(recognizer) {
        let nextTokenType = recognizer.inputStream.LA(2);
        let expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
          this.reportUnwantedToken(recognizer);
          recognizer.consume();
          let matchedSymbol = recognizer.currentToken;
          this.reportMatch(recognizer);
          return matchedSymbol;
        }
        return void 0;
      }
      /** Conjure up a missing token during error recovery.
       *
       *  The recognizer attempts to recover from single missing
       *  symbols. But, actions might refer to that missing symbol.
       *  For example, x=ID {f($x);}. The action clearly assumes
       *  that there has been an identifier matched previously and that
       *  $x points at that token. If that token is missing, but
       *  the next token in the stream is what we want we assume that
       *  this token is missing and we keep going. Because we
       *  have to return some token to replace the missing token,
       *  we have to conjure one up. This method gives the user control
       *  over the tokens returned for missing tokens. Mostly,
       *  you will want to create something special for identifier
       *  tokens. For literals such as '{' and ',', the default
       *  action in the parser or tree parser works. It simply creates
       *  a CommonToken of the appropriate type. The text will be the token.
       *  If you change what tokens must be created by the lexer,
       *  override this method to create the appropriate tokens.
       */
      getMissingSymbol(recognizer) {
        let currentSymbol = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let expectedTokenType = Token_1.Token.INVALID_TYPE;
        if (!expecting.isNil) {
          expectedTokenType = expecting.minElement;
        }
        let tokenText;
        if (expectedTokenType === Token_1.Token.EOF) {
          tokenText = "<missing EOF>";
        } else {
          tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
        }
        let current = currentSymbol;
        let lookback = recognizer.inputStream.tryLT(-1);
        if (current.type === Token_1.Token.EOF && lookback != null) {
          current = lookback;
        }
        return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
      }
      constructToken(tokenSource, expectedTokenType, tokenText, current) {
        let factory2 = tokenSource.tokenFactory;
        let x = current.tokenSource;
        let stream5 = x ? x.inputStream : void 0;
        return factory2.create({ source: tokenSource, stream: stream5 }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
      }
      getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
      }
      /** How should a token be displayed in an error message? The default
       *  is to display just the text, but during development you might
       *  want to have a lot of information spit out.  Override in that case
       *  to use t.toString() (which, for CommonToken, dumps everything about
       *  the token). This is better than forcing you to override a method in
       *  your token objects because you don't have to go modify your lexer
       *  so that it creates a new Java type.
       */
      getTokenErrorDisplay(t) {
        if (!t) {
          return "<no token>";
        }
        let s = this.getSymbolText(t);
        if (!s) {
          if (this.getSymbolType(t) === Token_1.Token.EOF) {
            s = "<EOF>";
          } else {
            s = `<${this.getSymbolType(t)}>`;
          }
        }
        return this.escapeWSAndQuote(s);
      }
      getSymbolText(symbol) {
        return symbol.text;
      }
      getSymbolType(symbol) {
        return symbol.type;
      }
      escapeWSAndQuote(s) {
        s = s.replace("\n", "\\n");
        s = s.replace("\r", "\\r");
        s = s.replace("	", "\\t");
        return "'" + s + "'";
      }
      /*  Compute the error recovery set for the current rule.  During
       *  rule invocation, the parser pushes the set of tokens that can
       *  follow that rule reference on the stack; this amounts to
       *  computing FIRST of what follows the rule reference in the
       *  enclosing rule. See LinearApproximator.FIRST().
       *  This local follow set only includes tokens
       *  from within the rule; i.e., the FIRST computation done by
       *  ANTLR stops at the end of a rule.
       *
       *  EXAMPLE
       *
       *  When you find a "no viable alt exception", the input is not
       *  consistent with any of the alternatives for rule r.  The best
       *  thing to do is to consume tokens until you see something that
       *  can legally follow a call to r *or* any rule that called r.
       *  You don't want the exact set of viable next tokens because the
       *  input might just be missing a token--you might consume the
       *  rest of the input looking for one of the missing tokens.
       *
       *  Consider grammar:
       *
       *  a : '[' b ']'
       *    | '(' b ')'
       *    ;
       *  b : c '^' INT ;
       *  c : ID
       *    | INT
       *    ;
       *
       *  At each rule invocation, the set of tokens that could follow
       *  that rule is pushed on a stack.  Here are the various
       *  context-sensitive follow sets:
       *
       *  FOLLOW(b1_in_a) = FIRST(']') = ']'
       *  FOLLOW(b2_in_a) = FIRST(')') = ')'
       *  FOLLOW(c_in_b) = FIRST('^') = '^'
       *
       *  Upon erroneous input "[]", the call chain is
       *
       *  a -> b -> c
       *
       *  and, hence, the follow context stack is:
       *
       *  depth     follow set       start of rule execution
       *    0         <EOF>                    a (from main())
       *    1          ']'                     b
       *    2          '^'                     c
       *
       *  Notice that ')' is not included, because b would have to have
       *  been called from a different context in rule a for ')' to be
       *  included.
       *
       *  For error recovery, we cannot consider FOLLOW(c)
       *  (context-sensitive or otherwise).  We need the combined set of
       *  all context-sensitive FOLLOW sets--the set of all tokens that
       *  could follow any reference in the call chain.  We need to
       *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
       *  we resync'd to that token, we'd consume until EOF.  We need to
       *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
       *  In this case, for input "[]", LA(1) is ']' and in the set, so we would
       *  not consume anything. After printing an error, rule c would
       *  return normally.  Rule b would not find the required '^' though.
       *  At this point, it gets a mismatched token error and
       *  exception (since LA(1) is not in the viable following token
       *  set).  The rule exception handler tries to recover, but finds
       *  the same recovery set and doesn't consume anything.  Rule b
       *  exits normally returning to rule a.  Now it finds the ']' (and
       *  with the successful match exits errorRecovery mode).
       *
       *  So, you can see that the parser walks up the call chain looking
       *  for the token that was a member of the recovery set.
       *
       *  Errors are not generated in errorRecovery mode.
       *
       *  ANTLR's error recovery mechanism is based upon original ideas:
       *
       *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
       *
       *  and
       *
       *  "A note on error recovery in recursive descent parsers":
       *  http://portal.acm.org/citation.cfm?id=947902.947905
       *
       *  Later, Josef Grosch had some good ideas:
       *
       *  "Efficient and Comfortable Error Recovery in Recursive Descent
       *  Parsers":
       *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
       *
       *  Like Grosch I implement context-sensitive FOLLOW sets that are combined
       *  at run-time upon error to avoid overhead during parsing.
       */
      getErrorRecoverySet(recognizer) {
        let atn = recognizer.interpreter.atn;
        let ctx = recognizer.context;
        let recoverSet = new IntervalSet_1.IntervalSet();
        while (ctx && ctx.invokingState >= 0) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          let follow = atn.nextTokens(rt.followState);
          recoverSet.addAll(follow);
          ctx = ctx._parent;
        }
        recoverSet.remove(Token_1.Token.EPSILON);
        return recoverSet;
      }
      /** Consume tokens until one matches the given token set. */
      consumeUntil(recognizer, set2) {
        let ttype = recognizer.inputStream.LA(1);
        while (ttype !== Token_1.Token.EOF && !set2.contains(ttype)) {
          recognizer.consume();
          ttype = recognizer.inputStream.LA(1);
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportMatch", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportError", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "sync", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolType", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "consumeUntil", null);
    exports2.DefaultErrorStrategy = DefaultErrorStrategy;
  }
});

// node_modules/antlr4ts/tree/TerminalNode.js
var require_TerminalNode = __commonJS({
  "node_modules/antlr4ts/tree/TerminalNode.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalNode = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TerminalNode = class {
      constructor(symbol) {
        this._symbol = symbol;
      }
      getChild(i2) {
        throw new RangeError("Terminal Node has no children.");
      }
      get symbol() {
        return this._symbol;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this._symbol;
      }
      get sourceInterval() {
        let tokenIndex = this._symbol.tokenIndex;
        return new Interval_1.Interval(tokenIndex, tokenIndex);
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitTerminal(this);
      }
      get text() {
        return this._symbol.text || "";
      }
      toStringTree(parser) {
        return this.toString();
      }
      toString() {
        if (this._symbol.type === Token_1.Token.EOF) {
          return "<EOF>";
        }
        return this._symbol.text || "";
      }
    };
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toStringTree", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toString", null);
    exports2.TerminalNode = TerminalNode;
  }
});

// node_modules/antlr4ts/tree/ErrorNode.js
var require_ErrorNode = __commonJS({
  "node_modules/antlr4ts/tree/ErrorNode.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorNode = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var ErrorNode = class extends TerminalNode_1.TerminalNode {
      constructor(token) {
        super(token);
      }
      accept(visitor) {
        return visitor.visitErrorNode(this);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ErrorNode.prototype, "accept", null);
    exports2.ErrorNode = ErrorNode;
  }
});

// node_modules/antlr4ts/atn/ParseInfo.js
var require_ParseInfo = __commonJS({
  "node_modules/antlr4ts/atn/ParseInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParseInfo = void 0;
    var Decorators_1 = require_Decorators();
    var ParseInfo = class ParseInfo {
      constructor(atnSimulator) {
        this.atnSimulator = atnSimulator;
      }
      /**
       * Gets an array of {@link DecisionInfo} instances containing the profiling
       * information gathered for each decision in the ATN.
       *
       * @returns An array of {@link DecisionInfo} instances, indexed by decision
       * number.
       */
      getDecisionInfo() {
        return this.atnSimulator.getDecisionInfo();
      }
      /**
       * Gets the decision numbers for decisions that required one or more
       * full-context predictions during parsing. These are decisions for which
       * {@link DecisionInfo#LL_Fallback} is non-zero.
       *
       * @returns A list of decision numbers which required one or more
       * full-context predictions during parsing.
       */
      getLLDecisions() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let LL = [];
        for (let i2 = 0; i2 < decisions.length; i2++) {
          let fallBack = decisions[i2].LL_Fallback;
          if (fallBack > 0) {
            LL.push(i2);
          }
        }
        return LL;
      }
      /**
       * Gets the total time spent during prediction across all decisions made
       * during parsing. This value is the sum of
       * {@link DecisionInfo#timeInPrediction} for all decisions.
       */
      getTotalTimeInPrediction() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let t = 0;
        for (let decision of decisions) {
          t += decision.timeInPrediction;
        }
        return t;
      }
      /**
       * Gets the total number of SLL lookahead operations across all decisions
       * made during parsing. This value is the sum of
       * {@link DecisionInfo#SLL_TotalLook} for all decisions.
       */
      getTotalSLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_TotalLook;
        }
        return k;
      }
      /**
       * Gets the total number of LL lookahead operations across all decisions
       * made during parsing. This value is the sum of
       * {@link DecisionInfo#LL_TotalLook} for all decisions.
       */
      getTotalLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_TotalLook;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for SLL prediction
       * across all decisions made during parsing.
       */
      getTotalSLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for LL prediction
       * across all decisions made during parsing.
       */
      getTotalLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for SLL and LL
       * prediction across all decisions made during parsing.
       *
       * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
       * {@link #getTotalLLATNLookaheadOps}.
       */
      getTotalATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getDFASize(decision) {
        if (decision) {
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
          return decisionToDFA.states.size;
        } else {
          let n2 = 0;
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
          for (let i2 = 0; i2 < decisionToDFA.length; i2++) {
            n2 += this.getDFASize(i2);
          }
          return n2;
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getDecisionInfo", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getLLDecisions", null);
    ParseInfo = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseInfo);
    exports2.ParseInfo = ParseInfo;
  }
});

// node_modules/antlr4ts/ProxyParserErrorListener.js
var require_ProxyParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ProxyParserErrorListener.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyParserErrorListener = void 0;
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
      constructor(delegates) {
        super(delegates);
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        });
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        });
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
    exports2.ProxyParserErrorListener = ProxyParserErrorListener;
  }
});

// node_modules/antlr4ts/misc/ParseCancellationException.js
var require_ParseCancellationException = __commonJS({
  "node_modules/antlr4ts/misc/ParseCancellationException.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParseCancellationException = void 0;
    var ParseCancellationException = class extends Error {
      constructor(cause) {
        super(cause.message);
        this.cause = cause;
        this.stack = cause.stack;
      }
      getCause() {
        return this.cause;
      }
    };
    exports2.ParseCancellationException = ParseCancellationException;
  }
});

// node_modules/antlr4ts/BailErrorStrategy.js
var require_BailErrorStrategy = __commonJS({
  "node_modules/antlr4ts/BailErrorStrategy.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BailErrorStrategy = void 0;
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var InputMismatchException_1 = require_InputMismatchException();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
      /** Instead of recovering from exception `e`, re-throw it wrapped
       *  in a {@link ParseCancellationException} so it is not caught by the
       *  rule function catches.  Use {@link Exception#getCause()} to get the
       *  original {@link RecognitionException}.
       */
      recover(recognizer, e) {
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      /** Make sure we don't attempt to recover inline; if the parser
       *  successfully recovers, it won't throw an exception.
       */
      recoverInline(recognizer) {
        let e = new InputMismatchException_1.InputMismatchException(recognizer);
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      /** Make sure we don't attempt to recover from problems in subrules. */
      sync(recognizer) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "sync", null);
    exports2.BailErrorStrategy = BailErrorStrategy;
  }
});

// node_modules/antlr4ts/misc/Character.js
var require_Character = __commonJS({
  "node_modules/antlr4ts/misc/Character.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSupplementaryCodePoint = exports2.isLowSurrogate = exports2.isHighSurrogate = void 0;
    function isHighSurrogate(ch) {
      return ch >= 55296 && ch <= 56319;
    }
    exports2.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(ch) {
      return ch >= 56320 && ch <= 57343;
    }
    exports2.isLowSurrogate = isLowSurrogate;
    function isSupplementaryCodePoint(ch) {
      return ch >= 65536;
    }
    exports2.isSupplementaryCodePoint = isSupplementaryCodePoint;
  }
});

// node_modules/antlr4ts/CodePointBuffer.js
var require_CodePointBuffer = __commonJS({
  "node_modules/antlr4ts/CodePointBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodePointBuffer = void 0;
    var assert = require("assert");
    var Character = require_Character();
    var CodePointBuffer = class _CodePointBuffer {
      constructor(buffer, size) {
        this.buffer = buffer;
        this._position = 0;
        this._size = size;
      }
      static withArray(buffer) {
        return new _CodePointBuffer(buffer, buffer.length);
      }
      get position() {
        return this._position;
      }
      set position(newPosition) {
        if (newPosition < 0 || newPosition > this._size) {
          throw new RangeError();
        }
        this._position = newPosition;
      }
      get remaining() {
        return this._size - this.position;
      }
      get(offset) {
        return this.buffer[offset];
      }
      array() {
        return this.buffer.slice(0, this._size);
      }
      static builder(initialBufferSize) {
        return new _CodePointBuffer.Builder(initialBufferSize);
      }
    };
    exports2.CodePointBuffer = CodePointBuffer;
    (function(CodePointBuffer2) {
      let Type;
      (function(Type2) {
        Type2[Type2["BYTE"] = 0] = "BYTE";
        Type2[Type2["CHAR"] = 1] = "CHAR";
        Type2[Type2["INT"] = 2] = "INT";
      })(Type || (Type = {}));
      class Builder {
        constructor(initialBufferSize) {
          this.type = 0;
          this.buffer = new Uint8Array(initialBufferSize);
          this.prevHighSurrogate = -1;
          this.position = 0;
        }
        build() {
          return new CodePointBuffer2(this.buffer, this.position);
        }
        static roundUpToNextPowerOfTwo(i2) {
          let nextPowerOfTwo = 32 - Math.clz32(i2 - 1);
          return Math.pow(2, nextPowerOfTwo);
        }
        ensureRemaining(remainingNeeded) {
          switch (this.type) {
            case 0:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint8Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 1:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint16Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 2:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Int32Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
          }
        }
        append(utf16In) {
          this.ensureRemaining(utf16In.length);
          this.appendArray(utf16In);
        }
        appendArray(utf16In) {
          switch (this.type) {
            case 0:
              this.appendArrayByte(utf16In);
              break;
            case 1:
              this.appendArrayChar(utf16In);
              break;
            case 2:
              this.appendArrayInt(utf16In);
              break;
          }
        }
        appendArrayByte(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outByte = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c3 = input[inOffset];
            if (c3 <= 255) {
              outByte[outOffset] = c3;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              if (!Character.isHighSurrogate(c3)) {
                this.byteToCharBuffer(utf16In.length);
                this.appendArrayChar(utf16In);
                return;
              } else {
                this.byteToIntBuffer(utf16In.length);
                this.appendArrayInt(utf16In);
                return;
              }
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayChar(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outChar = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c3 = input[inOffset];
            if (!Character.isHighSurrogate(c3)) {
              outChar[outOffset] = c3;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              this.charToIntBuffer(utf16In.length);
              this.appendArrayInt(utf16In);
              return;
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayInt(utf16In) {
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outInt = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c3 = input[inOffset];
            inOffset++;
            if (this.prevHighSurrogate !== -1) {
              if (Character.isLowSurrogate(c3)) {
                outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c3).codePointAt(0);
                outOffset++;
                this.prevHighSurrogate = -1;
              } else {
                outInt[outOffset] = this.prevHighSurrogate;
                outOffset++;
                if (Character.isHighSurrogate(c3)) {
                  this.prevHighSurrogate = c3;
                } else {
                  outInt[outOffset] = c3;
                  outOffset++;
                  this.prevHighSurrogate = -1;
                }
              }
            } else if (Character.isHighSurrogate(c3)) {
              this.prevHighSurrogate = c3;
            } else {
              outInt[outOffset] = c3;
              outOffset++;
            }
          }
          if (this.prevHighSurrogate !== -1) {
            outInt[outOffset] = this.prevHighSurrogate;
            outOffset++;
          }
          this.position = outOffset;
        }
        byteToCharBuffer(toAppend) {
          let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 1;
          this.buffer = newBuffer;
        }
        byteToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
        charToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
      }
      CodePointBuffer2.Builder = Builder;
    })(CodePointBuffer = exports2.CodePointBuffer || (exports2.CodePointBuffer = {}));
  }
});

// node_modules/antlr4ts/CodePointCharStream.js
var require_CodePointCharStream = __commonJS({
  "node_modules/antlr4ts/CodePointCharStream.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodePointCharStream = void 0;
    var assert = require("assert");
    var IntStream_1 = require_IntStream();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CodePointCharStream = class _CodePointCharStream {
      // Use the factory method {@link #fromBuffer(CodePointBuffer)} to
      // construct instances of this type.
      constructor(array, position, remaining, name) {
        assert(position === 0);
        this._array = array;
        this._size = remaining;
        this._name = name;
        this._position = 0;
      }
      get internalStorage() {
        return this._array;
      }
      static fromBuffer(codePointBuffer, name) {
        if (name === void 0 || name.length === 0) {
          name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return new _CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
      }
      consume() {
        if (this._size - this._position === 0) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new RangeError("cannot consume EOF");
        }
        this._position++;
      }
      get index() {
        return this._position;
      }
      get size() {
        return this._size;
      }
      /** mark/release do nothing; we have entire buffer */
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index) {
        this._position = index;
      }
      get sourceName() {
        return this._name;
      }
      toString() {
        return this.getText(Interval_1.Interval.of(0, this.size - 1));
      }
      LA(i2) {
        let offset;
        switch (Math.sign(i2)) {
          case -1:
            offset = this.index + i2;
            if (offset < 0) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
          case 0:
            return 0;
          case 1:
            offset = this.index + i2 - 1;
            if (offset >= this.size) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
        }
        throw new RangeError("Not reached");
      }
      /** Return the UTF-16 encoded string for the given interval */
      getText(interval) {
        const startIdx = Math.min(interval.a, this.size);
        const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
        if (this._array instanceof Int32Array) {
          return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        } else {
          return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "toString", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "getText", null);
    exports2.CodePointCharStream = CodePointCharStream;
  }
});

// node_modules/antlr4ts/CharStreams.js
var require_CharStreams = __commonJS({
  "node_modules/antlr4ts/CharStreams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CharStreams = void 0;
    var CodePointBuffer_1 = require_CodePointBuffer();
    var CodePointCharStream_1 = require_CodePointCharStream();
    var IntStream_1 = require_IntStream();
    var CharStreams2;
    (function(CharStreams3) {
      function fromString(s, sourceName) {
        if (sourceName === void 0 || sourceName.length === 0) {
          sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
        let cb = new Uint16Array(s.length);
        for (let i2 = 0; i2 < s.length; i2++) {
          cb[i2] = s.charCodeAt(i2);
        }
        codePointBufferBuilder.append(cb);
        return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
      }
      CharStreams3.fromString = fromString;
    })(CharStreams2 = exports2.CharStreams || (exports2.CharStreams = {}));
  }
});

// node_modules/antlr4ts/BufferedTokenStream.js
var require_BufferedTokenStream = __commonJS({
  "node_modules/antlr4ts/BufferedTokenStream.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferedTokenStream = void 0;
    var assert = require("assert");
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var BufferedTokenStream = class BufferedTokenStream {
      constructor(tokenSource) {
        this.tokens = [];
        this.p = -1;
        this.fetchedEOF = false;
        if (tokenSource == null) {
          throw new Error("tokenSource cannot be null");
        }
        this._tokenSource = tokenSource;
      }
      get tokenSource() {
        return this._tokenSource;
      }
      /** Reset this token stream by setting its token source. */
      set tokenSource(tokenSource) {
        this._tokenSource = tokenSource;
        this.tokens.length = 0;
        this.p = -1;
        this.fetchedEOF = false;
      }
      get index() {
        return this.p;
      }
      mark() {
        return 0;
      }
      release(marker) {
      }
      seek(index) {
        this.lazyInit();
        this.p = this.adjustSeekIndex(index);
      }
      get size() {
        return this.tokens.length;
      }
      consume() {
        let skipEofCheck;
        if (this.p >= 0) {
          if (this.fetchedEOF) {
            skipEofCheck = this.p < this.tokens.length - 1;
          } else {
            skipEofCheck = this.p < this.tokens.length;
          }
        } else {
          skipEofCheck = false;
        }
        if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
          throw new Error("cannot consume EOF");
        }
        if (this.sync(this.p + 1)) {
          this.p = this.adjustSeekIndex(this.p + 1);
        }
      }
      /** Make sure index `i` in tokens has a token.
       *
       * @returns `true` if a token is located at index `i`, otherwise
       *    `false`.
       * @see #get(int i)
       */
      sync(i2) {
        assert(i2 >= 0);
        let n2 = i2 - this.tokens.length + 1;
        if (n2 > 0) {
          let fetched = this.fetch(n2);
          return fetched >= n2;
        }
        return true;
      }
      /** Add `n` elements to buffer.
       *
       * @returns The actual number of elements added to the buffer.
       */
      fetch(n2) {
        if (this.fetchedEOF) {
          return 0;
        }
        for (let i2 = 0; i2 < n2; i2++) {
          let t = this.tokenSource.nextToken();
          if (this.isWritableToken(t)) {
            t.tokenIndex = this.tokens.length;
          }
          this.tokens.push(t);
          if (t.type === Token_1.Token.EOF) {
            this.fetchedEOF = true;
            return i2 + 1;
          }
        }
        return n2;
      }
      get(i2) {
        if (i2 < 0 || i2 >= this.tokens.length) {
          throw new RangeError("token index " + i2 + " out of range 0.." + (this.tokens.length - 1));
        }
        return this.tokens[i2];
      }
      /** Get all tokens from start..stop inclusively. */
      getRange(start, stop) {
        if (start < 0 || stop < 0) {
          return [];
        }
        this.lazyInit();
        let subset = new Array();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        for (let i2 = start; i2 <= stop; i2++) {
          let t = this.tokens[i2];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          subset.push(t);
        }
        return subset;
      }
      LA(i2) {
        let token = this.LT(i2);
        if (!token) {
          return Token_1.Token.INVALID_TYPE;
        }
        return token.type;
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        return this.tokens[this.p - k];
      }
      LT(k) {
        let result = this.tryLT(k);
        if (result === void 0) {
          throw new RangeError("requested lookback index out of range");
        }
        return result;
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i2 = this.p + k - 1;
        this.sync(i2);
        if (i2 >= this.tokens.length) {
          return this.tokens[this.tokens.length - 1];
        }
        return this.tokens[i2];
      }
      /**
       * Allowed derived classes to modify the behavior of operations which change
       * the current stream position by adjusting the target token index of a seek
       * operation. The default implementation simply returns `i`. If an
       * exception is thrown in this method, the current stream index should not be
       * changed.
       *
       * For example, {@link CommonTokenStream} overrides this method to ensure that
       * the seek target is always an on-channel token.
       *
       * @param i The target token index.
       * @returns The adjusted target token index.
       */
      adjustSeekIndex(i2) {
        return i2;
      }
      lazyInit() {
        if (this.p === -1) {
          this.setup();
        }
      }
      setup() {
        this.sync(0);
        this.p = this.adjustSeekIndex(0);
      }
      /** Given a start and stop index, return a `List` of all tokens in
       *  the token type `BitSet`.  Return an empty array if no tokens were found.  This
       *  method looks at both on and off channel tokens.
       */
      getTokens(start, stop, types2) {
        this.lazyInit();
        if (start === void 0) {
          assert(stop === void 0 && types2 === void 0);
          return this.tokens;
        } else if (stop === void 0) {
          stop = this.tokens.length - 1;
        }
        if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
          throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
        }
        if (start > stop) {
          return [];
        }
        if (types2 === void 0) {
          return this.tokens.slice(start, stop + 1);
        } else if (typeof types2 === "number") {
          types2 = (/* @__PURE__ */ new Set()).add(types2);
        }
        let typesSet = types2;
        let filteredTokens = this.tokens.slice(start, stop + 1);
        filteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));
        return filteredTokens;
      }
      /**
       * Given a starting index, return the index of the next token on channel.
       * Return `i` if `tokens[i]` is on channel. Return the index of
       * the EOF token if there are no tokens on channel between `i` and
       * EOF.
       */
      nextTokenOnChannel(i2, channel) {
        this.sync(i2);
        if (i2 >= this.size) {
          return this.size - 1;
        }
        let token = this.tokens[i2];
        while (token.channel !== channel) {
          if (token.type === Token_1.Token.EOF) {
            return i2;
          }
          i2++;
          this.sync(i2);
          token = this.tokens[i2];
        }
        return i2;
      }
      /**
       * Given a starting index, return the index of the previous token on
       * channel. Return `i` if `tokens[i]` is on channel. Return -1
       * if there are no tokens on channel between `i` and 0.
       *
       * If `i` specifies an index at or after the EOF token, the EOF token
       * index is returned. This is due to the fact that the EOF token is treated
       * as though it were on every channel.
       */
      previousTokenOnChannel(i2, channel) {
        this.sync(i2);
        if (i2 >= this.size) {
          return this.size - 1;
        }
        while (i2 >= 0) {
          let token = this.tokens[i2];
          if (token.type === Token_1.Token.EOF || token.channel === channel) {
            return i2;
          }
          i2--;
        }
        return i2;
      }
      /** Collect all tokens on specified channel to the right of
       *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL} or
       *  EOF. If `channel` is `-1`, find any non default channel token.
       */
      getHiddenTokensToRight(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        let to;
        let from = tokenIndex + 1;
        if (nextOnChannel === -1) {
          to = this.size - 1;
        } else {
          to = nextOnChannel;
        }
        return this.filterForChannel(from, to, channel);
      }
      /** Collect all tokens on specified channel to the left of
       *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL}.
       *  If `channel` is `-1`, find any non default channel token.
       */
      getHiddenTokensToLeft(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        if (tokenIndex === 0) {
          return [];
        }
        let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        if (prevOnChannel === tokenIndex - 1) {
          return [];
        }
        let from = prevOnChannel + 1;
        let to = tokenIndex - 1;
        return this.filterForChannel(from, to, channel);
      }
      filterForChannel(from, to, channel) {
        let hidden2 = new Array();
        for (let i2 = from; i2 <= to; i2++) {
          let t = this.tokens[i2];
          if (channel === -1) {
            if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
              hidden2.push(t);
            }
          } else {
            if (t.channel === channel) {
              hidden2.push(t);
            }
          }
        }
        return hidden2;
      }
      get sourceName() {
        return this.tokenSource.sourceName;
      }
      getText(interval) {
        if (interval === void 0) {
          interval = Interval_1.Interval.of(0, this.size - 1);
        } else if (!(interval instanceof Interval_1.Interval)) {
          interval = interval.sourceInterval;
        }
        let start = interval.a;
        let stop = interval.b;
        if (start < 0 || stop < 0) {
          return "";
        }
        this.fill();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        let buf = "";
        for (let i2 = start; i2 <= stop; i2++) {
          let t = this.tokens[i2];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          buf += t.text;
        }
        return buf.toString();
      }
      getTextFromRange(start, stop) {
        if (this.isToken(start) && this.isToken(stop)) {
          return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
        }
        return "";
      }
      /** Get all tokens from lexer until EOF. */
      fill() {
        this.lazyInit();
        const blockSize = 1e3;
        while (true) {
          let fetched = this.fetch(blockSize);
          if (fetched < blockSize) {
            return;
          }
        }
      }
      // TODO: Figure out a way to make this more flexible?
      isWritableToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
      // TODO: Figure out a way to make this more flexible?
      isToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], BufferedTokenStream.prototype, "_tokenSource", void 0);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "get", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LA", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LT", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getText", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getTextFromRange", null);
    BufferedTokenStream = __decorate([
      __param(0, Decorators_1.NotNull)
    ], BufferedTokenStream);
    exports2.BufferedTokenStream = BufferedTokenStream;
  }
});

// node_modules/antlr4ts/CommonTokenStream.js
var require_CommonTokenStream = __commonJS({
  "node_modules/antlr4ts/CommonTokenStream.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommonTokenStream = void 0;
    var BufferedTokenStream_1 = require_BufferedTokenStream();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
      /**
       * Constructs a new {@link CommonTokenStream} using the specified token
       * source and filtering tokens to the specified channel. Only tokens whose
       * {@link Token#getChannel} matches `channel` or have the
       * `Token.type` equal to {@link Token#EOF} will be returned by the
       * token stream lookahead methods.
       *
       * @param tokenSource The token source.
       * @param channel The channel to use for filtering tokens.
       */
      constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
        super(tokenSource);
        this.channel = channel;
      }
      adjustSeekIndex(i2) {
        return this.nextTokenOnChannel(i2, this.channel);
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        let i2 = this.p;
        let n2 = 1;
        while (n2 <= k && i2 > 0) {
          i2 = this.previousTokenOnChannel(i2 - 1, this.channel);
          n2++;
        }
        if (i2 < 0) {
          return void 0;
        }
        return this.tokens[i2];
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i2 = this.p;
        let n2 = 1;
        while (n2 < k) {
          if (this.sync(i2 + 1)) {
            i2 = this.nextTokenOnChannel(i2 + 1, this.channel);
          }
          n2++;
        }
        return this.tokens[i2];
      }
      /** Count EOF just once. */
      getNumberOfOnChannelTokens() {
        let n2 = 0;
        this.fill();
        for (let t of this.tokens) {
          if (t.channel === this.channel) {
            n2++;
          }
          if (t.type === Token_1.Token.EOF) {
            break;
          }
        }
        return n2;
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "adjustSeekIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLB", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream2.prototype, "tryLT", null);
    CommonTokenStream2 = __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonTokenStream2);
    exports2.CommonTokenStream = CommonTokenStream2;
  }
});

// node_modules/antlr4ts/ListTokenSource.js
var require_ListTokenSource = __commonJS({
  "node_modules/antlr4ts/ListTokenSource.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListTokenSource = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var ListTokenSource = class ListTokenSource {
      /**
       * Constructs a new {@link ListTokenSource} instance from the specified
       * collection of {@link Token} objects and source name.
       *
       * @param tokens The collection of {@link Token} objects to provide as a
       * {@link TokenSource}.
       * @param sourceName The name of the {@link TokenSource}. If this value is
       * `undefined`, {@link #getSourceName} will attempt to infer the name from
       * the next {@link Token} (or the previous token if the end of the input has
       * been reached).
       *
       * @exception NullPointerException if `tokens` is `undefined`
       */
      constructor(tokens, sourceName) {
        this.i = 0;
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        if (tokens == null) {
          throw new Error("tokens cannot be null");
        }
        this.tokens = tokens;
        this._sourceName = sourceName;
      }
      /**
       * {@inheritDoc}
       */
      get charPositionInLine() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].charPositionInLine;
        } else if (this.eofToken != null) {
          return this.eofToken.charPositionInLine;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let tokenText = lastToken.text;
          if (tokenText != null) {
            let lastNewLine = tokenText.lastIndexOf("\n");
            if (lastNewLine >= 0) {
              return tokenText.length - lastNewLine - 1;
            }
          }
          return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
        }
        return 0;
      }
      /**
       * {@inheritDoc}
       */
      nextToken() {
        if (this.i >= this.tokens.length) {
          if (this.eofToken == null) {
            let start = -1;
            if (this.tokens.length > 0) {
              let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
              if (previousStop !== -1) {
                start = previousStop + 1;
              }
            }
            let stop = Math.max(-1, start - 1);
            this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
          }
          return this.eofToken;
        }
        let t = this.tokens[this.i];
        if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
          this.eofToken = t;
        }
        this.i++;
        return t;
      }
      /**
       * {@inheritDoc}
       */
      get line() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].line;
        } else if (this.eofToken != null) {
          return this.eofToken.line;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let line = lastToken.line;
          let tokenText = lastToken.text;
          if (tokenText != null) {
            for (let i2 = 0; i2 < tokenText.length; i2++) {
              if (tokenText.charAt(i2) === "\n") {
                line++;
              }
            }
          }
          return line;
        }
        return 1;
      }
      /**
       * {@inheritDoc}
       */
      get inputStream() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].inputStream;
        } else if (this.eofToken != null) {
          return this.eofToken.inputStream;
        } else if (this.tokens.length > 0) {
          return this.tokens[this.tokens.length - 1].inputStream;
        }
        return void 0;
      }
      /**
       * {@inheritDoc}
       */
      get sourceName() {
        if (this._sourceName) {
          return this._sourceName;
        }
        let inputStream = this.inputStream;
        if (inputStream != null) {
          return inputStream.sourceName;
        }
        return "List";
      }
      /**
       * {@inheritDoc}
       */
      // @Override
      set tokenFactory(factory2) {
        this._factory = factory2;
      }
      /**
       * {@inheritDoc}
       */
      get tokenFactory() {
        return this._factory;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource.prototype, "tokenFactory", null);
    ListTokenSource = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource);
    exports2.ListTokenSource = ListTokenSource;
  }
});

// node_modules/antlr4ts/misc/MultiMap.js
var require_MultiMap = __commonJS({
  "node_modules/antlr4ts/misc/MultiMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiMap = void 0;
    var MultiMap = class extends Map {
      constructor() {
        super();
      }
      map(key, value) {
        let elementsForKey = super.get(key);
        if (!elementsForKey) {
          elementsForKey = [];
          super.set(key, elementsForKey);
        }
        elementsForKey.push(value);
      }
      getPairs() {
        let pairs = [];
        this.forEach((values, key) => {
          values.forEach((v) => {
            pairs.push([key, v]);
          });
        });
        return pairs;
      }
    };
    exports2.MultiMap = MultiMap;
  }
});

// node_modules/antlr4ts/tree/RuleNode.js
var require_RuleNode = __commonJS({
  "node_modules/antlr4ts/tree/RuleNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleNode = void 0;
    var RuleNode = class {
    };
    exports2.RuleNode = RuleNode;
  }
});

// node_modules/antlr4ts/tree/Trees.js
var require_Trees = __commonJS({
  "node_modules/antlr4ts/tree/Trees.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Trees = void 0;
    var ATN_1 = require_ATN();
    var CommonToken_1 = require_CommonToken();
    var ErrorNode_1 = require_ErrorNode();
    var Decorators_1 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleNode_1 = require_RuleNode();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var Utils = require_Utils();
    var Trees = class _Trees {
      static toStringTree(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else {
          ruleNames = arg2;
        }
        let s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        if (t.childCount === 0) {
          return s;
        }
        let buf = "";
        buf += "(";
        s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        buf += s;
        buf += " ";
        for (let i2 = 0; i2 < t.childCount; i2++) {
          if (i2 > 0) {
            buf += " ";
          }
          buf += this.toStringTree(t.getChild(i2), ruleNames);
        }
        buf += ")";
        return buf;
      }
      static getNodeText(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else if (arg2) {
          ruleNames = arg2;
        } else {
          let payload = t.payload;
          if (typeof payload.text === "string") {
            return payload.text;
          }
          return t.payload.toString();
        }
        if (t instanceof RuleNode_1.RuleNode) {
          let ruleContext = t.ruleContext;
          let ruleIndex = ruleContext.ruleIndex;
          let ruleName = ruleNames[ruleIndex];
          let altNumber = ruleContext.altNumber;
          if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            return ruleName + ":" + altNumber;
          }
          return ruleName;
        } else if (t instanceof ErrorNode_1.ErrorNode) {
          return t.toString();
        } else if (t instanceof TerminalNode_1.TerminalNode) {
          let symbol = t.symbol;
          return symbol.text || "";
        }
        throw new TypeError("Unexpected node type");
      }
      static getChildren(t) {
        let kids = [];
        for (let i2 = 0; i2 < t.childCount; i2++) {
          kids.push(t.getChild(i2));
        }
        return kids;
      }
      static getAncestors(t) {
        let ancestors = [];
        let p = t.parent;
        while (p) {
          ancestors.unshift(p);
          p = p.parent;
        }
        return ancestors;
      }
      /** Return true if t is u's parent or a node on path to root from u.
       *  Use === not equals().
       *
       *  @since 4.5.1
       */
      static isAncestorOf(t, u2) {
        if (!t || !u2 || !t.parent) {
          return false;
        }
        let p = u2.parent;
        while (p) {
          if (t === p) {
            return true;
          }
          p = p.parent;
        }
        return false;
      }
      static findAllTokenNodes(t, ttype) {
        return _Trees.findAllNodes(t, ttype, true);
      }
      static findAllRuleNodes(t, ruleIndex) {
        return _Trees.findAllNodes(t, ruleIndex, false);
      }
      static findAllNodes(t, index, findTokens) {
        let nodes = [];
        _Trees._findAllNodes(t, index, findTokens, nodes);
        return nodes;
      }
      static _findAllNodes(t, index, findTokens, nodes) {
        if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
          if (t.symbol.type === index) {
            nodes.push(t);
          }
        } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
          if (t.ruleIndex === index) {
            nodes.push(t);
          }
        }
        for (let i2 = 0; i2 < t.childCount; i2++) {
          _Trees._findAllNodes(t.getChild(i2), index, findTokens, nodes);
        }
      }
      /** Get all descendents; includes t itself.
       *
       * @since 4.5.1
       */
      static getDescendants(t) {
        let nodes = [];
        function recurse(e) {
          nodes.push(e);
          const n2 = e.childCount;
          for (let i2 = 0; i2 < n2; i2++) {
            recurse(e.getChild(i2));
          }
        }
        recurse(t);
        return nodes;
      }
      /** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
       *  inclusively using postorder traversal.  Recursive depth-first-search.
       *
       *  @since 4.5
       */
      static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
        let n2 = t.childCount;
        for (let i2 = 0; i2 < n2; i2++) {
          let child = t.getChild(i2);
          let r = _Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
          if (r) {
            return r;
          }
        }
        if (t instanceof ParserRuleContext_1.ParserRuleContext) {
          let stopToken = t.stop;
          if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
          (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
            return t;
          }
        }
        return void 0;
      }
      /** Replace any subtree siblings of root that are completely to left
       *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
       *  node. The source interval for t is not altered to suit smaller range!
       *
       *  WARNING: destructive to t.
       *
       *  @since 4.5.1
       */
      static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
        if (!t) {
          return;
        }
        let count2 = t.childCount;
        for (let i2 = 0; i2 < count2; i2++) {
          let child = t.getChild(i2);
          let range2 = child.sourceInterval;
          if (child instanceof ParserRuleContext_1.ParserRuleContext && (range2.b < startIndex || range2.a > stopIndex)) {
            if (_Trees.isAncestorOf(child, root)) {
              let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
              t.children[i2] = new TerminalNode_1.TerminalNode(abbrev);
            }
          }
        }
      }
      static findNodeSuchThat(t, pred) {
        if (pred(t)) {
          return t;
        }
        let n2 = t.childCount;
        for (let i2 = 0; i2 < n2; i2++) {
          let u2 = _Trees.findNodeSuchThat(t.getChild(i2), pred);
          if (u2 !== void 0) {
            return u2;
          }
        }
        return void 0;
      }
    };
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "toStringTree", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Trees, "getAncestors", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "getRootOfSubtreeEnclosingRegion", null);
    exports2.Trees = Trees;
  }
});

// node_modules/antlr4ts/RuleContext.js
var require_RuleContext = __commonJS({
  "node_modules/antlr4ts/RuleContext.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleContext = void 0;
    var ATN_1 = require_ATN();
    var Recognizer_1 = require_Recognizer();
    var RuleNode_1 = require_RuleNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContext = class _RuleContext extends RuleNode_1.RuleNode {
      constructor(parent, invokingState) {
        super();
        this._parent = parent;
        this.invokingState = invokingState != null ? invokingState : -1;
      }
      static getChildContext(parent, invokingState) {
        return new _RuleContext(parent, invokingState);
      }
      depth() {
        let n2 = 0;
        let p = this;
        while (p) {
          p = p._parent;
          n2++;
        }
        return n2;
      }
      /** A context is empty if there is no invoking state; meaning nobody called
       *  current context.
       */
      get isEmpty() {
        return this.invokingState === -1;
      }
      // satisfy the ParseTree / SyntaxTree interface
      get sourceInterval() {
        return Interval_1.Interval.INVALID;
      }
      get ruleContext() {
        return this;
      }
      get parent() {
        return this._parent;
      }
      /** @since 4.7. {@see ParseTree#setParent} comment */
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this;
      }
      /** Return the combined text of all child nodes. This method only considers
       *  tokens which have been added to the parse tree.
       *
       *  Since tokens on hidden channels (e.g. whitespace or comments) are not
       *  added to the parse trees, they will not appear in the output of this
       *  method.
       */
      get text() {
        if (this.childCount === 0) {
          return "";
        }
        let builder = "";
        for (let i2 = 0; i2 < this.childCount; i2++) {
          builder += this.getChild(i2).text;
        }
        return builder.toString();
      }
      get ruleIndex() {
        return -1;
      }
      /** For rule associated with this parse tree internal node, return
       *  the outer alternative number used to match the input. Default
       *  implementation does not compute nor store this alt num. Create
       *  a subclass of ParserRuleContext with backing field and set
       *  option contextSuperClass.
       *  to set it.
       *
       *  @since 4.5.3
       */
      get altNumber() {
        return ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      /** Set the outer alternative number for this context node. Default
       *  implementation does nothing to avoid backing field overhead for
       *  trees that don't need it.  Create
       *  a subclass of ParserRuleContext with backing field and set
       *  option contextSuperClass.
       *
       *  @since 4.5.3
       */
      set altNumber(altNumber) {
      }
      getChild(i2) {
        throw new RangeError("i must be greater than or equal to 0 and less than childCount");
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitChildren(this);
      }
      toStringTree(recog) {
        return Trees_1.Trees.toStringTree(this, recog);
      }
      toString(arg1, stop) {
        const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
        stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
        let buf = "";
        let p = this;
        buf += "[";
        while (p && p !== stop) {
          if (!ruleNames) {
            if (!p.isEmpty) {
              buf += p.invokingState;
            }
          } else {
            let ruleIndex = p.ruleIndex;
            let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
            buf += ruleName;
          }
          if (p._parent && (ruleNames || !p._parent.isEmpty)) {
            buf += " ";
          }
          p = p._parent;
        }
        buf += "]";
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "ruleContext", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "toStringTree", null);
    exports2.RuleContext = RuleContext;
  }
});

// node_modules/antlr4ts/ParserRuleContext.js
var require_ParserRuleContext = __commonJS({
  "node_modules/antlr4ts/ParserRuleContext.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParserRuleContext = void 0;
    var ErrorNode_1 = require_ErrorNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var RuleContext_1 = require_RuleContext();
    var TerminalNode_1 = require_TerminalNode();
    var ParserRuleContext = class _ParserRuleContext extends RuleContext_1.RuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber == null) {
          super();
        } else {
          super(parent, invokingStateNumber);
        }
      }
      static emptyContext() {
        return _ParserRuleContext.EMPTY;
      }
      /**
       * COPY a ctx (I'm deliberately not using copy constructor) to avoid
       * confusion with creating node with parent. Does not copy children
       * (except error leaves).
       *
       * This is used in the generated parser code to flip a generic XContext
       * node for rule X to a YContext for alt label Y. In that sense, it is not
       * really a generic copy function.
       *
       * If we do an error sync() at start of a rule, we might add error nodes
       * to the generic XContext so this function must copy those nodes to the
       * YContext as well else they are lost!
       */
      copyFrom(ctx) {
        this._parent = ctx._parent;
        this.invokingState = ctx.invokingState;
        this._start = ctx._start;
        this._stop = ctx._stop;
        if (ctx.children) {
          this.children = [];
          for (let child of ctx.children) {
            if (child instanceof ErrorNode_1.ErrorNode) {
              this.addChild(child);
            }
          }
        }
      }
      // Double dispatch methods for listeners
      enterRule(listener) {
      }
      exitRule(listener) {
      }
      /** Add a parse tree node to this as a child.  Works for
       *  internal and leaf nodes. Does not set parent link;
       *  other add methods must do that. Other addChild methods
       *  call this.
       *
       *  We cannot set the parent pointer of the incoming node
       *  because the existing interfaces do not have a setParent()
       *  method and I don't want to break backward compatibility for this.
       *
       *  @since 4.7
       */
      addAnyChild(t) {
        if (!this.children) {
          this.children = [t];
        } else {
          this.children.push(t);
        }
        return t;
      }
      addChild(t) {
        let result;
        if (t instanceof TerminalNode_1.TerminalNode) {
          t.setParent(this);
          this.addAnyChild(t);
          return;
        } else if (t instanceof RuleContext_1.RuleContext) {
          this.addAnyChild(t);
          return;
        } else {
          t = new TerminalNode_1.TerminalNode(t);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      addErrorNode(node) {
        if (node instanceof ErrorNode_1.ErrorNode) {
          const errorNode = node;
          errorNode.setParent(this);
          return this.addAnyChild(errorNode);
        } else {
          const badToken = node;
          let t = new ErrorNode_1.ErrorNode(badToken);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      //	public void trace(int s) {
      //		if ( states==null ) states = new ArrayList<Integer>();
      //		states.add(s);
      //	}
      /** Used by enterOuterAlt to toss out a RuleContext previously added as
       *  we entered a rule. If we have # label, we will need to remove
       *  generic ruleContext object.
       */
      removeLastChild() {
        if (this.children) {
          this.children.pop();
        }
      }
      get parent() {
        let parent = super.parent;
        if (parent === void 0 || parent instanceof _ParserRuleContext) {
          return parent;
        }
        throw new TypeError("Invalid parent type for ParserRuleContext");
      }
      // Note: in TypeScript, order or arguments reversed
      getChild(i2, ctxType) {
        if (!this.children || i2 < 0 || i2 >= this.children.length) {
          throw new RangeError("index parameter must be between >= 0 and <= number of children.");
        }
        if (ctxType == null) {
          return this.children[i2];
        }
        let result = this.tryGetChild(i2, ctxType);
        if (result === void 0) {
          throw new Error("The specified node does not exist");
        }
        return result;
      }
      tryGetChild(i2, ctxType) {
        if (!this.children || i2 < 0 || i2 >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o2 of this.children) {
          if (o2 instanceof ctxType) {
            j++;
            if (j === i2) {
              return o2;
            }
          }
        }
        return void 0;
      }
      getToken(ttype, i2) {
        let result = this.tryGetToken(ttype, i2);
        if (result === void 0) {
          throw new Error("The specified token does not exist");
        }
        return result;
      }
      tryGetToken(ttype, i2) {
        if (!this.children || i2 < 0 || i2 >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o2 of this.children) {
          if (o2 instanceof TerminalNode_1.TerminalNode) {
            let symbol = o2.symbol;
            if (symbol.type === ttype) {
              j++;
              if (j === i2) {
                return o2;
              }
            }
          }
        }
        return void 0;
      }
      getTokens(ttype) {
        let tokens = [];
        if (!this.children) {
          return tokens;
        }
        for (let o2 of this.children) {
          if (o2 instanceof TerminalNode_1.TerminalNode) {
            let symbol = o2.symbol;
            if (symbol.type === ttype) {
              tokens.push(o2);
            }
          }
        }
        return tokens;
      }
      get ruleContext() {
        return this;
      }
      // NOTE: argument order change from Java version
      getRuleContext(i2, ctxType) {
        return this.getChild(i2, ctxType);
      }
      tryGetRuleContext(i2, ctxType) {
        return this.tryGetChild(i2, ctxType);
      }
      getRuleContexts(ctxType) {
        let contexts = [];
        if (!this.children) {
          return contexts;
        }
        for (let o2 of this.children) {
          if (o2 instanceof ctxType) {
            contexts.push(o2);
          }
        }
        return contexts;
      }
      get childCount() {
        return this.children ? this.children.length : 0;
      }
      get sourceInterval() {
        if (!this._start) {
          return Interval_1.Interval.INVALID;
        }
        if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
          return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
        }
        return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
      }
      /**
       * Get the initial token in this context.
       * Note that the range from start to stop is inclusive, so for rules that do not consume anything
       * (for example, zero length or error productions) this token may exceed stop.
       */
      get start() {
        return this._start;
      }
      /**
       * Get the final token in this context.
       * Note that the range from start to stop is inclusive, so for rules that do not consume anything
       * (for example, zero length or error productions) this token may precede start.
       */
      get stop() {
        return this._stop;
      }
      /** Used for rule context info debugging during parse-time, not so much for ATN debugging */
      toInfoString(recognizer) {
        let rules = recognizer.getRuleInvocationStack(this).reverse();
        return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
      }
    };
    ParserRuleContext.EMPTY = new ParserRuleContext();
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext.prototype, "sourceInterval", null);
    exports2.ParserRuleContext = ParserRuleContext;
  }
});

// node_modules/antlr4ts/InterpreterRuleContext.js
var require_InterpreterRuleContext = __commonJS({
  "node_modules/antlr4ts/InterpreterRuleContext.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InterpreterRuleContext = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(ruleIndex, parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._ruleIndex = ruleIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InterpreterRuleContext.prototype, "ruleIndex", null);
    exports2.InterpreterRuleContext = InterpreterRuleContext;
  }
});

// node_modules/antlr4ts/ParserInterpreter.js
var require_ParserInterpreter = __commonJS({
  "node_modules/antlr4ts/ParserInterpreter.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParserInterpreter = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var InterpreterRuleContext_1 = require_InterpreterRuleContext();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var RecognitionException_1 = require_RecognitionException();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
      constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
        super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
        this._parentContextStack = [];
        this.overrideDecision = -1;
        this.overrideDecisionInputIndex = -1;
        this.overrideDecisionAlt = -1;
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
        if (grammarFileName instanceof ParserInterpreter2) {
          let old = grammarFileName;
          this._grammarFileName = old._grammarFileName;
          this._atn = old._atn;
          this.pushRecursionContextStates = old.pushRecursionContextStates;
          this._ruleNames = old._ruleNames;
          this._vocabulary = old._vocabulary;
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
        } else {
          vocabulary = vocabulary;
          ruleNames = ruleNames;
          atn = atn;
          this._grammarFileName = grammarFileName;
          this._atn = atn;
          this._ruleNames = ruleNames.slice(0);
          this._vocabulary = vocabulary;
          this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
          for (let state of atn.states) {
            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
              continue;
            }
            if (state.precedenceRuleDecision) {
              this.pushRecursionContextStates.set(state.stateNumber);
            }
          }
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
        }
      }
      reset(resetInput) {
        if (resetInput === void 0) {
          super.reset();
        } else {
          super.reset(resetInput);
        }
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
      }
      get atn() {
        return this._atn;
      }
      get vocabulary() {
        return this._vocabulary;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      /** Begin parsing at startRuleIndex */
      parse(startRuleIndex) {
        let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
        this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
        if (startRuleStartState.isPrecedenceRule) {
          this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
        } else {
          this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
        }
        while (true) {
          let p = this.atnState;
          switch (p.stateType) {
            case ATNStateType_1.ATNStateType.RULE_STOP:
              if (this._ctx.isEmpty) {
                if (startRuleStartState.isPrecedenceRule) {
                  let result = this._ctx;
                  let parentContext = this._parentContextStack.pop();
                  this.unrollRecursionContexts(parentContext[0]);
                  return result;
                } else {
                  this.exitRule();
                  return this._rootContext;
                }
              }
              this.visitRuleStopState(p);
              break;
            default:
              try {
                this.visitState(p);
              } catch (e) {
                if (e instanceof RecognitionException_1.RecognitionException) {
                  this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                  this.context.exception = e;
                  this.errorHandler.reportError(this, e);
                  this.recover(e);
                } else {
                  throw e;
                }
              }
              break;
          }
        }
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this._parentContextStack.push([this._ctx, localctx.invokingState]);
        super.enterRecursionRule(localctx, state, ruleIndex, precedence);
      }
      get atnState() {
        return this._atn.states[this.state];
      }
      visitState(p) {
        let predictedAlt = 1;
        if (p.numberOfTransitions > 1) {
          predictedAlt = this.visitDecisionState(p);
        }
        let transition = p.transition(predictedAlt - 1);
        switch (transition.serializationType) {
          case 1:
            if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
              let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
              let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
              this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
            }
            break;
          case 5:
            this.match(transition._label);
            break;
          case 2:
          case 7:
          case 8:
            if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
              this.recoverInline();
            }
            this.matchWildcard();
            break;
          case 9:
            this.matchWildcard();
            break;
          case 3:
            let ruleStartState = transition.target;
            let ruleIndex = ruleStartState.ruleIndex;
            let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
            if (ruleStartState.isPrecedenceRule) {
              this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
            } else {
              this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
            }
            break;
          case 4:
            let predicateTransition = transition;
            if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
              throw new FailedPredicateException_1.FailedPredicateException(this);
            }
            break;
          case 6:
            let actionTransition = transition;
            this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
            break;
          case 10:
            if (!this.precpred(this._ctx, transition.precedence)) {
              let precedence = transition.precedence;
              throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
            }
            break;
          default:
            throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
        }
        this.state = transition.target.stateNumber;
      }
      /** Method visitDecisionState() is called when the interpreter reaches
       *  a decision state (instance of DecisionState). It gives an opportunity
       *  for subclasses to track interesting things.
       */
      visitDecisionState(p) {
        let predictedAlt;
        this.errorHandler.sync(this);
        let decision = p.decision;
        if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
          predictedAlt = this.overrideDecisionAlt;
          this.overrideDecisionReached = true;
        } else {
          predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
        }
        return predictedAlt;
      }
      /** Provide simple "factory" for InterpreterRuleContext's.
       *  @since 4.5.1
       */
      createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
        return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
      }
      visitRuleStopState(p) {
        let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
        if (ruleStartState.isPrecedenceRule) {
          let parentContext = this._parentContextStack.pop();
          this.unrollRecursionContexts(parentContext[0]);
          this.state = parentContext[1];
        } else {
          this.exitRule();
        }
        let ruleTransition = this._atn.states[this.state].transition(0);
        this.state = ruleTransition.followState.stateNumber;
      }
      /** Override this parser interpreters normal decision-making process
       *  at a particular decision and input token index. Instead of
       *  allowing the adaptive prediction mechanism to choose the
       *  first alternative within a block that leads to a successful parse,
       *  force it to take the alternative, 1..n for n alternatives.
       *
       *  As an implementation limitation right now, you can only specify one
       *  override. This is sufficient to allow construction of different
       *  parse trees for ambiguous input. It means re-parsing the entire input
       *  in general because you're never sure where an ambiguous sequence would
       *  live in the various parse trees. For example, in one interpretation,
       *  an ambiguous input sequence would be matched completely in expression
       *  but in another it could match all the way back to the root.
       *
       *  s : e '!'? ;
       *  e : ID
       *    | ID '!'
       *    ;
       *
       *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first
       *  case, the ambiguous sequence is fully contained only by the root.
       *  In the second case, the ambiguous sequences fully contained within just
       *  e, as in: (e ID !).
       *
       *  Rather than trying to optimize this and make
       *  some intelligent decisions for optimization purposes, I settled on
       *  just re-parsing the whole input and then using
       *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal
       *  subtree that contains the ambiguous sequence. I originally tried to
       *  record the call stack at the point the parser detected and ambiguity but
       *  left recursive rules create a parse tree stack that does not reflect
       *  the actual call stack. That impedance mismatch was enough to make
       *  it it challenging to restart the parser at a deeply nested rule
       *  invocation.
       *
       *  Only parser interpreters can override decisions so as to avoid inserting
       *  override checking code in the critical ALL(*) prediction execution path.
       *
       *  @since 4.5
       */
      addDecisionOverride(decision, tokenIndex, forcedAlt) {
        this.overrideDecision = decision;
        this.overrideDecisionInputIndex = tokenIndex;
        this.overrideDecisionAlt = forcedAlt;
      }
      get overrideDecisionRoot() {
        return this._overrideDecisionRoot;
      }
      /** Rely on the error handler for this parser but, if no tokens are consumed
       *  to recover, add an error node. Otherwise, nothing is seen in the parse
       *  tree.
       */
      recover(e) {
        let i2 = this._input.index;
        this.errorHandler.recover(this, e);
        if (this._input.index === i2) {
          let tok = e.getOffendingToken();
          if (!tok) {
            throw new Error("Expected exception to have an offending token");
          }
          let source = tok.tokenSource;
          let stream5 = source !== void 0 ? source.inputStream : void 0;
          let sourcePair = { source, stream: stream5 };
          if (e instanceof InputMismatchException_1.InputMismatchException) {
            let expectedTokens = e.expectedTokens;
            if (expectedTokens === void 0) {
              throw new Error("Expected the exception to provide expected tokens");
            }
            let expectedTokenType = Token_1.Token.INVALID_TYPE;
            if (!expectedTokens.isNil) {
              expectedTokenType = expectedTokens.minElement;
            }
            let errToken = this.tokenFactory.create(
              sourcePair,
              expectedTokenType,
              tok.text,
              Token_1.Token.DEFAULT_CHANNEL,
              -1,
              -1,
              // invalid start/stop
              tok.line,
              tok.charPositionInLine
            );
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          } else {
            let source2 = tok.tokenSource;
            let errToken = this.tokenFactory.create(
              sourcePair,
              Token_1.Token.INVALID_TYPE,
              tok.text,
              Token_1.Token.DEFAULT_CHANNEL,
              -1,
              -1,
              // invalid start/stop
              tok.line,
              tok.charPositionInLine
            );
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          }
        }
      }
      recoverInline() {
        return this._errHandler.recoverInline(this);
      }
      /** Return the root of the parse, which can be useful if the parser
       *  bails out. You still can access the top node. Note that,
       *  because of the way left recursive rules add children, it's possible
       *  that the root will not have any children if the start rule immediately
       *  called and left recursive rule that fails.
       *
       * @since 4.5.1
       */
      get rootContext() {
        return this._rootContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "reset", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "vocabulary", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "enterRecursionRule", null);
    ParserInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], ParserInterpreter);
    exports2.ParserInterpreter = ParserInterpreter;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
var require_ParseTreeMatch = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParseTreeMatch = void 0;
    var Decorators_1 = require_Decorators();
    var ParseTreeMatch = class ParseTreeMatch {
      /**
       * Constructs a new instance of {@link ParseTreeMatch} from the specified
       * parse tree and pattern.
       *
       * @param tree The parse tree to match against the pattern.
       * @param pattern The parse tree pattern.
       * @param labels A mapping from label names to collections of
       * {@link ParseTree} objects located by the tree pattern matching process.
       * @param mismatchedNode The first node which failed to match the tree
       * pattern during the matching process.
       *
       * @throws {@link Error} if `tree` is not defined
       * @throws {@link Error} if `pattern` is not defined
       * @throws {@link Error} if `labels` is not defined
       */
      constructor(tree, pattern, labels, mismatchedNode) {
        if (!tree) {
          throw new Error("tree cannot be null");
        }
        if (!pattern) {
          throw new Error("pattern cannot be null");
        }
        if (!labels) {
          throw new Error("labels cannot be null");
        }
        this._tree = tree;
        this._pattern = pattern;
        this._labels = labels;
        this._mismatchedNode = mismatchedNode;
      }
      /**
       * Get the last node associated with a specific `label`.
       *
       * For example, for pattern `<id:ID>`, `get("id")` returns the
       * node matched for that `ID`. If more than one node
       * matched the specified label, only the last is returned. If there is
       * no node associated with the label, this returns `undefined`.
       *
       * Pattern tags like `<ID>` and `<expr>` without labels are
       * considered to be labeled with `ID` and `expr`, respectively.
       *
       * @param label The label to check.
       *
       * @returns The last {@link ParseTree} to match a tag with the specified
       * label, or `undefined` if no parse tree matched a tag with the label.
       */
      get(label) {
        let parseTrees = this._labels.get(label);
        if (!parseTrees || parseTrees.length === 0) {
          return void 0;
        }
        return parseTrees[parseTrees.length - 1];
      }
      /**
       * Return all nodes matching a rule or token tag with the specified label.
       *
       * If the `label` is the name of a parser rule or token in the
       * grammar, the resulting list will contain both the parse trees matching
       * rule or tags explicitly labeled with the label and the complete set of
       * parse trees matching the labeled and unlabeled tags in the pattern for
       * the parser rule or token. For example, if `label` is `"foo"`,
       * the result will contain *all* of the following.
       *
       * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
       *   `<foo:AnyTokenName>`.
       * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.
       * * Parse tree nodes matching tags of the form `<foo>`.
       *
       * @param label The label.
       *
       * @returns A collection of all {@link ParseTree} nodes matching tags with
       * the specified `label`. If no nodes matched the label, an empty list
       * is returned.
       */
      getAll(label) {
        const nodes = this._labels.get(label);
        if (!nodes) {
          return [];
        }
        return nodes;
      }
      /**
       * Return a mapping from label &rarr; [list of nodes].
       *
       * The map includes special entries corresponding to the names of rules and
       * tokens referenced in tags in the original pattern. For additional
       * information, see the description of {@link #getAll(String)}.
       *
       * @returns A mapping from labels to parse tree nodes. If the parse tree
       * pattern did not contain any rule or token tags, this map will be empty.
       */
      get labels() {
        return this._labels;
      }
      /**
       * Get the node at which we first detected a mismatch.
       *
       * @returns the node at which we first detected a mismatch, or `undefined`
       * if the match was successful.
       */
      get mismatchedNode() {
        return this._mismatchedNode;
      }
      /**
       * Gets a value indicating whether the match operation succeeded.
       *
       * @returns `true` if the match operation succeeded; otherwise,
       * `false`.
       */
      get succeeded() {
        return !this._mismatchedNode;
      }
      /**
       * Get the tree pattern we are matching against.
       *
       * @returns The tree pattern we are matching against.
       */
      get pattern() {
        return this._pattern;
      }
      /**
       * Get the parse tree we are trying to match to a pattern.
       *
       * @returns The {@link ParseTree} we are trying to match to a pattern.
       */
      get tree() {
        return this._tree;
      }
      /**
       * {@inheritDoc}
       */
      toString() {
        return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreeMatch.prototype, "getAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "labels", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "tree", null);
    __decorate([
      Decorators_1.Override
    ], ParseTreeMatch.prototype, "toString", null);
    ParseTreeMatch = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreeMatch);
    exports2.ParseTreeMatch = ParseTreeMatch;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexer.js
var require_XPathLexer = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathLexer = void 0;
    var ATNDeserializer_1 = require_ATNDeserializer();
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var Utils = require_Utils();
    var XPathLexer = class _XPathLexer extends Lexer_1.Lexer {
      // tslint:enable:no-trailing-whitespace
      constructor(input) {
        super(input);
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(_XPathLexer._ATN, this);
      }
      // @Override
      // @NotNull
      get vocabulary() {
        return _XPathLexer.VOCABULARY;
      }
      // @Override
      get grammarFileName() {
        return "XPathLexer.g4";
      }
      // @Override
      get ruleNames() {
        return _XPathLexer.ruleNames;
      }
      // @Override
      get serializedATN() {
        return _XPathLexer._serializedATN;
      }
      // @Override
      get channelNames() {
        return _XPathLexer.channelNames;
      }
      // @Override
      get modeNames() {
        return _XPathLexer.modeNames;
      }
      // @Override
      action(_localctx, ruleIndex, actionIndex) {
        switch (ruleIndex) {
          case 4:
            this.ID_action(_localctx, actionIndex);
            break;
        }
      }
      ID_action(_localctx, actionIndex) {
        switch (actionIndex) {
          case 0:
            let text2 = this.text;
            if (text2.charAt(0) === text2.charAt(0).toUpperCase()) {
              this.type = _XPathLexer.TOKEN_REF;
            } else {
              this.type = _XPathLexer.RULE_REF;
            }
            break;
        }
      }
      static get _ATN() {
        if (!_XPathLexer.__ATN) {
          _XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(_XPathLexer._serializedATN));
        }
        return _XPathLexer.__ATN;
      }
    };
    exports2.XPathLexer = XPathLexer;
    XPathLexer.TOKEN_REF = 1;
    XPathLexer.RULE_REF = 2;
    XPathLexer.ANYWHERE = 3;
    XPathLexer.ROOT = 4;
    XPathLexer.WILDCARD = 5;
    XPathLexer.BANG = 6;
    XPathLexer.ID = 7;
    XPathLexer.STRING = 8;
    XPathLexer.channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    XPathLexer.modeNames = [
      "DEFAULT_MODE"
    ];
    XPathLexer.ruleNames = [
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "NameChar",
      "NameStartChar",
      "STRING"
    ];
    XPathLexer._LITERAL_NAMES = [
      void 0,
      void 0,
      void 0,
      "'//'",
      "'/'",
      "'*'",
      "'!'"
    ];
    XPathLexer._SYMBOLIC_NAMES = [
      void 0,
      "TOKEN_REF",
      "RULE_REF",
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "STRING"
    ];
    XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
    XPathLexer._serializedATNSegments = 2;
    XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
    XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
    XPathLexer._serializedATN = Utils.join([
      XPathLexer._serializedATNSegment0,
      XPathLexer._serializedATNSegment1
    ], "");
  }
});

// node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
var require_XPathLexerErrorListener = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathLexerErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var XPathLexerErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathLexerErrorListener.prototype, "syntaxError", null);
    exports2.XPathLexerErrorListener = XPathLexerErrorListener;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathElement.js
var require_XPathElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathElement.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathElement = void 0;
    var Decorators_1 = require_Decorators();
    var XPathElement = class {
      /** Construct element like `/ID` or `ID` or `/*` etc...
       *  op is null if just node
       */
      constructor(nodeName) {
        this.nodeName = nodeName;
        this.invert = false;
      }
      toString() {
        let inv = this.invert ? "!" : "";
        let className = Object.constructor.name;
        return className + "[" + inv + this.nodeName + "]";
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathElement.prototype, "toString", null);
    exports2.XPathElement = XPathElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
var require_XPathRuleAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathRuleAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleAnywhereElement.prototype, "evaluate", null);
    exports2.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
var require_XPathRuleElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathRuleElement = void 0;
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        let nodes = [];
        for (let c3 of Trees_1.Trees.getChildren(t)) {
          if (c3 instanceof ParserRuleContext_1.ParserRuleContext) {
            if (c3.ruleIndex === this.ruleIndex && !this.invert || c3.ruleIndex !== this.ruleIndex && this.invert) {
              nodes.push(c3);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleElement.prototype, "evaluate", null);
    exports2.XPathRuleElement = XPathRuleElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
var require_XPathTokenAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathTokenAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenAnywhereElement.prototype, "evaluate", null);
    exports2.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
var require_XPathTokenElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathTokenElement = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        let nodes = [];
        for (let c3 of Trees_1.Trees.getChildren(t)) {
          if (c3 instanceof TerminalNode_1.TerminalNode) {
            if (c3.symbol.type === this.tokenType && !this.invert || c3.symbol.type !== this.tokenType && this.invert) {
              nodes.push(c3);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenElement.prototype, "evaluate", null);
    exports2.XPathTokenElement = XPathTokenElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
var require_XPathWildcardAnywhereElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathWildcardAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        if (this.invert) {
          return [];
        }
        return Trees_1.Trees.getDescendants(t);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
    exports2.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
var require_XPathWildcardElement = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPathWildcardElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        let kids = [];
        if (this.invert) {
          return kids;
        }
        for (let c3 of Trees_1.Trees.getChildren(t)) {
          kids.push(c3);
        }
        return kids;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardElement.prototype, "evaluate", null);
    exports2.XPathWildcardElement = XPathWildcardElement;
  }
});

// node_modules/antlr4ts/tree/xpath/XPath.js
var require_XPath = __commonJS({
  "node_modules/antlr4ts/tree/xpath/XPath.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XPath = void 0;
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Token_1 = require_Token();
    var XPathLexer_1 = require_XPathLexer();
    var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
    var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
    var XPathRuleElement_1 = require_XPathRuleElement();
    var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
    var XPathTokenElement_1 = require_XPathTokenElement();
    var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
    var XPathWildcardElement_1 = require_XPathWildcardElement();
    var XPath = class _XPath {
      constructor(parser, path15) {
        this.parser = parser;
        this.path = path15;
        this.elements = this.split(path15);
      }
      // TODO: check for invalid token/rule names, bad syntax
      split(path15) {
        let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path15));
        lexer.recover = (e) => {
          throw e;
        };
        lexer.removeErrorListeners();
        lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
        let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
        try {
          tokenStream.fill();
        } catch (e) {
          if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
            let pos = lexer.charPositionInLine;
            let msg = "Invalid tokens or characters at index " + pos + " in path '" + path15 + "' -- " + e.message;
            throw new RangeError(msg);
          }
          throw e;
        }
        let tokens = tokenStream.getTokens();
        let elements = [];
        let n2 = tokens.length;
        let i2 = 0;
        loop: while (i2 < n2) {
          let el = tokens[i2];
          let next;
          switch (el.type) {
            case XPathLexer_1.XPathLexer.ROOT:
            case XPathLexer_1.XPathLexer.ANYWHERE:
              let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
              i2++;
              next = tokens[i2];
              let invert = next.type === XPathLexer_1.XPathLexer.BANG;
              if (invert) {
                i2++;
                next = tokens[i2];
              }
              let pathElement = this.getXPathElement(next, anywhere);
              pathElement.invert = invert;
              elements.push(pathElement);
              i2++;
              break;
            case XPathLexer_1.XPathLexer.TOKEN_REF:
            case XPathLexer_1.XPathLexer.RULE_REF:
            case XPathLexer_1.XPathLexer.WILDCARD:
              elements.push(this.getXPathElement(el, false));
              i2++;
              break;
            case Token_1.Token.EOF:
              break loop;
            default:
              throw new Error("Unknowth path element " + el);
          }
        }
        return elements;
      }
      /**
       * Convert word like `*` or `ID` or `expr` to a path
       * element. `anywhere` is `true` if `//` precedes the
       * word.
       */
      getXPathElement(wordToken, anywhere) {
        if (wordToken.type === Token_1.Token.EOF) {
          throw new Error("Missing path element at end of path");
        }
        let word = wordToken.text;
        if (word == null) {
          throw new Error("Expected wordToken to have text content.");
        }
        let ttype = this.parser.getTokenType(word);
        let ruleIndex = this.parser.getRuleIndex(word);
        switch (wordToken.type) {
          case XPathLexer_1.XPathLexer.WILDCARD:
            return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
          case XPathLexer_1.XPathLexer.TOKEN_REF:
          case XPathLexer_1.XPathLexer.STRING:
            if (ttype === Token_1.Token.INVALID_TYPE) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
            }
            return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
          default:
            if (ruleIndex === -1) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
            }
            return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
        }
      }
      static findAll(tree, xpath, parser) {
        let p = new _XPath(parser, xpath);
        return p.evaluate(tree);
      }
      /**
       * Return a list of all nodes starting at `t` as root that satisfy the
       * path. The root `/` is relative to the node passed to {@link evaluate}.
       */
      evaluate(t) {
        let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
        dummyRoot.addChild(t);
        let work = /* @__PURE__ */ new Set([dummyRoot]);
        let i2 = 0;
        while (i2 < this.elements.length) {
          let next = /* @__PURE__ */ new Set();
          for (let node of work) {
            if (node.childCount > 0) {
              let matching = this.elements[i2].evaluate(node);
              matching.forEach(next.add, next);
            }
          }
          i2++;
          work = next;
        }
        return work;
      }
    };
    exports2.XPath = XPath;
    XPath.WILDCARD = "*";
    XPath.NOT = "!";
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
var require_ParseTreePattern = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParseTreePattern = void 0;
    var Decorators_1 = require_Decorators();
    var XPath_1 = require_XPath();
    var ParseTreePattern = class ParseTreePattern {
      /**
       * Construct a new instance of the {@link ParseTreePattern} class.
       *
       * @param matcher The {@link ParseTreePatternMatcher} which created this
       * tree pattern.
       * @param pattern The tree pattern in concrete syntax form.
       * @param patternRuleIndex The parser rule which serves as the root of the
       * tree pattern.
       * @param patternTree The tree pattern in {@link ParseTree} form.
       */
      constructor(matcher, pattern, patternRuleIndex, patternTree) {
        this._matcher = matcher;
        this._patternRuleIndex = patternRuleIndex;
        this._pattern = pattern;
        this._patternTree = patternTree;
      }
      /**
       * Match a specific parse tree against this tree pattern.
       *
       * @param tree The parse tree to match against this tree pattern.
       * @returns A {@link ParseTreeMatch} object describing the result of the
       * match operation. The `ParseTreeMatch.succeeded` method can be
       * used to determine whether or not the match was successful.
       */
      match(tree) {
        return this._matcher.match(tree, this);
      }
      /**
       * Determine whether or not a parse tree matches this tree pattern.
       *
       * @param tree The parse tree to match against this tree pattern.
       * @returns `true` if `tree` is a match for the current tree
       * pattern; otherwise, `false`.
       */
      matches(tree) {
        return this._matcher.match(tree, this).succeeded;
      }
      /**
       * Find all nodes using XPath and then try to match those subtrees against
       * this tree pattern.
       *
       * @param tree The {@link ParseTree} to match against this pattern.
       * @param xpath An expression matching the nodes
       *
       * @returns A collection of {@link ParseTreeMatch} objects describing the
       * successful matches. Unsuccessful matches are omitted from the result,
       * regardless of the reason for the failure.
       */
      findAll(tree, xpath) {
        let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
        let matches = [];
        for (let t of subtrees) {
          let match3 = this.match(t);
          if (match3.succeeded) {
            matches.push(match3);
          }
        }
        return matches;
      }
      /**
       * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
       *
       * @returns The {@link ParseTreePatternMatcher} which created this tree
       * pattern.
       */
      get matcher() {
        return this._matcher;
      }
      /**
       * Get the tree pattern in concrete syntax form.
       *
       * @returns The tree pattern in concrete syntax form.
       */
      get pattern() {
        return this._pattern;
      }
      /**
       * Get the parser rule which serves as the outermost rule for the tree
       * pattern.
       *
       * @returns The parser rule which serves as the outermost rule for the tree
       * pattern.
       */
      get patternRuleIndex() {
        return this._patternRuleIndex;
      }
      /**
       * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
       * the pattern are present in the parse tree as terminal nodes with a symbol
       * of type {@link RuleTagToken} or {@link TokenTagToken}.
       *
       * @returns The tree pattern as a {@link ParseTree}.
       */
      get patternTree() {
        return this._patternTree;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_pattern", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_patternTree", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_matcher", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "match", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "matches", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "findAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "matcher", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "patternTree", null);
    ParseTreePattern = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParseTreePattern);
    exports2.ParseTreePattern = ParseTreePattern;
  }
});

// node_modules/antlr4ts/tree/pattern/RuleTagToken.js
var require_RuleTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/RuleTagToken.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleTagToken = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var RuleTagToken = class RuleTagToken {
      /**
       * Constructs a new instance of {@link RuleTagToken} with the specified rule
       * name, bypass token type, and label.
       *
       * @param ruleName The name of the parser rule this rule tag matches.
       * @param bypassTokenType The bypass token type assigned to the parser rule.
       * @param label The label associated with the rule tag, or `undefined` if
       * the rule tag is unlabeled.
       *
       * @exception IllegalArgumentException if `ruleName` is not defined
       * or empty.
       */
      constructor(ruleName, bypassTokenType, label) {
        if (ruleName == null || ruleName.length === 0) {
          throw new Error("ruleName cannot be null or empty.");
        }
        this._ruleName = ruleName;
        this.bypassTokenType = bypassTokenType;
        this._label = label;
      }
      /**
       * Gets the name of the rule associated with this rule tag.
       *
       * @returns The name of the parser rule associated with this rule tag.
       */
      get ruleName() {
        return this._ruleName;
      }
      /**
       * Gets the label associated with the rule tag.
       *
       * @returns The name of the label associated with the rule tag, or
       * `undefined` if this is an unlabeled rule tag.
       */
      get label() {
        return this._label;
      }
      /**
       * {@inheritDoc}
       *
       * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
       */
      get channel() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      /**
       * {@inheritDoc}
       *
       * This method returns the rule tag formatted with `<` and `>`
       * delimiters.
       */
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._ruleName + ">";
        }
        return "<" + this._ruleName + ">";
      }
      /**
       * {@inheritDoc}
       *
       * Rule tag tokens have types assigned according to the rule bypass
       * transitions created during ATN deserialization.
       */
      get type() {
        return this.bypassTokenType;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns 0.
       */
      get line() {
        return 0;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get charPositionInLine() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get tokenIndex() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get startIndex() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get stopIndex() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns `undefined`.
       */
      get tokenSource() {
        return void 0;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns `undefined`.
       */
      get inputStream() {
        return void 0;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} returns a string of the form
       * `ruleName:bypassTokenType`.
       */
      toString() {
        return this._ruleName + ":" + this.bypassTokenType;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTagToken.prototype, "ruleName", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "toString", null);
    RuleTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RuleTagToken);
    exports2.RuleTagToken = RuleTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/Chunk.js
var require_Chunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/Chunk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Chunk = void 0;
    var Chunk = class {
    };
    exports2.Chunk = Chunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TagChunk.js
var require_TagChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TagChunk.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TagChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TagChunk = class extends Chunk_1.Chunk {
      /**
       * Construct a new instance of {@link TagChunk} using the specified label
       * and tag.
       *
       * @param label The label for the tag. If this is `undefined`, the
       * {@link TagChunk} represents an unlabeled tag.
       * @param tag The tag, which should be the name of a parser rule or token
       * type.
       *
       * @exception IllegalArgumentException if `tag` is not defined or
       * empty.
       */
      constructor(tag, label) {
        super();
        if (tag == null || tag.length === 0) {
          throw new Error("tag cannot be null or empty");
        }
        this._tag = tag;
        this._label = label;
      }
      /**
       * Get the tag for this chunk.
       *
       * @returns The tag for the chunk.
       */
      get tag() {
        return this._tag;
      }
      /**
       * Get the label, if any, assigned to this chunk.
       *
       * @returns The label assigned to this chunk, or `undefined` if no label is
       * assigned to the chunk.
       */
      get label() {
        return this._label;
      }
      /**
       * This method returns a text representation of the tag chunk. Labeled tags
       * are returned in the form `label:tag`, and unlabeled tags are
       * returned as just the tag name.
       */
      toString() {
        if (this._label != null) {
          return this._label + ":" + this._tag;
        }
        return this._tag;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TagChunk.prototype, "tag", null);
    __decorate([
      Decorators_1.Override
    ], TagChunk.prototype, "toString", null);
    exports2.TagChunk = TagChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TextChunk.js
var require_TextChunk = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TextChunk.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TextChunk = class TextChunk extends Chunk_1.Chunk {
      /**
       * Constructs a new instance of {@link TextChunk} with the specified text.
       *
       * @param text The text of this chunk.
       * @exception IllegalArgumentException if `text` is not defined.
       */
      constructor(text2) {
        super();
        if (text2 == null) {
          throw new Error("text cannot be null");
        }
        this._text = text2;
      }
      /**
       * Gets the raw text of this chunk.
       *
       * @returns The text of the chunk.
       */
      get text() {
        return this._text;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link TextChunk} returns the result of
       * `text` in single quotes.
       */
      toString() {
        return "'" + this._text + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "_text", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TextChunk.prototype, "toString", null);
    TextChunk = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TextChunk);
    exports2.TextChunk = TextChunk;
  }
});

// node_modules/antlr4ts/tree/pattern/TokenTagToken.js
var require_TokenTagToken = __commonJS({
  "node_modules/antlr4ts/tree/pattern/TokenTagToken.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenTagToken = void 0;
    var CommonToken_1 = require_CommonToken();
    var Decorators_1 = require_Decorators();
    var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
      /**
       * Constructs a new instance of {@link TokenTagToken} with the specified
       * token name, type, and label.
       *
       * @param tokenName The token name.
       * @param type The token type.
       * @param label The label associated with the token tag, or `undefined` if
       * the token tag is unlabeled.
       */
      constructor(tokenName, type, label) {
        super(type);
        this._tokenName = tokenName;
        this._label = label;
      }
      /**
       * Gets the token name.
       * @returns The token name.
       */
      get tokenName() {
        return this._tokenName;
      }
      /**
       * Gets the label associated with the rule tag.
       *
       * @returns The name of the label associated with the rule tag, or
       * `undefined` if this is an unlabeled rule tag.
       */
      get label() {
        return this._label;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link TokenTagToken} returns the token tag
       * formatted with `<` and `>` delimiters.
       */
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._tokenName + ">";
        }
        return "<" + this._tokenName + ">";
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link TokenTagToken} returns a string of the form
       * `tokenName:type`.
       */
      toString() {
        return this._tokenName + ":" + this.type;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "_tokenName", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "tokenName", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "toString", null);
    TokenTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TokenTagToken);
    exports2.TokenTagToken = TokenTagToken;
  }
});

// node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
var require_ParseTreePatternMatcher = __commonJS({
  "node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParseTreePatternMatcher = void 0;
    var BailErrorStrategy_1 = require_BailErrorStrategy();
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var ListTokenSource_1 = require_ListTokenSource();
    var MultiMap_1 = require_MultiMap();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var ParserInterpreter_1 = require_ParserInterpreter();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var ParseTreeMatch_1 = require_ParseTreeMatch();
    var ParseTreePattern_1 = require_ParseTreePattern();
    var RecognitionException_1 = require_RecognitionException();
    var RuleNode_1 = require_RuleNode();
    var RuleTagToken_1 = require_RuleTagToken();
    var TagChunk_1 = require_TagChunk();
    var TerminalNode_1 = require_TerminalNode();
    var TextChunk_1 = require_TextChunk();
    var Token_1 = require_Token();
    var TokenTagToken_1 = require_TokenTagToken();
    var ParseTreePatternMatcher = class _ParseTreePatternMatcher {
      /**
       * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
       * {@link Parser} object. The lexer input stream is altered for tokenizing
       * the tree patterns. The parser is used as a convenient mechanism to get
       * the grammar name, plus token, rule names.
       */
      constructor(lexer, parser) {
        this.start = "<";
        this.stop = ">";
        this.escape = "\\";
        this.escapeRE = /\\/g;
        this._lexer = lexer;
        this._parser = parser;
      }
      /**
       * Set the delimiters used for marking rule and token tags within concrete
       * syntax used by the tree pattern parser.
       *
       * @param start The start delimiter.
       * @param stop The stop delimiter.
       * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
       *
       * @throws {@link Error} if `start` is not defined or empty.
       * @throws {@link Error} if `stop` is not defined or empty.
       */
      setDelimiters(start, stop, escapeLeft) {
        if (!start) {
          throw new Error("start cannot be null or empty");
        }
        if (!stop) {
          throw new Error("stop cannot be null or empty");
        }
        this.start = start;
        this.stop = stop;
        this.escape = escapeLeft;
        this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
      }
      matches(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.matches(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return !mismatchedNode;
        }
      }
      // Implementation of match
      match(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.match(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
        }
      }
      /**
       * For repeated use of a tree pattern, compile it to a
       * {@link ParseTreePattern} using this method.
       */
      compile(pattern, patternRuleIndex) {
        let tokenList = this.tokenize(pattern);
        let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
        let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
        const parser = this._parser;
        let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
        let tree;
        try {
          parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
          tree = parserInterp.parse(patternRuleIndex);
        } catch (e) {
          if (e instanceof ParseCancellationException_1.ParseCancellationException) {
            throw e.getCause();
          } else if (e instanceof RecognitionException_1.RecognitionException) {
            throw e;
          } else if (e instanceof Error) {
            throw new _ParseTreePatternMatcher.CannotInvokeStartRule(e);
          } else {
            throw e;
          }
        }
        if (tokens.LA(1) !== Token_1.Token.EOF) {
          throw new _ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
        }
        return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
      }
      /**
       * Used to convert the tree pattern string into a series of tokens. The
       * input stream is reset.
       */
      get lexer() {
        return this._lexer;
      }
      /**
       * Used to collect to the grammar file name, token names, rule names for
       * used to parse the pattern into a parse tree.
       */
      get parser() {
        return this._parser;
      }
      // ---- SUPPORT CODE ----
      /**
       * Recursively walk `tree` against `patternTree`, filling
       * `match.`{@link ParseTreeMatch#labels labels}.
       *
       * @returns the first node encountered in `tree` which does not match
       * a corresponding node in `patternTree`, or `undefined` if the match
       * was successful. The specific node returned depends on the matching
       * algorithm used by the implementation, and may be overridden.
       */
      matchImpl(tree, patternTree, labels) {
        if (!tree) {
          throw new TypeError("tree cannot be null");
        }
        if (!patternTree) {
          throw new TypeError("patternTree cannot be null");
        }
        if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
          let mismatchedNode;
          if (tree.symbol.type === patternTree.symbol.type) {
            if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
              let tokenTagToken = patternTree.symbol;
              labels.map(tokenTagToken.tokenName, tree);
              const l = tokenTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else if (tree.text === patternTree.text) {
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
          return mismatchedNode;
        }
        if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
          let mismatchedNode;
          let ruleTagToken = this.getRuleTagToken(patternTree);
          if (ruleTagToken) {
            let m;
            if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
              labels.map(ruleTagToken.ruleName, tree);
              const l = ruleTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree.childCount !== patternTree.childCount) {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
            return mismatchedNode;
          }
          let n2 = tree.childCount;
          for (let i2 = 0; i2 < n2; i2++) {
            let childMatch = this.matchImpl(tree.getChild(i2), patternTree.getChild(i2), labels);
            if (childMatch) {
              return childMatch;
            }
          }
          return mismatchedNode;
        }
        return tree;
      }
      /** Is `t` `(expr <expr>)` subtree? */
      getRuleTagToken(t) {
        if (t instanceof RuleNode_1.RuleNode) {
          if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
            let c3 = t.getChild(0);
            if (c3.symbol instanceof RuleTagToken_1.RuleTagToken) {
              return c3.symbol;
            }
          }
        }
        return void 0;
      }
      tokenize(pattern) {
        let chunks = this.split(pattern);
        let tokens = [];
        for (let chunk of chunks) {
          if (chunk instanceof TagChunk_1.TagChunk) {
            let tagChunk = chunk;
            const firstChar = tagChunk.tag.substr(0, 1);
            if (firstChar === firstChar.toUpperCase()) {
              let ttype = this._parser.getTokenType(tagChunk.tag);
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
              }
              let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
              tokens.push(t);
            } else if (firstChar === firstChar.toLowerCase()) {
              let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
              if (ruleIndex === -1) {
                throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
              }
              let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
              tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
            } else {
              throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
            }
          } else {
            let textChunk = chunk;
            this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
            let t = this._lexer.nextToken();
            while (t.type !== Token_1.Token.EOF) {
              tokens.push(t);
              t = this._lexer.nextToken();
            }
          }
        }
        return tokens;
      }
      /** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */
      split(pattern) {
        let p = 0;
        let n2 = pattern.length;
        let chunks = [];
        let buf;
        let starts = [];
        let stops = [];
        while (p < n2) {
          if (p === pattern.indexOf(this.escape + this.start, p)) {
            p += this.escape.length + this.start.length;
          } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
            p += this.escape.length + this.stop.length;
          } else if (p === pattern.indexOf(this.start, p)) {
            starts.push(p);
            p += this.start.length;
          } else if (p === pattern.indexOf(this.stop, p)) {
            stops.push(p);
            p += this.stop.length;
          } else {
            p++;
          }
        }
        if (starts.length > stops.length) {
          throw new Error("unterminated tag in pattern: " + pattern);
        }
        if (starts.length < stops.length) {
          throw new Error("missing start tag in pattern: " + pattern);
        }
        let ntags = starts.length;
        for (let i2 = 0; i2 < ntags; i2++) {
          if (starts[i2] >= stops[i2]) {
            throw new Error("tag delimiters out of order in pattern: " + pattern);
          }
        }
        if (ntags === 0) {
          let text2 = pattern.substring(0, n2);
          chunks.push(new TextChunk_1.TextChunk(text2));
        }
        if (ntags > 0 && starts[0] > 0) {
          let text2 = pattern.substring(0, starts[0]);
          chunks.push(new TextChunk_1.TextChunk(text2));
        }
        for (let i2 = 0; i2 < ntags; i2++) {
          let tag = pattern.substring(starts[i2] + this.start.length, stops[i2]);
          let ruleOrToken = tag;
          let label;
          let colon = tag.indexOf(":");
          if (colon >= 0) {
            label = tag.substring(0, colon);
            ruleOrToken = tag.substring(colon + 1, tag.length);
          }
          chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
          if (i2 + 1 < ntags) {
            let text2 = pattern.substring(stops[i2] + this.stop.length, starts[i2 + 1]);
            chunks.push(new TextChunk_1.TextChunk(text2));
          }
        }
        if (ntags > 0) {
          let afterLastTag = stops[ntags - 1] + this.stop.length;
          if (afterLastTag < n2) {
            let text2 = pattern.substring(afterLastTag, n2);
            chunks.push(new TextChunk_1.TextChunk(text2));
          }
        }
        for (let i2 = 0; i2 < chunks.length; i2++) {
          let c3 = chunks[i2];
          if (c3 instanceof TextChunk_1.TextChunk) {
            let unescaped = c3.text.replace(this.escapeRE, "");
            if (unescaped.length < c3.text.length) {
              chunks[i2] = new TextChunk_1.TextChunk(unescaped);
            }
          }
        }
        return chunks;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "lexer", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "parser", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "matchImpl", null);
    exports2.ParseTreePatternMatcher = ParseTreePatternMatcher;
    (function(ParseTreePatternMatcher2) {
      class CannotInvokeStartRule extends Error {
        constructor(error) {
          super(`CannotInvokeStartRule: ${error}`);
          this.error = error;
        }
      }
      ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
      class StartRuleDoesNotConsumeFullPattern extends Error {
        constructor() {
          super("StartRuleDoesNotConsumeFullPattern");
        }
      }
      ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
    })(ParseTreePatternMatcher = exports2.ParseTreePatternMatcher || (exports2.ParseTreePatternMatcher = {}));
  }
});

// node_modules/antlr4ts/atn/DecisionEventInfo.js
var require_DecisionEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionEventInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecisionEventInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionEventInfo = class DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
        this.decision = decision;
        this.fullCtx = fullCtx;
        this.stopIndex = stopIndex;
        this.input = input;
        this.startIndex = startIndex;
        this.state = state;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DecisionEventInfo.prototype, "input", void 0);
    DecisionEventInfo = __decorate([
      __param(2, Decorators_1.NotNull)
    ], DecisionEventInfo);
    exports2.DecisionEventInfo = DecisionEventInfo;
  }
});

// node_modules/antlr4ts/atn/AmbiguityInfo.js
var require_AmbiguityInfo = __commonJS({
  "node_modules/antlr4ts/atn/AmbiguityInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AmbiguityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link AmbiguityInfo} class with the
       * specified detailed ambiguity information.
       *
       * @param decision The decision number
       * @param state The final simulator state identifying the ambiguous
       * alternatives for the current input
       * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.
       *                  The predicted alt is the min(ambigAlts)
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the ambiguity was identified during
       * prediction
       */
      constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.ambigAlts = ambigAlts;
      }
      /**
       * Gets the set of alternatives in the decision that lead to a valid parse.
       *
       * @since 4.5
       */
      get ambiguousAlternatives() {
        return this.ambigAlts;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambigAlts", void 0);
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
    AmbiguityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], AmbiguityInfo);
    exports2.AmbiguityInfo = AmbiguityInfo;
  }
});

// node_modules/antlr4ts/atn/ContextSensitivityInfo.js
var require_ContextSensitivityInfo = __commonJS({
  "node_modules/antlr4ts/atn/ContextSensitivityInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContextSensitivityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link ContextSensitivityInfo} class
       * with the specified detailed context sensitivity information.
       *
       * @param decision The decision number
       * @param state The final simulator state containing the unique
       * alternative identified by full-context prediction
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the context sensitivity was
       * identified during full-context prediction
       */
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, true);
      }
    };
    ContextSensitivityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ContextSensitivityInfo);
    exports2.ContextSensitivityInfo = ContextSensitivityInfo;
  }
});

// node_modules/antlr4ts/atn/DecisionInfo.js
var require_DecisionInfo = __commonJS({
  "node_modules/antlr4ts/atn/DecisionInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DecisionInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionInfo = class {
      /**
       * Constructs a new instance of the {@link DecisionInfo} class to contain
       * statistics for a particular decision.
       *
       * @param decision The decision number
       */
      constructor(decision) {
        this.invocations = 0;
        this.timeInPrediction = 0;
        this.SLL_TotalLook = 0;
        this.SLL_MinLook = 0;
        this.SLL_MaxLook = 0;
        this.LL_TotalLook = 0;
        this.LL_MinLook = 0;
        this.LL_MaxLook = 0;
        this.contextSensitivities = [];
        this.errors = [];
        this.ambiguities = [];
        this.predicateEvals = [];
        this.SLL_ATNTransitions = 0;
        this.SLL_DFATransitions = 0;
        this.LL_Fallback = 0;
        this.LL_ATNTransitions = 0;
        this.LL_DFATransitions = 0;
        this.decision = decision;
      }
      toString() {
        return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
      }
    };
    __decorate([
      Decorators_1.Override
    ], DecisionInfo.prototype, "toString", null);
    exports2.DecisionInfo = DecisionInfo;
  }
});

// node_modules/antlr4ts/atn/ErrorInfo.js
var require_ErrorInfo = __commonJS({
  "node_modules/antlr4ts/atn/ErrorInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link ErrorInfo} class with the
       * specified detailed syntax error information.
       *
       * @param decision The decision number
       * @param state The final simulator state reached during prediction
       * prior to reaching the {@link ATNSimulator#ERROR} state
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the syntax error was identified
       */
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
      }
    };
    ErrorInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ErrorInfo);
    exports2.ErrorInfo = ErrorInfo;
  }
});

// node_modules/antlr4ts/atn/LookaheadEventInfo.js
var require_LookaheadEventInfo = __commonJS({
  "node_modules/antlr4ts/atn/LookaheadEventInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LookaheadEventInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link LookaheadEventInfo} class with
       * the specified detailed lookahead information.
       *
       * @param decision The decision number
       * @param state The final simulator state containing the necessary
       * information to determine the result of a prediction, or `undefined` if
       * the final state is not available
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the prediction was finally made
       * @param fullCtx `true` if the current lookahead is part of an LL
       * prediction; otherwise, `false` if the current lookahead is part of
       * an SLL prediction
       */
      constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
        super(decision, state, input, startIndex, stopIndex, fullCtx);
        this.predictedAlt = predictedAlt;
      }
    };
    LookaheadEventInfo = __decorate([
      __param(3, Decorators_1.NotNull)
    ], LookaheadEventInfo);
    exports2.LookaheadEventInfo = LookaheadEventInfo;
  }
});

// node_modules/antlr4ts/atn/PredicateEvalInfo.js
var require_PredicateEvalInfo = __commonJS({
  "node_modules/antlr4ts/atn/PredicateEvalInfo.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PredicateEvalInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link PredicateEvalInfo} class with the
       * specified detailed predicate evaluation information.
       *
       * @param state The simulator state
       * @param decision The decision number
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the predicate evaluation was
       * triggered. Note that the input stream may be reset to other positions for
       * the actual evaluation of individual predicates.
       * @param semctx The semantic context which was evaluated
       * @param evalResult The results of evaluating the semantic context
       * @param predictedAlt The alternative number for the decision which is
       * guarded by the semantic context `semctx`. See {@link #predictedAlt}
       * for more information.
       *
       * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)
       * @see SemanticContext#eval(Recognizer, RuleContext)
       */
      constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.semctx = semctx;
        this.evalResult = evalResult;
        this.predictedAlt = predictedAlt;
      }
    };
    PredicateEvalInfo = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], PredicateEvalInfo);
    exports2.PredicateEvalInfo = PredicateEvalInfo;
  }
});

// node_modules/antlr4ts/atn/SimulatorState.js
var require_SimulatorState = __commonJS({
  "node_modules/antlr4ts/atn/SimulatorState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimulatorState = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var SimulatorState = class SimulatorState {
      constructor(outerContext, s0, useContext, remainingOuterContext) {
        this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
        this.s0 = s0;
        this.useContext = useContext;
        this.remainingOuterContext = remainingOuterContext;
      }
    };
    SimulatorState = __decorate([
      __param(1, Decorators_1.NotNull)
    ], SimulatorState);
    exports2.SimulatorState = SimulatorState;
  }
});

// node_modules/antlr4ts/atn/ProfilingATNSimulator.js
var require_ProfilingATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ProfilingATNSimulator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProfilingATNSimulator = void 0;
    var AmbiguityInfo_1 = require_AmbiguityInfo();
    var ATN_1 = require_ATN();
    var ATNSimulator_1 = require_ATNSimulator();
    var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
    var DecisionInfo_1 = require_DecisionInfo();
    var ErrorInfo_1 = require_ErrorInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo_1 = require_LookaheadEventInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PredicateEvalInfo_1 = require_PredicateEvalInfo();
    var SemanticContext_1 = require_SemanticContext();
    var SimulatorState_1 = require_SimulatorState();
    var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
      constructor(parser) {
        super(parser.interpreter.atn, parser);
        this._startIndex = 0;
        this._sllStopIndex = 0;
        this._llStopIndex = 0;
        this.currentDecision = 0;
        this.conflictingAltResolvedBySLL = 0;
        this.optimize_ll1 = false;
        this.reportAmbiguities = true;
        this.numDecisions = this.atn.decisionToState.length;
        this.decisions = [];
        for (let i2 = 0; i2 < this.numDecisions; i2++) {
          this.decisions.push(new DecisionInfo_1.DecisionInfo(i2));
        }
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext !== void 0) {
          return super.adaptivePredict(input, decision, outerContext, useContext);
        }
        try {
          this._input = input;
          this._startIndex = input.index;
          this._sllStopIndex = this._startIndex - 1;
          this._llStopIndex = -1;
          this.currentDecision = decision;
          this.currentState = void 0;
          this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
          let start = process.hrtime();
          let alt = super.adaptivePredict(input, decision, outerContext);
          let stop = process.hrtime();
          let nanoseconds = (stop[0] - start[0]) * 1e9;
          if (nanoseconds === 0) {
            nanoseconds = stop[1] - start[1];
          } else {
            nanoseconds += 1e9 - start[1] + stop[1];
          }
          this.decisions[decision].timeInPrediction += nanoseconds;
          this.decisions[decision].invocations++;
          let SLL_k = this._sllStopIndex - this._startIndex + 1;
          this.decisions[decision].SLL_TotalLook += SLL_k;
          this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
          if (SLL_k > this.decisions[decision].SLL_MaxLook) {
            this.decisions[decision].SLL_MaxLook = SLL_k;
            this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
          }
          if (this._llStopIndex >= 0) {
            let LL_k = this._llStopIndex - this._startIndex + 1;
            this.decisions[decision].LL_TotalLook += LL_k;
            this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
            if (LL_k > this.decisions[decision].LL_MaxLook) {
              this.decisions[decision].LL_MaxLook = LL_k;
              this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
            }
          }
          return alt;
        } finally {
          this._input = void 0;
          this.currentDecision = -1;
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        let state = super.getStartState(dfa, input, outerContext, useContext);
        this.currentState = state;
        return state;
      }
      computeStartState(dfa, globalContext, useContext) {
        let state = super.computeStartState(dfa, globalContext, useContext);
        this.currentState = state;
        return state;
      }
      computeReachSet(dfa, previous, t, contextCache) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        let reachState = super.computeReachSet(dfa, previous, t, contextCache);
        if (reachState == null) {
          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));
        }
        this.currentState = reachState;
        return reachState;
      }
      getExistingTargetState(previousD, t) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (this.currentState.useContext) {
          this._llStopIndex = this._input.index;
        } else {
          this._sllStopIndex = this._input.index;
        }
        let existingTargetState = super.getExistingTargetState(previousD, t);
        if (existingTargetState != null) {
          this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
          if (this.currentState.useContext) {
            this.decisions[this.currentDecision].LL_DFATransitions++;
          } else {
            this.decisions[this.currentDecision].SLL_DFATransitions++;
          }
          if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
            let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
          }
        }
        return existingTargetState;
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
        if (useContext) {
          this.decisions[this.currentDecision].LL_ATNTransitions++;
        } else {
          this.decisions[this.currentDecision].SLL_ATNTransitions++;
        }
        return targetState;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
        if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
          let fullContext = this._llStopIndex >= 0;
          let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
          this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
        }
        return result;
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
        }
        super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (conflictingAlts != null) {
          this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
        } else {
          this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
        }
        this.decisions[this.currentDecision].LL_Fallback++;
        super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let prediction;
        if (ambigAlts != null) {
          prediction = ambigAlts.nextSetBit(0);
        } else {
          prediction = configs.getRepresentedAlternatives().nextSetBit(0);
        }
        if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
        }
        this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
        super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
      }
      // ---------------------------------------------------------------------
      getDecisionInfo() {
        return this.decisions;
      }
      getCurrentState() {
        return this.currentState;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeReachSet", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
    exports2.ProfilingATNSimulator = ProfilingATNSimulator;
  }
});

// node_modules/antlr4ts/Parser.js
var require_Parser = __commonJS({
  "node_modules/antlr4ts/Parser.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve4) {
          resolve4(value);
        });
      }
      return new (P || (P = Promise))(function(resolve4, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Parser = void 0;
    var Utils = require_Utils();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNDeserializer_1 = require_ATNDeserializer();
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var ErrorNode_1 = require_ErrorNode();
    var IntegerStack_1 = require_IntegerStack();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var ParseInfo_1 = require_ParseInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
    var Recognizer_1 = require_Recognizer();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var TraceListener = class {
      constructor(ruleNames, tokenStream) {
        this.ruleNames = ruleNames;
        this.tokenStream = tokenStream;
      }
      enterEveryRule(ctx) {
        console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      exitEveryRule(ctx) {
        console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      visitErrorNode(node) {
      }
      visitTerminal(node) {
        let parent = node.parent.ruleContext;
        let token = node.symbol;
        console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
      }
    };
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "enterEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "exitEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitErrorNode", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitTerminal", null);
    var Parser = class _Parser extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
        this._precedenceStack = new IntegerStack_1.IntegerStack();
        this._buildParseTrees = true;
        this._parseListeners = [];
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this._precedenceStack.push(0);
        this.inputStream = input;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this.inputStream.seek(0);
        }
        this._errHandler.reset(this);
        this._ctx = void 0;
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this.isTrace = false;
        this._precedenceStack.clear();
        this._precedenceStack.push(0);
        let interpreter = this.interpreter;
        if (interpreter != null) {
          interpreter.reset();
        }
      }
      /**
       * Match current input symbol against `ttype`. If the symbol type
       * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are
       * called to complete the match process.
       *
       * If the symbol type does not match,
       * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
       * strategy to attempt recovery. If {@link #getBuildParseTree} is
       * `true` and the token index of the symbol returned by
       * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
       * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then
       * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
       *
       * @param ttype the token type to match
       * @returns the matched symbol
       * @ if the current input symbol did not match
       * `ttype` and the error strategy could not recover from the
       * mismatched symbol
       */
      match(ttype) {
        let t = this.currentToken;
        if (t.type === ttype) {
          if (ttype === Token_1.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      /**
       * Match current input symbol as a wildcard. If the symbol type matches
       * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}
       * and {@link #consume} are called to complete the match process.
       *
       * If the symbol type does not match,
       * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
       * strategy to attempt recovery. If {@link #getBuildParseTree} is
       * `true` and the token index of the symbol returned by
       * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
       * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then
       * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
       *
       * @returns the matched symbol
       * @ if the current input symbol did not match
       * a wildcard and the error strategy could not recover from the mismatched
       * symbol
       */
      matchWildcard() {
        let t = this.currentToken;
        if (t.type > 0) {
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      /**
       * Track the {@link ParserRuleContext} objects during the parse and hook
       * them up using the {@link ParserRuleContext#children} list so that it
       * forms a parse tree. The {@link ParserRuleContext} returned from the start
       * rule represents the root of the parse tree.
       *
       * Note that if we are not building parse trees, rule contexts only point
       * upwards. When a rule exits, it returns the context but that gets garbage
       * collected if nobody holds a reference. It points upwards but nobody
       * points at it.
       *
       * When we build parse trees, we are adding all of these contexts to
       * {@link ParserRuleContext#children} list. Contexts are then not candidates
       * for garbage collection.
       */
      set buildParseTree(buildParseTrees) {
        this._buildParseTrees = buildParseTrees;
      }
      /**
       * Gets whether or not a complete parse tree will be constructed while
       * parsing. This property is `true` for a newly constructed parser.
       *
       * @returns `true` if a complete parse tree will be constructed while
       * parsing, otherwise `false`
       */
      get buildParseTree() {
        return this._buildParseTrees;
      }
      getParseListeners() {
        return this._parseListeners;
      }
      /**
       * Registers `listener` to receive events during the parsing process.
       *
       * To support output-preserving grammar transformations (including but not
       * limited to left-recursion removal, automated left-factoring, and
       * optimized code generation), calls to listener methods during the parse
       * may differ substantially from calls made by
       * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In
       * particular, rule entry and exit events may occur in a different order
       * during the parse than after the parser. In addition, calls to certain
       * rule entry methods may be omitted.
       *
       * With the following specific exceptions, calls to listener events are
       * *deterministic*, i.e. for identical input the calls to listener
       * methods will be the same.
       *
       * * Alterations to the grammar used to generate code may change the
       *   behavior of the listener calls.
       * * Alterations to the command line options passed to ANTLR 4 when
       *   generating the parser may change the behavior of the listener calls.
       * * Changing the version of the ANTLR Tool used to generate the parser
       *   may change the behavior of the listener calls.
       *
       * @param listener the listener to add
       *
       * @throws {@link TypeError} if `listener` is `undefined`
       */
      addParseListener(listener) {
        if (listener == null) {
          throw new TypeError("listener cannot be null");
        }
        this._parseListeners.push(listener);
      }
      /**
       * Remove `listener` from the list of parse listeners.
       *
       * If `listener` is `undefined` or has not been added as a parse
       * listener, this method does nothing.
       *
       * @see #addParseListener
       *
       * @param listener the listener to remove
       */
      removeParseListener(listener) {
        let index = this._parseListeners.findIndex((l) => l === listener);
        if (index !== -1) {
          this._parseListeners.splice(index, 1);
        }
      }
      /**
       * Remove all parse listeners.
       *
       * @see #addParseListener
       */
      removeParseListeners() {
        this._parseListeners.length = 0;
      }
      /**
       * Notify any parse listeners of an enter rule event.
       *
       * @see #addParseListener
       */
      triggerEnterRuleEvent() {
        for (let listener of this._parseListeners) {
          if (listener.enterEveryRule) {
            listener.enterEveryRule(this._ctx);
          }
          this._ctx.enterRule(listener);
        }
      }
      /**
       * Notify any parse listeners of an exit rule event.
       *
       * @see #addParseListener
       */
      triggerExitRuleEvent() {
        for (let i2 = this._parseListeners.length - 1; i2 >= 0; i2--) {
          let listener = this._parseListeners[i2];
          this._ctx.exitRule(listener);
          if (listener.exitEveryRule) {
            listener.exitEveryRule(this._ctx);
          }
        }
      }
      /**
       * Gets the number of syntax errors reported during parsing. This value is
       * incremented each time {@link #notifyErrorListeners} is called.
       *
       * @see #notifyErrorListeners
       */
      get numberOfSyntaxErrors() {
        return this._syntaxErrors;
      }
      get tokenFactory() {
        return this._input.tokenSource.tokenFactory;
      }
      /**
       * The ATN with bypass alternatives is expensive to create so we create it
       * lazily.
       *
       * @ if the current parser does not
       * implement the `serializedATN` property.
       */
      getATNWithBypassAlts() {
        let serializedAtn = this.serializedATN;
        if (serializedAtn == null) {
          throw new Error("The current parser does not support an ATN with bypass alternatives.");
        }
        let result = _Parser.bypassAltsAtnCache.get(serializedAtn);
        if (result == null) {
          let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
          deserializationOptions.isGenerateRuleBypassTransitions = true;
          result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils.toCharArray(serializedAtn));
          _Parser.bypassAltsAtnCache.set(serializedAtn, result);
        }
        return result;
      }
      compileParseTreePattern(pattern, patternRuleIndex, lexer) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!lexer) {
            if (this.inputStream) {
              let tokenSource = this.inputStream.tokenSource;
              if (tokenSource instanceof Lexer_1.Lexer) {
                lexer = tokenSource;
              }
            }
            if (!lexer) {
              throw new Error("Parser can't discover a lexer to use");
            }
          }
          let currentLexer = lexer;
          let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
          let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
          return matcher.compile(pattern, patternRuleIndex);
        });
      }
      get errorHandler() {
        return this._errHandler;
      }
      set errorHandler(handler) {
        this._errHandler = handler;
      }
      get inputStream() {
        return this._input;
      }
      /** Set the token stream and reset the parser. */
      set inputStream(input) {
        this.reset(false);
        this._input = input;
      }
      /** Match needs to return the current input symbol, which gets put
       *  into the label for the associated token ref; e.g., x=ID.
       */
      get currentToken() {
        return this._input.LT(1);
      }
      notifyErrorListeners(msg, offendingToken, e) {
        if (offendingToken === void 0) {
          offendingToken = this.currentToken;
        } else if (offendingToken === null) {
          offendingToken = void 0;
        }
        this._syntaxErrors++;
        let line = -1;
        let charPositionInLine = -1;
        if (offendingToken != null) {
          line = offendingToken.line;
          charPositionInLine = offendingToken.charPositionInLine;
        }
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
        }
      }
      /**
       * Consume and return the [current symbol](`currentToken`).
       *
       * E.g., given the following input with `A` being the current
       * lookahead symbol, this function moves the cursor to `B` and returns
       * `A`.
       *
       * ```
       * A B
       * ^
       * ```
       *
       * If the parser is not in error recovery mode, the consumed symbol is added
       * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and
       * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.
       * If the parser *is* in error recovery mode, the consumed symbol is
       * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then
       * {@link ParserRuleContext#addErrorNode(ErrorNode)} and
       * {@link ParseTreeListener#visitErrorNode} is called on any parse
       * listeners.
       */
      consume() {
        let o2 = this.currentToken;
        if (o2.type !== _Parser.EOF) {
          this.inputStream.consume();
        }
        let hasListener = this._parseListeners.length !== 0;
        if (this._buildParseTrees || hasListener) {
          if (this._errHandler.inErrorRecoveryMode(this)) {
            let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o2));
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitErrorNode) {
                  listener.visitErrorNode(node);
                }
              }
            }
          } else {
            let node = this.createTerminalNode(this._ctx, o2);
            this._ctx.addChild(node);
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitTerminal) {
                  listener.visitTerminal(node);
                }
              }
            }
          }
        }
        return o2;
      }
      /**
       * How to create a token leaf node associated with a parent.
       * Typically, the terminal node to create is not a function of the parent.
       *
       * @since 4.7
       */
      createTerminalNode(parent, t) {
        return new TerminalNode_1.TerminalNode(t);
      }
      /**
       * How to create an error node, given a token, associated with a parent.
       * Typically, the error node to create is not a function of the parent.
       *
       * @since 4.7
       */
      createErrorNode(parent, t) {
        return new ErrorNode_1.ErrorNode(t);
      }
      addContextToParseTree() {
        let parent = this._ctx._parent;
        if (parent != null) {
          parent.addChild(this._ctx);
        }
      }
      /**
       * Always called by generated parsers upon entry to a rule. Access field
       * {@link #_ctx} get the current context.
       */
      enterRule(localctx, state, ruleIndex) {
        this.state = state;
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      enterLeftFactoredRule(localctx, state, ruleIndex) {
        this.state = state;
        if (this._buildParseTrees) {
          let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
          this._ctx.removeLastChild();
          factoredContext._parent = localctx;
          localctx.addChild(factoredContext);
        }
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      exitRule() {
        if (this.matchedEOF) {
          this._ctx._stop = this._input.LT(1);
        } else {
          this._ctx._stop = this._input.tryLT(-1);
        }
        this.triggerExitRuleEvent();
        this.state = this._ctx.invokingState;
        this._ctx = this._ctx._parent;
      }
      enterOuterAlt(localctx, altNum) {
        localctx.altNumber = altNum;
        if (this._buildParseTrees && this._ctx !== localctx) {
          let parent = this._ctx._parent;
          if (parent != null) {
            parent.removeLastChild();
            parent.addChild(localctx);
          }
        }
        this._ctx = localctx;
      }
      /**
       * Get the precedence level for the top-most precedence rule.
       *
       * @returns The precedence level for the top-most precedence rule, or -1 if
       * the parser context is not nested within a precedence rule.
       */
      get precedence() {
        if (this._precedenceStack.isEmpty) {
          return -1;
        }
        return this._precedenceStack.peek();
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this._precedenceStack.push(precedence);
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        this.triggerEnterRuleEvent();
      }
      /** Like {@link #enterRule} but for recursive rules.
       *  Make the current context the child of the incoming localctx.
       */
      pushNewRecursionContext(localctx, state, ruleIndex) {
        let previous = this._ctx;
        previous._parent = localctx;
        previous.invokingState = state;
        previous._stop = this._input.tryLT(-1);
        this._ctx = localctx;
        this._ctx._start = previous._start;
        if (this._buildParseTrees) {
          this._ctx.addChild(previous);
        }
        this.triggerEnterRuleEvent();
      }
      unrollRecursionContexts(_parentctx) {
        this._precedenceStack.pop();
        this._ctx._stop = this._input.tryLT(-1);
        let retctx = this._ctx;
        if (this._parseListeners.length > 0) {
          while (this._ctx !== _parentctx) {
            this.triggerExitRuleEvent();
            this._ctx = this._ctx._parent;
          }
        } else {
          this._ctx = _parentctx;
        }
        retctx._parent = _parentctx;
        if (this._buildParseTrees && _parentctx != null) {
          _parentctx.addChild(retctx);
        }
      }
      getInvokingContext(ruleIndex) {
        let p = this._ctx;
        while (p && p.ruleIndex !== ruleIndex) {
          p = p._parent;
        }
        return p;
      }
      get context() {
        return this._ctx;
      }
      set context(ctx) {
        this._ctx = ctx;
      }
      precpred(localctx, precedence) {
        return precedence >= this._precedenceStack.peek();
      }
      getErrorListenerDispatch() {
        return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
      }
      inContext(context) {
        return false;
      }
      /**
       * Checks whether or not `symbol` can follow the current state in the
       * ATN. The behavior of this method is equivalent to the following, but is
       * implemented such that the complete context-sensitive follow set does not
       * need to be explicitly constructed.
       *
       * ```
       * return getExpectedTokens().contains(symbol);
       * ```
       *
       * @param symbol the symbol type to check
       * @returns `true` if `symbol` can follow the current state in
       * the ATN, otherwise `false`.
       */
      isExpectedToken(symbol) {
        let atn = this.interpreter.atn;
        let ctx = this._ctx;
        let s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
          return true;
        }
        if (!following.contains(Token_1.Token.EPSILON)) {
          return false;
        }
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = atn.nextTokens(rt.followState);
          if (following.contains(symbol)) {
            return true;
          }
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
          return true;
        }
        return false;
      }
      get isMatchedEOF() {
        return this.matchedEOF;
      }
      /**
       * Computes the set of input symbols which could follow the current parser
       * state and context, as given by {@link #getState} and {@link #getContext},
       * respectively.
       *
       * @see ATN#getExpectedTokens(int, RuleContext)
       */
      getExpectedTokens() {
        return this.atn.getExpectedTokens(this.state, this.context);
      }
      getExpectedTokensWithinCurrentRule() {
        let atn = this.interpreter.atn;
        let s = atn.states[this.state];
        return atn.nextTokens(s);
      }
      /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
      getRuleIndex(ruleName) {
        let ruleIndex = this.getRuleIndexMap().get(ruleName);
        if (ruleIndex != null) {
          return ruleIndex;
        }
        return -1;
      }
      get ruleContext() {
        return this._ctx;
      }
      /** Return List&lt;String&gt; of the rule names in your parser instance
       *  leading up to a call to the current rule.  You could override if
       *  you want more details such as the file/line info of where
       *  in the ATN a rule is invoked.
       *
       *  This is very useful for error messages.
       */
      getRuleInvocationStack(ctx = this._ctx) {
        let p = ctx;
        let ruleNames = this.ruleNames;
        let stack = [];
        while (p != null) {
          let ruleIndex = p.ruleIndex;
          if (ruleIndex < 0) {
            stack.push("n/a");
          } else {
            stack.push(ruleNames[ruleIndex]);
          }
          p = p._parent;
        }
        return stack;
      }
      /** For debugging and other purposes. */
      getDFAStrings() {
        let s = [];
        for (let dfa of this._interp.atn.decisionToDFA) {
          s.push(dfa.toString(this.vocabulary, this.ruleNames));
        }
        return s;
      }
      /** For debugging and other purposes. */
      dumpDFA() {
        let seenOne = false;
        for (let dfa of this._interp.atn.decisionToDFA) {
          if (!dfa.isEmpty) {
            if (seenOne) {
              console.log();
            }
            console.log("Decision " + dfa.decision + ":");
            process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
            seenOne = true;
          }
        }
      }
      get sourceName() {
        return this._input.sourceName;
      }
      get parseInfo() {
        return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
          let interp = this.interpreter;
          if (interp instanceof m.ProfilingATNSimulator) {
            return new ParseInfo_1.ParseInfo(interp);
          }
          return void 0;
        });
      }
      /**
       * @since 4.3
       */
      setProfile(profile) {
        return __awaiter(this, void 0, void 0, function* () {
          let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
          let interp = this.interpreter;
          if (profile) {
            if (!(interp instanceof m.ProfilingATNSimulator)) {
              this.interpreter = new m.ProfilingATNSimulator(this);
            }
          } else if (interp instanceof m.ProfilingATNSimulator) {
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
          }
          this.interpreter.setPredictionMode(interp.getPredictionMode());
        });
      }
      /** During a parse is sometimes useful to listen in on the rule entry and exit
       *  events as well as token matches. This is for quick and dirty debugging.
       */
      set isTrace(trace) {
        if (!trace) {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
            this._tracer = void 0;
          }
        } else {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
          } else {
            this._tracer = new TraceListener(this.ruleNames, this._input);
          }
          this.addParseListener(this._tracer);
        }
      }
      /**
       * Gets whether a {@link TraceListener} is registered as a parse listener
       * for the parser.
       */
      get isTrace() {
        return this._tracer != null;
      }
    };
    Parser.bypassAltsAtnCache = /* @__PURE__ */ new Map();
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "_errHandler", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "matchWildcard", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getParseListeners", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser.prototype, "addParseListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getATNWithBypassAlts", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Parser.prototype, "errorHandler", null);
    __decorate([
      Decorators_1.Override
    ], Parser.prototype, "inputStream", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "currentToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser.prototype, "enterRule", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.Nullable)
    ], Parser.prototype, "precpred", null);
    __decorate([
      Decorators_1.Override
    ], Parser.prototype, "getErrorListenerDispatch", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getExpectedTokens", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getExpectedTokensWithinCurrentRule", null);
    __decorate([
      Decorators_1.Override
    ], Parser.prototype, "parseInfo", null);
    exports2.Parser = Parser;
  }
});

// node_modules/antlr4ts/NoViableAltException.js
var require_NoViableAltException = __commonJS({
  "node_modules/antlr4ts/NoViableAltException.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoViableAltException = void 0;
    var Parser_1 = require_Parser();
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var NoViableAltException = class extends RecognitionException_1.RecognitionException {
      constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
        if (recognizer instanceof Parser_1.Parser) {
          if (input === void 0) {
            input = recognizer.inputStream;
          }
          if (startToken === void 0) {
            startToken = recognizer.currentToken;
          }
          if (offendingToken === void 0) {
            offendingToken = recognizer.currentToken;
          }
          if (ctx === void 0) {
            ctx = recognizer.context;
          }
        }
        super(recognizer, input, ctx);
        this._deadEndConfigs = deadEndConfigs;
        this._startToken = startToken;
        this.setOffendingToken(recognizer, offendingToken);
      }
      get startToken() {
        return this._startToken;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], NoViableAltException.prototype, "_startToken", void 0);
    exports2.NoViableAltException = NoViableAltException;
  }
});

// node_modules/antlr4ts/atn/PredictionMode.js
var require_PredictionMode = __commonJS({
  "node_modules/antlr4ts/atn/PredictionMode.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PredictionMode = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var RuleStopState_1 = require_RuleStopState();
    var PredictionMode;
    (function(PredictionMode2) {
      PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
      PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
      PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
    })(PredictionMode = exports2.PredictionMode || (exports2.PredictionMode = {}));
    (function(PredictionMode2) {
      class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(AltAndContextConfigEqualityComparator.INSTANCE);
        }
      }
      class AltAndContextConfigEqualityComparator {
        AltAndContextConfigEqualityComparator() {
        }
        /**
         * The hash code is only a function of the {@link ATNState#stateNumber}
         * and {@link ATNConfig#context}.
         */
        hashCode(o2) {
          let hashCode = MurmurHash_1.MurmurHash.initialize(7);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o2.state.stateNumber);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o2.context);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
          return hashCode;
        }
        equals(a2, b) {
          if (a2 === b) {
            return true;
          }
          if (a2 == null || b == null) {
            return false;
          }
          return a2.state.stateNumber === b.state.stateNumber && a2.context.equals(b.context);
        }
      }
      AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
      function hasConfigInRuleStopState(configs) {
        for (let c3 of configs) {
          if (c3.state instanceof RuleStopState_1.RuleStopState) {
            return true;
          }
        }
        return false;
      }
      PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
      function allConfigsInRuleStopStates(configs) {
        for (let config2 of configs) {
          if (!(config2.state instanceof RuleStopState_1.RuleStopState)) {
            return false;
          }
        }
        return true;
      }
      PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
    })(PredictionMode = exports2.PredictionMode || (exports2.PredictionMode = {}));
  }
});

// node_modules/antlr4ts/atn/ParserATNSimulator.js
var require_ParserATNSimulator = __commonJS({
  "node_modules/antlr4ts/atn/ParserATNSimulator.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParserATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BitSet_1 = require_BitSet();
    var ConflictInfo_1 = require_ConflictInfo();
    var DecisionState_1 = require_DecisionState();
    var DFAState_1 = require_DFAState();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var NoViableAltException_1 = require_NoViableAltException();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var PredictionMode_1 = require_PredictionMode();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SemanticContext_1 = require_SemanticContext();
    var SetTransition_1 = require_SetTransition();
    var SimulatorState_1 = require_SimulatorState();
    var Token_1 = require_Token();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var assert = require("assert");
    var MAX_SHORT_VALUE = 65535;
    var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
    var ParserATNSimulator = class ParserATNSimulator2 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, parser) {
        super(atn);
        this.predictionMode = PredictionMode_1.PredictionMode.LL;
        this.force_global_context = false;
        this.always_try_local_context = true;
        this.enable_global_context_dfa = false;
        this.optimize_unique_closure = true;
        this.optimize_ll1 = true;
        this.optimize_tail_calls = true;
        this.tail_call_preserves_sll = true;
        this.treat_sllk1_conflict_as_ambiguity = false;
        this.reportAmbiguities = false;
        this.userWantsCtxSensitive = true;
        this._parser = parser;
      }
      getPredictionMode() {
        return this.predictionMode;
      }
      setPredictionMode(predictionMode) {
        this.predictionMode = predictionMode;
      }
      reset() {
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext === void 0) {
          useContext = false;
        }
        let dfa = this.atn.decisionToDFA[decision];
        assert(dfa != null);
        if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
          let ll_1 = input.LA(1);
          if (ll_1 >= 0 && ll_1 <= 65535) {
            let key = (decision << 16 >>> 0) + ll_1;
            let alt = this.atn.LL1Table.get(key);
            if (alt != null) {
              return alt;
            }
          }
        }
        this.dfa = dfa;
        if (this.force_global_context) {
          useContext = true;
        } else if (!this.always_try_local_context) {
          useContext = useContext || dfa.isContextSensitive;
        }
        this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
        if (outerContext == null) {
          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
        }
        let state;
        if (!dfa.isEmpty) {
          state = this.getStartState(dfa, input, outerContext, useContext);
        }
        if (state == null) {
          if (outerContext == null) {
            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
          }
          if (ParserATNSimulator2.debug) {
            console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
          }
          state = this.computeStartState(dfa, outerContext, useContext);
        }
        let m = input.mark();
        let index = input.index;
        try {
          let alt = this.execDFA(dfa, input, index, state);
          if (ParserATNSimulator2.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          return alt;
        } finally {
          this.dfa = void 0;
          input.seek(index);
          input.release(m);
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        if (!useContext) {
          if (dfa.isPrecedenceDfa) {
            let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
            if (state == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
          } else {
            if (dfa.s0 == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
          }
        }
        if (!this.enable_global_context_dfa) {
          return void 0;
        }
        let remainingContext = outerContext;
        assert(outerContext != null);
        let s0;
        if (dfa.isPrecedenceDfa) {
          s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
        } else {
          s0 = dfa.s0full;
        }
        while (remainingContext != null && s0 != null && s0.isContextSensitive) {
          remainingContext = this.skipTailCalls(remainingContext);
          s0 = s0.getContextTarget(this.getReturnState(remainingContext));
          if (remainingContext.isEmpty) {
            assert(s0 == null || !s0.isContextSensitive);
          } else {
            remainingContext = remainingContext.parent;
          }
        }
        if (s0 == null) {
          return void 0;
        }
        return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
      }
      execDFA(dfa, input, startIndex, state) {
        let outerContext = state.outerContext;
        if (ParserATNSimulator2.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
        }
        if (ParserATNSimulator2.dfa_debug) {
          console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
        }
        let s = state.s0;
        let t = input.LA(1);
        let remainingOuterContext = state.remainingOuterContext;
        while (true) {
          if (ParserATNSimulator2.dfa_debug) {
            console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
          }
          if (state.useContext) {
            while (s.isContextSymbol(t)) {
              let next;
              if (remainingOuterContext != null) {
                remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                next = s.getContextTarget(this.getReturnState(remainingOuterContext));
              }
              if (next == null) {
                let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                return this.execATN(dfa, input, startIndex, initialState);
              }
              assert(remainingOuterContext != null);
              remainingOuterContext = remainingOuterContext.parent;
              s = next;
            }
          }
          if (this.isAcceptState(s, state.useContext)) {
            if (s.predicates != null) {
              if (ParserATNSimulator2.dfa_debug) {
                console.log("accept " + s);
              }
            } else {
              if (ParserATNSimulator2.dfa_debug) {
                console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
              }
            }
            break;
          }
          assert(!this.isAcceptState(s, state.useContext));
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            if (ParserATNSimulator2.dfa_debug && t >= 0) {
              console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
            }
            let alt;
            if (ParserATNSimulator2.dfa_debug) {
              let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
              console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
            }
            let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            alt = this.execATN(dfa, input, startIndex, initialState);
            if (ParserATNSimulator2.dfa_debug) {
              console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            }
            if (ParserATNSimulator2.dfa_debug) {
              console.log("DFA decision " + dfa.decision + " predicts " + alt);
            }
            return alt;
          } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            return this.handleNoViableAlt(input, startIndex, errorState);
          }
          s = target;
          if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
        if (!state.useContext && s.configs.conflictInfo != null) {
          if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
            if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
            } else {
              assert(!state.useContext);
              let conflictingAlts;
              let predicates3 = s.predicates;
              if (predicates3 != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predicates3, outerContext, true);
                if (conflictingAlts.cardinality() === 1) {
                  return conflictingAlts.nextSetBit(0);
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
              if (this.reportAmbiguities) {
                let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.adaptivePredict(input, dfa.decision, outerContext, true);
            }
          }
        }
        let predicates2 = s.predicates;
        if (predicates2 != null) {
          let stopIndex = input.index;
          if (startIndex !== stopIndex) {
            input.seek(startIndex);
          }
          let alts = this.evalSemanticContext(predicates2, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
          switch (alts.cardinality()) {
            case 0:
              throw this.noViableAlt(input, outerContext, s.configs, startIndex);
            case 1:
              return alts.nextSetBit(0);
            default:
              if (startIndex !== stopIndex) {
                input.seek(stopIndex);
              }
              this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
              return alts.nextSetBit(0);
          }
        }
        if (ParserATNSimulator2.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
        }
        return s.prediction;
      }
      /**
       * Determines if a particular DFA state should be treated as an accept state
       * for the current prediction mode. In addition to the `useContext`
       * parameter, the {@link #getPredictionMode()} method provides the
       * prediction mode controlling the prediction algorithm as a whole.
       *
       * The default implementation simply returns the value of
       * `DFAState.isAcceptState` except for conflict states when
       * `useContext` is `true` and {@link #getPredictionMode()} is
       * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only
       * conflict states where {@link ATNConfigSet#isExactConflict} is
       * `true` are considered accept states.
       *
       * @param state The DFA state to check.
       * @param useContext `true` if the prediction algorithm is currently
       * considering the full parser context; otherwise, `false` if the
       * algorithm is currently performing a local context prediction.
       *
       * @returns `true` if the specified `state` is an accept state;
       * otherwise, `false`.
       */
      isAcceptState(state, useContext) {
        if (!state.isAcceptState) {
          return false;
        }
        if (state.configs.conflictingAlts == null) {
          return true;
        }
        if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
          return state.configs.isExactConflict;
        }
        return true;
      }
      /** Performs ATN simulation to compute a predicted alternative based
       *  upon the remaining input, but also updates the DFA cache to avoid
       *  having to traverse the ATN again for the same input sequence.
       *
       * There are some key conditions we're looking for after computing a new
       * set of ATN configs (proposed DFA state):
       *
       * * if the set is empty, there is no viable alternative for current symbol
       * * does the state uniquely predict an alternative?
       * * does the state have a conflict that would prevent us from
       *   putting it on the work list?
       * * if in non-greedy decision is there a config at a rule stop state?
       *
       * We also have some key operations to do:
       *
       * * add an edge from previous DFA state to potentially new DFA state, D,
       *   upon current symbol but only if adding to work list, which means in all
       *   cases except no viable alternative (and possibly non-greedy decisions?)
       * * collecting predicates and adding semantic context to DFA accept states
       * * adding rule context to context-sensitive DFA accept states
       * * consuming an input symbol
       * * reporting a conflict
       * * reporting an ambiguity
       * * reporting a context sensitivity
       * * reporting insufficient predicates
       *
       * We should isolate those operations, which are side-effecting, to the
       * main work loop. We can isolate lots of code into other functions, but
       * they should be side effect free. They can return package that
       * indicates whether we should report something, whether we need to add a
       * DFA edge, whether we need to augment accept state with semantic
       * context or rule invocation context. Actually, it seems like we always
       * add predicates if they exist, so that can simply be done in the main
       * loop for any accept state creation or modification request.
       *
       * cover these cases:
       *   dead end
       *   single alt
       *   single alt + preds
       *   conflict
       *   conflict + preds
       *
       * TODO: greedy + those
       */
      execATN(dfa, input, startIndex, initialState) {
        if (ParserATNSimulator2.debug) {
          console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
        }
        let outerContext = initialState.outerContext;
        let useContext = initialState.useContext;
        let t = input.LA(1);
        let previous = initialState;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        while (true) {
          let nextState = this.computeReachSet(dfa, previous, t, contextCache);
          if (nextState == null) {
            this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
            return this.handleNoViableAlt(input, startIndex, previous);
          }
          let D = nextState.s0;
          assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
          assert(D.isAcceptState || D.configs.conflictInfo == null);
          if (this.isAcceptState(D, useContext)) {
            let conflictingAlts = D.configs.conflictingAlts;
            let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
            if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                if (t >= 0 && t <= MAX_SHORT_VALUE) {
                  let key = (dfa.decision << 16 >>> 0) + t;
                  this.atn.LL1Table.set(key, predictedAlt);
                }
              }
              if (useContext && this.always_try_local_context) {
                this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
              }
            }
            predictedAlt = D.prediction;
            let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
            if (attemptFullContext) {
              attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
            }
            if (D.configs.hasSemanticContext) {
              let predPredictions = D.predicates;
              if (predPredictions != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                switch (conflictingAlts.cardinality()) {
                  case 0:
                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                  case 1:
                    return conflictingAlts.nextSetBit(0);
                  default:
                    break;
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
            }
            if (!attemptFullContext) {
              if (conflictingAlts != null) {
                if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                  this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                }
                predictedAlt = conflictingAlts.nextSetBit(0);
              }
              return predictedAlt;
            } else {
              assert(!useContext);
              assert(this.isAcceptState(D, false));
              if (ParserATNSimulator2.debug) {
                console.log("RETRY with outerContext=" + outerContext);
              }
              let fullContextState = this.computeStartState(dfa, outerContext, true);
              if (this.reportAmbiguities) {
                this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.execATN(dfa, input, startIndex, fullContextState);
            }
          }
          previous = nextState;
          if (t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
      }
      /**
       * This method is used to improve the localization of error messages by
       * choosing an alternative rather than throwing a
       * {@link NoViableAltException} in particular prediction scenarios where the
       * {@link #ERROR} state was reached during ATN simulation.
       *
       * The default implementation of this method uses the following
       * algorithm to identify an ATN configuration which successfully parsed the
       * decision entry rule. Choosing such an alternative ensures that the
       * {@link ParserRuleContext} returned by the calling rule will be complete
       * and valid, and the syntax error will be reported later at a more
       * localized location.
       *
       * * If no configuration in `configs` reached the end of the
       *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.
       * * If all configurations in `configs` which reached the end of the
       *   decision rule predict the same alternative, return that alternative.
       * * If the configurations in `configs` which reached the end of the
       *   decision rule predict multiple alternatives (call this *S*),
       *   choose an alternative in the following order.
       *
       *     1. Filter the configurations in `configs` to only those
       *        configurations which remain viable after evaluating semantic predicates.
       *        If the set of these filtered configurations which also reached the end of
       *        the decision rule is not empty, return the minimum alternative
       *        represented in this set.
       *     1. Otherwise, choose the minimum alternative in *S*.
       *
       * In some scenarios, the algorithm described above could predict an
       * alternative which will result in a {@link FailedPredicateException} in
       * parser. Specifically, this could occur if the *only* configuration
       * capable of successfully parsing to the end of the decision rule is
       * blocked by a semantic predicate. By choosing this alternative within
       * {@link #adaptivePredict} instead of throwing a
       * {@link NoViableAltException}, the resulting
       * {@link FailedPredicateException} in the parser will identify the specific
       * predicate which is preventing the parser from successfully parsing the
       * decision rule, which helps developers identify and correct logic errors
       * in semantic predicates.
       *
       * @param input The input {@link TokenStream}
       * @param startIndex The start index for the current prediction, which is
       * the input index where any semantic context in `configs` should be
       * evaluated
       * @param previous The ATN simulation state immediately before the
       * {@link #ERROR} state was reached
       *
       * @returns The value to return from {@link #adaptivePredict}, or
       * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
       * identified and {@link #adaptivePredict} should report an error instead.
       */
      handleNoViableAlt(input, startIndex, previous) {
        if (previous.s0 != null) {
          let alts = new BitSet_1.BitSet();
          let maxAlt = 0;
          for (let config2 of previous.s0.configs) {
            if (config2.reachesIntoOuterContext || config2.state instanceof RuleStopState_1.RuleStopState) {
              alts.set(config2.alt);
              maxAlt = Math.max(maxAlt, config2.alt);
            }
          }
          switch (alts.cardinality()) {
            case 0:
              break;
            case 1:
              return alts.nextSetBit(0);
            default:
              if (!previous.s0.configs.hasSemanticContext) {
                return alts.nextSetBit(0);
              }
              let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
              for (let config2 of previous.s0.configs) {
                if (config2.reachesIntoOuterContext || config2.state instanceof RuleStopState_1.RuleStopState) {
                  filteredConfigs.add(config2);
                }
              }
              let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
              if (altToPred != null) {
                let predicates2 = this.getPredicatePredictions(alts, altToPred);
                if (predicates2 != null) {
                  let stopIndex = input.index;
                  try {
                    input.seek(startIndex);
                    let filteredAlts = this.evalSemanticContext(predicates2, previous.outerContext, false);
                    if (!filteredAlts.isEmpty) {
                      return filteredAlts.nextSetBit(0);
                    }
                  } finally {
                    input.seek(stopIndex);
                  }
                }
              }
              return alts.nextSetBit(0);
          }
        }
        throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);
      }
      computeReachSet(dfa, previous, t, contextCache) {
        let useContext = previous.useContext;
        let remainingGlobalContext = previous.remainingOuterContext;
        let s = previous.s0;
        if (useContext) {
          while (s.isContextSymbol(t)) {
            let next;
            if (remainingGlobalContext != null) {
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
            }
            if (next == null) {
              break;
            }
            assert(remainingGlobalContext != null);
            remainingGlobalContext = remainingGlobalContext.parent;
            s = next;
          }
        }
        assert(!this.isAcceptState(s, useContext));
        if (this.isAcceptState(s, useContext)) {
          return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);
        }
        let s0 = s;
        let target = this.getExistingTargetState(s0, t);
        if (target == null) {
          let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
          target = result[0];
          remainingGlobalContext = result[1];
        }
        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          return void 0;
        }
        assert(!useContext || !target.configs.dipsIntoOuterContext);
        return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);
      }
      /**
       * Get an existing target state for an edge in the DFA. If the target state
       * for the edge has not yet been computed or is otherwise not available,
       * this method returns `undefined`.
       *
       * @param s The current DFA state
       * @param t The next input symbol
       * @returns The existing target DFA state for the given input symbol
       * `t`, or `undefined` if the target state for this edge is not
       * already cached
       */
      getExistingTargetState(s, t) {
        return s.getTarget(t);
      }
      /**
       * Compute a target state for an edge in the DFA, and attempt to add the
       * computed state and corresponding edge to the DFA.
       *
       * @param dfa
       * @param s The current DFA state
       * @param remainingGlobalContext
       * @param t The next input symbol
       * @param useContext
       * @param contextCache
       *
       * @returns The computed target DFA state for the given input symbol
       * `t`. If `t` does not lead to a valid DFA state, this method
       * returns {@link #ERROR}.
       */
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let closureConfigs = s.configs.toArray();
        let contextElements;
        let reach = new ATNConfigSet_1.ATNConfigSet();
        let stepIntoGlobal;
        do {
          let hasMoreContext = !useContext || remainingGlobalContext != null;
          if (!hasMoreContext) {
            reach.isOutermostConfigSet = true;
          }
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let skippedStopStates;
          for (let c3 of closureConfigs) {
            if (ParserATNSimulator2.debug) {
              console.log("testing " + this.getTokenName(t) + " at " + c3.toString());
            }
            if (c3.state instanceof RuleStopState_1.RuleStopState) {
              assert(c3.context.isEmpty);
              if (useContext && !c3.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                if (skippedStopStates == null) {
                  skippedStopStates = [];
                }
                skippedStopStates.push(c3);
              }
              continue;
            }
            let n2 = c3.state.numberOfOptimizedTransitions;
            for (let ti = 0; ti < n2; ti++) {
              let trans = c3.state.getOptimizedTransition(ti);
              let target = this.getReachableTarget(c3, trans, t);
              if (target != null) {
                reachIntermediate.add(c3.transform(target, false), contextCache);
              }
            }
          }
          if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
            reach = reachIntermediate;
            break;
          }
          let collectPredicates = false;
          let treatEofAsEpsilon = t === Token_1.Token.EOF;
          this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
          stepIntoGlobal = reach.dipsIntoOuterContext;
          if (t === IntStream_1.IntStream.EOF) {
            reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
          }
          if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
            assert(skippedStopStates.length > 0);
            for (let c3 of skippedStopStates) {
              reach.add(c3, contextCache);
            }
          }
          if (useContext && stepIntoGlobal) {
            reach.clear();
            remainingGlobalContext = remainingGlobalContext;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            let nextContextElement = this.getReturnState(remainingGlobalContext);
            if (contextElements == null) {
              contextElements = new IntegerList_1.IntegerList();
            }
            if (remainingGlobalContext.isEmpty) {
              remainingGlobalContext = void 0;
            } else {
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            contextElements.add(nextContextElement);
            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              for (let i2 = 0; i2 < closureConfigs.length; i2++) {
                closureConfigs[i2] = closureConfigs[i2].appendContext(nextContextElement, contextCache);
              }
            }
          }
        } while (useContext && stepIntoGlobal);
        if (reach.isEmpty) {
          this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
        }
        let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
        return [result, remainingGlobalContext];
      }
      /**
       * Return a configuration set containing only the configurations from
       * `configs` which are in a {@link RuleStopState}. If all
       * configurations in `configs` are already in a rule stop state, this
       * method simply returns `configs`.
       *
       * @param configs the configuration set to update
       * @param contextCache the {@link PredictionContext} cache
       *
       * @returns `configs` if all configurations in `configs` are in a
       * rule stop state, otherwise return a new configuration set containing only
       * the configurations from `configs` which are in a rule stop state
       */
      removeAllConfigsNotInRuleStopState(configs, contextCache) {
        if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
          return configs;
        }
        let result = new ATNConfigSet_1.ATNConfigSet();
        for (let config2 of configs) {
          if (!(config2.state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          result.add(config2, contextCache);
        }
        return result;
      }
      computeStartState(dfa, globalContext, useContext) {
        let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
        if (s0 != null) {
          if (!useContext) {
            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
          }
          s0.setContextSensitive(this.atn);
        }
        let decision = dfa.decision;
        let p = dfa.atnStartState;
        let previousContext = 0;
        let remainingGlobalContext = globalContext;
        let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        if (useContext) {
          if (!this.enable_global_context_dfa) {
            while (remainingGlobalContext != null) {
              if (remainingGlobalContext.isEmpty) {
                previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                remainingGlobalContext = void 0;
              } else {
                previousContext = this.getReturnState(remainingGlobalContext);
                initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                remainingGlobalContext = remainingGlobalContext.parent;
              }
            }
          }
          while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
            let next;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            if (remainingGlobalContext.isEmpty) {
              next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
              remainingGlobalContext = void 0;
            } else {
              previousContext = this.getReturnState(remainingGlobalContext);
              next = s0.getContextTarget(previousContext);
              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            if (next == null) {
              break;
            }
            s0 = next;
          }
        }
        if (s0 != null && !s0.isContextSensitive) {
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
        }
        let configs = new ATNConfigSet_1.ATNConfigSet();
        while (true) {
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let n2 = p.numberOfTransitions;
          for (let ti = 0; ti < n2; ti++) {
            let target = p.transition(ti).target;
            reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
          }
          let hasMoreContext = remainingGlobalContext != null;
          if (!hasMoreContext) {
            configs.isOutermostConfigSet = true;
          }
          let collectPredicates = true;
          this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
          let stepIntoGlobal = configs.dipsIntoOuterContext;
          let next;
          if (useContext && !this.enable_global_context_dfa) {
            s0 = this.addDFAState(dfa, configs, contextCache);
            break;
          } else if (s0 == null) {
            if (!dfa.isPrecedenceDfa) {
              next = this.addDFAState(dfa, configs, contextCache);
              if (useContext) {
                if (!dfa.s0full) {
                  dfa.s0full = next;
                } else {
                  next = dfa.s0full;
                }
              } else {
                if (!dfa.s0) {
                  dfa.s0 = next;
                } else {
                  next = dfa.s0;
                }
              }
            } else {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
              next = this.addDFAState(dfa, configs, contextCache);
              dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
            }
          } else {
            if (dfa.isPrecedenceDfa) {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
            }
            next = this.addDFAState(dfa, configs, contextCache);
            s0.setContextTarget(previousContext, next);
          }
          s0 = next;
          if (!useContext || !stepIntoGlobal) {
            break;
          }
          next.setContextSensitive(this.atn);
          remainingGlobalContext = remainingGlobalContext;
          configs.clear();
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          let nextContextElement = this.getReturnState(remainingGlobalContext);
          if (remainingGlobalContext.isEmpty) {
            remainingGlobalContext = void 0;
          } else {
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
          }
          previousContext = nextContextElement;
        }
        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
      }
      /**
       * This method transforms the start state computed by
       * {@link #computeStartState} to the special start state used by a
       * precedence DFA for a particular precedence value. The transformation
       * process applies the following changes to the start state's configuration
       * set.
       *
       * 1. Evaluate the precedence predicates for each configuration using
       *    {@link SemanticContext#evalPrecedence}.
       * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,
       *    remove all configurations which predict an alternative greater than 1,
       *    for which another configuration that predicts alternative 1 is in the
       *    same ATN state with the same prediction context. This transformation is
       *    valid for the following reasons:
       *
       *     * The closure block cannot contain any epsilon transitions which bypass
       *       the body of the closure, so all states reachable via alternative 1 are
       *       part of the precedence alternatives of the transformed left-recursive
       *       rule.
       *     * The "primary" portion of a left recursive rule cannot contain an
       *       epsilon transition, so the only way an alternative other than 1 can exist
       *       in a state that is also reachable via alternative 1 is by nesting calls
       *       to the left-recursive rule, with the outer calls not being at the
       *       preferred precedence level. The
       *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
       *       configurations which do not meet this condition, and therefore are not
       *       eligible for elimination during the filtering process.
       *
       * The prediction context must be considered by this filter to address
       * situations like the following.
       *
       * ```antlr
       * grammar TA;
       * prog: statement* EOF;
       * statement: letterA | statement letterA 'b' ;
       * letterA: 'a';
       * ```
       *
       * If the above grammar, the ATN state immediately before the token
       * reference `'a'` in `letterA` is reachable from the left edge
       * of both the primary and closure blocks of the left-recursive rule
       * `statement`. The prediction context associated with each of these
       * configurations distinguishes between them, and prevents the alternative
       * which stepped out to `prog` (and then back in to `statement`
       * from being eliminated by the filter.
       *
       * @param configs The configuration set computed by
       * {@link #computeStartState} as the start state for the DFA.
       * @returns The transformed configuration set representing the start state
       * for a precedence DFA at a particular precedence level (determined by
       * calling {@link Parser#getPrecedence}).
       */
      applyPrecedenceFilter(configs, globalContext, contextCache) {
        let statesFromAlt1 = /* @__PURE__ */ new Map();
        let configSet = new ATNConfigSet_1.ATNConfigSet();
        for (let config2 of configs) {
          if (config2.alt !== 1) {
            continue;
          }
          let updatedContext = config2.semanticContext.evalPrecedence(this._parser, globalContext);
          if (updatedContext == null) {
            continue;
          }
          statesFromAlt1.set(config2.state.stateNumber, config2.context);
          if (updatedContext !== config2.semanticContext) {
            configSet.add(config2.transform(config2.state, false, updatedContext), contextCache);
          } else {
            configSet.add(config2, contextCache);
          }
        }
        for (let config2 of configs) {
          if (config2.alt === 1) {
            continue;
          }
          if (!config2.isPrecedenceFilterSuppressed) {
            let context = statesFromAlt1.get(config2.state.stateNumber);
            if (context != null && context.equals(config2.context)) {
              continue;
            }
          }
          configSet.add(config2, contextCache);
        }
        return configSet;
      }
      getReachableTarget(source, trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
          return trans.target;
        }
        return void 0;
      }
      /** collect and set D's semantic context */
      predicateDFAState(D, configs, nalts) {
        let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
        if (!conflictingAlts) {
          throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
        }
        if (ParserATNSimulator2.debug) {
          console.log("predicateDFAState " + D);
        }
        let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
        let predPredictions;
        if (altToPred != null) {
          predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
          D.predicates = predPredictions;
        }
        return predPredictions;
      }
      getPredsForAmbigAlts(ambigAlts, configs, nalts) {
        let altToPred = new Array(nalts + 1);
        let n2 = altToPred.length;
        for (let c3 of configs) {
          if (ambigAlts.get(c3.alt)) {
            altToPred[c3.alt] = SemanticContext_1.SemanticContext.or(altToPred[c3.alt], c3.semanticContext);
          }
        }
        let nPredAlts = 0;
        for (let i2 = 0; i2 < n2; i2++) {
          if (altToPred[i2] == null) {
            altToPred[i2] = SemanticContext_1.SemanticContext.NONE;
          } else if (altToPred[i2] !== SemanticContext_1.SemanticContext.NONE) {
            nPredAlts++;
          }
        }
        let result = altToPred;
        if (nPredAlts === 0) {
          result = void 0;
        }
        if (ParserATNSimulator2.debug) {
          console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
        }
        return result;
      }
      getPredicatePredictions(ambigAlts, altToPred) {
        let pairs = [];
        let containsPredicate = false;
        for (let i2 = 1; i2 < altToPred.length; i2++) {
          let pred = altToPred[i2];
          assert(pred != null);
          if (ambigAlts != null && ambigAlts.get(i2) && pred === SemanticContext_1.SemanticContext.NONE) {
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i2));
          } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
            containsPredicate = true;
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i2));
          }
        }
        if (!containsPredicate) {
          return void 0;
        }
        return pairs;
      }
      /** Look through a list of predicate/alt pairs, returning alts for the
       *  pairs that win. An `undefined` predicate indicates an alt containing an
       *  unpredicated config which behaves as "always true."
       */
      evalSemanticContext(predPredictions, outerContext, complete) {
        let predictions = new BitSet_1.BitSet();
        for (let pair of predPredictions) {
          if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
            continue;
          }
          let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
          if (ParserATNSimulator2.debug || ParserATNSimulator2.dfa_debug) {
            console.log("eval pred " + pair + "=" + evaluatedResult);
          }
          if (evaluatedResult) {
            if (ParserATNSimulator2.debug || ParserATNSimulator2.dfa_debug) {
              console.log("PREDICT " + pair.alt);
            }
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
          }
        }
        return predictions;
      }
      /**
       * Evaluate a semantic context within a specific parser context.
       *
       * This method might not be called for every semantic context evaluated
       * during the prediction process. In particular, we currently do not
       * evaluate the following but it may change in the future:
       *
       * * Precedence predicates (represented by
       *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
       *   through this method.
       * * Operator predicates (represented by {@link SemanticContext.AND} and
       *   {@link SemanticContext.OR}) are evaluated as a single semantic
       *   context, rather than evaluating the operands individually.
       *   Implementations which require evaluation results from individual
       *   predicates should override this method to explicitly handle evaluation of
       *   the operands within operator predicates.
       *
       * @param pred The semantic context to evaluate
       * @param parserCallStack The parser context in which to evaluate the
       * semantic context
       * @param alt The alternative which is guarded by `pred`
       *
       * @since 4.3
       */
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        return pred.eval(this._parser, parserCallStack);
      }
      /* TODO: If we are doing predicates, there is no point in pursuing
           closure operations if we reach a DFA state that uniquely predicts
           alternative. We will not be caching that DFA state and it is a
           waste to pursue the closure. Might have to advance when we do
           ambig detection thought :(
            */
      closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let currentConfigs = sourceConfigs;
        let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        while (currentConfigs.size > 0) {
          let intermediate = new ATNConfigSet_1.ATNConfigSet();
          for (let config2 of currentConfigs) {
            this.closureImpl(config2, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
          }
          currentConfigs = intermediate;
        }
      }
      closureImpl(config2, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
        if (ParserATNSimulator2.debug) {
          console.log("closure(" + config2.toString(this._parser, true) + ")");
        }
        if (config2.state instanceof RuleStopState_1.RuleStopState) {
          if (!config2.context.isEmpty) {
            let hasEmpty = config2.context.hasEmpty;
            let nonEmptySize = config2.context.size - (hasEmpty ? 1 : 0);
            for (let i2 = 0; i2 < nonEmptySize; i2++) {
              let newContext = config2.context.getParent(i2);
              let returnState = this.atn.states[config2.context.getReturnState(i2)];
              let c3 = ATNConfig_1.ATNConfig.create(returnState, config2.alt, newContext, config2.semanticContext);
              c3.outerContextDepth = config2.outerContextDepth;
              c3.isPrecedenceFilterSuppressed = config2.isPrecedenceFilterSuppressed;
              assert(depth > MIN_INTEGER_VALUE);
              this.closureImpl(c3, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
            }
            if (!hasEmpty || !hasMoreContexts) {
              return;
            }
            config2 = config2.transform(config2.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          } else if (!hasMoreContexts) {
            configs.add(config2, contextCache);
            return;
          } else {
            if (ParserATNSimulator2.debug) {
              console.log("FALLING off rule " + this.getRuleName(config2.state.ruleIndex));
            }
            if (config2.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
              config2 = config2.transform(config2.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            } else if (!config2.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config2.context)) {
              configs.add(config2, contextCache);
            }
          }
        }
        let p = config2.state;
        if (!p.onlyHasEpsilonTransitions) {
          configs.add(config2, contextCache);
          if (ParserATNSimulator2.debug) {
            console.log("added config " + configs);
          }
        }
        for (let i2 = 0; i2 < p.numberOfOptimizedTransitions; i2++) {
          if (i2 === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config2.context.hasEmpty) {
            let precedenceDecision = p;
            let suppress = true;
            for (let j = 0; j < config2.context.size; j++) {
              if (!precedenceDecision.precedenceLoopbackStates.get(config2.context.getReturnState(j))) {
                suppress = false;
                break;
              }
            }
            if (suppress) {
              continue;
            }
          }
          let t = p.getOptimizedTransition(i2);
          let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
          let c3 = this.getEpsilonTarget(config2, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
          if (c3 != null) {
            if (t instanceof RuleTransition_1.RuleTransition) {
              if (intermediate != null && !collectPredicates) {
                intermediate.add(c3, contextCache);
                continue;
              }
            }
            let newDepth = depth;
            if (config2.state instanceof RuleStopState_1.RuleStopState) {
              if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                  c3.isPrecedenceFilterSuppressed = true;
                }
              }
              c3.outerContextDepth = c3.outerContextDepth + 1;
              if (!closureBusy.add(c3)) {
                continue;
              }
              assert(newDepth > MIN_INTEGER_VALUE);
              newDepth--;
              if (ParserATNSimulator2.debug) {
                console.log("dips into outer ctx: " + c3);
              }
            } else if (t instanceof RuleTransition_1.RuleTransition) {
              if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config2.context))) {
                assert(c3.context === config2.context);
                if (newDepth === 0) {
                  newDepth--;
                  if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config2.context)) {
                    c3.outerContextDepth = c3.outerContextDepth + 1;
                  }
                }
              } else {
                if (newDepth >= 0) {
                  newDepth++;
                }
              }
            } else {
              if (!t.isEpsilon && !closureBusy.add(c3)) {
                continue;
              }
            }
            this.closureImpl(c3, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
          }
        }
      }
      getRuleName(index) {
        if (this._parser != null && index >= 0) {
          return this._parser.ruleNames[index];
        }
        return "<rule " + index + ">";
      }
      getEpsilonTarget(config2, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
        switch (t.serializationType) {
          case 3:
            return this.ruleTransition(config2, t, contextCache);
          case 10:
            return this.precedenceTransition(config2, t, collectPredicates, inContext);
          case 4:
            return this.predTransition(config2, t, collectPredicates, inContext);
          case 6:
            return this.actionTransition(config2, t);
          case 1:
            return config2.transform(t.target, false);
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(Token_1.Token.EOF, 0, 1)) {
                return config2.transform(t.target, false);
              }
            }
            return void 0;
          default:
            return void 0;
        }
      }
      actionTransition(config2, t) {
        if (ParserATNSimulator2.debug) {
          console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
        }
        return config2.transform(t.target, false);
      }
      precedenceTransition(config2, pt, collectPredicates, inContext) {
        if (ParserATNSimulator2.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c3;
        if (collectPredicates && inContext) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config2.semanticContext, pt.predicate);
          c3 = config2.transform(pt.target, false, newSemCtx);
        } else {
          c3 = config2.transform(pt.target, false);
        }
        if (ParserATNSimulator2.debug) {
          console.log("config from pred transition=" + c3);
        }
        return c3;
      }
      predTransition(config2, pt, collectPredicates, inContext) {
        if (ParserATNSimulator2.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c3;
        if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config2.semanticContext, pt.predicate);
          c3 = config2.transform(pt.target, false, newSemCtx);
        } else {
          c3 = config2.transform(pt.target, false);
        }
        if (ParserATNSimulator2.debug) {
          console.log("config from pred transition=" + c3);
        }
        return c3;
      }
      ruleTransition(config2, t, contextCache) {
        if (ParserATNSimulator2.debug) {
          console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config2.context);
        }
        let returnState = t.followState;
        let newContext;
        if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config2.context))) {
          newContext = config2.context;
        } else if (contextCache != null) {
          newContext = contextCache.getChild(config2.context, returnState.stateNumber);
        } else {
          newContext = config2.context.getChild(returnState.stateNumber);
        }
        return config2.transform(t.target, false, newContext);
      }
      isConflicted(configset, contextCache) {
        if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
          return void 0;
        }
        let configs = configset.toArray();
        configs.sort(ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR);
        let exact = !configset.dipsIntoOuterContext;
        let alts = new BitSet_1.BitSet();
        let minAlt = configs[0].alt;
        alts.set(minAlt);
        let currentState = configs[0].state.nonStopStateNumber;
        for (let config2 of configs) {
          let stateNumber = config2.state.nonStopStateNumber;
          if (stateNumber !== currentState) {
            if (config2.alt !== minAlt) {
              return void 0;
            }
            currentState = stateNumber;
          }
        }
        let representedAlts;
        if (exact) {
          currentState = configs[0].state.nonStopStateNumber;
          representedAlts = new BitSet_1.BitSet();
          let maxAlt = minAlt;
          for (let config2 of configs) {
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            let alt = config2.alt;
            representedAlts.set(alt);
            maxAlt = alt;
          }
          currentState = configs[0].state.nonStopStateNumber;
          let currentAlt = minAlt;
          for (let config2 of configs) {
            let stateNumber = config2.state.nonStopStateNumber;
            let alt = config2.alt;
            if (stateNumber !== currentState) {
              if (currentAlt !== maxAlt) {
                exact = false;
                break;
              }
              currentState = stateNumber;
              currentAlt = minAlt;
            } else if (alt !== currentAlt) {
              if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                exact = false;
                break;
              }
              currentAlt = alt;
            }
          }
        }
        currentState = configs[0].state.nonStopStateNumber;
        let firstIndexCurrentState = 0;
        let lastIndexCurrentStateMinAlt = 0;
        let joinedCheckContext = configs[0].context;
        for (let i2 = 1; i2 < configs.length; i2++) {
          let config2 = configs[i2];
          if (config2.alt !== minAlt) {
            break;
          }
          if (config2.state.nonStopStateNumber !== currentState) {
            break;
          }
          lastIndexCurrentStateMinAlt = i2;
          joinedCheckContext = contextCache.join(joinedCheckContext, configs[i2].context);
        }
        for (let i2 = lastIndexCurrentStateMinAlt + 1; i2 < configs.length; i2++) {
          let config2 = configs[i2];
          let state = config2.state;
          alts.set(config2.alt);
          if (state.nonStopStateNumber !== currentState) {
            currentState = state.nonStopStateNumber;
            firstIndexCurrentState = i2;
            lastIndexCurrentStateMinAlt = i2;
            joinedCheckContext = config2.context;
            for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
              let config22 = configs[j];
              if (config22.alt !== minAlt) {
                break;
              }
              if (config22.state.nonStopStateNumber !== currentState) {
                break;
              }
              lastIndexCurrentStateMinAlt = j;
              joinedCheckContext = contextCache.join(joinedCheckContext, config22.context);
            }
            i2 = lastIndexCurrentStateMinAlt;
            continue;
          }
          let joinedCheckContext2 = config2.context;
          let currentAlt = config2.alt;
          let lastIndexCurrentStateCurrentAlt = i2;
          for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
            let config22 = configs[j];
            if (config22.alt !== currentAlt) {
              break;
            }
            if (config22.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateCurrentAlt = j;
            joinedCheckContext2 = contextCache.join(joinedCheckContext2, config22.context);
          }
          i2 = lastIndexCurrentStateCurrentAlt;
          let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
          if (!joinedCheckContext.equals(check)) {
            return void 0;
          }
          exact = exact && joinedCheckContext.equals(joinedCheckContext2);
        }
        return new ConflictInfo_1.ConflictInfo(alts, exact);
      }
      getConflictingAltsFromConfigSet(configs) {
        let conflictingAlts = configs.conflictingAlts;
        if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          conflictingAlts = new BitSet_1.BitSet();
          conflictingAlts.set(configs.uniqueAlt);
        }
        return conflictingAlts;
      }
      getTokenName(t) {
        if (t === Token_1.Token.EOF) {
          return "EOF";
        }
        let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        let displayName = vocabulary.getDisplayName(t);
        if (displayName === String(t)) {
          return displayName;
        }
        return displayName + "<" + t + ">";
      }
      getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
      }
      dumpDeadEndConfigs(nvae) {
        console.log("dead end configs: ");
        let deadEndConfigs = nvae.deadEndConfigs;
        if (!deadEndConfigs) {
          return;
        }
        for (let c3 of deadEndConfigs) {
          let trans = "no edges";
          if (c3.state.numberOfOptimizedTransitions > 0) {
            let t = c3.state.getOptimizedTransition(0);
            if (t instanceof AtomTransition_1.AtomTransition) {
              trans = "Atom " + this.getTokenName(t._label);
            } else if (t instanceof SetTransition_1.SetTransition) {
              let not = t instanceof NotSetTransition_1.NotSetTransition;
              trans = (not ? "~" : "") + "Set " + t.set.toString();
            }
          }
          console.log(c3.toString(this._parser, true) + ":" + trans);
        }
      }
      noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
      }
      getUniqueAlt(configs) {
        let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c3 of configs) {
          if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
            alt = c3.alt;
          } else if (c3.alt !== alt) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
        }
        return alt;
      }
      configWithAltAtStopState(configs, alt) {
        for (let c3 of configs) {
          if (c3.alt === alt) {
            if (c3.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
        }
        return false;
      }
      addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
        assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
        let from = fromState;
        let to = this.addDFAState(dfa, toConfigs, contextCache);
        if (contextTransitions != null) {
          for (let context of contextTransitions.toArray()) {
            if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (from.configs.isOutermostConfigSet) {
                continue;
              }
            }
            from.setContextSensitive(this.atn);
            from.setContextSymbol(t);
            let next = from.getContextTarget(context);
            if (next != null) {
              from = next;
              continue;
            }
            next = this.addDFAContextState(dfa, from.configs, context, contextCache);
            assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
            from.setContextTarget(context, next);
            from = next;
          }
        }
        if (ParserATNSimulator2.debug) {
          console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
        }
        this.setDFAEdge(from, t, to);
        if (ParserATNSimulator2.debug) {
          console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
        }
        return to;
      }
      setDFAEdge(p, t, q) {
        if (p != null) {
          p.setTarget(t, q);
        }
      }
      /** See comment on LexerInterpreter.addDFAState. */
      addDFAContextState(dfa, configs, returnContext, contextCache) {
        if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
          for (let config2 of configs) {
            contextConfigs.add(config2.appendContext(returnContext, contextCache));
          }
          return this.addDFAState(dfa, contextConfigs, contextCache);
        } else {
          assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
          configs = configs.clone(true);
          configs.isOutermostConfigSet = true;
          return this.addDFAState(dfa, configs, contextCache);
        }
      }
      /** See comment on LexerInterpreter.addDFAState. */
      addDFAState(dfa, configs, contextCache) {
        let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
        if (enableDfa) {
          if (!configs.isReadOnly) {
            configs.optimizeConfigs(this);
          }
          let proposed = this.createDFAState(dfa, configs);
          let existing = dfa.states.get(proposed);
          if (existing != null) {
            return existing;
          }
        }
        if (!configs.isReadOnly) {
          if (configs.conflictInfo == null) {
            configs.conflictInfo = this.isConflicted(configs, contextCache);
          }
        }
        let newState = this.createDFAState(dfa, configs.clone(true));
        let decisionState = this.atn.getDecisionState(dfa.decision);
        let predictedAlt = this.getUniqueAlt(configs);
        if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
        } else if (configs.conflictingAlts != null) {
          let conflictingAlts = configs.conflictingAlts;
          if (conflictingAlts) {
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
          }
        }
        if (newState.isAcceptState && configs.hasSemanticContext) {
          this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
        }
        if (!enableDfa) {
          return newState;
        }
        let added = dfa.addState(newState);
        if (ParserATNSimulator2.debug && added === newState) {
          console.log("adding new DFA state: " + newState);
        }
        return added;
      }
      createDFAState(dfa, configs) {
        return new DFAState_1.DFAState(configs);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        }
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        }
      }
      /** If context sensitive parsing, we know it's ambiguity not conflict */
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        }
      }
      getReturnState(context) {
        if (context.isEmpty) {
          return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        let state = this.atn.states[context.invokingState];
        let transition = state.transition(0);
        return transition.followState.stateNumber;
      }
      skipTailCalls(context) {
        if (!this.optimize_tail_calls) {
          return context;
        }
        while (!context.isEmpty) {
          let state = this.atn.states[context.invokingState];
          assert(
            state.numberOfTransitions === 1 && state.transition(0).serializationType === 3
            /* RULE */
          );
          let transition = state.transition(0);
          if (!transition.tailCall) {
            break;
          }
          context = context.parent;
        }
        return context;
      }
      /**
       * @since 4.3
       */
      get parser() {
        return this._parser;
      }
    };
    ParserATNSimulator.debug = false;
    ParserATNSimulator.dfa_debug = false;
    ParserATNSimulator.retry_debug = false;
    ParserATNSimulator.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
      let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
      if (diff !== 0) {
        return diff;
      }
      diff = o1.alt - o2.alt;
      if (diff !== 0) {
        return diff;
      }
      return 0;
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "predictionMode", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "getPredictionMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "setPredictionMode", null);
    __decorate([
      Decorators_1.Override
    ], ParserATNSimulator.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "adaptivePredict", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "execDFA", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "handleNoViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "removeAllConfigsNotInRuleStopState", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "applyPrecedenceFilter", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getReachableTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getPredsForAmbigAlts", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "evalSemanticContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "evalSemanticContextImpl", null);
    __decorate([
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.Nullable)
    ], ParserATNSimulator.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable),
      __param(3, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "closureImpl", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "getRuleName", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getEpsilonTarget", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "actionTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "precedenceTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "predTransition", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator.prototype, "ruleTransition", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "isConflicted", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "getTokenName", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "dumpDeadEndConfigs", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "noViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getUniqueAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "configWithAltAtStopState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "addDFAEdge", null);
    __decorate([
      __param(0, Decorators_1.Nullable),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator.prototype, "setDFAEdge", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "addDFAContextState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "createDFAState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "reportAttemptingFullContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "reportAmbiguity", null);
    ParserATNSimulator = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator);
    exports2.ParserATNSimulator = ParserATNSimulator;
  }
});

// node_modules/antlr4ts/atn/PlusBlockStartState.js
var require_PlusBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/PlusBlockStartState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PlusBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusBlockStartState.prototype, "stateType", null);
    exports2.PlusBlockStartState = PlusBlockStartState;
  }
});

// node_modules/antlr4ts/atn/PlusLoopbackState.js
var require_PlusLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/PlusLoopbackState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PlusLoopbackState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var PlusLoopbackState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusLoopbackState.prototype, "stateType", null);
    exports2.PlusLoopbackState = PlusLoopbackState;
  }
});

// node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
var require_PrecedencePredicateTransition = __commonJS({
  "node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrecedencePredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, precedence) {
        super(target);
        this.precedence = precedence;
      }
      get serializationType() {
        return 10;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
      }
      toString() {
        return this.precedence + " >= _p";
      }
    };
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "toString", null);
    PrecedencePredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PrecedencePredicateTransition);
    exports2.PrecedencePredicateTransition = PrecedencePredicateTransition;
  }
});

// node_modules/antlr4ts/atn/RangeTransition.js
var require_RangeTransition = __commonJS({
  "node_modules/antlr4ts/atn/RangeTransition.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RangeTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RangeTransition = class RangeTransition extends Transition_1.Transition {
      constructor(target, from, to) {
        super(target);
        this.from = from;
        this.to = to;
      }
      get serializationType() {
        return 2;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this.from, this.to);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= this.from && symbol <= this.to;
      }
      toString() {
        return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
      }
    };
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "toString", null);
    RangeTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RangeTransition);
    exports2.RangeTransition = RangeTransition;
  }
});

// node_modules/antlr4ts/atn/RuleStartState.js
var require_RuleStartState = __commonJS({
  "node_modules/antlr4ts/atn/RuleStartState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleStartState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStartState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.isPrecedenceRule = false;
        this.leftFactored = false;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStartState.prototype, "stateType", null);
    exports2.RuleStartState = RuleStartState;
  }
});

// node_modules/antlr4ts/atn/StarBlockStartState.js
var require_StarBlockStartState = __commonJS({
  "node_modules/antlr4ts/atn/StarBlockStartState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StarBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarBlockStartState.prototype, "stateType", null);
    exports2.StarBlockStartState = StarBlockStartState;
  }
});

// node_modules/antlr4ts/atn/StarLoopbackState.js
var require_StarLoopbackState = __commonJS({
  "node_modules/antlr4ts/atn/StarLoopbackState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StarLoopbackState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var StarLoopbackState = class extends ATNState_1.ATNState {
      get loopEntryState() {
        return this.transition(0).target;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopbackState.prototype, "stateType", null);
    exports2.StarLoopbackState = StarLoopbackState;
  }
});

// node_modules/antlr4ts/atn/TokensStartState.js
var require_TokensStartState = __commonJS({
  "node_modules/antlr4ts/atn/TokensStartState.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokensStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var TokensStartState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.TOKEN_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], TokensStartState.prototype, "stateType", null);
    exports2.TokensStartState = TokensStartState;
  }
});

// node_modules/antlr4ts/misc/UUID.js
var require_UUID = __commonJS({
  "node_modules/antlr4ts/misc/UUID.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UUID = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var UUID = class _UUID {
      constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
        this.data = new Uint32Array(4);
        this.data[0] = mostSigBits;
        this.data[1] = moreSigBits;
        this.data[2] = lessSigBits;
        this.data[3] = leastSigBits;
      }
      static fromString(data) {
        if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
          throw new Error("Incorrectly formatted UUID");
        }
        let segments = data.split("-");
        let mostSigBits = parseInt(segments[0], 16);
        let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
        let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
        let leastSigBits = parseInt(segments[4].substr(-8), 16);
        return new _UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _UUID)) {
          return false;
        }
        return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
      }
      toString() {
        return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
      }
    };
    exports2.UUID = UUID;
  }
});

// node_modules/antlr4ts/atn/ATNDeserializer.js
var require_ATNDeserializer = __commonJS({
  "node_modules/antlr4ts/atn/ATNDeserializer.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ATNDeserializer = void 0;
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATN_1 = require_ATN();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BasicBlockStartState_1 = require_BasicBlockStartState();
    var BasicState_1 = require_BasicState();
    var BitSet_1 = require_BitSet();
    var BlockEndState_1 = require_BlockEndState();
    var BlockStartState_1 = require_BlockStartState();
    var DecisionState_1 = require_DecisionState();
    var DFA_1 = require_DFA();
    var EpsilonTransition_1 = require_EpsilonTransition();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LexerChannelAction_1 = require_LexerChannelAction();
    var LexerCustomAction_1 = require_LexerCustomAction();
    var LexerModeAction_1 = require_LexerModeAction();
    var LexerMoreAction_1 = require_LexerMoreAction();
    var LexerPopModeAction_1 = require_LexerPopModeAction();
    var LexerPushModeAction_1 = require_LexerPushModeAction();
    var LexerSkipAction_1 = require_LexerSkipAction();
    var LexerTypeAction_1 = require_LexerTypeAction();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PlusBlockStartState_1 = require_PlusBlockStartState();
    var PlusLoopbackState_1 = require_PlusLoopbackState();
    var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
    var PredicateTransition_1 = require_PredicateTransition();
    var RangeTransition_1 = require_RangeTransition();
    var RuleStartState_1 = require_RuleStartState();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SetTransition_1 = require_SetTransition();
    var StarBlockStartState_1 = require_StarBlockStartState();
    var StarLoopbackState_1 = require_StarLoopbackState();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var TokensStartState_1 = require_TokensStartState();
    var UUID_1 = require_UUID();
    var WildcardTransition_1 = require_WildcardTransition();
    var UnicodeDeserializingMode;
    (function(UnicodeDeserializingMode2) {
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
    })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
    var ATNDeserializer = class _ATNDeserializer {
      constructor(deserializationOptions) {
        if (deserializationOptions === void 0) {
          deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
        }
        this.deserializationOptions = deserializationOptions;
      }
      static get SERIALIZED_VERSION() {
        return 3;
      }
      /**
       * Determines if a particular serialized representation of an ATN supports
       * a particular feature, identified by the {@link UUID} used for serializing
       * the ATN at the time the feature was first introduced.
       *
       * @param feature The {@link UUID} marking the first time the feature was
       * supported in the serialized ATN.
       * @param actualUuid The {@link UUID} of the actual serialized ATN which is
       * currently being deserialized.
       * @returns `true` if the `actualUuid` value represents a
       * serialized ATN at or after the feature identified by `feature` was
       * introduced; otherwise, `false`.
       */
      static isFeatureSupported(feature, actualUuid) {
        let featureIndex = _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
        if (featureIndex < 0) {
          return false;
        }
        return _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
      }
      static getUnicodeDeserializer(mode) {
        if (mode === 0) {
          return {
            readUnicode: (data, p) => {
              return _ATNDeserializer.toInt(data[p]);
            },
            size: 1
          };
        } else {
          return {
            readUnicode: (data, p) => {
              return _ATNDeserializer.toInt32(data, p);
            },
            size: 2
          };
        }
      }
      deserialize(data) {
        data = data.slice(0);
        for (let i2 = 1; i2 < data.length; i2++) {
          data[i2] = data[i2] - 2 & 65535;
        }
        let p = 0;
        let version = _ATNDeserializer.toInt(data[p++]);
        if (version !== _ATNDeserializer.SERIALIZED_VERSION) {
          let reason = `Could not deserialize ATN with version ${version} (expected ${_ATNDeserializer.SERIALIZED_VERSION}).`;
          throw new Error(reason);
        }
        let uuid = _ATNDeserializer.toUUID(data, p);
        p += 8;
        if (_ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
          let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${_ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;
          throw new Error(reason);
        }
        let supportsLexerActions = _ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);
        let grammarType = _ATNDeserializer.toInt(data[p++]);
        let maxTokenType = _ATNDeserializer.toInt(data[p++]);
        let atn = new ATN_1.ATN(grammarType, maxTokenType);
        let loopBackStateNumbers = [];
        let endStateNumbers = [];
        let nstates = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 0; i2 < nstates; i2++) {
          let stype = _ATNDeserializer.toInt(data[p++]);
          if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            atn.addState(new InvalidState_1.InvalidState());
            continue;
          }
          let ruleIndex = _ATNDeserializer.toInt(data[p++]);
          if (ruleIndex === 65535) {
            ruleIndex = -1;
          }
          let s = this.stateFactory(stype, ruleIndex);
          if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
            let loopBackStateNumber = _ATNDeserializer.toInt(data[p++]);
            loopBackStateNumbers.push([s, loopBackStateNumber]);
          } else if (s instanceof BlockStartState_1.BlockStartState) {
            let endStateNumber = _ATNDeserializer.toInt(data[p++]);
            endStateNumbers.push([s, endStateNumber]);
          }
          atn.addState(s);
        }
        for (let pair of loopBackStateNumbers) {
          pair[0].loopBackState = atn.states[pair[1]];
        }
        for (let pair of endStateNumbers) {
          pair[0].endState = atn.states[pair[1]];
        }
        let numNonGreedyStates = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 0; i2 < numNonGreedyStates; i2++) {
          let stateNumber = _ATNDeserializer.toInt(data[p++]);
          atn.states[stateNumber].nonGreedy = true;
        }
        let numSllDecisions = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 0; i2 < numSllDecisions; i2++) {
          let stateNumber = _ATNDeserializer.toInt(data[p++]);
          atn.states[stateNumber].sll = true;
        }
        let numPrecedenceStates = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 0; i2 < numPrecedenceStates; i2++) {
          let stateNumber = _ATNDeserializer.toInt(data[p++]);
          atn.states[stateNumber].isPrecedenceRule = true;
        }
        let nrules = _ATNDeserializer.toInt(data[p++]);
        if (atn.grammarType === 0) {
          atn.ruleToTokenType = new Int32Array(nrules);
        }
        atn.ruleToStartState = new Array(nrules);
        for (let i2 = 0; i2 < nrules; i2++) {
          let s = _ATNDeserializer.toInt(data[p++]);
          let startState = atn.states[s];
          startState.leftFactored = _ATNDeserializer.toInt(data[p++]) !== 0;
          atn.ruleToStartState[i2] = startState;
          if (atn.grammarType === 0) {
            let tokenType = _ATNDeserializer.toInt(data[p++]);
            if (tokenType === 65535) {
              tokenType = Token_1.Token.EOF;
            }
            atn.ruleToTokenType[i2] = tokenType;
            if (!_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {
              let actionIndexIgnored = _ATNDeserializer.toInt(data[p++]);
              if (actionIndexIgnored === 65535) {
                actionIndexIgnored = -1;
              }
            }
          }
        }
        atn.ruleToStopState = new Array(nrules);
        for (let state of atn.states) {
          if (!(state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          atn.ruleToStopState[state.ruleIndex] = state;
          atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
        let nmodes = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 0; i2 < nmodes; i2++) {
          let s = _ATNDeserializer.toInt(data[p++]);
          atn.modeToStartState.push(atn.states[s]);
        }
        atn.modeToDFA = new Array(nmodes);
        for (let i2 = 0; i2 < nmodes; i2++) {
          atn.modeToDFA[i2] = new DFA_1.DFA(atn.modeToStartState[i2]);
        }
        let sets = [];
        p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
          0
          /* UNICODE_BMP */
        ));
        if (_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {
          p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
            1
            /* UNICODE_SMP */
          ));
        }
        let nedges = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 0; i2 < nedges; i2++) {
          let src = _ATNDeserializer.toInt(data[p]);
          let trg = _ATNDeserializer.toInt(data[p + 1]);
          let ttype = _ATNDeserializer.toInt(data[p + 2]);
          let arg1 = _ATNDeserializer.toInt(data[p + 3]);
          let arg2 = _ATNDeserializer.toInt(data[p + 4]);
          let arg3 = _ATNDeserializer.toInt(data[p + 5]);
          let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
          let srcState = atn.states[src];
          srcState.addTransition(trans);
          p += 6;
        }
        let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
          hashCode: (o2) => o2.stopState ^ o2.returnState ^ o2.outermostPrecedenceReturn,
          equals: (a2, b) => {
            return a2.stopState === b.stopState && a2.returnState === b.returnState && a2.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
          }
        });
        let returnTransitions = [];
        for (let state of atn.states) {
          let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
          for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
            let t = state.transition(i2);
            if (!(t instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            let ruleTransition = t;
            let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
            if (!returningFromLeftFactored && returningToLeftFactored) {
              continue;
            }
            let outermostPrecedenceReturn = -1;
            if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
              if (ruleTransition.precedence === 0) {
                outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
              }
            }
            let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
            if (returnTransitionsSet.add(current)) {
              returnTransitions.push(current);
            }
          }
        }
        for (let returnTransition of returnTransitions) {
          let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
          atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
        }
        for (let state of atn.states) {
          if (state instanceof BlockStartState_1.BlockStartState) {
            if (state.endState === void 0) {
              throw new Error("IllegalStateException");
            }
            if (state.endState.startState !== void 0) {
              throw new Error("IllegalStateException");
            }
            state.endState.startState = state;
          }
          if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
            let loopbackState = state;
            for (let i2 = 0; i2 < loopbackState.numberOfTransitions; i2++) {
              let target = loopbackState.transition(i2).target;
              if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                target.loopBackState = loopbackState;
              }
            }
          } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            let loopbackState = state;
            for (let i2 = 0; i2 < loopbackState.numberOfTransitions; i2++) {
              let target = loopbackState.transition(i2).target;
              if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                target.loopBackState = loopbackState;
              }
            }
          }
        }
        let ndecisions = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 1; i2 <= ndecisions; i2++) {
          let s = _ATNDeserializer.toInt(data[p++]);
          let decState = atn.states[s];
          atn.decisionToState.push(decState);
          decState.decision = i2 - 1;
        }
        if (atn.grammarType === 0) {
          if (supportsLexerActions) {
            atn.lexerActions = new Array(_ATNDeserializer.toInt(data[p++]));
            for (let i2 = 0; i2 < atn.lexerActions.length; i2++) {
              let actionType = _ATNDeserializer.toInt(data[p++]);
              let data1 = _ATNDeserializer.toInt(data[p++]);
              if (data1 === 65535) {
                data1 = -1;
              }
              let data2 = _ATNDeserializer.toInt(data[p++]);
              if (data2 === 65535) {
                data2 = -1;
              }
              let lexerAction = this.lexerActionFactory(actionType, data1, data2);
              atn.lexerActions[i2] = lexerAction;
            }
          } else {
            let legacyLexerActions = [];
            for (let state of atn.states) {
              for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                let transition = state.transition(i2);
                if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                  continue;
                }
                let ruleIndex = transition.ruleIndex;
                let actionIndex = transition.actionIndex;
                let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                state.setTransition(i2, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                legacyLexerActions.push(lexerAction);
              }
            }
            atn.lexerActions = legacyLexerActions;
          }
        }
        this.markPrecedenceDecisions(atn);
        atn.decisionToDFA = new Array(ndecisions);
        for (let i2 = 0; i2 < ndecisions; i2++) {
          atn.decisionToDFA[i2] = new DFA_1.DFA(atn.decisionToState[i2], i2);
        }
        if (this.deserializationOptions.isVerifyATN) {
          this.verifyATN(atn);
        }
        if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
          atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
          for (let i2 = 0; i2 < atn.ruleToStartState.length; i2++) {
            atn.ruleToTokenType[i2] = atn.maxTokenType + i2 + 1;
          }
          for (let i2 = 0; i2 < atn.ruleToStartState.length; i2++) {
            let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
            bypassStart.ruleIndex = i2;
            atn.addState(bypassStart);
            let bypassStop = new BlockEndState_1.BlockEndState();
            bypassStop.ruleIndex = i2;
            atn.addState(bypassStop);
            bypassStart.endState = bypassStop;
            atn.defineDecisionState(bypassStart);
            bypassStop.startState = bypassStart;
            let endState;
            let excludeTransition;
            if (atn.ruleToStartState[i2].isPrecedenceRule) {
              endState = void 0;
              for (let state of atn.states) {
                if (state.ruleIndex !== i2) {
                  continue;
                }
                if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                  continue;
                }
                let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                  continue;
                }
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  endState = state;
                  break;
                }
              }
              if (!endState) {
                throw new Error("Couldn't identify final state of the precedence rule prefix section.");
              }
              excludeTransition = endState.loopBackState.transition(0);
            } else {
              endState = atn.ruleToStopState[i2];
            }
            for (let state of atn.states) {
              for (let i3 = 0; i3 < state.numberOfTransitions; i3++) {
                let transition = state.transition(i3);
                if (transition === excludeTransition) {
                  continue;
                }
                if (transition.target === endState) {
                  transition.target = bypassStop;
                }
              }
            }
            while (atn.ruleToStartState[i2].numberOfTransitions > 0) {
              let transition = atn.ruleToStartState[i2].removeTransition(atn.ruleToStartState[i2].numberOfTransitions - 1);
              bypassStart.addTransition(transition);
            }
            atn.ruleToStartState[i2].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
            bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
            let matchState = new BasicState_1.BasicState();
            atn.addState(matchState);
            matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i2]));
            bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        if (this.deserializationOptions.isOptimize) {
          while (true) {
            let optimizationCount = 0;
            optimizationCount += _ATNDeserializer.inlineSetRules(atn);
            optimizationCount += _ATNDeserializer.combineChainedEpsilons(atn);
            let preserveOrder = atn.grammarType === 0;
            optimizationCount += _ATNDeserializer.optimizeSets(atn, preserveOrder);
            if (optimizationCount === 0) {
              break;
            }
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        _ATNDeserializer.identifyTailCalls(atn);
        return atn;
      }
      deserializeSets(data, p, sets, unicodeDeserializer) {
        let nsets = _ATNDeserializer.toInt(data[p++]);
        for (let i2 = 0; i2 < nsets; i2++) {
          let nintervals = _ATNDeserializer.toInt(data[p]);
          p++;
          let set2 = new IntervalSet_1.IntervalSet();
          sets.push(set2);
          let containsEof = _ATNDeserializer.toInt(data[p++]) !== 0;
          if (containsEof) {
            set2.add(-1);
          }
          for (let j = 0; j < nintervals; j++) {
            let a2 = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            let b = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            set2.add(a2, b);
          }
        }
        return p;
      }
      /**
       * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
       * the {@link StarLoopEntryState#precedenceRuleDecision} field to the
       * correct value.
       *
       * @param atn The ATN.
       */
      markPrecedenceDecisions(atn) {
        let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
        for (let state of atn.states) {
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
            if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                rulePrecedenceDecisions.set(state.ruleIndex, state);
                state.precedenceRuleDecision = true;
                state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
              }
            }
          }
        }
        for (let precedenceDecision of rulePrecedenceDecisions) {
          for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
            if (transition.serializationType !== 1) {
              continue;
            }
            let epsilonTransition = transition;
            if (epsilonTransition.outermostPrecedenceReturn !== -1) {
              continue;
            }
            precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
          }
        }
      }
      verifyATN(atn) {
        for (let state of atn.states) {
          this.checkCondition(state !== void 0, "ATN states should not be undefined.");
          if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            continue;
          }
          this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
          if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
            let starLoopEntryState = state;
            this.checkCondition(starLoopEntryState.loopBackState !== void 0);
            this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
            if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
              this.checkCondition(!starLoopEntryState.nonGreedy);
            } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
              this.checkCondition(starLoopEntryState.nonGreedy);
            } else {
              throw new Error("IllegalStateException");
            }
          }
          if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            this.checkCondition(state.numberOfTransitions === 1);
            this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
          }
          if (state instanceof LoopEndState_1.LoopEndState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof RuleStartState_1.RuleStartState) {
            this.checkCondition(state.stopState !== void 0);
          }
          if (state instanceof BlockStartState_1.BlockStartState) {
            this.checkCondition(state.endState !== void 0);
          }
          if (state instanceof BlockEndState_1.BlockEndState) {
            this.checkCondition(state.startState !== void 0);
          }
          if (state instanceof DecisionState_1.DecisionState) {
            let decisionState = state;
            this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
          } else {
            this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
          }
        }
      }
      checkCondition(condition, message) {
        if (!condition) {
          throw new Error("IllegalStateException: " + message);
        }
      }
      static inlineSetRules(atn) {
        let inlinedCalls = 0;
        let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
        for (let i2 = 0; i2 < atn.ruleToStartState.length; i2++) {
          let startState = atn.ruleToStartState[i2];
          let middleState = startState;
          while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
            middleState = middleState.getOptimizedTransition(0).target;
          }
          if (middleState.numberOfOptimizedTransitions !== 1) {
            continue;
          }
          let matchTransition = middleState.getOptimizedTransition(0);
          let matchTarget = matchTransition.target;
          if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          switch (matchTransition.serializationType) {
            case 5:
            case 2:
            case 7:
              ruleToInlineTransition[i2] = matchTransition;
              break;
            case 8:
            case 9:
              continue;
            default:
              continue;
          }
        }
        for (let state of atn.states) {
          if (state.ruleIndex < 0) {
            continue;
          }
          let optimizedTransitions;
          for (let i2 = 0; i2 < state.numberOfOptimizedTransitions; i2++) {
            let transition = state.getOptimizedTransition(i2);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            let ruleTransition = transition;
            let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
            if (effective === void 0) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i2; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(i2));
              }
            }
            inlinedCalls++;
            let target = ruleTransition.followState;
            let intermediateState = new BasicState_1.BasicState();
            intermediateState.setRuleIndex(target.ruleIndex);
            atn.addState(intermediateState);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
            switch (effective.serializationType) {
              case 5:
                intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                break;
              case 2:
                intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                break;
              case 7:
                intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                break;
              default:
                throw new Error("UnsupportedOperationException");
            }
          }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
        }
        return inlinedCalls;
      }
      static combineChainedEpsilons(atn) {
        let removedEdges = 0;
        for (let state of atn.states) {
          if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          let optimizedTransitions;
          nextTransition: for (let i2 = 0; i2 < state.numberOfOptimizedTransitions; i2++) {
            let transition = state.getOptimizedTransition(i2);
            let intermediate = transition.target;
            if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue nextTransition;
            }
            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
              if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
            }
            removedEdges++;
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i2; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(j));
              }
            }
            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
              let target = intermediate.getOptimizedTransition(j).target;
              optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
            }
          }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
        }
        return removedEdges;
      }
      static optimizeSets(atn, preserveOrder) {
        if (preserveOrder) {
          return 0;
        }
        let removedPaths = 0;
        let decisions = atn.decisionToState;
        for (let decision of decisions) {
          let setTransitions = new IntervalSet_1.IntervalSet();
          for (let i2 = 0; i2 < decision.numberOfOptimizedTransitions; i2++) {
            let epsTransition = decision.getOptimizedTransition(i2);
            if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
              continue;
            }
            if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            let transition = epsTransition.target.getOptimizedTransition(0);
            if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
              continue;
            }
            if (transition instanceof NotSetTransition_1.NotSetTransition) {
              continue;
            }
            if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
              setTransitions.add(i2);
            }
          }
          if (setTransitions.size <= 1) {
            continue;
          }
          let optimizedTransitions = [];
          for (let i2 = 0; i2 < decision.numberOfOptimizedTransitions; i2++) {
            if (!setTransitions.contains(i2)) {
              optimizedTransitions.push(decision.getOptimizedTransition(i2));
            }
          }
          let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
          let matchSet = new IntervalSet_1.IntervalSet();
          for (let interval of setTransitions.intervals) {
            for (let j = interval.a; j <= interval.b; j++) {
              let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
              if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                throw new Error("Not yet implemented.");
              } else {
                matchSet.addAll(matchTransition.label);
              }
            }
          }
          let newTransition;
          if (matchSet.intervals.length === 1) {
            if (matchSet.size === 1) {
              newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
            } else {
              let matchInterval = matchSet.intervals[0];
              newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
            }
          } else {
            newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
          }
          let setOptimizedState = new BasicState_1.BasicState();
          setOptimizedState.setRuleIndex(decision.ruleIndex);
          atn.addState(setOptimizedState);
          setOptimizedState.addTransition(newTransition);
          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
          removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
          if (decision.isOptimized) {
            while (decision.numberOfOptimizedTransitions > 0) {
              decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
            }
          }
          for (let transition of optimizedTransitions) {
            decision.addOptimizedTransition(transition);
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
        }
        return removedPaths;
      }
      static identifyTailCalls(atn) {
        for (let state of atn.states) {
          for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
            let transition = state.transition(i2);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
          if (!state.isOptimized) {
            continue;
          }
          for (let i2 = 0; i2 < state.numberOfOptimizedTransitions; i2++) {
            let transition = state.getOptimizedTransition(i2);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
        }
      }
      static testTailCall(atn, transition, optimizedPath) {
        if (!optimizedPath && transition.tailCall) {
          return true;
        }
        if (optimizedPath && transition.optimizedTailCall) {
          return true;
        }
        let reachable = new BitSet_1.BitSet(atn.states.length);
        let worklist = [];
        worklist.push(transition.followState);
        while (true) {
          let state = worklist.pop();
          if (!state) {
            break;
          }
          if (reachable.get(state.stateNumber)) {
            continue;
          }
          if (state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          if (!state.onlyHasEpsilonTransitions) {
            return false;
          }
          let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
          for (let i2 = 0; i2 < transitionCount; i2++) {
            let t = optimizedPath ? state.getOptimizedTransition(i2) : state.transition(i2);
            if (t.serializationType !== 1) {
              return false;
            }
            worklist.push(t.target);
          }
        }
        return true;
      }
      static toInt(c3) {
        return c3;
      }
      static toInt32(data, offset) {
        return (data[offset] | data[offset + 1] << 16) >>> 0;
      }
      static toUUID(data, offset) {
        let leastSigBits = _ATNDeserializer.toInt32(data, offset);
        let lessSigBits = _ATNDeserializer.toInt32(data, offset + 2);
        let moreSigBits = _ATNDeserializer.toInt32(data, offset + 4);
        let mostSigBits = _ATNDeserializer.toInt32(data, offset + 6);
        return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
        let target = atn.states[trg];
        switch (type) {
          case 1:
            return new EpsilonTransition_1.EpsilonTransition(target);
          case 2:
            if (arg3 !== 0) {
              return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
            } else {
              return new RangeTransition_1.RangeTransition(target, arg1, arg2);
            }
          case 3:
            let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
            return rt;
          case 4:
            let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
            return pt;
          case 10:
            return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
          case 5:
            if (arg3 !== 0) {
              return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
            } else {
              return new AtomTransition_1.AtomTransition(target, arg1);
            }
          case 6:
            let a2 = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
            return a2;
          case 7:
            return new SetTransition_1.SetTransition(target, sets[arg1]);
          case 8:
            return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
          case 9:
            return new WildcardTransition_1.WildcardTransition(target);
        }
        throw new Error("The specified transition type is not valid.");
      }
      stateFactory(type, ruleIndex) {
        let s;
        switch (type) {
          case ATNStateType_1.ATNStateType.INVALID_TYPE:
            return new InvalidState_1.InvalidState();
          case ATNStateType_1.ATNStateType.BASIC:
            s = new BasicState_1.BasicState();
            break;
          case ATNStateType_1.ATNStateType.RULE_START:
            s = new RuleStartState_1.RuleStartState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_START:
            s = new BasicBlockStartState_1.BasicBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
            s = new PlusBlockStartState_1.PlusBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
            s = new StarBlockStartState_1.StarBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.TOKEN_START:
            s = new TokensStartState_1.TokensStartState();
            break;
          case ATNStateType_1.ATNStateType.RULE_STOP:
            s = new RuleStopState_1.RuleStopState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_END:
            s = new BlockEndState_1.BlockEndState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            s = new StarLoopbackState_1.StarLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            s = new StarLoopEntryState_1.StarLoopEntryState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
            s = new PlusLoopbackState_1.PlusLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.LOOP_END:
            s = new LoopEndState_1.LoopEndState();
            break;
          default:
            let message = `The specified state type ${type} is not valid.`;
            throw new Error(message);
        }
        s.ruleIndex = ruleIndex;
        return s;
      }
      lexerActionFactory(type, data1, data2) {
        switch (type) {
          case 0:
            return new LexerChannelAction_1.LexerChannelAction(data1);
          case 1:
            return new LexerCustomAction_1.LexerCustomAction(data1, data2);
          case 2:
            return new LexerModeAction_1.LexerModeAction(data1);
          case 3:
            return LexerMoreAction_1.LexerMoreAction.INSTANCE;
          case 4:
            return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
          case 5:
            return new LexerPushModeAction_1.LexerPushModeAction(data1);
          case 6:
            return LexerSkipAction_1.LexerSkipAction.INSTANCE;
          case 7:
            return new LexerTypeAction_1.LexerTypeAction(data1);
          default:
            let message = `The specified lexer action type ${type} is not valid.`;
            throw new Error(message);
        }
      }
    };
    ATNDeserializer.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
    ATNDeserializer.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
    ATNDeserializer.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
    ATNDeserializer.SUPPORTED_UUIDS = [
      ATNDeserializer.BASE_SERIALIZED_UUID,
      ATNDeserializer.ADDED_LEXER_ACTIONS,
      ATNDeserializer.ADDED_UNICODE_SMP
    ];
    ATNDeserializer.SERIALIZED_UUID = ATNDeserializer.ADDED_UNICODE_SMP;
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializer.prototype, "deserializationOptions", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer.prototype, "deserialize", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer.prototype, "markPrecedenceDecisions", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer.prototype, "edgeFactory", null);
    exports2.ATNDeserializer = ATNDeserializer;
  }
});

// node_modules/@apexdevtools/apex-parser/lib/ApexLexer.js
var require_ApexLexer = __commonJS({
  "node_modules/@apexdevtools/apex-parser/lib/ApexLexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApexLexer = void 0;
    var ATNDeserializer_1 = require_ATNDeserializer();
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var Utils = require_Utils();
    var ApexLexer2 = class _ApexLexer extends Lexer_1.Lexer {
      // tslint:enable:no-trailing-whitespace
      constructor(input) {
        super(input);
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(_ApexLexer._ATN, this);
      }
      // @Override
      // @NotNull
      get vocabulary() {
        return _ApexLexer.VOCABULARY;
      }
      // @Override
      get grammarFileName() {
        return "ApexLexer.g4";
      }
      // @Override
      get ruleNames() {
        return _ApexLexer.ruleNames;
      }
      // @Override
      get serializedATN() {
        return _ApexLexer._serializedATN;
      }
      // @Override
      get channelNames() {
        return _ApexLexer.channelNames;
      }
      // @Override
      get modeNames() {
        return _ApexLexer.modeNames;
      }
      static get _ATN() {
        if (!_ApexLexer.__ATN) {
          _ApexLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(_ApexLexer._serializedATN));
        }
        return _ApexLexer.__ATN;
      }
    };
    exports2.ApexLexer = ApexLexer2;
    ApexLexer2.ABSTRACT = 1;
    ApexLexer2.AFTER = 2;
    ApexLexer2.BEFORE = 3;
    ApexLexer2.BREAK = 4;
    ApexLexer2.CATCH = 5;
    ApexLexer2.CLASS = 6;
    ApexLexer2.CONTINUE = 7;
    ApexLexer2.DELETE = 8;
    ApexLexer2.DO = 9;
    ApexLexer2.ELSE = 10;
    ApexLexer2.ENUM = 11;
    ApexLexer2.EXTENDS = 12;
    ApexLexer2.FINAL = 13;
    ApexLexer2.FINALLY = 14;
    ApexLexer2.FOR = 15;
    ApexLexer2.GET = 16;
    ApexLexer2.GLOBAL = 17;
    ApexLexer2.IF = 18;
    ApexLexer2.IMPLEMENTS = 19;
    ApexLexer2.INHERITED = 20;
    ApexLexer2.INSERT = 21;
    ApexLexer2.INSTANCEOF = 22;
    ApexLexer2.INTERFACE = 23;
    ApexLexer2.MERGE = 24;
    ApexLexer2.NEW = 25;
    ApexLexer2.NULL = 26;
    ApexLexer2.ON = 27;
    ApexLexer2.OVERRIDE = 28;
    ApexLexer2.PRIVATE = 29;
    ApexLexer2.PROTECTED = 30;
    ApexLexer2.PUBLIC = 31;
    ApexLexer2.RETURN = 32;
    ApexLexer2.SYSTEMRUNAS = 33;
    ApexLexer2.SET = 34;
    ApexLexer2.SHARING = 35;
    ApexLexer2.STATIC = 36;
    ApexLexer2.SUPER = 37;
    ApexLexer2.SWITCH = 38;
    ApexLexer2.TESTMETHOD = 39;
    ApexLexer2.THIS = 40;
    ApexLexer2.THROW = 41;
    ApexLexer2.TRANSIENT = 42;
    ApexLexer2.TRIGGER = 43;
    ApexLexer2.TRY = 44;
    ApexLexer2.UNDELETE = 45;
    ApexLexer2.UPDATE = 46;
    ApexLexer2.UPSERT = 47;
    ApexLexer2.VIRTUAL = 48;
    ApexLexer2.VOID = 49;
    ApexLexer2.WEBSERVICE = 50;
    ApexLexer2.WHEN = 51;
    ApexLexer2.WHILE = 52;
    ApexLexer2.WITH = 53;
    ApexLexer2.WITHOUT = 54;
    ApexLexer2.LIST = 55;
    ApexLexer2.MAP = 56;
    ApexLexer2.SYSTEM = 57;
    ApexLexer2.USER = 58;
    ApexLexer2.SELECT = 59;
    ApexLexer2.COUNT = 60;
    ApexLexer2.FROM = 61;
    ApexLexer2.AS = 62;
    ApexLexer2.USING = 63;
    ApexLexer2.SCOPE = 64;
    ApexLexer2.WHERE = 65;
    ApexLexer2.ORDER = 66;
    ApexLexer2.BY = 67;
    ApexLexer2.LIMIT = 68;
    ApexLexer2.SOQLAND = 69;
    ApexLexer2.SOQLOR = 70;
    ApexLexer2.NOT = 71;
    ApexLexer2.AVG = 72;
    ApexLexer2.COUNT_DISTINCT = 73;
    ApexLexer2.MIN = 74;
    ApexLexer2.MAX = 75;
    ApexLexer2.SUM = 76;
    ApexLexer2.TYPEOF = 77;
    ApexLexer2.END = 78;
    ApexLexer2.THEN = 79;
    ApexLexer2.LIKE = 80;
    ApexLexer2.IN = 81;
    ApexLexer2.INCLUDES = 82;
    ApexLexer2.EXCLUDES = 83;
    ApexLexer2.ASC = 84;
    ApexLexer2.DESC = 85;
    ApexLexer2.NULLS = 86;
    ApexLexer2.FIRST = 87;
    ApexLexer2.LAST = 88;
    ApexLexer2.GROUP = 89;
    ApexLexer2.ALL = 90;
    ApexLexer2.ROWS = 91;
    ApexLexer2.VIEW = 92;
    ApexLexer2.HAVING = 93;
    ApexLexer2.ROLLUP = 94;
    ApexLexer2.TOLABEL = 95;
    ApexLexer2.OFFSET = 96;
    ApexLexer2.DATA = 97;
    ApexLexer2.CATEGORY = 98;
    ApexLexer2.AT = 99;
    ApexLexer2.ABOVE = 100;
    ApexLexer2.BELOW = 101;
    ApexLexer2.ABOVE_OR_BELOW = 102;
    ApexLexer2.SECURITY_ENFORCED = 103;
    ApexLexer2.SYSTEM_MODE = 104;
    ApexLexer2.USER_MODE = 105;
    ApexLexer2.REFERENCE = 106;
    ApexLexer2.CUBE = 107;
    ApexLexer2.FORMAT = 108;
    ApexLexer2.TRACKING = 109;
    ApexLexer2.VIEWSTAT = 110;
    ApexLexer2.CUSTOM = 111;
    ApexLexer2.STANDARD = 112;
    ApexLexer2.DISTANCE = 113;
    ApexLexer2.GEOLOCATION = 114;
    ApexLexer2.GROUPING = 115;
    ApexLexer2.CONVERT_CURRENCY = 116;
    ApexLexer2.CALENDAR_MONTH = 117;
    ApexLexer2.CALENDAR_QUARTER = 118;
    ApexLexer2.CALENDAR_YEAR = 119;
    ApexLexer2.DAY_IN_MONTH = 120;
    ApexLexer2.DAY_IN_WEEK = 121;
    ApexLexer2.DAY_IN_YEAR = 122;
    ApexLexer2.DAY_ONLY = 123;
    ApexLexer2.FISCAL_MONTH = 124;
    ApexLexer2.FISCAL_QUARTER = 125;
    ApexLexer2.FISCAL_YEAR = 126;
    ApexLexer2.HOUR_IN_DAY = 127;
    ApexLexer2.WEEK_IN_MONTH = 128;
    ApexLexer2.WEEK_IN_YEAR = 129;
    ApexLexer2.CONVERT_TIMEZONE = 130;
    ApexLexer2.YESTERDAY = 131;
    ApexLexer2.TODAY = 132;
    ApexLexer2.TOMORROW = 133;
    ApexLexer2.LAST_WEEK = 134;
    ApexLexer2.THIS_WEEK = 135;
    ApexLexer2.NEXT_WEEK = 136;
    ApexLexer2.LAST_MONTH = 137;
    ApexLexer2.THIS_MONTH = 138;
    ApexLexer2.NEXT_MONTH = 139;
    ApexLexer2.LAST_90_DAYS = 140;
    ApexLexer2.NEXT_90_DAYS = 141;
    ApexLexer2.LAST_N_DAYS_N = 142;
    ApexLexer2.NEXT_N_DAYS_N = 143;
    ApexLexer2.N_DAYS_AGO_N = 144;
    ApexLexer2.NEXT_N_WEEKS_N = 145;
    ApexLexer2.LAST_N_WEEKS_N = 146;
    ApexLexer2.N_WEEKS_AGO_N = 147;
    ApexLexer2.NEXT_N_MONTHS_N = 148;
    ApexLexer2.LAST_N_MONTHS_N = 149;
    ApexLexer2.N_MONTHS_AGO_N = 150;
    ApexLexer2.THIS_QUARTER = 151;
    ApexLexer2.LAST_QUARTER = 152;
    ApexLexer2.NEXT_QUARTER = 153;
    ApexLexer2.NEXT_N_QUARTERS_N = 154;
    ApexLexer2.LAST_N_QUARTERS_N = 155;
    ApexLexer2.N_QUARTERS_AGO_N = 156;
    ApexLexer2.THIS_YEAR = 157;
    ApexLexer2.LAST_YEAR = 158;
    ApexLexer2.NEXT_YEAR = 159;
    ApexLexer2.NEXT_N_YEARS_N = 160;
    ApexLexer2.LAST_N_YEARS_N = 161;
    ApexLexer2.N_YEARS_AGO_N = 162;
    ApexLexer2.THIS_FISCAL_QUARTER = 163;
    ApexLexer2.LAST_FISCAL_QUARTER = 164;
    ApexLexer2.NEXT_FISCAL_QUARTER = 165;
    ApexLexer2.NEXT_N_FISCAL_QUARTERS_N = 166;
    ApexLexer2.LAST_N_FISCAL_QUARTERS_N = 167;
    ApexLexer2.N_FISCAL_QUARTERS_AGO_N = 168;
    ApexLexer2.THIS_FISCAL_YEAR = 169;
    ApexLexer2.LAST_FISCAL_YEAR = 170;
    ApexLexer2.NEXT_FISCAL_YEAR = 171;
    ApexLexer2.NEXT_N_FISCAL_YEARS_N = 172;
    ApexLexer2.LAST_N_FISCAL_YEARS_N = 173;
    ApexLexer2.N_FISCAL_YEARS_AGO_N = 174;
    ApexLexer2.DateLiteral = 175;
    ApexLexer2.TimeLiteral = 176;
    ApexLexer2.DateTimeLiteral = 177;
    ApexLexer2.IntegralCurrencyLiteral = 178;
    ApexLexer2.FIND = 179;
    ApexLexer2.EMAIL = 180;
    ApexLexer2.NAME = 181;
    ApexLexer2.PHONE = 182;
    ApexLexer2.SIDEBAR = 183;
    ApexLexer2.FIELDS = 184;
    ApexLexer2.METADATA = 185;
    ApexLexer2.PRICEBOOKID = 186;
    ApexLexer2.NETWORK = 187;
    ApexLexer2.SNIPPET = 188;
    ApexLexer2.TARGET_LENGTH = 189;
    ApexLexer2.DIVISION = 190;
    ApexLexer2.RETURNING = 191;
    ApexLexer2.LISTVIEW = 192;
    ApexLexer2.FindLiteral = 193;
    ApexLexer2.FindLiteralAlt = 194;
    ApexLexer2.IntegerLiteral = 195;
    ApexLexer2.LongLiteral = 196;
    ApexLexer2.NumberLiteral = 197;
    ApexLexer2.BooleanLiteral = 198;
    ApexLexer2.StringLiteral = 199;
    ApexLexer2.NullLiteral = 200;
    ApexLexer2.LPAREN = 201;
    ApexLexer2.RPAREN = 202;
    ApexLexer2.LBRACE = 203;
    ApexLexer2.RBRACE = 204;
    ApexLexer2.LBRACK = 205;
    ApexLexer2.RBRACK = 206;
    ApexLexer2.SEMI = 207;
    ApexLexer2.COMMA = 208;
    ApexLexer2.DOT = 209;
    ApexLexer2.ASSIGN = 210;
    ApexLexer2.GT = 211;
    ApexLexer2.LT = 212;
    ApexLexer2.BANG = 213;
    ApexLexer2.TILDE = 214;
    ApexLexer2.QUESTIONDOT = 215;
    ApexLexer2.QUESTION = 216;
    ApexLexer2.COLON = 217;
    ApexLexer2.EQUAL = 218;
    ApexLexer2.TRIPLEEQUAL = 219;
    ApexLexer2.NOTEQUAL = 220;
    ApexLexer2.LESSANDGREATER = 221;
    ApexLexer2.TRIPLENOTEQUAL = 222;
    ApexLexer2.AND = 223;
    ApexLexer2.OR = 224;
    ApexLexer2.COAL = 225;
    ApexLexer2.INC = 226;
    ApexLexer2.DEC = 227;
    ApexLexer2.ADD = 228;
    ApexLexer2.SUB = 229;
    ApexLexer2.MUL = 230;
    ApexLexer2.DIV = 231;
    ApexLexer2.BITAND = 232;
    ApexLexer2.BITOR = 233;
    ApexLexer2.CARET = 234;
    ApexLexer2.MAPTO = 235;
    ApexLexer2.ADD_ASSIGN = 236;
    ApexLexer2.SUB_ASSIGN = 237;
    ApexLexer2.MUL_ASSIGN = 238;
    ApexLexer2.DIV_ASSIGN = 239;
    ApexLexer2.AND_ASSIGN = 240;
    ApexLexer2.OR_ASSIGN = 241;
    ApexLexer2.XOR_ASSIGN = 242;
    ApexLexer2.LSHIFT_ASSIGN = 243;
    ApexLexer2.RSHIFT_ASSIGN = 244;
    ApexLexer2.URSHIFT_ASSIGN = 245;
    ApexLexer2.ATSIGN = 246;
    ApexLexer2.Identifier = 247;
    ApexLexer2.WS = 248;
    ApexLexer2.DOC_COMMENT = 249;
    ApexLexer2.COMMENT = 250;
    ApexLexer2.LINE_COMMENT = 251;
    ApexLexer2.WHITESPACE_CHANNEL = 2;
    ApexLexer2.COMMENT_CHANNEL = 3;
    ApexLexer2.channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN",
      "WHITESPACE_CHANNEL",
      "COMMENT_CHANNEL"
    ];
    ApexLexer2.modeNames = [
      "DEFAULT_MODE"
    ];
    ApexLexer2.ruleNames = [
      "ABSTRACT",
      "AFTER",
      "BEFORE",
      "BREAK",
      "CATCH",
      "CLASS",
      "CONTINUE",
      "DELETE",
      "DO",
      "ELSE",
      "ENUM",
      "EXTENDS",
      "FINAL",
      "FINALLY",
      "FOR",
      "GET",
      "GLOBAL",
      "IF",
      "IMPLEMENTS",
      "INHERITED",
      "INSERT",
      "INSTANCEOF",
      "INTERFACE",
      "MERGE",
      "NEW",
      "NULL",
      "ON",
      "OVERRIDE",
      "PRIVATE",
      "PROTECTED",
      "PUBLIC",
      "RETURN",
      "SYSTEMRUNAS",
      "SET",
      "SHARING",
      "STATIC",
      "SUPER",
      "SWITCH",
      "TESTMETHOD",
      "THIS",
      "THROW",
      "TRANSIENT",
      "TRIGGER",
      "TRY",
      "UNDELETE",
      "UPDATE",
      "UPSERT",
      "VIRTUAL",
      "VOID",
      "WEBSERVICE",
      "WHEN",
      "WHILE",
      "WITH",
      "WITHOUT",
      "LIST",
      "MAP",
      "SYSTEM",
      "USER",
      "SELECT",
      "COUNT",
      "FROM",
      "AS",
      "USING",
      "SCOPE",
      "WHERE",
      "ORDER",
      "BY",
      "LIMIT",
      "SOQLAND",
      "SOQLOR",
      "NOT",
      "AVG",
      "COUNT_DISTINCT",
      "MIN",
      "MAX",
      "SUM",
      "TYPEOF",
      "END",
      "THEN",
      "LIKE",
      "IN",
      "INCLUDES",
      "EXCLUDES",
      "ASC",
      "DESC",
      "NULLS",
      "FIRST",
      "LAST",
      "GROUP",
      "ALL",
      "ROWS",
      "VIEW",
      "HAVING",
      "ROLLUP",
      "TOLABEL",
      "OFFSET",
      "DATA",
      "CATEGORY",
      "AT",
      "ABOVE",
      "BELOW",
      "ABOVE_OR_BELOW",
      "SECURITY_ENFORCED",
      "SYSTEM_MODE",
      "USER_MODE",
      "REFERENCE",
      "CUBE",
      "FORMAT",
      "TRACKING",
      "VIEWSTAT",
      "CUSTOM",
      "STANDARD",
      "DISTANCE",
      "GEOLOCATION",
      "GROUPING",
      "CONVERT_CURRENCY",
      "CALENDAR_MONTH",
      "CALENDAR_QUARTER",
      "CALENDAR_YEAR",
      "DAY_IN_MONTH",
      "DAY_IN_WEEK",
      "DAY_IN_YEAR",
      "DAY_ONLY",
      "FISCAL_MONTH",
      "FISCAL_QUARTER",
      "FISCAL_YEAR",
      "HOUR_IN_DAY",
      "WEEK_IN_MONTH",
      "WEEK_IN_YEAR",
      "CONVERT_TIMEZONE",
      "YESTERDAY",
      "TODAY",
      "TOMORROW",
      "LAST_WEEK",
      "THIS_WEEK",
      "NEXT_WEEK",
      "LAST_MONTH",
      "THIS_MONTH",
      "NEXT_MONTH",
      "LAST_90_DAYS",
      "NEXT_90_DAYS",
      "LAST_N_DAYS_N",
      "NEXT_N_DAYS_N",
      "N_DAYS_AGO_N",
      "NEXT_N_WEEKS_N",
      "LAST_N_WEEKS_N",
      "N_WEEKS_AGO_N",
      "NEXT_N_MONTHS_N",
      "LAST_N_MONTHS_N",
      "N_MONTHS_AGO_N",
      "THIS_QUARTER",
      "LAST_QUARTER",
      "NEXT_QUARTER",
      "NEXT_N_QUARTERS_N",
      "LAST_N_QUARTERS_N",
      "N_QUARTERS_AGO_N",
      "THIS_YEAR",
      "LAST_YEAR",
      "NEXT_YEAR",
      "NEXT_N_YEARS_N",
      "LAST_N_YEARS_N",
      "N_YEARS_AGO_N",
      "THIS_FISCAL_QUARTER",
      "LAST_FISCAL_QUARTER",
      "NEXT_FISCAL_QUARTER",
      "NEXT_N_FISCAL_QUARTERS_N",
      "LAST_N_FISCAL_QUARTERS_N",
      "N_FISCAL_QUARTERS_AGO_N",
      "THIS_FISCAL_YEAR",
      "LAST_FISCAL_YEAR",
      "NEXT_FISCAL_YEAR",
      "NEXT_N_FISCAL_YEARS_N",
      "LAST_N_FISCAL_YEARS_N",
      "N_FISCAL_YEARS_AGO_N",
      "DateLiteral",
      "TimeLiteral",
      "DateTimeLiteral",
      "IntegralCurrencyLiteral",
      "FIND",
      "EMAIL",
      "NAME",
      "PHONE",
      "SIDEBAR",
      "FIELDS",
      "METADATA",
      "PRICEBOOKID",
      "NETWORK",
      "SNIPPET",
      "TARGET_LENGTH",
      "DIVISION",
      "RETURNING",
      "LISTVIEW",
      "FindLiteral",
      "FindCharacters",
      "FindCharacter",
      "FindLiteralAlt",
      "FindCharactersAlt",
      "FindCharacterAlt",
      "FindEscapeSequence",
      "IntegerLiteral",
      "LongLiteral",
      "NumberLiteral",
      "HexCharacter",
      "Digit",
      "BooleanLiteral",
      "StringLiteral",
      "StringCharacters",
      "StringCharacter",
      "EscapeSequence",
      "NullLiteral",
      "LPAREN",
      "RPAREN",
      "LBRACE",
      "RBRACE",
      "LBRACK",
      "RBRACK",
      "SEMI",
      "COMMA",
      "DOT",
      "ASSIGN",
      "GT",
      "LT",
      "BANG",
      "TILDE",
      "QUESTIONDOT",
      "QUESTION",
      "COLON",
      "EQUAL",
      "TRIPLEEQUAL",
      "NOTEQUAL",
      "LESSANDGREATER",
      "TRIPLENOTEQUAL",
      "AND",
      "OR",
      "COAL",
      "INC",
      "DEC",
      "ADD",
      "SUB",
      "MUL",
      "DIV",
      "BITAND",
      "BITOR",
      "CARET",
      "MAPTO",
      "ADD_ASSIGN",
      "SUB_ASSIGN",
      "MUL_ASSIGN",
      "DIV_ASSIGN",
      "AND_ASSIGN",
      "OR_ASSIGN",
      "XOR_ASSIGN",
      "LSHIFT_ASSIGN",
      "RSHIFT_ASSIGN",
      "URSHIFT_ASSIGN",
      "ATSIGN",
      "Identifier",
      "JavaLetter",
      "JavaLetterOrDigit",
      "WS",
      "DOC_COMMENT",
      "COMMENT",
      "LINE_COMMENT"
    ];
    ApexLexer2._LITERAL_NAMES = [
      void 0,
      "'abstract'",
      "'after'",
      "'before'",
      "'break'",
      "'catch'",
      "'class'",
      "'continue'",
      "'delete'",
      "'do'",
      "'else'",
      "'enum'",
      "'extends'",
      "'final'",
      "'finally'",
      "'for'",
      "'get'",
      "'global'",
      "'if'",
      "'implements'",
      "'inherited'",
      "'insert'",
      "'instanceof'",
      "'interface'",
      "'merge'",
      "'new'",
      "'null'",
      "'on'",
      "'override'",
      "'private'",
      "'protected'",
      "'public'",
      "'return'",
      "'system.runas'",
      "'set'",
      "'sharing'",
      "'static'",
      "'super'",
      "'switch'",
      "'testmethod'",
      "'this'",
      "'throw'",
      "'transient'",
      "'trigger'",
      "'try'",
      "'undelete'",
      "'update'",
      "'upsert'",
      "'virtual'",
      "'void'",
      "'webservice'",
      "'when'",
      "'while'",
      "'with'",
      "'without'",
      "'list'",
      "'map'",
      "'system'",
      "'user'",
      "'select'",
      "'count'",
      "'from'",
      "'as'",
      "'using'",
      "'scope'",
      "'where'",
      "'order'",
      "'by'",
      "'limit'",
      "'and'",
      "'or'",
      "'not'",
      "'avg'",
      "'count_distinct'",
      "'min'",
      "'max'",
      "'sum'",
      "'typeof'",
      "'end'",
      "'then'",
      "'like'",
      "'in'",
      "'includes'",
      "'excludes'",
      "'asc'",
      "'desc'",
      "'nulls'",
      "'first'",
      "'last'",
      "'group'",
      "'all'",
      "'rows'",
      "'view'",
      "'having'",
      "'rollup'",
      "'tolabel'",
      "'offset'",
      "'data'",
      "'category'",
      "'at'",
      "'above'",
      "'below'",
      "'above_or_below'",
      "'security_enforced'",
      "'system_mode'",
      "'user_mode'",
      "'reference'",
      "'cube'",
      "'format'",
      "'tracking'",
      "'viewstat'",
      "'custom'",
      "'standard'",
      "'distance'",
      "'geolocation'",
      "'grouping'",
      "'convertcurrency'",
      "'calendar_month'",
      "'calendar_quarter'",
      "'calendar_year'",
      "'day_in_month'",
      "'day_in_week'",
      "'day_in_year'",
      "'day_only'",
      "'fiscal_month'",
      "'fiscal_quarter'",
      "'fiscal_year'",
      "'hour_in_day'",
      "'week_in_month'",
      "'week_in_year'",
      "'converttimezone'",
      "'yesterday'",
      "'today'",
      "'tomorrow'",
      "'last_week'",
      "'this_week'",
      "'next_week'",
      "'last_month'",
      "'this_month'",
      "'next_month'",
      "'last_90_days'",
      "'next_90_days'",
      "'last_n_days'",
      "'next_n_days'",
      "'n_days_ago'",
      "'next_n_weeks'",
      "'last_n_weeks'",
      "'n_weeks_ago'",
      "'next_n_months'",
      "'last_n_months'",
      "'n_months_ago'",
      "'this_quarter'",
      "'last_quarter'",
      "'next_quarter'",
      "'next_n_quarters'",
      "'last_n_quarters'",
      "'n_quarters_ago'",
      "'this_year'",
      "'last_year'",
      "'next_year'",
      "'next_n_years'",
      "'last_n_years'",
      "'n_years_ago'",
      "'this_fiscal_quarter'",
      "'last_fiscal_quarter'",
      "'next_fiscal_quarter'",
      "'next_n_fiscal_quarters'",
      "'last_n_fiscal_quarters'",
      "'n_fiscal_quarters_ago'",
      "'this_fiscal_year'",
      "'last_fiscal_year'",
      "'next_fiscal_year'",
      "'next_n_fiscal_years'",
      "'last_n_fiscal_years'",
      "'n_fiscal_years_ago'",
      void 0,
      void 0,
      void 0,
      void 0,
      "'find'",
      "'email'",
      "'name'",
      "'phone'",
      "'sidebar'",
      "'fields'",
      "'metadata'",
      "'pricebookid'",
      "'network'",
      "'snippet'",
      "'target_length'",
      "'division'",
      "'returning'",
      "'listview'",
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      "'('",
      "')'",
      "'{'",
      "'}'",
      "'['",
      "']'",
      "';'",
      "','",
      "'.'",
      "'='",
      "'>'",
      "'<'",
      "'!'",
      "'~'",
      "'?.'",
      "'?'",
      "':'",
      "'=='",
      "'==='",
      "'!='",
      "'<>'",
      "'!=='",
      "'&&'",
      "'||'",
      "'??'",
      "'++'",
      "'--'",
      "'+'",
      "'-'",
      "'*'",
      "'/'",
      "'&'",
      "'|'",
      "'^'",
      "'=>'",
      "'+='",
      "'-='",
      "'*='",
      "'/='",
      "'&='",
      "'|='",
      "'^='",
      "'<<='",
      "'>>='",
      "'>>>='",
      "'@'"
    ];
    ApexLexer2._SYMBOLIC_NAMES = [
      void 0,
      "ABSTRACT",
      "AFTER",
      "BEFORE",
      "BREAK",
      "CATCH",
      "CLASS",
      "CONTINUE",
      "DELETE",
      "DO",
      "ELSE",
      "ENUM",
      "EXTENDS",
      "FINAL",
      "FINALLY",
      "FOR",
      "GET",
      "GLOBAL",
      "IF",
      "IMPLEMENTS",
      "INHERITED",
      "INSERT",
      "INSTANCEOF",
      "INTERFACE",
      "MERGE",
      "NEW",
      "NULL",
      "ON",
      "OVERRIDE",
      "PRIVATE",
      "PROTECTED",
      "PUBLIC",
      "RETURN",
      "SYSTEMRUNAS",
      "SET",
      "SHARING",
      "STATIC",
      "SUPER",
      "SWITCH",
      "TESTMETHOD",
      "THIS",
      "THROW",
      "TRANSIENT",
      "TRIGGER",
      "TRY",
      "UNDELETE",
      "UPDATE",
      "UPSERT",
      "VIRTUAL",
      "VOID",
      "WEBSERVICE",
      "WHEN",
      "WHILE",
      "WITH",
      "WITHOUT",
      "LIST",
      "MAP",
      "SYSTEM",
      "USER",
      "SELECT",
      "COUNT",
      "FROM",
      "AS",
      "USING",
      "SCOPE",
      "WHERE",
      "ORDER",
      "BY",
      "LIMIT",
      "SOQLAND",
      "SOQLOR",
      "NOT",
      "AVG",
      "COUNT_DISTINCT",
      "MIN",
      "MAX",
      "SUM",
      "TYPEOF",
      "END",
      "THEN",
      "LIKE",
      "IN",
      "INCLUDES",
      "EXCLUDES",
      "ASC",
      "DESC",
      "NULLS",
      "FIRST",
      "LAST",
      "GROUP",
      "ALL",
      "ROWS",
      "VIEW",
      "HAVING",
      "ROLLUP",
      "TOLABEL",
      "OFFSET",
      "DATA",
      "CATEGORY",
      "AT",
      "ABOVE",
      "BELOW",
      "ABOVE_OR_BELOW",
      "SECURITY_ENFORCED",
      "SYSTEM_MODE",
      "USER_MODE",
      "REFERENCE",
      "CUBE",
      "FORMAT",
      "TRACKING",
      "VIEWSTAT",
      "CUSTOM",
      "STANDARD",
      "DISTANCE",
      "GEOLOCATION",
      "GROUPING",
      "CONVERT_CURRENCY",
      "CALENDAR_MONTH",
      "CALENDAR_QUARTER",
      "CALENDAR_YEAR",
      "DAY_IN_MONTH",
      "DAY_IN_WEEK",
      "DAY_IN_YEAR",
      "DAY_ONLY",
      "FISCAL_MONTH",
      "FISCAL_QUARTER",
      "FISCAL_YEAR",
      "HOUR_IN_DAY",
      "WEEK_IN_MONTH",
      "WEEK_IN_YEAR",
      "CONVERT_TIMEZONE",
      "YESTERDAY",
      "TODAY",
      "TOMORROW",
      "LAST_WEEK",
      "THIS_WEEK",
      "NEXT_WEEK",
      "LAST_MONTH",
      "THIS_MONTH",
      "NEXT_MONTH",
      "LAST_90_DAYS",
      "NEXT_90_DAYS",
      "LAST_N_DAYS_N",
      "NEXT_N_DAYS_N",
      "N_DAYS_AGO_N",
      "NEXT_N_WEEKS_N",
      "LAST_N_WEEKS_N",
      "N_WEEKS_AGO_N",
      "NEXT_N_MONTHS_N",
      "LAST_N_MONTHS_N",
      "N_MONTHS_AGO_N",
      "THIS_QUARTER",
      "LAST_QUARTER",
      "NEXT_QUARTER",
      "NEXT_N_QUARTERS_N",
      "LAST_N_QUARTERS_N",
      "N_QUARTERS_AGO_N",
      "THIS_YEAR",
      "LAST_YEAR",
      "NEXT_YEAR",
      "NEXT_N_YEARS_N",
      "LAST_N_YEARS_N",
      "N_YEARS_AGO_N",
      "THIS_FISCAL_QUARTER",
      "LAST_FISCAL_QUARTER",
      "NEXT_FISCAL_QUARTER",
      "NEXT_N_FISCAL_QUARTERS_N",
      "LAST_N_FISCAL_QUARTERS_N",
      "N_FISCAL_QUARTERS_AGO_N",
      "THIS_FISCAL_YEAR",
      "LAST_FISCAL_YEAR",
      "NEXT_FISCAL_YEAR",
      "NEXT_N_FISCAL_YEARS_N",
      "LAST_N_FISCAL_YEARS_N",
      "N_FISCAL_YEARS_AGO_N",
      "DateLiteral",
      "TimeLiteral",
      "DateTimeLiteral",
      "IntegralCurrencyLiteral",
      "FIND",
      "EMAIL",
      "NAME",
      "PHONE",
      "SIDEBAR",
      "FIELDS",
      "METADATA",
      "PRICEBOOKID",
      "NETWORK",
      "SNIPPET",
      "TARGET_LENGTH",
      "DIVISION",
      "RETURNING",
      "LISTVIEW",
      "FindLiteral",
      "FindLiteralAlt",
      "IntegerLiteral",
      "LongLiteral",
      "NumberLiteral",
      "BooleanLiteral",
      "StringLiteral",
      "NullLiteral",
      "LPAREN",
      "RPAREN",
      "LBRACE",
      "RBRACE",
      "LBRACK",
      "RBRACK",
      "SEMI",
      "COMMA",
      "DOT",
      "ASSIGN",
      "GT",
      "LT",
      "BANG",
      "TILDE",
      "QUESTIONDOT",
      "QUESTION",
      "COLON",
      "EQUAL",
      "TRIPLEEQUAL",
      "NOTEQUAL",
      "LESSANDGREATER",
      "TRIPLENOTEQUAL",
      "AND",
      "OR",
      "COAL",
      "INC",
      "DEC",
      "ADD",
      "SUB",
      "MUL",
      "DIV",
      "BITAND",
      "BITOR",
      "CARET",
      "MAPTO",
      "ADD_ASSIGN",
      "SUB_ASSIGN",
      "MUL_ASSIGN",
      "DIV_ASSIGN",
      "AND_ASSIGN",
      "OR_ASSIGN",
      "XOR_ASSIGN",
      "LSHIFT_ASSIGN",
      "RSHIFT_ASSIGN",
      "URSHIFT_ASSIGN",
      "ATSIGN",
      "Identifier",
      "WS",
      "DOC_COMMENT",
      "COMMENT",
      "LINE_COMMENT"
    ];
    ApexLexer2.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(ApexLexer2._LITERAL_NAMES, ApexLexer2._SYMBOLIC_NAMES, []);
    ApexLexer2._serializedATNSegments = 5;
    ApexLexer2._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\xFD\u0A3D\b					\x07	\x07\b	\b			\n	\n\v	\v\f	\f\r	\r													\x1B	\x1B				 	 !	!"	"#	#$	$%	%&	&\'	\'(	()	)*	*+	+,	,-	-.	./	/0	01	12	23	34	45	56	67	78	89	9:	:;	;<	<=	=>	>?	?@	@A	AB	BC	CD	DE	EF	FG	GH	HI	IJ	JK	KL	LM	MN	NO	OP	PQ	QR	RS	ST	TU	UV	VW	WX	XY	YZ	Z[	[\\	\\]	]^	^_	_`	`a	ab	bc	cd	de	ef	fg	gh	hi	ij	jk	kl	lm	mn	no	op	pq	qr	rs	st	tu	uv	vw	wx	xy	yz	z{	{|	|}	}~	~\x7F	\x7F\x80	\x80\x81	\x81\x82	\x82\x83	\x83\x84	\x84\x85	\x85\x86	\x86\x87	\x87\x88	\x88\x89	\x89\x8A	\x8A\x8B	\x8B\x8C	\x8C\x8D	\x8D\x8E	\x8E\x8F	\x8F\x90	\x90\x91	\x91\x92	\x92\x93	\x93\x94	\x94\x95	\x95\x96	\x96\x97	\x97\x98	\x98\x99	\x99\x9A	\x9A\x9B	\x9B\x9C	\x9C\x9D	\x9D\x9E	\x9E\x9F	\x9F\xA0	\xA0\xA1	\xA1\xA2	\xA2\xA3	\xA3\xA4	\xA4\xA5	\xA5\xA6	\xA6\xA7	\xA7\xA8	\xA8\xA9	\xA9\xAA	\xAA\xAB	\xAB\xAC	\xAC\xAD	\xAD\xAE	\xAE\xAF	\xAF\xB0	\xB0\xB1	\xB1\xB2	\xB2\xB3	\xB3\xB4	\xB4\xB5	\xB5\xB6	\xB6\xB7	\xB7\xB8	\xB8\xB9	\xB9\xBA	\xBA\xBB	\xBB\xBC	\xBC\xBD	\xBD\xBE	\xBE\xBF	\xBF\xC0	\xC0\xC1	\xC1\xC2	\xC2\xC3	\xC3\xC4	\xC4\xC5	\xC5\xC6	\xC6\xC7	\xC7\xC8	\xC8\xC9	\xC9\xCA	\xCA\xCB	\xCB\xCC	\xCC\xCD	\xCD\xCE	\xCE\xCF	\xCF\xD0	\xD0\xD1	\xD1\xD2	\xD2\xD3	\xD3\xD4	\xD4\xD5	\xD5\xD6	\xD6\xD7	\xD7\xD8	\xD8\xD9	\xD9\xDA	\xDA\xDB	\xDB\xDC	\xDC\xDD	\xDD\xDE	\xDE\xDF	\xDF\xE0	\xE0\xE1	\xE1\xE2	\xE2\xE3	\xE3\xE4	\xE4\xE5	\xE5\xE6	\xE6\xE7	\xE7\xE8	\xE8\xE9	\xE9\xEA	\xEA\xEB	\xEB\xEC	\xEC\xED	\xED\xEE	\xEE\xEF	\xEF\xF0	\xF0\xF1	\xF1\xF2	\xF2\xF3	\xF3\xF4	\xF4\xF5	\xF5\xF6	\xF6\xF7	\xF7\xF8	\xF8\xF9	\xF9\xFA	\xFA\xFB	\xFB\xFC	\xFC\xFD	\xFD\xFE	\xFE\xFF	\xFF\u0100	\u0100\u0101	\u0101\u0102	\u0102\u0103	\u0103\u0104	\u0104\u0105	\u0105\u0106	\u0106\u0107	\u0107\u0108	\u0108\x07\x07\x07\x07\x07\x07\b\b\b\b\b\b\b\b\b							\n\n\n\v\v\v\v\v\f\f\f\f\f\r\r\r\r\r\r\r\r\x1B\x1B\x1B\x1B\x1B       !!!!!!!"""""""""""""####$$$$$$$$%%%%%%%&&&&&&\'\'\'\'\'\'\'((((((((((()))))******++++++++++,,,,,,,,----.........///////0000000111111112222233333333333444445555556666677777777888889999:::::::;;;;;<<<<<<<======>>>>>???@@@@@@AAAAAABBBBBBCCCCCCDDDEEEEEEFFFFGGGHHHHIIIIJJJJJJJJJJJJJJJKKKKLLLLMMMMNNNNNNNOOOOPPPPPQQQQQRRRSSSSSSSSSTTTTTTTTTUUUUVVVVVWWWWWWXXXXXXYYYYYZZZZZZ[[[[\\\\\\\\\\]]]]]^^^^^^^_______````````aaaaaaabbbbbcccccccccdddeeeeeeffffffggggggggggggggghhhhhhhhhhhhhhhhhhiiiiiiiiiiiijjjjjjjjjjkkkkkkkkkklllllmmmmmmmnnnnnnnnnooooooooopppppppqqqqqqqqqrrrrrrrrrsssssssssssstttttttttuuuuuuuuuuuuuuuuvvvvvvvvvvvvvvvwwwwwwwwwwwwwwwwwxxxxxxxxxxxxxxyyyyyyyyyyyyyzzzzzzzzzzzz{{{{{{{{{{{{|||||||||}}}}}}}}}}}}}~~~~~~~~~~~~~~~\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x80\x80\x80\x80\x80\x80\x80\x80\x80\x80\x80\x80\x81\x81\x81\x81\x81\x81\x81\x81\x81\x81\x81\x81\x81\x81\x82\x82\x82\x82\x82\x82\x82\x82\x82\x82\x82\x82\x82\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x84\x84\x84\x84\x84\x84\x84\x84\x84\x84\x85\x85\x85\x85\x85\x85\x86\x86\x86\x86\x86\x86\x86\x86\x86\x87\x87\x87\x87\x87\x87\x87\x87\x87\x87\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x89\x89\x89\x89\x89\x89\x89\x89\x89\x89\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8C\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8E\x8E\x8E\x8E\x8E\x8E\x8E\x8E\x8E\x8E\x8E\x8E\x8E\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x91\x91\x91\x91\x91\x91\x91\x91\x91\x91\x91\x92\x92\x92\x92\x92\x92\x92\x92\x92\x92\x92\x92\x92\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x94\x94\x94\x94\x94\x94\x94\x94\x94\x94\x94\x94\x95\x95\x95\x95\x95\x95\x95\x95\x95\x95\x95\x95\x95\x95\x96\x96\x96\x96\x96\x96\x96\x96\x96\x96\x96\x96\x96\x96\x97\x97\x97\x97\x97\x97\x97\x97\x97\x97\x97\x97\x97\x98\x98\x98\x98\x98\x98\x98\x98\x98\x98\x98\x98\x98\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x9A\x9A\x9A\x9A\x9A\x9A\x9A\x9A\x9A\x9A\x9A\x9A\x9A\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9D\x9E\x9E\x9E\x9E\x9E\x9E\x9E\x9E\x9E\x9E\x9F\x9F\x9F\x9F\x9F\x9F\x9F\x9F\x9F\x9F\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA1\xA1\xA1\xA1\xA1\xA1\xA1\xA1\xA1\xA1\xA1\xA1\xA1\xA2\xA2\xA2\xA2\xA2\xA2\xA2\xA2\xA2\xA2\xA2\xA2\xA2\xA3\xA3\xA3\xA3\xA3\xA3\xA3\xA3\xA3\xA3\xA3\xA3\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA4\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA5\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA6\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA7\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA8\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xA9\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAB\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAC\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAD\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAE\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xAF\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\u086B\n\xB1\r\xB1\xB1\u086C\xB1\u086F\n\xB1\xB1\xB1\xB1\xB1\u0874\n\xB1\r\xB1\xB1\u0875\xB1\xB1\xB1\u087A\n\xB1\r\xB1\xB1\u087B\xB1\u087E\n\xB1\xB1\u0880\n\xB1\xB2\xB2\xB2\xB2\xB3\xB3\xB3\xB3\xB3\u088A\n\xB3\r\xB3\xB3\u088B\xB4\xB4\xB4\xB4\xB4\xB5\xB5\xB5\xB5\xB5\xB5\xB6\xB6\xB6\xB6\xB6\xB7\xB7\xB7\xB7\xB7\xB7\xB8\xB8\xB8\xB8\xB8\xB8\xB8\xB8\xB9\xB9\xB9\xB9\xB9\xB9\xB9\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBD\xBD\xBD\xBD\xBD\xBD\xBD\xBD\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBF\xBF\xBF\xBF\xBF\xBF\xBF\xBF\xBF\xC0\xC0\xC0\xC0\xC0\xC0\xC0\xC0\xC0\xC0\xC1\xC1\xC1\xC1\xC1\xC1\xC1\xC1\xC1\xC2\xC2\xC2\u0904\n\xC2\xC2\xC2\xC2\xC2\xC2\xC2\xC2\xC2\xC2\u090E\n\xC2\xC2\xC2\xC3\xC3\u0913\n\xC3\r\xC3\xC3\u0914\xC4\xC4\xC4\u0919\n\xC4\xC5\xC5\xC5\u091D\n\xC5\xC5\xC5\xC5\xC5\xC5\xC5\xC5\xC5\xC5\u0927\n\xC5\xC5\xC5\xC6\xC6\u092C\n\xC6\r\xC6\xC6\u092D\xC7\xC7\xC7\u0932\n\xC7\xC8\xC8\xC8\xC9\xC9\x07\xC9\u0939\n\xC9\f\xC9\xC9\u093C\v\xC9\xCA\xCA\x07\xCA\u0940\n\xCA\f\xCA\xCA\u0943\v\xCA\xCA\xCA\xCB\x07\xCB\u0948\n\xCB\f\xCB\xCB\u094B\v\xCB\xCB\xCB\xCB\x07\xCB\u0950\n\xCB\f\xCB\xCB\u0953\v\xCB\xCB\xCB\u0956\n\xCB\xCC\xCC\xCD\xCD\xCE\xCE\xCE\xCE\xCE\xCE\xCE\xCE\xCE\xCE\u0965\n\xCE\xCF\xCF\xCF\u0969\n\xCF\xCF\xCF\xD0\xD0\u096E\n\xD0\r\xD0\xD0\u096F\xD1\xD1\xD1\u0974\n\xD1\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\u0980\n\xD2\xD3\xD3\xD4\xD4\xD5\xD5\xD6\xD6\xD7\xD7\xD8\xD8\xD9\xD9\xDA\xDA\xDB\xDB\xDC\xDC\xDD\xDD\xDE\xDE\xDF\xDF\xE0\xE0\xE1\xE1\xE2\xE2\xE2\xE3\xE3\xE4\xE4\xE5\xE5\xE5\xE6\xE6\xE6\xE6\xE7';
    ApexLexer2._serializedATNSegment1 = `\xE7\xE7\xE8\xE8\xE8\xE9\xE9\xE9\xE9\xEA\xEA\xEA\xEB\xEB\xEB\xEC\xEC\xEC\xED\xED\xED\xEE\xEE\xEE\xEF\xEF\xF0\xF0\xF1\xF1\xF2\xF2\xF3\xF3\xF4\xF4\xF5\xF5\xF6\xF6\xF6\xF7\xF7\xF7\xF8\xF8\xF8\xF9\xF9\xF9\xFA\xFA\xFA\xFB\xFB\xFB\xFC\xFC\xFC\xFD\xFD\xFD\xFE\xFE\xFE\xFE\xFF\xFF\xFF\xFF\u0100\u0100\u0100\u0100\u0100\u0101\u0101\u0102\u0102\x07\u0102\u09FE
\u0102\f\u0102\u0102\u0A01\v\u0102\u0103\u0103\u0103\u0103\u0103\u0A07
\u0103\u0104\u0104\u0104\u0104\u0104\u0A0D
\u0104\u0105\u0105\u0A10
\u0105\r\u0105\u0105\u0A11\u0105\u0105\u0106\u0106\u0106\u0106\u0106\x07\u0106\u0A1B
\u0106\f\u0106\u0106\u0A1E\v\u0106\u0106\u0106\u0106\u0106\u0106\u0107\u0107\u0107\u0107\x07\u0107\u0A29
\u0107\f\u0107\u0107\u0A2C\v\u0107\u0107\u0107\u0107\u0107\u0107\u0108\u0108\u0108\u0108\x07\u0108\u0A37
\u0108\f\u0108\u0108\u0A3A\v\u0108\u0108\u0108\u0A1C\u0A2A\u0109\x07	\v\x07\r\b	
\v\f\r\x1B!#%')+-/13\x1B579;= ?!A"C#E$G%I&K'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s;u<w=y>{?}@\x7FA\x81B\x83C\x85D\x87E\x89F\x8BG\x8DH\x8FI\x91J\x93K\x95L\x97M\x99N\x9BO\x9DP\x9FQ\xA1R\xA3S\xA5T\xA7U\xA9V\xABW\xADX\xAFY\xB1Z\xB3[\xB5\\\xB7]\xB9^\xBB_\xBD\`\xBFa\xC1b\xC3c\xC5d\xC7e\xC9f\xCBg\xCDh\xCFi\xD1j\xD3k\xD5l\xD7m\xD9n\xDBo\xDDp\xDFq\xE1r\xE3s\xE5t\xE7u\xE9v\xEBw\xEDx\xEFy\xF1z\xF3{\xF5|\xF7}\xF9~\xFB\x7F\xFD\x80\xFF\x81\u0101\x82\u0103\x83\u0105\x84\u0107\x85\u0109\x86\u010B\x87\u010D\x88\u010F\x89\u0111\x8A\u0113\x8B\u0115\x8C\u0117\x8D\u0119\x8E\u011B\x8F\u011D\x90\u011F\x91\u0121\x92\u0123\x93\u0125\x94\u0127\x95\u0129\x96\u012B\x97\u012D\x98\u012F\x99\u0131\x9A\u0133\x9B\u0135\x9C\u0137\x9D\u0139\x9E\u013B\x9F\u013D\xA0\u013F\xA1\u0141\xA2\u0143\xA3\u0145\xA4\u0147\xA5\u0149\xA6\u014B\xA7\u014D\xA8\u014F\xA9\u0151\xAA\u0153\xAB\u0155\xAC\u0157\xAD\u0159\xAE\u015B\xAF\u015D\xB0\u015F\xB1\u0161\xB2\u0163\xB3\u0165\xB4\u0167\xB5\u0169\xB6\u016B\xB7\u016D\xB8\u016F\xB9\u0171\xBA\u0173\xBB\u0175\xBC\u0177\xBD\u0179\xBE\u017B\xBF\u017D\xC0\u017F\xC1\u0181\xC2\u0183\xC3\u0185\u0187\u0189\xC4\u018B\u018D\u018F\u0191\xC5\u0193\xC6\u0195\xC7\u0197\u0199\u019B\xC8\u019D\xC9\u019F\u01A1\u01A3\u01A5\xCA\u01A7\xCB\u01A9\xCC\u01AB\xCD\u01AD\xCE\u01AF\xCF\u01B1\xD0\u01B3\xD1\u01B5\xD2\u01B7\xD3\u01B9\xD4\u01BB\xD5\u01BD\xD6\u01BF\xD7\u01C1\xD8\u01C3\xD9\u01C5\xDA\u01C7\xDB\u01C9\xDC\u01CB\xDD\u01CD\xDE\u01CF\xDF\u01D1\xE0\u01D3\xE1\u01D5\xE2\u01D7\xE3\u01D9\xE4\u01DB\xE5\u01DD\xE6\u01DF\xE7\u01E1\xE8\u01E3\xE9\u01E5\xEA\u01E7\xEB\u01E9\xEC\u01EB\xED\u01ED\xEE\u01EF\xEF\u01F1\xF0\u01F3\xF1\u01F5\xF2\u01F7\xF3\u01F9\xF4\u01FB\xF5\u01FD\xF6\u01FF\xF7\u0201\xF8\u0203\xF9\u0205\u0207\u0209\xFA\u020B\xFB\u020D\xFC\u020F\xFD--//c|))^^^^\x7F\x7F
#$(-//<<AA^^\`\`}\x80NNnnFFff2;CHch2;
$$))^^ddhhppttvv&&C\\aac|\u0101\u{10801}\u{10801}\uDC02\uE001\x07&&2;C\\aac|\v\f""\f\f\u0A52\x07	\v\r\x1B!#%')+-/13579;=?ACEGIKMOQSUWY[]_acegikmoqsuwy{}\x7F\x81\x83\x85\x87\x89\x8B\x8D\x8F\x91\x93\x95\x97\x99\x9B\x9D\x9F\xA1\xA3\xA5\xA7\xA9\xAB\xAD\xAF\xB1\xB3\xB5\xB7\xB9\xBB\xBD\xBF\xC1\xC3\xC5\xC7\xC9\xCB\xCD\xCF\xD1\xD3\xD5\xD7\xD9\xDB\xDD\xDF\xE1\xE3\xE5\xE7\xE9\xEB\xED\xEF\xF1\xF3\xF5\xF7\xF9\xFB\xFD\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u0179\u017B\u017D\u017F\u0181\u0183\u0189\u0191\u0193\u0195\u019B\u019D\u01A5\u01A7\u01A9\u01AB\u01AD\u01AF\u01B1\u01B3\u01B5\u01B7\u01B9\u01BB\u01BD\u01BF\u01C1\u01C3\u01C5\u01C7\u01C9\u01CB\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F1\u01F3\u01F5\u01F7\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0209\u020B\u020D\u020F\u0211\u021A\x07\u0220	\u0227\v\u022D\r\u0233\u0239\u0242\u0249\u024C\u0251\u0256\x1B\u025E\u0264\u026C!\u0270#\u0274%\u027B'\u027E)\u0289+\u0293-\u029A/\u02A51\u02AF3\u02B55\u02B97\u02BE9\u02C1;\u02CA=\u02D2?\u02DCA\u02E3C\u02EAE\u02F7G\u02FBI\u0303K\u030AM\u0310O\u0317Q\u0322S\u0327U\u032DW\u0337Y\u033F[\u0343]\u034C_\u0353a\u035Ac\u0362e\u0367g\u0372i\u0377k\u037Dm\u0382o\u038Aq\u038Fs\u0393u\u039Aw\u039Fy\u03A6{\u03AC}\u03B1\x7F\u03B4\x81\u03BA\x83\u03C0\x85\u03C6\x87\u03CC\x89\u03CF\x8B\u03D5\x8D\u03D9\x8F\u03DC\x91\u03E0\x93\u03E4\x95\u03F3\x97\u03F7\x99\u03FB\x9B\u03FF\x9D\u0406\x9F\u040A\xA1\u040F\xA3\u0414\xA5\u0417\xA7\u0420\xA9\u0429\xAB\u042D\xAD\u0432\xAF\u0438\xB1\u043E\xB3\u0443\xB5\u0449\xB7\u044D\xB9\u0452\xBB\u0457\xBD\u045E\xBF\u0465\xC1\u046D\xC3\u0474\xC5\u0479\xC7\u0482\xC9\u0485\xCB\u048B\xCD\u0491\xCF\u04A0\xD1\u04B2\xD3\u04BE\xD5\u04C8\xD7\u04D2\xD9\u04D7\xDB\u04DE\xDD\u04E7\xDF\u04F0\xE1\u04F7\xE3\u0500\xE5\u0509\xE7\u0515\xE9\u051E\xEB\u052E\xED\u053D\xEF\u054E\xF1\u055C\xF3\u0569\xF5\u0575\xF7\u0581\xF9\u058A\xFB\u0597\xFD\u05A6\xFF\u05B2\u0101\u05BE\u0103\u05CC\u0105\u05D9\u0107\u05E9\u0109\u05F3\u010B\u05F9\u010D\u0602\u010F\u060C\u0111\u0616\u0113\u0620\u0115\u062B\u0117\u0636\u0119\u0641\u011B\u064E\u011D\u065B\u011F\u0667\u0121\u0673\u0123\u067E\u0125\u068B\u0127\u0698\u0129\u06A4\u012B\u06B2\u012D\u06C0\u012F\u06CD\u0131\u06DA\u0133\u06E7\u0135\u06F4\u0137\u0704\u0139\u0714\u013B\u0723\u013D\u072D\u013F\u0737\u0141\u0741\u0143\u074E\u0145\u075B\u0147\u0767\u0149\u077B\u014B\u078F\u014D\u07A3\u014F\u07BA\u0151\u07D1\u0153\u07E7\u0155\u07F8\u0157\u0809\u0159\u081A\u015B\u082E\u015D\u0842\u015F\u0855\u0161\u0860\u0163\u0881\u0165\u0885\u0167\u088D\u0169\u0892\u016B\u0898\u016D\u089D\u016F\u08A3\u0171\u08AB\u0173\u08B2\u0175\u08BB\u0177\u08C7\u0179\u08CF\u017B\u08D7\u017D\u08E5\u017F\u08EE\u0181\u08F8\u0183\u0901\u0185\u0912\u0187\u0918\u0189\u091A\u018B\u092B\u018D\u0931\u018F\u0933\u0191\u0936\u0193\u093D\u0195\u0949\u0197\u0957\u0199\u0959\u019B\u0964\u019D\u0966\u019F\u096D\u01A1\u0973\u01A3\u097F\u01A5\u0981\u01A7\u0983\u01A9\u0985\u01AB\u0987\u01AD\u0989\u01AF\u098B\u01B1\u098D\u01B3\u098F\u01B5\u0991\u01B7\u0993\u01B9\u0995\u01BB\u0997\u01BD\u0999\u01BF\u099B\u01C1\u099D\u01C3\u099F\u01C5\u09A2\u01C7\u09A4\u01C9\u09A6\u01CB\u09A9\u01CD\u09AD\u01CF\u09B0\u01D1\u09B3\u01D3\u09B7\u01D5\u09BA\u01D7\u09BD\u01D9\u09C0\u01DB\u09C3\u01DD\u09C6\u01DF\u09C8\u01E1\u09CA\u01E3\u09CC\u01E5\u09CE\u01E7\u09D0\u01E9\u09D2\u01EB\u09D4\u01ED\u09D7\u01EF\u09DA\u01F1\u09DD\u01F3\u09E0\u01F5\u09E3\u01F7\u09E6\u01F9\u09E9\u01FB\u09EC\u01FD\u09F0\u01FF\u09F4\u0201\u09F9\u0203\u09FB\u0205\u0A06\u0207\u0A0C\u0209\u0A0F\u020B\u0A15\u020D\u0A24\u020F\u0A32\u0211\u0212\x07c\u0212\u0213\x07d\u0213\u0214\x07u\u0214\u0215\x07v\u0215\u0216\x07t\u0216\u0217\x07c\u0217\u0218\x07e\u0218\u0219\x07v\u0219\u021A\u021B\x07c\u021B\u021C\x07h\u021C\u021D\x07v\u021D\u021E\x07g\u021E\u021F\x07t\u021F\u0220\u0221\x07d\u0221\u0222\x07g\u0222\u0223\x07h\u0223\u0224\x07q\u0224\u0225\x07t\u0225\u0226\x07g\u0226\b\u0227\u0228\x07d\u0228\u0229\x07t\u0229\u022A\x07g\u022A\u022B\x07c\u022B\u022C\x07m\u022C
\u022D\u022E\x07e\u022E\u022F\x07c\u022F\u0230\x07v\u0230\u0231\x07e\u0231\u0232\x07j\u0232\f\u0233\u0234\x07e\u0234\u0235\x07n\u0235\u0236\x07c\u0236\u0237\x07u\u0237\u0238\x07u\u0238\u0239\u023A\x07e\u023A\u023B\x07q\u023B\u023C\x07p\u023C\u023D\x07v\u023D\u023E\x07k\u023E\u023F\x07p\u023F\u0240\x07w\u0240\u0241\x07g\u0241\u0242\u0243\x07f\u0243\u0244\x07g\u0244\u0245\x07n\u0245\u0246\x07g\u0246\u0247\x07v\u0247\u0248\x07g\u0248\u0249\u024A\x07f\u024A\u024B\x07q\u024B\u024C\u024D\x07g\u024D\u024E\x07n\u024E\u024F\x07u\u024F\u0250\x07g\u0250\u0251\u0252\x07g\u0252\u0253\x07p\u0253\u0254\x07w\u0254\u0255\x07o\u0255\u0256\u0257\x07g\u0257\u0258\x07z\u0258\u0259\x07v\u0259\u025A\x07g\u025A\u025B\x07p\u025B\u025C\x07f\u025C\u025D\x07u\u025D\u025E\u025F\x07h\u025F\u0260\x07k\u0260\u0261\x07p\u0261\u0262\x07c\u0262\u0263\x07n\u0263\u0264\u0265\x07h\u0265\u0266\x07k\u0266\u0267\x07p\u0267\u0268\x07c\u0268\u0269\x07n\u0269\u026A\x07n\u026A\u026B\x07{\u026B\u026C\u026D\x07h\u026D\u026E\x07q\u026E\u026F\x07t\u026F \u0270\u0271\x07i\u0271\u0272\x07g\u0272\u0273\x07v\u0273"\u0274\u0275\x07i\u0275\u0276\x07n\u0276\u0277\x07q\u0277\u0278\x07d\u0278\u0279\x07c\u0279\u027A\x07n\u027A$\u027B\u027C\x07k\u027C\u027D\x07h\u027D&\u027E\u027F\x07k\u027F\u0280\x07o\u0280\u0281\x07r\u0281\u0282\x07n\u0282\u0283\x07g\u0283\u0284`;
    ApexLexer2._serializedATNSegment2 = "\x07o\u0284\u0285\x07g\u0285\u0286\x07p\u0286\u0287\x07v\u0287\u0288\x07u\u0288(\u0289\u028A\x07k\u028A\u028B\x07p\u028B\u028C\x07j\u028C\u028D\x07g\u028D\u028E\x07t\u028E\u028F\x07k\u028F\u0290\x07v\u0290\u0291\x07g\u0291\u0292\x07f\u0292*\u0293\u0294\x07k\u0294\u0295\x07p\u0295\u0296\x07u\u0296\u0297\x07g\u0297\u0298\x07t\u0298\u0299\x07v\u0299,\u029A\u029B\x07k\u029B\u029C\x07p\u029C\u029D\x07u\u029D\u029E\x07v\u029E\u029F\x07c\u029F\u02A0\x07p\u02A0\u02A1\x07e\u02A1\u02A2\x07g\u02A2\u02A3\x07q\u02A3\u02A4\x07h\u02A4.\u02A5\u02A6\x07k\u02A6\u02A7\x07p\u02A7\u02A8\x07v\u02A8\u02A9\x07g\u02A9\u02AA\x07t\u02AA\u02AB\x07h\u02AB\u02AC\x07c\u02AC\u02AD\x07e\u02AD\u02AE\x07g\u02AE0\u02AF\u02B0\x07o\u02B0\u02B1\x07g\u02B1\u02B2\x07t\u02B2\u02B3\x07i\u02B3\u02B4\x07g\u02B42\u02B5\u02B6\x07p\u02B6\u02B7\x07g\u02B7\u02B8\x07y\u02B84\u02B9\u02BA\x07p\u02BA\u02BB\x07w\u02BB\u02BC\x07n\u02BC\u02BD\x07n\u02BD6\u02BE\u02BF\x07q\u02BF\u02C0\x07p\u02C08\u02C1\u02C2\x07q\u02C2\u02C3\x07x\u02C3\u02C4\x07g\u02C4\u02C5\x07t\u02C5\u02C6\x07t\u02C6\u02C7\x07k\u02C7\u02C8\x07f\u02C8\u02C9\x07g\u02C9:\u02CA\u02CB\x07r\u02CB\u02CC\x07t\u02CC\u02CD\x07k\u02CD\u02CE\x07x\u02CE\u02CF\x07c\u02CF\u02D0\x07v\u02D0\u02D1\x07g\u02D1<\u02D2\u02D3\x07r\u02D3\u02D4\x07t\u02D4\u02D5\x07q\u02D5\u02D6\x07v\u02D6\u02D7\x07g\u02D7\u02D8\x07e\u02D8\u02D9\x07v\u02D9\u02DA\x07g\u02DA\u02DB\x07f\u02DB>\u02DC\u02DD\x07r\u02DD\u02DE\x07w\u02DE\u02DF\x07d\u02DF\u02E0\x07n\u02E0\u02E1\x07k\u02E1\u02E2\x07e\u02E2@\u02E3\u02E4\x07t\u02E4\u02E5\x07g\u02E5\u02E6\x07v\u02E6\u02E7\x07w\u02E7\u02E8\x07t\u02E8\u02E9\x07p\u02E9B\u02EA\u02EB\x07u\u02EB\u02EC\x07{\u02EC\u02ED\x07u\u02ED\u02EE\x07v\u02EE\u02EF\x07g\u02EF\u02F0\x07o\u02F0\u02F1\x070\u02F1\u02F2\x07t\u02F2\u02F3\x07w\u02F3\u02F4\x07p\u02F4\u02F5\x07c\u02F5\u02F6\x07u\u02F6D\u02F7\u02F8\x07u\u02F8\u02F9\x07g\u02F9\u02FA\x07v\u02FAF\u02FB\u02FC\x07u\u02FC\u02FD\x07j\u02FD\u02FE\x07c\u02FE\u02FF\x07t\u02FF\u0300\x07k\u0300\u0301\x07p\u0301\u0302\x07i\u0302H\u0303\u0304\x07u\u0304\u0305\x07v\u0305\u0306\x07c\u0306\u0307\x07v\u0307\u0308\x07k\u0308\u0309\x07e\u0309J\u030A\u030B\x07u\u030B\u030C\x07w\u030C\u030D\x07r\u030D\u030E\x07g\u030E\u030F\x07t\u030FL\u0310\u0311\x07u\u0311\u0312\x07y\u0312\u0313\x07k\u0313\u0314\x07v\u0314\u0315\x07e\u0315\u0316\x07j\u0316N\u0317\u0318\x07v\u0318\u0319\x07g\u0319\u031A\x07u\u031A\u031B\x07v\u031B\u031C\x07o\u031C\u031D\x07g\u031D\u031E\x07v\u031E\u031F\x07j\u031F\u0320\x07q\u0320\u0321\x07f\u0321P\u0322\u0323\x07v\u0323\u0324\x07j\u0324\u0325\x07k\u0325\u0326\x07u\u0326R\u0327\u0328\x07v\u0328\u0329\x07j\u0329\u032A\x07t\u032A\u032B\x07q\u032B\u032C\x07y\u032CT\u032D\u032E\x07v\u032E\u032F\x07t\u032F\u0330\x07c\u0330\u0331\x07p\u0331\u0332\x07u\u0332\u0333\x07k\u0333\u0334\x07g\u0334\u0335\x07p\u0335\u0336\x07v\u0336V\u0337\u0338\x07v\u0338\u0339\x07t\u0339\u033A\x07k\u033A\u033B\x07i\u033B\u033C\x07i\u033C\u033D\x07g\u033D\u033E\x07t\u033EX\u033F\u0340\x07v\u0340\u0341\x07t\u0341\u0342\x07{\u0342Z\u0343\u0344\x07w\u0344\u0345\x07p\u0345\u0346\x07f\u0346\u0347\x07g\u0347\u0348\x07n\u0348\u0349\x07g\u0349\u034A\x07v\u034A\u034B\x07g\u034B\\\u034C\u034D\x07w\u034D\u034E\x07r\u034E\u034F\x07f\u034F\u0350\x07c\u0350\u0351\x07v\u0351\u0352\x07g\u0352^\u0353\u0354\x07w\u0354\u0355\x07r\u0355\u0356\x07u\u0356\u0357\x07g\u0357\u0358\x07t\u0358\u0359\x07v\u0359`\u035A\u035B\x07x\u035B\u035C\x07k\u035C\u035D\x07t\u035D\u035E\x07v\u035E\u035F\x07w\u035F\u0360\x07c\u0360\u0361\x07n\u0361b\u0362\u0363\x07x\u0363\u0364\x07q\u0364\u0365\x07k\u0365\u0366\x07f\u0366d\u0367\u0368\x07y\u0368\u0369\x07g\u0369\u036A\x07d\u036A\u036B\x07u\u036B\u036C\x07g\u036C\u036D\x07t\u036D\u036E\x07x\u036E\u036F\x07k\u036F\u0370\x07e\u0370\u0371\x07g\u0371f\u0372\u0373\x07y\u0373\u0374\x07j\u0374\u0375\x07g\u0375\u0376\x07p\u0376h\u0377\u0378\x07y\u0378\u0379\x07j\u0379\u037A\x07k\u037A\u037B\x07n\u037B\u037C\x07g\u037Cj\u037D\u037E\x07y\u037E\u037F\x07k\u037F\u0380\x07v\u0380\u0381\x07j\u0381l\u0382\u0383\x07y\u0383\u0384\x07k\u0384\u0385\x07v\u0385\u0386\x07j\u0386\u0387\x07q\u0387\u0388\x07w\u0388\u0389\x07v\u0389n\u038A\u038B\x07n\u038B\u038C\x07k\u038C\u038D\x07u\u038D\u038E\x07v\u038Ep\u038F\u0390\x07o\u0390\u0391\x07c\u0391\u0392\x07r\u0392r\u0393\u0394\x07u\u0394\u0395\x07{\u0395\u0396\x07u\u0396\u0397\x07v\u0397\u0398\x07g\u0398\u0399\x07o\u0399t\u039A\u039B\x07w\u039B\u039C\x07u\u039C\u039D\x07g\u039D\u039E\x07t\u039Ev\u039F\u03A0\x07u\u03A0\u03A1\x07g\u03A1\u03A2\x07n\u03A2\u03A3\x07g\u03A3\u03A4\x07e\u03A4\u03A5\x07v\u03A5x\u03A6\u03A7\x07e\u03A7\u03A8\x07q\u03A8\u03A9\x07w\u03A9\u03AA\x07p\u03AA\u03AB\x07v\u03ABz\u03AC\u03AD\x07h\u03AD\u03AE\x07t\u03AE\u03AF\x07q\u03AF\u03B0\x07o\u03B0|\u03B1\u03B2\x07c\u03B2\u03B3\x07u\u03B3~\u03B4\u03B5\x07w\u03B5\u03B6\x07u\u03B6\u03B7\x07k\u03B7\u03B8\x07p\u03B8\u03B9\x07i\u03B9\x80\u03BA\u03BB\x07u\u03BB\u03BC\x07e\u03BC\u03BD\x07q\u03BD\u03BE\x07r\u03BE\u03BF\x07g\u03BF\x82\u03C0\u03C1\x07y\u03C1\u03C2\x07j\u03C2\u03C3\x07g\u03C3\u03C4\x07t\u03C4\u03C5\x07g\u03C5\x84\u03C6\u03C7\x07q\u03C7\u03C8\x07t\u03C8\u03C9\x07f\u03C9\u03CA\x07g\u03CA\u03CB\x07t\u03CB\x86\u03CC\u03CD\x07d\u03CD\u03CE\x07{\u03CE\x88\u03CF\u03D0\x07n\u03D0\u03D1\x07k\u03D1\u03D2\x07o\u03D2\u03D3\x07k\u03D3\u03D4\x07v\u03D4\x8A\u03D5\u03D6\x07c\u03D6\u03D7\x07p\u03D7\u03D8\x07f\u03D8\x8C\u03D9\u03DA\x07q\u03DA\u03DB\x07t\u03DB\x8E\u03DC\u03DD\x07p\u03DD\u03DE\x07q\u03DE\u03DF\x07v\u03DF\x90\u03E0\u03E1\x07c\u03E1\u03E2\x07x\u03E2\u03E3\x07i\u03E3\x92\u03E4\u03E5\x07e\u03E5\u03E6\x07q\u03E6\u03E7\x07w\u03E7\u03E8\x07p\u03E8\u03E9\x07v\u03E9\u03EA\x07a\u03EA\u03EB\x07f\u03EB\u03EC\x07k\u03EC\u03ED\x07u\u03ED\u03EE\x07v\u03EE\u03EF\x07k\u03EF\u03F0\x07p\u03F0\u03F1\x07e\u03F1\u03F2\x07v\u03F2\x94\u03F3\u03F4\x07o\u03F4\u03F5\x07k\u03F5\u03F6\x07p\u03F6\x96\u03F7\u03F8\x07o\u03F8\u03F9\x07c\u03F9\u03FA\x07z\u03FA\x98\u03FB\u03FC\x07u\u03FC\u03FD\x07w\u03FD\u03FE\x07o\u03FE\x9A\u03FF\u0400\x07v\u0400\u0401\x07{\u0401\u0402\x07r\u0402\u0403\x07g\u0403\u0404\x07q\u0404\u0405\x07h\u0405\x9C\u0406\u0407\x07g\u0407\u0408\x07p\u0408\u0409\x07f\u0409\x9E\u040A\u040B\x07v\u040B\u040C\x07j\u040C\u040D\x07g\u040D\u040E\x07p\u040E\xA0\u040F\u0410\x07n\u0410\u0411\x07k\u0411\u0412\x07m\u0412\u0413\x07g\u0413\xA2\u0414\u0415\x07k\u0415\u0416\x07p\u0416\xA4\u0417\u0418\x07k\u0418\u0419\x07p\u0419\u041A\x07e\u041A\u041B\x07n\u041B\u041C\x07w\u041C\u041D\x07f\u041D\u041E\x07g\u041E\u041F\x07u\u041F\xA6\u0420\u0421\x07g\u0421\u0422\x07z\u0422\u0423\x07e\u0423\u0424\x07n\u0424\u0425\x07w\u0425\u0426\x07f\u0426\u0427\x07g\u0427\u0428\x07u\u0428\xA8\u0429\u042A\x07c\u042A\u042B\x07u\u042B\u042C\x07e\u042C\xAA\u042D\u042E\x07f\u042E\u042F\x07g\u042F\u0430\x07u\u0430\u0431\x07e\u0431\xAC\u0432\u0433\x07p\u0433\u0434\x07w\u0434\u0435\x07n\u0435\u0436\x07n\u0436\u0437\x07u\u0437\xAE\u0438\u0439\x07h\u0439\u043A\x07k\u043A\u043B\x07t\u043B\u043C\x07u\u043C\u043D\x07v\u043D\xB0\u043E\u043F\x07n\u043F\u0440\x07c\u0440\u0441\x07u\u0441\u0442\x07v\u0442\xB2\u0443\u0444\x07i\u0444\u0445\x07t\u0445\u0446\x07q\u0446\u0447\x07w\u0447\u0448\x07r\u0448\xB4\u0449\u044A\x07c\u044A\u044B\x07n\u044B\u044C\x07n\u044C\xB6\u044D\u044E\x07t\u044E\u044F\x07q\u044F\u0450\x07y\u0450\u0451\x07u\u0451\xB8\u0452\u0453\x07x\u0453\u0454\x07k\u0454\u0455\x07g\u0455\u0456\x07y\u0456\xBA\u0457\u0458\x07j\u0458\u0459\x07c\u0459\u045A\x07x\u045A\u045B\x07k\u045B\u045C\x07p\u045C\u045D\x07i\u045D\xBC\u045E\u045F\x07t\u045F\u0460\x07q\u0460\u0461\x07n\u0461\u0462\x07n\u0462\u0463\x07w\u0463\u0464\x07r\u0464\xBE\u0465\u0466\x07v\u0466\u0467\x07q\u0467\u0468\x07n\u0468\u0469\x07c\u0469\u046A\x07d\u046A\u046B\x07g\u046B\u046C\x07n\u046C\xC0\u046D\u046E\x07q\u046E\u046F\x07h\u046F\u0470\x07h\u0470\u0471\x07u\u0471\u0472\x07g\u0472\u0473\x07v\u0473\xC2\u0474\u0475\x07f\u0475\u0476\x07c\u0476\u0477\x07v\u0477\u0478\x07c\u0478\xC4\u0479\u047A\x07e\u047A\u047B\x07c\u047B\u047C\x07v\u047C\u047D\x07g\u047D\u047E\x07i\u047E\u047F\x07q\u047F\u0480\x07t\u0480\u0481\x07{\u0481\xC6\u0482\u0483\x07c\u0483\u0484\x07v\u0484\xC8\u0485\u0486\x07c\u0486\u0487\x07d\u0487\u0488\x07q\u0488\u0489\x07x\u0489\u048A\x07g\u048A\xCA\u048B\u048C\x07d\u048C\u048D\x07g\u048D\u048E\x07n\u048E\u048F\x07q\u048F\u0490\x07y\u0490\xCC\u0491\u0492\x07c\u0492\u0493\x07d\u0493\u0494\x07q\u0494\u0495\x07x\u0495\u0496\x07g\u0496\u0497\x07a\u0497\u0498\x07q\u0498\u0499\x07t\u0499\u049A\x07a\u049A\u049B\x07d\u049B\u049C\x07g\u049C\u049D\x07n\u049D\u049E\x07q\u049E\u049F\x07y\u049F\xCE\u04A0\u04A1\x07u\u04A1\u04A2\x07g\u04A2\u04A3\x07e\u04A3\u04A4\x07w\u04A4\u04A5\x07t\u04A5\u04A6\x07k\u04A6\u04A7\x07v\u04A7\u04A8\x07{\u04A8\u04A9\x07a\u04A9\u04AA\x07g\u04AA\u04AB\x07p\u04AB\u04AC\x07h\u04AC\u04AD\x07q\u04AD\u04AE\x07t\u04AE\u04AF\x07e\u04AF\u04B0\x07g\u04B0\u04B1\x07f\u04B1\xD0\u04B2\u04B3\x07u\u04B3\u04B4\x07{\u04B4\u04B5\x07u\u04B5\u04B6\x07v\u04B6\u04B7\x07g\u04B7\u04B8\x07o\u04B8\u04B9\x07a\u04B9\u04BA\x07o\u04BA\u04BB\x07q\u04BB\u04BC\x07f\u04BC\u04BD\x07g\u04BD\xD2\u04BE\u04BF\x07w\u04BF\u04C0\x07u\u04C0\u04C1\x07g\u04C1\u04C2\x07t\u04C2\u04C3\x07a\u04C3\u04C4\x07o\u04C4\u04C5\x07q\u04C5\u04C6\x07f\u04C6\u04C7\x07g\u04C7\xD4\u04C8\u04C9\x07t\u04C9\u04CA\x07g\u04CA\u04CB\x07h\u04CB\u04CC\x07g\u04CC\u04CD\x07t\u04CD\u04CE\x07g\u04CE\u04CF\x07p\u04CF\u04D0\x07e\u04D0\u04D1\x07g\u04D1\xD6\u04D2\u04D3\x07e\u04D3\u04D4\x07w\u04D4\u04D5\x07d\u04D5\u04D6\x07g\u04D6\xD8\u04D7\u04D8\x07h\u04D8\u04D9\x07q\u04D9\u04DA\x07t\u04DA\u04DB\x07o\u04DB\u04DC\x07c\u04DC\u04DD\x07v\u04DD\xDA\u04DE\u04DF\x07v\u04DF\u04E0\x07t\u04E0\u04E1\x07c\u04E1\u04E2\x07e\u04E2\u04E3\x07m\u04E3\u04E4\x07k\u04E4\u04E5\x07p\u04E5\u04E6\x07i\u04E6\xDC\u04E7\u04E8\x07x\u04E8\u04E9\x07k\u04E9\u04EA\x07g\u04EA\u04EB\x07y\u04EB\u04EC\x07u\u04EC\u04ED\x07v\u04ED\u04EE\x07c\u04EE\u04EF\x07v\u04EF\xDE\u04F0\u04F1\x07e\u04F1\u04F2\x07w\u04F2\u04F3\x07u\u04F3\u04F4\x07v\u04F4\u04F5\x07q\u04F5\u04F6\x07o\u04F6\xE0\u04F7\u04F8\x07u\u04F8\u04F9\x07v\u04F9\u04FA\x07c\u04FA\u04FB\x07p\u04FB\u04FC\x07f\u04FC\u04FD\x07c\u04FD\u04FE\x07t\u04FE\u04FF\x07f\u04FF\xE2\u0500\u0501\x07f\u0501\u0502\x07k\u0502\u0503\x07u\u0503\u0504\x07v\u0504\u0505\x07c\u0505\u0506\x07p\u0506\u0507\x07e\u0507\u0508\x07g\u0508\xE4\u0509\u050A\x07i\u050A\u050B\x07g\u050B\u050C\x07q\u050C\u050D\x07n\u050D\u050E\x07q\u050E\u050F\x07e\u050F\u0510\x07c\u0510\u0511\x07v\u0511\u0512\x07k\u0512\u0513\x07q\u0513\u0514\x07p\u0514\xE6\u0515\u0516\x07i\u0516\u0517\x07t\u0517\u0518\x07q\u0518\u0519\x07w\u0519\u051A\x07r\u051A\u051B\x07k\u051B\u051C\x07p\u051C\u051D\x07i\u051D\xE8\u051E\u051F\x07e\u051F\u0520\x07q\u0520\u0521\x07p\u0521\u0522\x07x\u0522\u0523\x07g\u0523\u0524\x07t\u0524\u0525\x07v\u0525\u0526\x07e\u0526\u0527\x07w\u0527\u0528\x07t\u0528\u0529\x07t\u0529\u052A\x07g\u052A\u052B\x07p\u052B\u052C\x07e\u052C\u052D\x07{\u052D\xEA\u052E\u052F\x07e\u052F\u0530\x07c\u0530\u0531\x07n\u0531\u0532\x07g\u0532\u0533\x07p\u0533\u0534\x07f\u0534\u0535\x07c\u0535\u0536\x07t\u0536\u0537\x07a\u0537\u0538\x07o\u0538\u0539\x07q\u0539\u053A\x07p\u053A\u053B\x07v\u053B\u053C\x07j\u053C\xEC\u053D\u053E\x07e\u053E\u053F\x07c\u053F\u0540\x07n\u0540\u0541\x07g\u0541\u0542\x07p\u0542\u0543\x07f\u0543\u0544\x07c\u0544\u0545\x07t\u0545\u0546\x07a\u0546\u0547\x07s\u0547\u0548\x07w\u0548\u0549\x07c\u0549\u054A\x07t\u054A\u054B\x07v\u054B\u054C\x07g\u054C\u054D\x07t\u054D\xEE\u054E\u054F\x07e\u054F\u0550\x07c\u0550\u0551\x07n\u0551\u0552\x07g\u0552\u0553\x07p\u0553\u0554\x07f\u0554\u0555\x07c\u0555\u0556\x07t\u0556\u0557\x07a\u0557\u0558\x07{\u0558\u0559\x07g\u0559\u055A\x07c\u055A\u055B\x07t\u055B\xF0\u055C\u055D\x07f\u055D\u055E\x07c\u055E\u055F\x07{\u055F\u0560\x07a\u0560\u0561\x07k\u0561\u0562\x07p\u0562\u0563\x07a\u0563\u0564\x07o\u0564\u0565\x07q\u0565\u0566\x07p\u0566\u0567\x07v\u0567\u0568\x07j\u0568\xF2\u0569\u056A\x07f\u056A\u056B\x07c\u056B\u056C\x07{\u056C\u056D\x07a\u056D\u056E\x07k\u056E\u056F\x07p\u056F\u0570\x07a\u0570\u0571\x07y\u0571\u0572\x07g\u0572\u0573\x07g\u0573\u0574\x07m\u0574\xF4\u0575\u0576\x07f\u0576\u0577\x07c\u0577\u0578\x07{\u0578\u0579\x07a\u0579\u057A\x07k\u057A\u057B\x07p\u057B\u057C\x07a\u057C\u057D\x07{\u057D\u057E\x07g\u057E\u057F\x07c\u057F\u0580\x07t\u0580\xF6\u0581\u0582\x07f\u0582\u0583\x07c\u0583\u0584\x07{\u0584\u0585\x07a\u0585\u0586\x07q\u0586\u0587\x07p\u0587\u0588\x07n\u0588\u0589\x07{\u0589\xF8\u058A\u058B\x07h\u058B\u058C\x07k\u058C\u058D\x07u\u058D\u058E\x07e\u058E\u058F\x07c\u058F\u0590\x07n\u0590\u0591\x07a\u0591\u0592\x07o\u0592\u0593\x07q\u0593\u0594\x07p\u0594\u0595\x07v\u0595\u0596\x07j\u0596\xFA\u0597\u0598\x07h\u0598\u0599\x07k\u0599\u059A\x07u\u059A\u059B\x07e\u059B\u059C\x07c\u059C\u059D\x07n\u059D\u059E\x07a\u059E\u059F\x07s\u059F\u05A0\x07w\u05A0\u05A1\x07c\u05A1\u05A2\x07t\u05A2\u05A3\x07v\u05A3\u05A4\x07g\u05A4\u05A5\x07t\u05A5\xFC\u05A6\u05A7\x07h\u05A7\u05A8\x07k\u05A8\u05A9\x07u\u05A9\u05AA\x07e\u05AA\u05AB\x07c\u05AB\u05AC\x07n\u05AC\u05AD\x07a\u05AD\u05AE\x07{\u05AE\u05AF\x07g\u05AF\u05B0\x07c\u05B0\u05B1\x07t\u05B1\xFE\u05B2\u05B3\x07j\u05B3\u05B4\x07q\u05B4\u05B5\x07w\u05B5\u05B6\x07t\u05B6\u05B7\x07a\u05B7\u05B8\x07k\u05B8\u05B9\x07p\u05B9\u05BA\x07a\u05BA\u05BB\x07f\u05BB\u05BC\x07c\u05BC\u05BD\x07{\u05BD\u0100\u05BE\u05BF\x07y\u05BF\u05C0\x07g\u05C0\u05C1\x07g\u05C1\u05C2\x07m\u05C2\u05C3\x07a\u05C3\u05C4\x07k\u05C4\u05C5\x07p";
    ApexLexer2._serializedATNSegment3 = "\u05C5\u05C6\x07a\u05C6\u05C7\x07o\u05C7\u05C8\x07q\u05C8\u05C9\x07p\u05C9\u05CA\x07v\u05CA\u05CB\x07j\u05CB\u0102\u05CC\u05CD\x07y\u05CD\u05CE\x07g\u05CE\u05CF\x07g\u05CF\u05D0\x07m\u05D0\u05D1\x07a\u05D1\u05D2\x07k\u05D2\u05D3\x07p\u05D3\u05D4\x07a\u05D4\u05D5\x07{\u05D5\u05D6\x07g\u05D6\u05D7\x07c\u05D7\u05D8\x07t\u05D8\u0104\u05D9\u05DA\x07e\u05DA\u05DB\x07q\u05DB\u05DC\x07p\u05DC\u05DD\x07x\u05DD\u05DE\x07g\u05DE\u05DF\x07t\u05DF\u05E0\x07v\u05E0\u05E1\x07v\u05E1\u05E2\x07k\u05E2\u05E3\x07o\u05E3\u05E4\x07g\u05E4\u05E5\x07|\u05E5\u05E6\x07q\u05E6\u05E7\x07p\u05E7\u05E8\x07g\u05E8\u0106\u05E9\u05EA\x07{\u05EA\u05EB\x07g\u05EB\u05EC\x07u\u05EC\u05ED\x07v\u05ED\u05EE\x07g\u05EE\u05EF\x07t\u05EF\u05F0\x07f\u05F0\u05F1\x07c\u05F1\u05F2\x07{\u05F2\u0108\u05F3\u05F4\x07v\u05F4\u05F5\x07q\u05F5\u05F6\x07f\u05F6\u05F7\x07c\u05F7\u05F8\x07{\u05F8\u010A\u05F9\u05FA\x07v\u05FA\u05FB\x07q\u05FB\u05FC\x07o\u05FC\u05FD\x07q\u05FD\u05FE\x07t\u05FE\u05FF\x07t\u05FF\u0600\x07q\u0600\u0601\x07y\u0601\u010C\u0602\u0603\x07n\u0603\u0604\x07c\u0604\u0605\x07u\u0605\u0606\x07v\u0606\u0607\x07a\u0607\u0608\x07y\u0608\u0609\x07g\u0609\u060A\x07g\u060A\u060B\x07m\u060B\u010E\u060C\u060D\x07v\u060D\u060E\x07j\u060E\u060F\x07k\u060F\u0610\x07u\u0610\u0611\x07a\u0611\u0612\x07y\u0612\u0613\x07g\u0613\u0614\x07g\u0614\u0615\x07m\u0615\u0110\u0616\u0617\x07p\u0617\u0618\x07g\u0618\u0619\x07z\u0619\u061A\x07v\u061A\u061B\x07a\u061B\u061C\x07y\u061C\u061D\x07g\u061D\u061E\x07g\u061E\u061F\x07m\u061F\u0112\u0620\u0621\x07n\u0621\u0622\x07c\u0622\u0623\x07u\u0623\u0624\x07v\u0624\u0625\x07a\u0625\u0626\x07o\u0626\u0627\x07q\u0627\u0628\x07p\u0628\u0629\x07v\u0629\u062A\x07j\u062A\u0114\u062B\u062C\x07v\u062C\u062D\x07j\u062D\u062E\x07k\u062E\u062F\x07u\u062F\u0630\x07a\u0630\u0631\x07o\u0631\u0632\x07q\u0632\u0633\x07p\u0633\u0634\x07v\u0634\u0635\x07j\u0635\u0116\u0636\u0637\x07p\u0637\u0638\x07g\u0638\u0639\x07z\u0639\u063A\x07v\u063A\u063B\x07a\u063B\u063C\x07o\u063C\u063D\x07q\u063D\u063E\x07p\u063E\u063F\x07v\u063F\u0640\x07j\u0640\u0118\u0641\u0642\x07n\u0642\u0643\x07c\u0643\u0644\x07u\u0644\u0645\x07v\u0645\u0646\x07a\u0646\u0647\x07;\u0647\u0648\x072\u0648\u0649\x07a\u0649\u064A\x07f\u064A\u064B\x07c\u064B\u064C\x07{\u064C\u064D\x07u\u064D\u011A\u064E\u064F\x07p\u064F\u0650\x07g\u0650\u0651\x07z\u0651\u0652\x07v\u0652\u0653\x07a\u0653\u0654\x07;\u0654\u0655\x072\u0655\u0656\x07a\u0656\u0657\x07f\u0657\u0658\x07c\u0658\u0659\x07{\u0659\u065A\x07u\u065A\u011C\u065B\u065C\x07n\u065C\u065D\x07c\u065D\u065E\x07u\u065E\u065F\x07v\u065F\u0660\x07a\u0660\u0661\x07p\u0661\u0662\x07a\u0662\u0663\x07f\u0663\u0664\x07c\u0664\u0665\x07{\u0665\u0666\x07u\u0666\u011E\u0667\u0668\x07p\u0668\u0669\x07g\u0669\u066A\x07z\u066A\u066B\x07v\u066B\u066C\x07a\u066C\u066D\x07p\u066D\u066E\x07a\u066E\u066F\x07f\u066F\u0670\x07c\u0670\u0671\x07{\u0671\u0672\x07u\u0672\u0120\u0673\u0674\x07p\u0674\u0675\x07a\u0675\u0676\x07f\u0676\u0677\x07c\u0677\u0678\x07{\u0678\u0679\x07u\u0679\u067A\x07a\u067A\u067B\x07c\u067B\u067C\x07i\u067C\u067D\x07q\u067D\u0122\u067E\u067F\x07p\u067F\u0680\x07g\u0680\u0681\x07z\u0681\u0682\x07v\u0682\u0683\x07a\u0683\u0684\x07p\u0684\u0685\x07a\u0685\u0686\x07y\u0686\u0687\x07g\u0687\u0688\x07g\u0688\u0689\x07m\u0689\u068A\x07u\u068A\u0124\u068B\u068C\x07n\u068C\u068D\x07c\u068D\u068E\x07u\u068E\u068F\x07v\u068F\u0690\x07a\u0690\u0691\x07p\u0691\u0692\x07a\u0692\u0693\x07y\u0693\u0694\x07g\u0694\u0695\x07g\u0695\u0696\x07m\u0696\u0697\x07u\u0697\u0126\u0698\u0699\x07p\u0699\u069A\x07a\u069A\u069B\x07y\u069B\u069C\x07g\u069C\u069D\x07g\u069D\u069E\x07m\u069E\u069F\x07u\u069F\u06A0\x07a\u06A0\u06A1\x07c\u06A1\u06A2\x07i\u06A2\u06A3\x07q\u06A3\u0128\u06A4\u06A5\x07p\u06A5\u06A6\x07g\u06A6\u06A7\x07z\u06A7\u06A8\x07v\u06A8\u06A9\x07a\u06A9\u06AA\x07p\u06AA\u06AB\x07a\u06AB\u06AC\x07o\u06AC\u06AD\x07q\u06AD\u06AE\x07p\u06AE\u06AF\x07v\u06AF\u06B0\x07j\u06B0\u06B1\x07u\u06B1\u012A\u06B2\u06B3\x07n\u06B3\u06B4\x07c\u06B4\u06B5\x07u\u06B5\u06B6\x07v\u06B6\u06B7\x07a\u06B7\u06B8\x07p\u06B8\u06B9\x07a\u06B9\u06BA\x07o\u06BA\u06BB\x07q\u06BB\u06BC\x07p\u06BC\u06BD\x07v\u06BD\u06BE\x07j\u06BE\u06BF\x07u\u06BF\u012C\u06C0\u06C1\x07p\u06C1\u06C2\x07a\u06C2\u06C3\x07o\u06C3\u06C4\x07q\u06C4\u06C5\x07p\u06C5\u06C6\x07v\u06C6\u06C7\x07j\u06C7\u06C8\x07u\u06C8\u06C9\x07a\u06C9\u06CA\x07c\u06CA\u06CB\x07i\u06CB\u06CC\x07q\u06CC\u012E\u06CD\u06CE\x07v\u06CE\u06CF\x07j\u06CF\u06D0\x07k\u06D0\u06D1\x07u\u06D1\u06D2\x07a\u06D2\u06D3\x07s\u06D3\u06D4\x07w\u06D4\u06D5\x07c\u06D5\u06D6\x07t\u06D6\u06D7\x07v\u06D7\u06D8\x07g\u06D8\u06D9\x07t\u06D9\u0130\u06DA\u06DB\x07n\u06DB\u06DC\x07c\u06DC\u06DD\x07u\u06DD\u06DE\x07v\u06DE\u06DF\x07a\u06DF\u06E0\x07s\u06E0\u06E1\x07w\u06E1\u06E2\x07c\u06E2\u06E3\x07t\u06E3\u06E4\x07v\u06E4\u06E5\x07g\u06E5\u06E6\x07t\u06E6\u0132\u06E7\u06E8\x07p\u06E8\u06E9\x07g\u06E9\u06EA\x07z\u06EA\u06EB\x07v\u06EB\u06EC\x07a\u06EC\u06ED\x07s\u06ED\u06EE\x07w\u06EE\u06EF\x07c\u06EF\u06F0\x07t\u06F0\u06F1\x07v\u06F1\u06F2\x07g\u06F2\u06F3\x07t\u06F3\u0134\u06F4\u06F5\x07p\u06F5\u06F6\x07g\u06F6\u06F7\x07z\u06F7\u06F8\x07v\u06F8\u06F9\x07a\u06F9\u06FA\x07p\u06FA\u06FB\x07a\u06FB\u06FC\x07s\u06FC\u06FD\x07w\u06FD\u06FE\x07c\u06FE\u06FF\x07t\u06FF\u0700\x07v\u0700\u0701\x07g\u0701\u0702\x07t\u0702\u0703\x07u\u0703\u0136\u0704\u0705\x07n\u0705\u0706\x07c\u0706\u0707\x07u\u0707\u0708\x07v\u0708\u0709\x07a\u0709\u070A\x07p\u070A\u070B\x07a\u070B\u070C\x07s\u070C\u070D\x07w\u070D\u070E\x07c\u070E\u070F\x07t\u070F\u0710\x07v\u0710\u0711\x07g\u0711\u0712\x07t\u0712\u0713\x07u\u0713\u0138\u0714\u0715\x07p\u0715\u0716\x07a\u0716\u0717\x07s\u0717\u0718\x07w\u0718\u0719\x07c\u0719\u071A\x07t\u071A\u071B\x07v\u071B\u071C\x07g\u071C\u071D\x07t\u071D\u071E\x07u\u071E\u071F\x07a\u071F\u0720\x07c\u0720\u0721\x07i\u0721\u0722\x07q\u0722\u013A\u0723\u0724\x07v\u0724\u0725\x07j\u0725\u0726\x07k\u0726\u0727\x07u\u0727\u0728\x07a\u0728\u0729\x07{\u0729\u072A\x07g\u072A\u072B\x07c\u072B\u072C\x07t\u072C\u013C\u072D\u072E\x07n\u072E\u072F\x07c\u072F\u0730\x07u\u0730\u0731\x07v\u0731\u0732\x07a\u0732\u0733\x07{\u0733\u0734\x07g\u0734\u0735\x07c\u0735\u0736\x07t\u0736\u013E\u0737\u0738\x07p\u0738\u0739\x07g\u0739\u073A\x07z\u073A\u073B\x07v\u073B\u073C\x07a\u073C\u073D\x07{\u073D\u073E\x07g\u073E\u073F\x07c\u073F\u0740\x07t\u0740\u0140\u0741\u0742\x07p\u0742\u0743\x07g\u0743\u0744\x07z\u0744\u0745\x07v\u0745\u0746\x07a\u0746\u0747\x07p\u0747\u0748\x07a\u0748\u0749\x07{\u0749\u074A\x07g\u074A\u074B\x07c\u074B\u074C\x07t\u074C\u074D\x07u\u074D\u0142\u074E\u074F\x07n\u074F\u0750\x07c\u0750\u0751\x07u\u0751\u0752\x07v\u0752\u0753\x07a\u0753\u0754\x07p\u0754\u0755\x07a\u0755\u0756\x07{\u0756\u0757\x07g\u0757\u0758\x07c\u0758\u0759\x07t\u0759\u075A\x07u\u075A\u0144\u075B\u075C\x07p\u075C\u075D\x07a\u075D\u075E\x07{\u075E\u075F\x07g\u075F\u0760\x07c\u0760\u0761\x07t\u0761\u0762\x07u\u0762\u0763\x07a\u0763\u0764\x07c\u0764\u0765\x07i\u0765\u0766\x07q\u0766\u0146\u0767\u0768\x07v\u0768\u0769\x07j\u0769\u076A\x07k\u076A\u076B\x07u\u076B\u076C\x07a\u076C\u076D\x07h\u076D\u076E\x07k\u076E\u076F\x07u\u076F\u0770\x07e\u0770\u0771\x07c\u0771\u0772\x07n\u0772\u0773\x07a\u0773\u0774\x07s\u0774\u0775\x07w\u0775\u0776\x07c\u0776\u0777\x07t\u0777\u0778\x07v\u0778\u0779\x07g\u0779\u077A\x07t\u077A\u0148\u077B\u077C\x07n\u077C\u077D\x07c\u077D\u077E\x07u\u077E\u077F\x07v\u077F\u0780\x07a\u0780\u0781\x07h\u0781\u0782\x07k\u0782\u0783\x07u\u0783\u0784\x07e\u0784\u0785\x07c\u0785\u0786\x07n\u0786\u0787\x07a\u0787\u0788\x07s\u0788\u0789\x07w\u0789\u078A\x07c\u078A\u078B\x07t\u078B\u078C\x07v\u078C\u078D\x07g\u078D\u078E\x07t\u078E\u014A\u078F\u0790\x07p\u0790\u0791\x07g\u0791\u0792\x07z\u0792\u0793\x07v\u0793\u0794\x07a\u0794\u0795\x07h\u0795\u0796\x07k\u0796\u0797\x07u\u0797\u0798\x07e\u0798\u0799\x07c\u0799\u079A\x07n\u079A\u079B\x07a\u079B\u079C\x07s\u079C\u079D\x07w\u079D\u079E\x07c\u079E\u079F\x07t\u079F\u07A0\x07v\u07A0\u07A1\x07g\u07A1\u07A2\x07t\u07A2\u014C\u07A3\u07A4\x07p\u07A4\u07A5\x07g\u07A5\u07A6\x07z\u07A6\u07A7\x07v\u07A7\u07A8\x07a\u07A8\u07A9\x07p\u07A9\u07AA\x07a\u07AA\u07AB\x07h\u07AB\u07AC\x07k\u07AC\u07AD\x07u\u07AD\u07AE\x07e\u07AE\u07AF\x07c\u07AF\u07B0\x07n\u07B0\u07B1\x07a\u07B1\u07B2\x07s\u07B2\u07B3\x07w\u07B3\u07B4\x07c\u07B4\u07B5\x07t\u07B5\u07B6\x07v\u07B6\u07B7\x07g\u07B7\u07B8\x07t\u07B8\u07B9\x07u\u07B9\u014E\u07BA\u07BB\x07n\u07BB\u07BC\x07c\u07BC\u07BD\x07u\u07BD\u07BE\x07v\u07BE\u07BF\x07a\u07BF\u07C0\x07p\u07C0\u07C1\x07a\u07C1\u07C2\x07h\u07C2\u07C3\x07k\u07C3\u07C4\x07u\u07C4\u07C5\x07e\u07C5\u07C6\x07c\u07C6\u07C7\x07n\u07C7\u07C8\x07a\u07C8\u07C9\x07s\u07C9\u07CA\x07w\u07CA\u07CB\x07c\u07CB\u07CC\x07t\u07CC\u07CD\x07v\u07CD\u07CE\x07g\u07CE\u07CF\x07t\u07CF\u07D0\x07u\u07D0\u0150\u07D1\u07D2\x07p\u07D2\u07D3\x07a\u07D3\u07D4\x07h\u07D4\u07D5\x07k\u07D5\u07D6\x07u\u07D6\u07D7\x07e\u07D7\u07D8\x07c\u07D8\u07D9\x07n\u07D9\u07DA\x07a\u07DA\u07DB\x07s\u07DB\u07DC\x07w\u07DC\u07DD\x07c\u07DD\u07DE\x07t\u07DE\u07DF\x07v\u07DF\u07E0\x07g\u07E0\u07E1\x07t\u07E1\u07E2\x07u\u07E2\u07E3\x07a\u07E3\u07E4\x07c\u07E4\u07E5\x07i\u07E5\u07E6\x07q\u07E6\u0152\u07E7\u07E8\x07v\u07E8\u07E9\x07j\u07E9\u07EA\x07k\u07EA\u07EB\x07u\u07EB\u07EC\x07a\u07EC\u07ED\x07h\u07ED\u07EE\x07k\u07EE\u07EF\x07u\u07EF\u07F0\x07e\u07F0\u07F1\x07c\u07F1\u07F2\x07n\u07F2\u07F3\x07a\u07F3\u07F4\x07{\u07F4\u07F5\x07g\u07F5\u07F6\x07c\u07F6\u07F7\x07t\u07F7\u0154\u07F8\u07F9\x07n\u07F9\u07FA\x07c\u07FA\u07FB\x07u\u07FB\u07FC\x07v\u07FC\u07FD\x07a\u07FD\u07FE\x07h\u07FE\u07FF\x07k\u07FF\u0800\x07u\u0800\u0801\x07e\u0801\u0802\x07c\u0802\u0803\x07n\u0803\u0804\x07a\u0804\u0805\x07{\u0805\u0806\x07g\u0806\u0807\x07c\u0807\u0808\x07t\u0808\u0156\u0809\u080A\x07p\u080A\u080B\x07g\u080B\u080C\x07z\u080C\u080D\x07v\u080D\u080E\x07a\u080E\u080F\x07h\u080F\u0810\x07k\u0810\u0811\x07u\u0811\u0812\x07e\u0812\u0813\x07c\u0813\u0814\x07n\u0814\u0815\x07a\u0815\u0816\x07{\u0816\u0817\x07g\u0817\u0818\x07c\u0818\u0819\x07t\u0819\u0158\u081A\u081B\x07p\u081B\u081C\x07g\u081C\u081D\x07z\u081D\u081E\x07v\u081E\u081F\x07a\u081F\u0820\x07p\u0820\u0821\x07a\u0821\u0822\x07h\u0822\u0823\x07k\u0823\u0824\x07u\u0824\u0825\x07e\u0825\u0826\x07c\u0826\u0827\x07n\u0827\u0828\x07a\u0828\u0829\x07{\u0829\u082A\x07g\u082A\u082B\x07c\u082B\u082C\x07t\u082C\u082D\x07u\u082D\u015A\u082E\u082F\x07n\u082F\u0830\x07c\u0830\u0831\x07u\u0831\u0832\x07v\u0832\u0833\x07a\u0833\u0834\x07p\u0834\u0835\x07a\u0835\u0836\x07h\u0836\u0837\x07k\u0837\u0838\x07u\u0838\u0839\x07e\u0839\u083A\x07c\u083A\u083B\x07n\u083B\u083C\x07a\u083C\u083D\x07{\u083D\u083E\x07g\u083E\u083F\x07c\u083F\u0840\x07t\u0840\u0841\x07u\u0841\u015C\u0842\u0843\x07p\u0843\u0844\x07a\u0844\u0845\x07h\u0845\u0846\x07k\u0846\u0847\x07u\u0847\u0848\x07e\u0848\u0849\x07c\u0849\u084A\x07n\u084A\u084B\x07a\u084B\u084C\x07{\u084C\u084D\x07g\u084D\u084E\x07c\u084E\u084F\x07t\u084F\u0850\x07u\u0850\u0851\x07a\u0851\u0852\x07c\u0852\u0853\x07i\u0853\u0854\x07q\u0854\u015E\u0855\u0856\u0199\xCD\u0856\u0857\u0199\xCD\u0857\u0858\u0199\xCD\u0858\u0859\u0199\xCD\u0859\u085A\x07/\u085A\u085B\u0199\xCD\u085B\u085C\u0199\xCD\u085C\u085D\x07/\u085D\u085E\u0199\xCD\u085E\u085F\u0199\xCD\u085F\u0160\u0860\u0861\u0199\xCD\u0861\u0862\u0199\xCD\u0862\u0863\x07<\u0863\u0864\u0199\xCD\u0864\u0865\u0199\xCD\u0865\u0866\x07<\u0866\u0867\u0199\xCD\u0867\u086E\u0199\xCD\u0868\u086A\x070\u0869\u086B\u0199\xCD\u086A\u0869\u086B\u086C\u086C\u086A\u086C\u086D\u086D\u086F\u086E\u0868\u086E\u086F\u086F\u087F\u0870\u0880\x07|\u0871\u0873	\u0872\u0874\u0199\xCD\u0873\u0872\u0874\u0875\u0875\u0873\u0875\u0876\u0876\u087D\u0877\u0879\x07<\u0878\u087A\u0199\xCD\u0879\u0878\u087A\u087B\u087B\u0879\u087B\u087C\u087C\u087E\u087D\u0877\u087D\u087E\u087E\u0880\u087F\u0870\u087F\u0871\u0880\u0162\u0881\u0882\u015F\xB0\u0882\u0883\x07v\u0883\u0884\u0161\xB1\u0884\u0164\u0885\u0886	\u0886\u0887	\u0887\u0889	\u0888\u088A\u0199\xCD\u0889\u0888\u088A\u088B\u088B\u0889\u088B\u088C\u088C\u0166\u088D\u088E\x07h\u088E\u088F\x07k\u088F\u0890\x07p\u0890\u0891\x07f\u0891\u0168\u0892\u0893\x07g\u0893\u0894\x07o\u0894\u0895\x07c\u0895\u0896\x07k\u0896\u0897\x07n\u0897\u016A\u0898\u0899\x07p\u0899\u089A\x07c\u089A\u089B\x07o\u089B\u089C\x07g\u089C\u016C\u089D\u089E\x07r\u089E\u089F\x07j\u089F\u08A0\x07q\u08A0\u08A1\x07p\u08A1\u08A2\x07g\u08A2\u016E\u08A3\u08A4\x07u\u08A4\u08A5\x07k\u08A5\u08A6\x07f\u08A6\u08A7\x07g\u08A7\u08A8\x07d\u08A8\u08A9\x07c\u08A9\u08AA\x07t\u08AA\u0170\u08AB\u08AC\x07h\u08AC\u08AD\x07k\u08AD\u08AE\x07g\u08AE\u08AF\x07n\u08AF\u08B0\x07f\u08B0\u08B1\x07u\u08B1\u0172\u08B2\u08B3\x07o\u08B3\u08B4\x07g\u08B4\u08B5\x07v\u08B5\u08B6\x07c\u08B6\u08B7\x07f\u08B7\u08B8\x07c\u08B8\u08B9\x07v\u08B9\u08BA\x07c\u08BA\u0174\u08BB\u08BC\x07r\u08BC\u08BD\x07t\u08BD\u08BE\x07k\u08BE\u08BF\x07e\u08BF\u08C0\x07g\u08C0\u08C1\x07d\u08C1\u08C2\x07q\u08C2\u08C3\x07q\u08C3\u08C4\x07m\u08C4\u08C5\x07k\u08C5\u08C6\x07f\u08C6\u0176\u08C7\u08C8\x07p\u08C8\u08C9\x07g\u08C9\u08CA\x07v\u08CA\u08CB\x07y\u08CB\u08CC\x07q\u08CC\u08CD\x07t\u08CD\u08CE\x07m\u08CE\u0178\u08CF\u08D0\x07u\u08D0\u08D1\x07p\u08D1\u08D2\x07k\u08D2\u08D3\x07r\u08D3\u08D4\x07r\u08D4\u08D5\x07g\u08D5\u08D6\x07v\u08D6\u017A\u08D7\u08D8\x07v\u08D8\u08D9\x07c\u08D9\u08DA\x07t\u08DA\u08DB\x07i\u08DB\u08DC\x07g\u08DC\u08DD\x07v\u08DD\u08DE\x07a\u08DE\u08DF\x07n\u08DF\u08E0\x07g\u08E0\u08E1\x07p\u08E1\u08E2\x07i\u08E2\u08E3\x07v\u08E3\u08E4\x07j\u08E4\u017C\u08E5\u08E6\x07f\u08E6\u08E7\x07k\u08E7\u08E8\x07x\u08E8\u08E9\x07k\u08E9\u08EA\x07u\u08EA\u08EB\x07k\u08EB\u08EC\x07q\u08EC\u08ED\x07p\u08ED\u017E\u08EE\u08EF\x07t\u08EF\u08F0\x07g\u08F0\u08F1\x07v\u08F1\u08F2\x07w\u08F2\u08F3\x07t\u08F3\u08F4\x07p\u08F4\u08F5\x07k\u08F5\u08F6\x07p\u08F6\u08F7\x07i\u08F7\u0180\u08F8\u08F9\x07n\u08F9\u08FA\x07k\u08FA\u08FB\x07u\u08FB\u08FC\x07v\u08FC\u08FD\x07x\u08FD\u08FE\x07k\u08FE\u08FF\x07g";
    ApexLexer2._serializedATNSegment4 = "\u08FF\u0900\x07y\u0900\u0182\u0901\u0903\x07]\u0902\u0904\u0209\u0105\u0903\u0902\u0903\u0904\u0904\u0905\u0905\u0906\x07h\u0906\u0907\x07k\u0907\u0908\x07p\u0908\u0909\x07f\u0909\u090A\u090A\u090B\u0209\u0105\u090B\u090D\x07)\u090C\u090E\u0185\xC3\u090D\u090C\u090D\u090E\u090E\u090F\u090F\u0910\x07)\u0910\u0184\u0911\u0913\u0187\xC4\u0912\u0911\u0913\u0914\u0914\u0912\u0914\u0915\u0915\u0186\u0916\u0919\n\u0917\u0919\u018F\xC8\u0918\u0916\u0918\u0917\u0919\u0188\u091A\u091C\x07]\u091B\u091D\u0209\u0105\u091C\u091B\u091C\u091D\u091D\u091E\u091E\u091F\x07h\u091F\u0920\x07k\u0920\u0921\x07p\u0921\u0922\x07f\u0922\u0923\u0923\u0924\u0209\u0105\u0924\u0926\x07}\u0925\u0927\u018B\xC6\u0926\u0925\u0926\u0927\u0927\u0928\u0928\u0929\x07\x7F\u0929\u018A\u092A\u092C\u018D\xC7\u092B\u092A\u092C\u092D\u092D\u092B\u092D\u092E\u092E\u018C\u092F\u0932\n\u0930\u0932\u018F\xC8\u0931\u092F\u0931\u0930\u0932\u018E\u0933\u0934\x07^\u0934\u0935	\u0935\u0190\u0936\u093A\u0199\xCD\u0937\u0939\u0199\xCD\u0938\u0937\u0939\u093C\u093A\u0938\u093A\u093B\u093B\u0192\u093C\u093A\u093D\u0941\u0199\xCD\u093E\u0940\u0199\xCD\u093F\u093E\u0940\u0943\u0941\u093F\u0941\u0942\u0942\u0944\u0943\u0941\u0944\u0945	\x07\u0945\u0194\u0946\u0948\u0199\xCD\u0947\u0946\u0948\u094B\u0949\u0947\u0949\u094A\u094A\u094C\u094B\u0949\u094C\u094D\x070\u094D\u0951\u0199\xCD\u094E\u0950\u0199\xCD\u094F\u094E\u0950\u0953\u0951\u094F\u0951\u0952\u0952\u0955\u0953\u0951\u0954\u0956	\b\u0955\u0954\u0955\u0956\u0956\u0196\u0957\u0958		\u0958\u0198\u0959\u095A	\n\u095A\u019A\u095B\u095C\x07v\u095C\u095D\x07t\u095D\u095E\x07w\u095E\u0965\x07g\u095F\u0960\x07h\u0960\u0961\x07c\u0961\u0962\x07n\u0962\u0963\x07u\u0963\u0965\x07g\u0964\u095B\u0964\u095F\u0965\u019C\u0966\u0968\x07)\u0967\u0969\u019F\xD0\u0968\u0967\u0968\u0969\u0969\u096A\u096A\u096B\x07)\u096B\u019E\u096C\u096E\u01A1\xD1\u096D\u096C\u096E\u096F\u096F\u096D\u096F\u0970\u0970\u01A0\u0971\u0974\n\u0972\u0974\u01A3\xD2\u0973\u0971\u0973\u0972\u0974\u01A2\u0975\u0976\x07^\u0976\u0980	\v\u0977\u0978\x07^\u0978\u0979\x07w\u0979\u097A\u097A\u097B\u0197\xCC\u097B\u097C\u0197\xCC\u097C\u097D\u0197\xCC\u097D\u097E\u0197\xCC\u097E\u0980\u097F\u0975\u097F\u0977\u0980\u01A4\u0981\u09825\x1B\u0982\u01A6\u0983\u0984\x07*\u0984\u01A8\u0985\u0986\x07+\u0986\u01AA\u0987\u0988\x07}\u0988\u01AC\u0989\u098A\x07\x7F\u098A\u01AE\u098B\u098C\x07]\u098C\u01B0\u098D\u098E\x07_\u098E\u01B2\u098F\u0990\x07=\u0990\u01B4\u0991\u0992\x07.\u0992\u01B6\u0993\u0994\x070\u0994\u01B8\u0995\u0996\x07?\u0996\u01BA\u0997\u0998\x07@\u0998\u01BC\u0999\u099A\x07>\u099A\u01BE\u099B\u099C\x07#\u099C\u01C0\u099D\u099E\x07\x80\u099E\u01C2\u099F\u09A0\x07A\u09A0\u09A1\x070\u09A1\u01C4\u09A2\u09A3\x07A\u09A3\u01C6\u09A4\u09A5\x07<\u09A5\u01C8\u09A6\u09A7\x07?\u09A7\u09A8\x07?\u09A8\u01CA\u09A9\u09AA\x07?\u09AA\u09AB\x07?\u09AB\u09AC\x07?\u09AC\u01CC\u09AD\u09AE\x07#\u09AE\u09AF\x07?\u09AF\u01CE\u09B0\u09B1\x07>\u09B1\u09B2\x07@\u09B2\u01D0\u09B3\u09B4\x07#\u09B4\u09B5\x07?\u09B5\u09B6\x07?\u09B6\u01D2\u09B7\u09B8\x07(\u09B8\u09B9\x07(\u09B9\u01D4\u09BA\u09BB\x07~\u09BB\u09BC\x07~\u09BC\u01D6\u09BD\u09BE\x07A\u09BE\u09BF\x07A\u09BF\u01D8\u09C0\u09C1\x07-\u09C1\u09C2\x07-\u09C2\u01DA\u09C3\u09C4\x07/\u09C4\u09C5\x07/\u09C5\u01DC\u09C6\u09C7\x07-\u09C7\u01DE\u09C8\u09C9\x07/\u09C9\u01E0\u09CA\u09CB\x07,\u09CB\u01E2\u09CC\u09CD\x071\u09CD\u01E4\u09CE\u09CF\x07(\u09CF\u01E6\u09D0\u09D1\x07~\u09D1\u01E8\u09D2\u09D3\x07`\u09D3\u01EA\u09D4\u09D5\x07?\u09D5\u09D6\x07@\u09D6\u01EC\u09D7\u09D8\x07-\u09D8\u09D9\x07?\u09D9\u01EE\u09DA\u09DB\x07/\u09DB\u09DC\x07?\u09DC\u01F0\u09DD\u09DE\x07,\u09DE\u09DF\x07?\u09DF\u01F2\u09E0\u09E1\x071\u09E1\u09E2\x07?\u09E2\u01F4\u09E3\u09E4\x07(\u09E4\u09E5\x07?\u09E5\u01F6\u09E6\u09E7\x07~\u09E7\u09E8\x07?\u09E8\u01F8\u09E9\u09EA\x07`\u09EA\u09EB\x07?\u09EB\u01FA\u09EC\u09ED\x07>\u09ED\u09EE\x07>\u09EE\u09EF\x07?\u09EF\u01FC\u09F0\u09F1\x07@\u09F1\u09F2\x07@\u09F2\u09F3\x07?\u09F3\u01FE\u09F4\u09F5\x07@\u09F5\u09F6\x07@\u09F6\u09F7\x07@\u09F7\u09F8\x07?\u09F8\u0200\u09F9\u09FA\x07B\u09FA\u0202\u09FB\u09FF\u0205\u0103\u09FC\u09FE\u0207\u0104\u09FD\u09FC\u09FE\u0A01\u09FF\u09FD\u09FF\u0A00\u0A00\u0204\u0A01\u09FF\u0A02\u0A07	\f\u0A03\u0A07\n\r\u0A04\u0A05	\u0A05\u0A07	\u0A06\u0A02\u0A06\u0A03\u0A06\u0A04\u0A07\u0206\u0A08\u0A0D	\u0A09\u0A0D\n\r\u0A0A\u0A0B	\u0A0B\u0A0D	\u0A0C\u0A08\u0A0C\u0A09\u0A0C\u0A0A\u0A0D\u0208\u0A0E\u0A10	\u0A0F\u0A0E\u0A10\u0A11\u0A11\u0A0F\u0A11\u0A12\u0A12\u0A13\u0A13\u0A14\b\u0105\u0A14\u020A\u0A15\u0A16\x071\u0A16\u0A17\x07,\u0A17\u0A18\x07,\u0A18\u0A1C\u0A19\u0A1B\v\u0A1A\u0A19\u0A1B\u0A1E\u0A1C\u0A1D\u0A1C\u0A1A\u0A1D\u0A1F\u0A1E\u0A1C\u0A1F\u0A20\x07,\u0A20\u0A21\x071\u0A21\u0A22\u0A22\u0A23\b\u0106\u0A23\u020C\u0A24\u0A25\x071\u0A25\u0A26\x07,\u0A26\u0A2A\u0A27\u0A29\v\u0A28\u0A27\u0A29\u0A2C\u0A2A\u0A2B\u0A2A\u0A28\u0A2B\u0A2D\u0A2C\u0A2A\u0A2D\u0A2E\x07,\u0A2E\u0A2F\x071\u0A2F\u0A30\u0A30\u0A31\b\u0107\u0A31\u020E\u0A32\u0A33\x071\u0A33\u0A34\x071\u0A34\u0A38\u0A35\u0A37\n\u0A36\u0A35\u0A37\u0A3A\u0A38\u0A36\u0A38\u0A39\u0A39\u0A3B\u0A3A\u0A38\u0A3B\u0A3C\b\u0108\u0A3C\u0210#\u086C\u086E\u0875\u087B\u087D\u087F\u088B\u0903\u090D\u0914\u0918\u091C\u0926\u092D\u0931\u093A\u0941\u0949\u0951\u0955\u0964\u0968\u096F\u0973\u097F\u09FF\u0A06\u0A0C\u0A11\u0A1C\u0A2A\u0A38";
    ApexLexer2._serializedATN = Utils.join([
      ApexLexer2._serializedATNSegment0,
      ApexLexer2._serializedATNSegment1,
      ApexLexer2._serializedATNSegment2,
      ApexLexer2._serializedATNSegment3,
      ApexLexer2._serializedATNSegment4
    ], "");
  }
});

// node_modules/@apexdevtools/apex-parser/lib/ApexParser.js
var require_ApexParser = __commonJS({
  "node_modules/@apexdevtools/apex-parser/lib/ApexParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ForStatementContext = exports2.WhenLiteralContext = exports2.WhenValueContext = exports2.WhenControlContext = exports2.SwitchStatementContext = exports2.IfStatementContext = exports2.StatementContext = exports2.LocalVariableDeclarationContext = exports2.LocalVariableDeclarationStatementContext = exports2.BlockContext = exports2.ElementValueArrayInitializerContext = exports2.ElementValueContext = exports2.ElementValuePairContext = exports2.ElementValuePairsContext = exports2.AnnotationContext = exports2.LiteralContext = exports2.QualifiedNameContext = exports2.FormalParameterContext = exports2.FormalParameterListContext = exports2.FormalParametersContext = exports2.TypeArgumentsContext = exports2.TypeNameContext = exports2.ArraySubscriptsContext = exports2.TypeRefContext = exports2.ArrayInitializerContext = exports2.VariableDeclaratorContext = exports2.VariableDeclaratorsContext = exports2.InterfaceMethodDeclarationContext = exports2.PropertyDeclarationContext = exports2.FieldDeclarationContext = exports2.ConstructorDeclarationContext = exports2.MethodDeclarationContext = exports2.TriggerMemberDeclarationContext = exports2.MemberDeclarationContext = exports2.ModifierContext = exports2.ClassBodyDeclarationContext = exports2.InterfaceBodyContext = exports2.ClassBodyContext = exports2.TypeListContext = exports2.InterfaceDeclarationContext = exports2.EnumConstantsContext = exports2.EnumDeclarationContext = exports2.ClassDeclarationContext = exports2.TypeDeclarationContext = exports2.CompilationUnitContext = exports2.TriggerBlockMemberContext = exports2.TriggerBlockContext = exports2.TriggerCaseContext = exports2.TriggerUnitContext = exports2.ApexParser = void 0;
    exports2.CoalExpressionContext = exports2.LogOrExpressionContext = exports2.LogAndExpressionContext = exports2.BitOrExpressionContext = exports2.BitNotExpressionContext = exports2.BitAndExpressionContext = exports2.EqualityExpressionContext = exports2.InstanceOfExpressionContext = exports2.CmpExpressionContext = exports2.BitExpressionContext = exports2.Arth2ExpressionContext = exports2.Arth1ExpressionContext = exports2.NegExpressionContext = exports2.PreOpExpressionContext = exports2.PostOpExpressionContext = exports2.SubExpressionContext = exports2.CastExpressionContext = exports2.NewExpressionContext = exports2.MethodCallExpressionContext = exports2.ArrayExpressionContext = exports2.DotExpressionContext = exports2.PrimaryExpressionContext = exports2.ExpressionContext = exports2.ExpressionListContext = exports2.ParExpressionContext = exports2.ForUpdateContext = exports2.EnhancedForControlContext = exports2.ForInitContext = exports2.ForControlContext = exports2.FinallyBlockContext = exports2.CatchClauseContext = exports2.SetterContext = exports2.GetterContext = exports2.PropertyBlockContext = exports2.ExpressionStatementContext = exports2.RunAsStatementContext = exports2.MergeStatementContext = exports2.UpsertStatementContext = exports2.UndeleteStatementContext = exports2.DeleteStatementContext = exports2.UpdateStatementContext = exports2.InsertStatementContext = exports2.AccessLevelContext = exports2.ContinueStatementContext = exports2.BreakStatementContext = exports2.ThrowStatementContext = exports2.ReturnStatementContext = exports2.TryStatementContext = exports2.DoWhileStatementContext = exports2.WhileStatementContext = void 0;
    exports2.SignedNumberContext = exports2.ValueListContext = exports2.ValueContext = exports2.ComparisonOperatorContext = exports2.FieldExpressionContext = exports2.ConditionalExpressionContext = exports2.LogicalExpressionContext = exports2.WhereClauseContext = exports2.UsingScopeContext = exports2.FieldNameListContext = exports2.ElseClauseContext = exports2.WhenClauseContext = exports2.TypeOfContext = exports2.CoordinateValueContext = exports2.LocationValueContext = exports2.DateFieldNameContext = exports2.SoqlFunctionContext = exports2.SoqlFieldsParameterContext = exports2.SubFieldEntryContext = exports2.SubFieldListContext = exports2.FromNameListContext = exports2.FieldNameContext = exports2.SelectEntryContext = exports2.SelectListContext = exports2.SubQueryContext = exports2.QueryContext = exports2.SoqlLiteralContext = exports2.ArgumentsContext = exports2.SetCreatorRestContext = exports2.MapCreatorRestPairContext = exports2.MapCreatorRestContext = exports2.ArrayCreatorRestContext = exports2.ClassCreatorRestContext = exports2.NoRestContext = exports2.IdCreatedNamePairContext = exports2.CreatedNameContext = exports2.CreatorContext = exports2.DotMethodCallContext = exports2.MethodCallContext = exports2.SoslPrimaryContext = exports2.SoqlPrimaryContext = exports2.IdPrimaryContext = exports2.VoidPrimaryContext = exports2.TypeRefPrimaryContext = exports2.LiteralPrimaryContext = exports2.SuperPrimaryContext = exports2.ThisPrimaryContext = exports2.PrimaryContext = exports2.AssignExpressionContext = exports2.CondExpressionContext = void 0;
    exports2.AnyIdContext = exports2.IdContext = exports2.SoslIdContext = exports2.NetworkListContext = exports2.UpdateTypeContext = exports2.UpdateListContext = exports2.FieldListContext = exports2.FieldSpecContext = exports2.FieldSpecListContext = exports2.SearchGroupContext = exports2.SoslWithClauseContext = exports2.SoslClausesContext = exports2.SoslLiteralAltContext = exports2.SoslLiteralContext = exports2.SoqlIdContext = exports2.SignedIntegerContext = exports2.DateFormulaContext = exports2.BoundExpressionContext = exports2.ForClausesContext = exports2.AllRowsClauseContext = exports2.OffsetClauseContext = exports2.LimitClauseContext = exports2.FieldOrderContext = exports2.FieldOrderListContext = exports2.OrderByClauseContext = exports2.GroupByClauseContext = exports2.FilteringSelectorContext = exports2.DataCategoryNameContext = exports2.DataCategorySelectionContext = exports2.FilteringExpressionContext = exports2.WithClauseContext = void 0;
    var ATN_1 = require_ATN();
    var ATNDeserializer_1 = require_ATNDeserializer();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var NoViableAltException_1 = require_NoViableAltException();
    var Parser_1 = require_Parser();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var RecognitionException_1 = require_RecognitionException();
    var Token_1 = require_Token();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var Utils = require_Utils();
    var ApexParser2 = class _ApexParser extends Parser_1.Parser {
      constructor(input) {
        super(input);
        this._interp = new ParserATNSimulator_1.ParserATNSimulator(_ApexParser._ATN, this);
      }
      // @Override
      // @NotNull
      get vocabulary() {
        return _ApexParser.VOCABULARY;
      }
      // tslint:enable:no-trailing-whitespace
      // @Override
      get grammarFileName() {
        return "ApexParser.g4";
      }
      // @Override
      get ruleNames() {
        return _ApexParser.ruleNames;
      }
      // @Override
      get serializedATN() {
        return _ApexParser._serializedATN;
      }
      createFailedPredicateException(predicate, message) {
        return new FailedPredicateException_1.FailedPredicateException(this, predicate, message);
      }
      // @RuleVersion(0)
      triggerUnit() {
        let _localctx = new TriggerUnitContext(this._ctx, this.state);
        this.enterRule(_localctx, 0, _ApexParser.RULE_triggerUnit);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 296;
            this.match(_ApexParser.TRIGGER);
            this.state = 297;
            this.id();
            this.state = 298;
            this.match(_ApexParser.ON);
            this.state = 299;
            this.id();
            this.state = 300;
            this.match(_ApexParser.LPAREN);
            this.state = 301;
            this.triggerCase();
            this.state = 306;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 302;
                  this.match(_ApexParser.COMMA);
                  this.state = 303;
                  this.triggerCase();
                }
              }
              this.state = 308;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 309;
            this.match(_ApexParser.RPAREN);
            this.state = 310;
            this.triggerBlock();
            this.state = 311;
            this.match(_ApexParser.EOF);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      triggerCase() {
        let _localctx = new TriggerCaseContext(this._ctx, this.state);
        this.enterRule(_localctx, 2, _ApexParser.RULE_triggerCase);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 313;
            _la = this._input.LA(1);
            if (!(_la === _ApexParser.AFTER || _la === _ApexParser.BEFORE)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 314;
            _la = this._input.LA(1);
            if (!(_la === _ApexParser.DELETE || _la === _ApexParser.INSERT || _la === _ApexParser.UNDELETE || _la === _ApexParser.UPDATE)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      triggerBlock() {
        let _localctx = new TriggerBlockContext(this._ctx, this.state);
        this.enterRule(_localctx, 4, _ApexParser.RULE_triggerBlock);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 316;
            this.match(_ApexParser.LBRACE);
            this.state = 320;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.BREAK | 1 << _ApexParser.CLASS | 1 << _ApexParser.CONTINUE | 1 << _ApexParser.DELETE | 1 << _ApexParser.DO | 1 << _ApexParser.ENUM | 1 << _ApexParser.FINAL | 1 << _ApexParser.FOR | 1 << _ApexParser.GET | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.IF | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSERT | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.INTERFACE | 1 << _ApexParser.MERGE | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 32 & ~31) === 0 && (1 << _la - 32 & (1 << _ApexParser.RETURN - 32 | 1 << _ApexParser.SYSTEMRUNAS - 32 | 1 << _ApexParser.SET - 32 | 1 << _ApexParser.SHARING - 32 | 1 << _ApexParser.STATIC - 32 | 1 << _ApexParser.SUPER - 32 | 1 << _ApexParser.SWITCH - 32 | 1 << _ApexParser.TESTMETHOD - 32 | 1 << _ApexParser.THIS - 32 | 1 << _ApexParser.THROW - 32 | 1 << _ApexParser.TRANSIENT - 32 | 1 << _ApexParser.TRIGGER - 32 | 1 << _ApexParser.TRY - 32 | 1 << _ApexParser.UNDELETE - 32 | 1 << _ApexParser.UPDATE - 32 | 1 << _ApexParser.UPSERT - 32 | 1 << _ApexParser.VIRTUAL - 32 | 1 << _ApexParser.VOID - 32 | 1 << _ApexParser.WEBSERVICE - 32 | 1 << _ApexParser.WHEN - 32 | 1 << _ApexParser.WHILE - 32 | 1 << _ApexParser.WITH - 32 | 1 << _ApexParser.WITHOUT - 32 | 1 << _ApexParser.LIST - 32 | 1 << _ApexParser.MAP - 32 | 1 << _ApexParser.SYSTEM - 32 | 1 << _ApexParser.USER - 32 | 1 << _ApexParser.SELECT - 32 | 1 << _ApexParser.COUNT - 32 | 1 << _ApexParser.FROM - 32 | 1 << _ApexParser.AS - 32 | 1 << _ApexParser.USING - 32)) !== 0 || (_la - 64 & ~31) === 0 && (1 << _la - 64 & (1 << _ApexParser.SCOPE - 64 | 1 << _ApexParser.WHERE - 64 | 1 << _ApexParser.ORDER - 64 | 1 << _ApexParser.BY - 64 | 1 << _ApexParser.LIMIT - 64 | 1 << _ApexParser.SOQLAND - 64 | 1 << _ApexParser.SOQLOR - 64 | 1 << _ApexParser.NOT - 64 | 1 << _ApexParser.AVG - 64 | 1 << _ApexParser.COUNT_DISTINCT - 64 | 1 << _ApexParser.MIN - 64 | 1 << _ApexParser.MAX - 64 | 1 << _ApexParser.SUM - 64 | 1 << _ApexParser.TYPEOF - 64 | 1 << _ApexParser.END - 64 | 1 << _ApexParser.THEN - 64 | 1 << _ApexParser.LIKE - 64 | 1 << _ApexParser.IN - 64 | 1 << _ApexParser.INCLUDES - 64 | 1 << _ApexParser.EXCLUDES - 64 | 1 << _ApexParser.ASC - 64 | 1 << _ApexParser.DESC - 64 | 1 << _ApexParser.NULLS - 64 | 1 << _ApexParser.FIRST - 64 | 1 << _ApexParser.LAST - 64 | 1 << _ApexParser.GROUP - 64 | 1 << _ApexParser.ALL - 64 | 1 << _ApexParser.ROWS - 64 | 1 << _ApexParser.VIEW - 64 | 1 << _ApexParser.HAVING - 64 | 1 << _ApexParser.ROLLUP - 64 | 1 << _ApexParser.TOLABEL - 64)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _ApexParser.OFFSET - 96 | 1 << _ApexParser.DATA - 96 | 1 << _ApexParser.CATEGORY - 96 | 1 << _ApexParser.AT - 96 | 1 << _ApexParser.ABOVE - 96 | 1 << _ApexParser.BELOW - 96 | 1 << _ApexParser.ABOVE_OR_BELOW - 96 | 1 << _ApexParser.SECURITY_ENFORCED - 96 | 1 << _ApexParser.SYSTEM_MODE - 96 | 1 << _ApexParser.USER_MODE - 96 | 1 << _ApexParser.REFERENCE - 96 | 1 << _ApexParser.CUBE - 96 | 1 << _ApexParser.FORMAT - 96 | 1 << _ApexParser.TRACKING - 96 | 1 << _ApexParser.VIEWSTAT - 96 | 1 << _ApexParser.CUSTOM - 96 | 1 << _ApexParser.STANDARD - 96 | 1 << _ApexParser.DISTANCE - 96 | 1 << _ApexParser.GEOLOCATION - 96 | 1 << _ApexParser.GROUPING - 96 | 1 << _ApexParser.CONVERT_CURRENCY - 96 | 1 << _ApexParser.CALENDAR_MONTH - 96 | 1 << _ApexParser.CALENDAR_QUARTER - 96 | 1 << _ApexParser.CALENDAR_YEAR - 96 | 1 << _ApexParser.DAY_IN_MONTH - 96 | 1 << _ApexParser.DAY_IN_WEEK - 96 | 1 << _ApexParser.DAY_IN_YEAR - 96 | 1 << _ApexParser.DAY_ONLY - 96 | 1 << _ApexParser.FISCAL_MONTH - 96 | 1 << _ApexParser.FISCAL_QUARTER - 96 | 1 << _ApexParser.FISCAL_YEAR - 96 | 1 << _ApexParser.HOUR_IN_DAY - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _ApexParser.WEEK_IN_MONTH - 128 | 1 << _ApexParser.WEEK_IN_YEAR - 128 | 1 << _ApexParser.CONVERT_TIMEZONE - 128 | 1 << _ApexParser.YESTERDAY - 128 | 1 << _ApexParser.TODAY - 128 | 1 << _ApexParser.TOMORROW - 128 | 1 << _ApexParser.LAST_WEEK - 128 | 1 << _ApexParser.THIS_WEEK - 128 | 1 << _ApexParser.NEXT_WEEK - 128 | 1 << _ApexParser.LAST_MONTH - 128 | 1 << _ApexParser.THIS_MONTH - 128 | 1 << _ApexParser.NEXT_MONTH - 128 | 1 << _ApexParser.LAST_90_DAYS - 128 | 1 << _ApexParser.NEXT_90_DAYS - 128 | 1 << _ApexParser.LAST_N_DAYS_N - 128 | 1 << _ApexParser.NEXT_N_DAYS_N - 128 | 1 << _ApexParser.N_DAYS_AGO_N - 128 | 1 << _ApexParser.NEXT_N_WEEKS_N - 128 | 1 << _ApexParser.LAST_N_WEEKS_N - 128 | 1 << _ApexParser.N_WEEKS_AGO_N - 128 | 1 << _ApexParser.NEXT_N_MONTHS_N - 128 | 1 << _ApexParser.LAST_N_MONTHS_N - 128 | 1 << _ApexParser.N_MONTHS_AGO_N - 128 | 1 << _ApexParser.THIS_QUARTER - 128 | 1 << _ApexParser.LAST_QUARTER - 128 | 1 << _ApexParser.NEXT_QUARTER - 128 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 128 | 1 << _ApexParser.LAST_N_QUARTERS_N - 128 | 1 << _ApexParser.N_QUARTERS_AGO_N - 128 | 1 << _ApexParser.THIS_YEAR - 128 | 1 << _ApexParser.LAST_YEAR - 128 | 1 << _ApexParser.NEXT_YEAR - 128)) !== 0 || (_la - 160 & ~31) === 0 && (1 << _la - 160 & (1 << _ApexParser.NEXT_N_YEARS_N - 160 | 1 << _ApexParser.LAST_N_YEARS_N - 160 | 1 << _ApexParser.N_YEARS_AGO_N - 160 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 160 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 160 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 160 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 160 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 160 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 160 | 1 << _ApexParser.THIS_FISCAL_YEAR - 160 | 1 << _ApexParser.LAST_FISCAL_YEAR - 160 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 160 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 160 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 160 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 160 | 1 << _ApexParser.IntegralCurrencyLiteral - 160 | 1 << _ApexParser.FIND - 160 | 1 << _ApexParser.EMAIL - 160 | 1 << _ApexParser.NAME - 160 | 1 << _ApexParser.PHONE - 160 | 1 << _ApexParser.SIDEBAR - 160 | 1 << _ApexParser.FIELDS - 160 | 1 << _ApexParser.METADATA - 160 | 1 << _ApexParser.PRICEBOOKID - 160 | 1 << _ApexParser.NETWORK - 160 | 1 << _ApexParser.SNIPPET - 160 | 1 << _ApexParser.TARGET_LENGTH - 160 | 1 << _ApexParser.DIVISION - 160 | 1 << _ApexParser.RETURNING - 160)) !== 0 || (_la - 192 & ~31) === 0 && (1 << _la - 192 & (1 << _ApexParser.LISTVIEW - 192 | 1 << _ApexParser.FindLiteral - 192 | 1 << _ApexParser.IntegerLiteral - 192 | 1 << _ApexParser.LongLiteral - 192 | 1 << _ApexParser.NumberLiteral - 192 | 1 << _ApexParser.BooleanLiteral - 192 | 1 << _ApexParser.StringLiteral - 192 | 1 << _ApexParser.LPAREN - 192 | 1 << _ApexParser.LBRACE - 192 | 1 << _ApexParser.LBRACK - 192 | 1 << _ApexParser.BANG - 192 | 1 << _ApexParser.TILDE - 192)) !== 0 || (_la - 226 & ~31) === 0 && (1 << _la - 226 & (1 << _ApexParser.INC - 226 | 1 << _ApexParser.DEC - 226 | 1 << _ApexParser.ADD - 226 | 1 << _ApexParser.SUB - 226 | 1 << _ApexParser.ATSIGN - 226 | 1 << _ApexParser.Identifier - 226)) !== 0) {
              {
                {
                  this.state = 317;
                  this.triggerBlockMember();
                }
              }
              this.state = 322;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 323;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      triggerBlockMember() {
        let _localctx = new TriggerBlockMemberContext(this._ctx, this.state);
        this.enterRule(_localctx, 6, _ApexParser.RULE_triggerBlockMember);
        try {
          let _alt;
          this.state = 333;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 3, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 328;
                this._errHandler.sync(this);
                _alt = this.interpreter.adaptivePredict(this._input, 2, this._ctx);
                while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                  if (_alt === 1) {
                    {
                      {
                        this.state = 325;
                        this.modifier();
                      }
                    }
                  }
                  this.state = 330;
                  this._errHandler.sync(this);
                  _alt = this.interpreter.adaptivePredict(this._input, 2, this._ctx);
                }
                this.state = 331;
                this.triggerMemberDeclaration();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 332;
                this.statement();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      compilationUnit() {
        let _localctx = new CompilationUnitContext(this._ctx, this.state);
        this.enterRule(_localctx, 8, _ApexParser.RULE_compilationUnit);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 335;
            this.typeDeclaration();
            this.state = 336;
            this.match(_ApexParser.EOF);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      typeDeclaration() {
        let _localctx = new TypeDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 10, _ApexParser.RULE_typeDeclaration);
        let _la;
        try {
          this.state = 359;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 7, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 341;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.FINAL | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _ApexParser.STATIC - 36 | 1 << _ApexParser.TESTMETHOD - 36 | 1 << _ApexParser.TRANSIENT - 36 | 1 << _ApexParser.VIRTUAL - 36 | 1 << _ApexParser.WEBSERVICE - 36 | 1 << _ApexParser.WITH - 36 | 1 << _ApexParser.WITHOUT - 36)) !== 0 || _la === _ApexParser.ATSIGN) {
                  {
                    {
                      this.state = 338;
                      this.modifier();
                    }
                  }
                  this.state = 343;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 344;
                this.classDeclaration();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 348;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.FINAL | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _ApexParser.STATIC - 36 | 1 << _ApexParser.TESTMETHOD - 36 | 1 << _ApexParser.TRANSIENT - 36 | 1 << _ApexParser.VIRTUAL - 36 | 1 << _ApexParser.WEBSERVICE - 36 | 1 << _ApexParser.WITH - 36 | 1 << _ApexParser.WITHOUT - 36)) !== 0 || _la === _ApexParser.ATSIGN) {
                  {
                    {
                      this.state = 345;
                      this.modifier();
                    }
                  }
                  this.state = 350;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 351;
                this.enumDeclaration();
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 355;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.FINAL | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _ApexParser.STATIC - 36 | 1 << _ApexParser.TESTMETHOD - 36 | 1 << _ApexParser.TRANSIENT - 36 | 1 << _ApexParser.VIRTUAL - 36 | 1 << _ApexParser.WEBSERVICE - 36 | 1 << _ApexParser.WITH - 36 | 1 << _ApexParser.WITHOUT - 36)) !== 0 || _la === _ApexParser.ATSIGN) {
                  {
                    {
                      this.state = 352;
                      this.modifier();
                    }
                  }
                  this.state = 357;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 358;
                this.interfaceDeclaration();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      classDeclaration() {
        let _localctx = new ClassDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 12, _ApexParser.RULE_classDeclaration);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 361;
            this.match(_ApexParser.CLASS);
            this.state = 362;
            this.id();
            this.state = 365;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.EXTENDS) {
              {
                this.state = 363;
                this.match(_ApexParser.EXTENDS);
                this.state = 364;
                this.typeRef();
              }
            }
            this.state = 369;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.IMPLEMENTS) {
              {
                this.state = 367;
                this.match(_ApexParser.IMPLEMENTS);
                this.state = 368;
                this.typeList();
              }
            }
            this.state = 371;
            this.classBody();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      enumDeclaration() {
        let _localctx = new EnumDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 14, _ApexParser.RULE_enumDeclaration);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 373;
            this.match(_ApexParser.ENUM);
            this.state = 374;
            this.id();
            this.state = 375;
            this.match(_ApexParser.LBRACE);
            this.state = 377;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.Identifier) {
              {
                this.state = 376;
                this.enumConstants();
              }
            }
            this.state = 379;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      enumConstants() {
        let _localctx = new EnumConstantsContext(this._ctx, this.state);
        this.enterRule(_localctx, 16, _ApexParser.RULE_enumConstants);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 381;
            this.id();
            this.state = 386;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 382;
                  this.match(_ApexParser.COMMA);
                  this.state = 383;
                  this.id();
                }
              }
              this.state = 388;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      interfaceDeclaration() {
        let _localctx = new InterfaceDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 18, _ApexParser.RULE_interfaceDeclaration);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 389;
            this.match(_ApexParser.INTERFACE);
            this.state = 390;
            this.id();
            this.state = 393;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.EXTENDS) {
              {
                this.state = 391;
                this.match(_ApexParser.EXTENDS);
                this.state = 392;
                this.typeList();
              }
            }
            this.state = 395;
            this.interfaceBody();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      typeList() {
        let _localctx = new TypeListContext(this._ctx, this.state);
        this.enterRule(_localctx, 20, _ApexParser.RULE_typeList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 397;
            this.typeRef();
            this.state = 402;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 398;
                  this.match(_ApexParser.COMMA);
                  this.state = 399;
                  this.typeRef();
                }
              }
              this.state = 404;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      classBody() {
        let _localctx = new ClassBodyContext(this._ctx, this.state);
        this.enterRule(_localctx, 22, _ApexParser.RULE_classBody);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 405;
            this.match(_ApexParser.LBRACE);
            this.state = 409;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.CLASS | 1 << _ApexParser.ENUM | 1 << _ApexParser.FINAL | 1 << _ApexParser.GET | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.INTERFACE | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.STATIC - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TESTMETHOD - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VIRTUAL - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WEBSERVICE - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.LBRACE || _la === _ApexParser.SEMI || _la === _ApexParser.ATSIGN || _la === _ApexParser.Identifier) {
              {
                {
                  this.state = 406;
                  this.classBodyDeclaration();
                }
              }
              this.state = 411;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 412;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      interfaceBody() {
        let _localctx = new InterfaceBodyContext(this._ctx, this.state);
        this.enterRule(_localctx, 24, _ApexParser.RULE_interfaceBody);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 414;
            this.match(_ApexParser.LBRACE);
            this.state = 418;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.FINAL | 1 << _ApexParser.GET | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.STATIC - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TESTMETHOD - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VIRTUAL - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WEBSERVICE - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.ATSIGN || _la === _ApexParser.Identifier) {
              {
                {
                  this.state = 415;
                  this.interfaceMethodDeclaration();
                }
              }
              this.state = 420;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 421;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      classBodyDeclaration() {
        let _localctx = new ClassBodyDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 26, _ApexParser.RULE_classBodyDeclaration);
        let _la;
        try {
          let _alt;
          this.state = 435;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 18, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 423;
                this.match(_ApexParser.SEMI);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 425;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.STATIC) {
                  {
                    this.state = 424;
                    this.match(_ApexParser.STATIC);
                  }
                }
                this.state = 427;
                this.block();
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 431;
                this._errHandler.sync(this);
                _alt = this.interpreter.adaptivePredict(this._input, 17, this._ctx);
                while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                  if (_alt === 1) {
                    {
                      {
                        this.state = 428;
                        this.modifier();
                      }
                    }
                  }
                  this.state = 433;
                  this._errHandler.sync(this);
                  _alt = this.interpreter.adaptivePredict(this._input, 17, this._ctx);
                }
                this.state = 434;
                this.memberDeclaration();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      modifier() {
        let _localctx = new ModifierContext(this._ctx, this.state);
        this.enterRule(_localctx, 28, _ApexParser.RULE_modifier);
        try {
          this.state = 456;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.ATSIGN:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 437;
                this.annotation();
              }
              break;
            case _ApexParser.GLOBAL:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 438;
                this.match(_ApexParser.GLOBAL);
              }
              break;
            case _ApexParser.PUBLIC:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 439;
                this.match(_ApexParser.PUBLIC);
              }
              break;
            case _ApexParser.PROTECTED:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 440;
                this.match(_ApexParser.PROTECTED);
              }
              break;
            case _ApexParser.PRIVATE:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 441;
                this.match(_ApexParser.PRIVATE);
              }
              break;
            case _ApexParser.TRANSIENT:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 442;
                this.match(_ApexParser.TRANSIENT);
              }
              break;
            case _ApexParser.STATIC:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 443;
                this.match(_ApexParser.STATIC);
              }
              break;
            case _ApexParser.ABSTRACT:
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 444;
                this.match(_ApexParser.ABSTRACT);
              }
              break;
            case _ApexParser.FINAL:
              this.enterOuterAlt(_localctx, 9);
              {
                this.state = 445;
                this.match(_ApexParser.FINAL);
              }
              break;
            case _ApexParser.WEBSERVICE:
              this.enterOuterAlt(_localctx, 10);
              {
                this.state = 446;
                this.match(_ApexParser.WEBSERVICE);
              }
              break;
            case _ApexParser.OVERRIDE:
              this.enterOuterAlt(_localctx, 11);
              {
                this.state = 447;
                this.match(_ApexParser.OVERRIDE);
              }
              break;
            case _ApexParser.VIRTUAL:
              this.enterOuterAlt(_localctx, 12);
              {
                this.state = 448;
                this.match(_ApexParser.VIRTUAL);
              }
              break;
            case _ApexParser.TESTMETHOD:
              this.enterOuterAlt(_localctx, 13);
              {
                this.state = 449;
                this.match(_ApexParser.TESTMETHOD);
              }
              break;
            case _ApexParser.WITH:
              this.enterOuterAlt(_localctx, 14);
              {
                this.state = 450;
                this.match(_ApexParser.WITH);
                this.state = 451;
                this.match(_ApexParser.SHARING);
              }
              break;
            case _ApexParser.WITHOUT:
              this.enterOuterAlt(_localctx, 15);
              {
                this.state = 452;
                this.match(_ApexParser.WITHOUT);
                this.state = 453;
                this.match(_ApexParser.SHARING);
              }
              break;
            case _ApexParser.INHERITED:
              this.enterOuterAlt(_localctx, 16);
              {
                this.state = 454;
                this.match(_ApexParser.INHERITED);
                this.state = 455;
                this.match(_ApexParser.SHARING);
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      memberDeclaration() {
        let _localctx = new MemberDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 30, _ApexParser.RULE_memberDeclaration);
        try {
          this.state = 465;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 20, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 458;
                this.methodDeclaration();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 459;
                this.constructorDeclaration();
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 460;
                this.interfaceDeclaration();
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 461;
                this.classDeclaration();
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 462;
                this.enumDeclaration();
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 463;
                this.propertyDeclaration();
              }
              break;
            case 7:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 464;
                this.fieldDeclaration();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      triggerMemberDeclaration() {
        let _localctx = new TriggerMemberDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 32, _ApexParser.RULE_triggerMemberDeclaration);
        try {
          this.state = 473;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 21, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 467;
                this.methodDeclaration();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 468;
                this.interfaceDeclaration();
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 469;
                this.classDeclaration();
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 470;
                this.enumDeclaration();
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 471;
                this.propertyDeclaration();
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 472;
                this.fieldDeclaration();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      methodDeclaration() {
        let _localctx = new MethodDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 34, _ApexParser.RULE_methodDeclaration);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 477;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.AFTER:
              case _ApexParser.BEFORE:
              case _ApexParser.GET:
              case _ApexParser.INHERITED:
              case _ApexParser.INSTANCEOF:
              case _ApexParser.SET:
              case _ApexParser.SHARING:
              case _ApexParser.SWITCH:
              case _ApexParser.TRANSIENT:
              case _ApexParser.TRIGGER:
              case _ApexParser.WHEN:
              case _ApexParser.WITH:
              case _ApexParser.WITHOUT:
              case _ApexParser.LIST:
              case _ApexParser.MAP:
              case _ApexParser.SYSTEM:
              case _ApexParser.USER:
              case _ApexParser.SELECT:
              case _ApexParser.COUNT:
              case _ApexParser.FROM:
              case _ApexParser.AS:
              case _ApexParser.USING:
              case _ApexParser.SCOPE:
              case _ApexParser.WHERE:
              case _ApexParser.ORDER:
              case _ApexParser.BY:
              case _ApexParser.LIMIT:
              case _ApexParser.SOQLAND:
              case _ApexParser.SOQLOR:
              case _ApexParser.NOT:
              case _ApexParser.AVG:
              case _ApexParser.COUNT_DISTINCT:
              case _ApexParser.MIN:
              case _ApexParser.MAX:
              case _ApexParser.SUM:
              case _ApexParser.TYPEOF:
              case _ApexParser.END:
              case _ApexParser.THEN:
              case _ApexParser.LIKE:
              case _ApexParser.IN:
              case _ApexParser.INCLUDES:
              case _ApexParser.EXCLUDES:
              case _ApexParser.ASC:
              case _ApexParser.DESC:
              case _ApexParser.NULLS:
              case _ApexParser.FIRST:
              case _ApexParser.LAST:
              case _ApexParser.GROUP:
              case _ApexParser.ALL:
              case _ApexParser.ROWS:
              case _ApexParser.VIEW:
              case _ApexParser.HAVING:
              case _ApexParser.ROLLUP:
              case _ApexParser.TOLABEL:
              case _ApexParser.OFFSET:
              case _ApexParser.DATA:
              case _ApexParser.CATEGORY:
              case _ApexParser.AT:
              case _ApexParser.ABOVE:
              case _ApexParser.BELOW:
              case _ApexParser.ABOVE_OR_BELOW:
              case _ApexParser.SECURITY_ENFORCED:
              case _ApexParser.SYSTEM_MODE:
              case _ApexParser.USER_MODE:
              case _ApexParser.REFERENCE:
              case _ApexParser.CUBE:
              case _ApexParser.FORMAT:
              case _ApexParser.TRACKING:
              case _ApexParser.VIEWSTAT:
              case _ApexParser.CUSTOM:
              case _ApexParser.STANDARD:
              case _ApexParser.DISTANCE:
              case _ApexParser.GEOLOCATION:
              case _ApexParser.GROUPING:
              case _ApexParser.CONVERT_CURRENCY:
              case _ApexParser.CALENDAR_MONTH:
              case _ApexParser.CALENDAR_QUARTER:
              case _ApexParser.CALENDAR_YEAR:
              case _ApexParser.DAY_IN_MONTH:
              case _ApexParser.DAY_IN_WEEK:
              case _ApexParser.DAY_IN_YEAR:
              case _ApexParser.DAY_ONLY:
              case _ApexParser.FISCAL_MONTH:
              case _ApexParser.FISCAL_QUARTER:
              case _ApexParser.FISCAL_YEAR:
              case _ApexParser.HOUR_IN_DAY:
              case _ApexParser.WEEK_IN_MONTH:
              case _ApexParser.WEEK_IN_YEAR:
              case _ApexParser.CONVERT_TIMEZONE:
              case _ApexParser.YESTERDAY:
              case _ApexParser.TODAY:
              case _ApexParser.TOMORROW:
              case _ApexParser.LAST_WEEK:
              case _ApexParser.THIS_WEEK:
              case _ApexParser.NEXT_WEEK:
              case _ApexParser.LAST_MONTH:
              case _ApexParser.THIS_MONTH:
              case _ApexParser.NEXT_MONTH:
              case _ApexParser.LAST_90_DAYS:
              case _ApexParser.NEXT_90_DAYS:
              case _ApexParser.LAST_N_DAYS_N:
              case _ApexParser.NEXT_N_DAYS_N:
              case _ApexParser.N_DAYS_AGO_N:
              case _ApexParser.NEXT_N_WEEKS_N:
              case _ApexParser.LAST_N_WEEKS_N:
              case _ApexParser.N_WEEKS_AGO_N:
              case _ApexParser.NEXT_N_MONTHS_N:
              case _ApexParser.LAST_N_MONTHS_N:
              case _ApexParser.N_MONTHS_AGO_N:
              case _ApexParser.THIS_QUARTER:
              case _ApexParser.LAST_QUARTER:
              case _ApexParser.NEXT_QUARTER:
              case _ApexParser.NEXT_N_QUARTERS_N:
              case _ApexParser.LAST_N_QUARTERS_N:
              case _ApexParser.N_QUARTERS_AGO_N:
              case _ApexParser.THIS_YEAR:
              case _ApexParser.LAST_YEAR:
              case _ApexParser.NEXT_YEAR:
              case _ApexParser.NEXT_N_YEARS_N:
              case _ApexParser.LAST_N_YEARS_N:
              case _ApexParser.N_YEARS_AGO_N:
              case _ApexParser.THIS_FISCAL_QUARTER:
              case _ApexParser.LAST_FISCAL_QUARTER:
              case _ApexParser.NEXT_FISCAL_QUARTER:
              case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
              case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
              case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
              case _ApexParser.THIS_FISCAL_YEAR:
              case _ApexParser.LAST_FISCAL_YEAR:
              case _ApexParser.NEXT_FISCAL_YEAR:
              case _ApexParser.NEXT_N_FISCAL_YEARS_N:
              case _ApexParser.LAST_N_FISCAL_YEARS_N:
              case _ApexParser.N_FISCAL_YEARS_AGO_N:
              case _ApexParser.IntegralCurrencyLiteral:
              case _ApexParser.FIND:
              case _ApexParser.EMAIL:
              case _ApexParser.NAME:
              case _ApexParser.PHONE:
              case _ApexParser.SIDEBAR:
              case _ApexParser.FIELDS:
              case _ApexParser.METADATA:
              case _ApexParser.PRICEBOOKID:
              case _ApexParser.NETWORK:
              case _ApexParser.SNIPPET:
              case _ApexParser.TARGET_LENGTH:
              case _ApexParser.DIVISION:
              case _ApexParser.RETURNING:
              case _ApexParser.LISTVIEW:
              case _ApexParser.Identifier:
                {
                  this.state = 475;
                  this.typeRef();
                }
                break;
              case _ApexParser.VOID:
                {
                  this.state = 476;
                  this.match(_ApexParser.VOID);
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
            this.state = 479;
            this.id();
            this.state = 480;
            this.formalParameters();
            this.state = 483;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.LBRACE:
                {
                  this.state = 481;
                  this.block();
                }
                break;
              case _ApexParser.SEMI:
                {
                  this.state = 482;
                  this.match(_ApexParser.SEMI);
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      constructorDeclaration() {
        let _localctx = new ConstructorDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 36, _ApexParser.RULE_constructorDeclaration);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 485;
            this.qualifiedName();
            this.state = 486;
            this.formalParameters();
            this.state = 487;
            this.block();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldDeclaration() {
        let _localctx = new FieldDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 38, _ApexParser.RULE_fieldDeclaration);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 489;
            this.typeRef();
            this.state = 490;
            this.variableDeclarators();
            this.state = 491;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      propertyDeclaration() {
        let _localctx = new PropertyDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 40, _ApexParser.RULE_propertyDeclaration);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 493;
            this.typeRef();
            this.state = 494;
            this.id();
            this.state = 495;
            this.match(_ApexParser.LBRACE);
            this.state = 499;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.FINAL | 1 << _ApexParser.GET | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.STATIC - 34 | 1 << _ApexParser.TESTMETHOD - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.VIRTUAL - 34 | 1 << _ApexParser.WEBSERVICE - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34)) !== 0 || _la === _ApexParser.ATSIGN) {
              {
                {
                  this.state = 496;
                  this.propertyBlock();
                }
              }
              this.state = 501;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 502;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      interfaceMethodDeclaration() {
        let _localctx = new InterfaceMethodDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 42, _ApexParser.RULE_interfaceMethodDeclaration);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 507;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 25, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 504;
                    this.modifier();
                  }
                }
              }
              this.state = 509;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 25, this._ctx);
            }
            this.state = 512;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.AFTER:
              case _ApexParser.BEFORE:
              case _ApexParser.GET:
              case _ApexParser.INHERITED:
              case _ApexParser.INSTANCEOF:
              case _ApexParser.SET:
              case _ApexParser.SHARING:
              case _ApexParser.SWITCH:
              case _ApexParser.TRANSIENT:
              case _ApexParser.TRIGGER:
              case _ApexParser.WHEN:
              case _ApexParser.WITH:
              case _ApexParser.WITHOUT:
              case _ApexParser.LIST:
              case _ApexParser.MAP:
              case _ApexParser.SYSTEM:
              case _ApexParser.USER:
              case _ApexParser.SELECT:
              case _ApexParser.COUNT:
              case _ApexParser.FROM:
              case _ApexParser.AS:
              case _ApexParser.USING:
              case _ApexParser.SCOPE:
              case _ApexParser.WHERE:
              case _ApexParser.ORDER:
              case _ApexParser.BY:
              case _ApexParser.LIMIT:
              case _ApexParser.SOQLAND:
              case _ApexParser.SOQLOR:
              case _ApexParser.NOT:
              case _ApexParser.AVG:
              case _ApexParser.COUNT_DISTINCT:
              case _ApexParser.MIN:
              case _ApexParser.MAX:
              case _ApexParser.SUM:
              case _ApexParser.TYPEOF:
              case _ApexParser.END:
              case _ApexParser.THEN:
              case _ApexParser.LIKE:
              case _ApexParser.IN:
              case _ApexParser.INCLUDES:
              case _ApexParser.EXCLUDES:
              case _ApexParser.ASC:
              case _ApexParser.DESC:
              case _ApexParser.NULLS:
              case _ApexParser.FIRST:
              case _ApexParser.LAST:
              case _ApexParser.GROUP:
              case _ApexParser.ALL:
              case _ApexParser.ROWS:
              case _ApexParser.VIEW:
              case _ApexParser.HAVING:
              case _ApexParser.ROLLUP:
              case _ApexParser.TOLABEL:
              case _ApexParser.OFFSET:
              case _ApexParser.DATA:
              case _ApexParser.CATEGORY:
              case _ApexParser.AT:
              case _ApexParser.ABOVE:
              case _ApexParser.BELOW:
              case _ApexParser.ABOVE_OR_BELOW:
              case _ApexParser.SECURITY_ENFORCED:
              case _ApexParser.SYSTEM_MODE:
              case _ApexParser.USER_MODE:
              case _ApexParser.REFERENCE:
              case _ApexParser.CUBE:
              case _ApexParser.FORMAT:
              case _ApexParser.TRACKING:
              case _ApexParser.VIEWSTAT:
              case _ApexParser.CUSTOM:
              case _ApexParser.STANDARD:
              case _ApexParser.DISTANCE:
              case _ApexParser.GEOLOCATION:
              case _ApexParser.GROUPING:
              case _ApexParser.CONVERT_CURRENCY:
              case _ApexParser.CALENDAR_MONTH:
              case _ApexParser.CALENDAR_QUARTER:
              case _ApexParser.CALENDAR_YEAR:
              case _ApexParser.DAY_IN_MONTH:
              case _ApexParser.DAY_IN_WEEK:
              case _ApexParser.DAY_IN_YEAR:
              case _ApexParser.DAY_ONLY:
              case _ApexParser.FISCAL_MONTH:
              case _ApexParser.FISCAL_QUARTER:
              case _ApexParser.FISCAL_YEAR:
              case _ApexParser.HOUR_IN_DAY:
              case _ApexParser.WEEK_IN_MONTH:
              case _ApexParser.WEEK_IN_YEAR:
              case _ApexParser.CONVERT_TIMEZONE:
              case _ApexParser.YESTERDAY:
              case _ApexParser.TODAY:
              case _ApexParser.TOMORROW:
              case _ApexParser.LAST_WEEK:
              case _ApexParser.THIS_WEEK:
              case _ApexParser.NEXT_WEEK:
              case _ApexParser.LAST_MONTH:
              case _ApexParser.THIS_MONTH:
              case _ApexParser.NEXT_MONTH:
              case _ApexParser.LAST_90_DAYS:
              case _ApexParser.NEXT_90_DAYS:
              case _ApexParser.LAST_N_DAYS_N:
              case _ApexParser.NEXT_N_DAYS_N:
              case _ApexParser.N_DAYS_AGO_N:
              case _ApexParser.NEXT_N_WEEKS_N:
              case _ApexParser.LAST_N_WEEKS_N:
              case _ApexParser.N_WEEKS_AGO_N:
              case _ApexParser.NEXT_N_MONTHS_N:
              case _ApexParser.LAST_N_MONTHS_N:
              case _ApexParser.N_MONTHS_AGO_N:
              case _ApexParser.THIS_QUARTER:
              case _ApexParser.LAST_QUARTER:
              case _ApexParser.NEXT_QUARTER:
              case _ApexParser.NEXT_N_QUARTERS_N:
              case _ApexParser.LAST_N_QUARTERS_N:
              case _ApexParser.N_QUARTERS_AGO_N:
              case _ApexParser.THIS_YEAR:
              case _ApexParser.LAST_YEAR:
              case _ApexParser.NEXT_YEAR:
              case _ApexParser.NEXT_N_YEARS_N:
              case _ApexParser.LAST_N_YEARS_N:
              case _ApexParser.N_YEARS_AGO_N:
              case _ApexParser.THIS_FISCAL_QUARTER:
              case _ApexParser.LAST_FISCAL_QUARTER:
              case _ApexParser.NEXT_FISCAL_QUARTER:
              case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
              case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
              case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
              case _ApexParser.THIS_FISCAL_YEAR:
              case _ApexParser.LAST_FISCAL_YEAR:
              case _ApexParser.NEXT_FISCAL_YEAR:
              case _ApexParser.NEXT_N_FISCAL_YEARS_N:
              case _ApexParser.LAST_N_FISCAL_YEARS_N:
              case _ApexParser.N_FISCAL_YEARS_AGO_N:
              case _ApexParser.IntegralCurrencyLiteral:
              case _ApexParser.FIND:
              case _ApexParser.EMAIL:
              case _ApexParser.NAME:
              case _ApexParser.PHONE:
              case _ApexParser.SIDEBAR:
              case _ApexParser.FIELDS:
              case _ApexParser.METADATA:
              case _ApexParser.PRICEBOOKID:
              case _ApexParser.NETWORK:
              case _ApexParser.SNIPPET:
              case _ApexParser.TARGET_LENGTH:
              case _ApexParser.DIVISION:
              case _ApexParser.RETURNING:
              case _ApexParser.LISTVIEW:
              case _ApexParser.Identifier:
                {
                  this.state = 510;
                  this.typeRef();
                }
                break;
              case _ApexParser.VOID:
                {
                  this.state = 511;
                  this.match(_ApexParser.VOID);
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
            this.state = 514;
            this.id();
            this.state = 515;
            this.formalParameters();
            this.state = 516;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      variableDeclarators() {
        let _localctx = new VariableDeclaratorsContext(this._ctx, this.state);
        this.enterRule(_localctx, 44, _ApexParser.RULE_variableDeclarators);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 518;
            this.variableDeclarator();
            this.state = 523;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 519;
                  this.match(_ApexParser.COMMA);
                  this.state = 520;
                  this.variableDeclarator();
                }
              }
              this.state = 525;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      variableDeclarator() {
        let _localctx = new VariableDeclaratorContext(this._ctx, this.state);
        this.enterRule(_localctx, 46, _ApexParser.RULE_variableDeclarator);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 526;
            this.id();
            this.state = 529;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.ASSIGN) {
              {
                this.state = 527;
                this.match(_ApexParser.ASSIGN);
                this.state = 528;
                this.expression(0);
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      arrayInitializer() {
        let _localctx = new ArrayInitializerContext(this._ctx, this.state);
        this.enterRule(_localctx, 48, _ApexParser.RULE_arrayInitializer);
        let _la;
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 531;
            this.match(_ApexParser.LBRACE);
            this.state = 543;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
              {
                this.state = 532;
                this.expression(0);
                this.state = 537;
                this._errHandler.sync(this);
                _alt = this.interpreter.adaptivePredict(this._input, 29, this._ctx);
                while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                  if (_alt === 1) {
                    {
                      {
                        this.state = 533;
                        this.match(_ApexParser.COMMA);
                        this.state = 534;
                        this.expression(0);
                      }
                    }
                  }
                  this.state = 539;
                  this._errHandler.sync(this);
                  _alt = this.interpreter.adaptivePredict(this._input, 29, this._ctx);
                }
                this.state = 541;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.COMMA) {
                  {
                    this.state = 540;
                    this.match(_ApexParser.COMMA);
                  }
                }
              }
            }
            this.state = 545;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      typeRef() {
        let _localctx = new TypeRefContext(this._ctx, this.state);
        this.enterRule(_localctx, 50, _ApexParser.RULE_typeRef);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 547;
            this.typeName();
            this.state = 552;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 32, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 548;
                    this.match(_ApexParser.DOT);
                    this.state = 549;
                    this.typeName();
                  }
                }
              }
              this.state = 554;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 32, this._ctx);
            }
            this.state = 555;
            this.arraySubscripts();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      arraySubscripts() {
        let _localctx = new ArraySubscriptsContext(this._ctx, this.state);
        this.enterRule(_localctx, 52, _ApexParser.RULE_arraySubscripts);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 561;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 33, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 557;
                    this.match(_ApexParser.LBRACK);
                    this.state = 558;
                    this.match(_ApexParser.RBRACK);
                  }
                }
              }
              this.state = 563;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 33, this._ctx);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      typeName() {
        let _localctx = new TypeNameContext(this._ctx, this.state);
        this.enterRule(_localctx, 54, _ApexParser.RULE_typeName);
        try {
          this.state = 580;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 38, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 564;
                this.match(_ApexParser.LIST);
                this.state = 566;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 34, this._ctx)) {
                  case 1:
                    {
                      this.state = 565;
                      this.typeArguments();
                    }
                    break;
                }
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 568;
                this.match(_ApexParser.SET);
                this.state = 570;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 35, this._ctx)) {
                  case 1:
                    {
                      this.state = 569;
                      this.typeArguments();
                    }
                    break;
                }
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 572;
                this.match(_ApexParser.MAP);
                this.state = 574;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 36, this._ctx)) {
                  case 1:
                    {
                      this.state = 573;
                      this.typeArguments();
                    }
                    break;
                }
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 576;
                this.id();
                this.state = 578;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 37, this._ctx)) {
                  case 1:
                    {
                      this.state = 577;
                      this.typeArguments();
                    }
                    break;
                }
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      typeArguments() {
        let _localctx = new TypeArgumentsContext(this._ctx, this.state);
        this.enterRule(_localctx, 56, _ApexParser.RULE_typeArguments);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 582;
            this.match(_ApexParser.LT);
            this.state = 583;
            this.typeList();
            this.state = 584;
            this.match(_ApexParser.GT);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      formalParameters() {
        let _localctx = new FormalParametersContext(this._ctx, this.state);
        this.enterRule(_localctx, 58, _ApexParser.RULE_formalParameters);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 586;
            this.match(_ApexParser.LPAREN);
            this.state = 588;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.FINAL | 1 << _ApexParser.GET | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.STATIC - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TESTMETHOD - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VIRTUAL - 34 | 1 << _ApexParser.WEBSERVICE - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.ATSIGN || _la === _ApexParser.Identifier) {
              {
                this.state = 587;
                this.formalParameterList();
              }
            }
            this.state = 590;
            this.match(_ApexParser.RPAREN);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      formalParameterList() {
        let _localctx = new FormalParameterListContext(this._ctx, this.state);
        this.enterRule(_localctx, 60, _ApexParser.RULE_formalParameterList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 592;
            this.formalParameter();
            this.state = 597;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 593;
                  this.match(_ApexParser.COMMA);
                  this.state = 594;
                  this.formalParameter();
                }
              }
              this.state = 599;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      formalParameter() {
        let _localctx = new FormalParameterContext(this._ctx, this.state);
        this.enterRule(_localctx, 62, _ApexParser.RULE_formalParameter);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 603;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 41, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 600;
                    this.modifier();
                  }
                }
              }
              this.state = 605;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 41, this._ctx);
            }
            this.state = 606;
            this.typeRef();
            this.state = 607;
            this.id();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      qualifiedName() {
        let _localctx = new QualifiedNameContext(this._ctx, this.state);
        this.enterRule(_localctx, 64, _ApexParser.RULE_qualifiedName);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 609;
            this.id();
            this.state = 614;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.DOT) {
              {
                {
                  this.state = 610;
                  this.match(_ApexParser.DOT);
                  this.state = 611;
                  this.id();
                }
              }
              this.state = 616;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      literal() {
        let _localctx = new LiteralContext(this._ctx, this.state);
        this.enterRule(_localctx, 66, _ApexParser.RULE_literal);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 617;
            _la = this._input.LA(1);
            if (!(_la === _ApexParser.NULL || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195)) !== 0)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      annotation() {
        let _localctx = new AnnotationContext(this._ctx, this.state);
        this.enterRule(_localctx, 68, _ApexParser.RULE_annotation);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 619;
            this.match(_ApexParser.ATSIGN);
            this.state = 620;
            this.qualifiedName();
            this.state = 627;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.LPAREN) {
              {
                this.state = 621;
                this.match(_ApexParser.LPAREN);
                this.state = 624;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 43, this._ctx)) {
                  case 1:
                    {
                      this.state = 622;
                      this.elementValuePairs();
                    }
                    break;
                  case 2:
                    {
                      this.state = 623;
                      this.elementValue();
                    }
                    break;
                }
                this.state = 626;
                this.match(_ApexParser.RPAREN);
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      elementValuePairs() {
        let _localctx = new ElementValuePairsContext(this._ctx, this.state);
        this.enterRule(_localctx, 70, _ApexParser.RULE_elementValuePairs);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 629;
            this.elementValuePair();
            this.state = 636;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.COMMA || _la === _ApexParser.Identifier) {
              {
                {
                  this.state = 631;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  if (_la === _ApexParser.COMMA) {
                    {
                      this.state = 630;
                      this.match(_ApexParser.COMMA);
                    }
                  }
                  this.state = 633;
                  this.elementValuePair();
                }
              }
              this.state = 638;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      elementValuePair() {
        let _localctx = new ElementValuePairContext(this._ctx, this.state);
        this.enterRule(_localctx, 72, _ApexParser.RULE_elementValuePair);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 639;
            this.id();
            this.state = 640;
            this.match(_ApexParser.ASSIGN);
            this.state = 641;
            this.elementValue();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      elementValue() {
        let _localctx = new ElementValueContext(this._ctx, this.state);
        this.enterRule(_localctx, 74, _ApexParser.RULE_elementValue);
        try {
          this.state = 646;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.AFTER:
            case _ApexParser.BEFORE:
            case _ApexParser.GET:
            case _ApexParser.INHERITED:
            case _ApexParser.INSTANCEOF:
            case _ApexParser.NEW:
            case _ApexParser.NULL:
            case _ApexParser.SET:
            case _ApexParser.SHARING:
            case _ApexParser.SUPER:
            case _ApexParser.SWITCH:
            case _ApexParser.THIS:
            case _ApexParser.TRANSIENT:
            case _ApexParser.TRIGGER:
            case _ApexParser.VOID:
            case _ApexParser.WHEN:
            case _ApexParser.WITH:
            case _ApexParser.WITHOUT:
            case _ApexParser.LIST:
            case _ApexParser.MAP:
            case _ApexParser.SYSTEM:
            case _ApexParser.USER:
            case _ApexParser.SELECT:
            case _ApexParser.COUNT:
            case _ApexParser.FROM:
            case _ApexParser.AS:
            case _ApexParser.USING:
            case _ApexParser.SCOPE:
            case _ApexParser.WHERE:
            case _ApexParser.ORDER:
            case _ApexParser.BY:
            case _ApexParser.LIMIT:
            case _ApexParser.SOQLAND:
            case _ApexParser.SOQLOR:
            case _ApexParser.NOT:
            case _ApexParser.AVG:
            case _ApexParser.COUNT_DISTINCT:
            case _ApexParser.MIN:
            case _ApexParser.MAX:
            case _ApexParser.SUM:
            case _ApexParser.TYPEOF:
            case _ApexParser.END:
            case _ApexParser.THEN:
            case _ApexParser.LIKE:
            case _ApexParser.IN:
            case _ApexParser.INCLUDES:
            case _ApexParser.EXCLUDES:
            case _ApexParser.ASC:
            case _ApexParser.DESC:
            case _ApexParser.NULLS:
            case _ApexParser.FIRST:
            case _ApexParser.LAST:
            case _ApexParser.GROUP:
            case _ApexParser.ALL:
            case _ApexParser.ROWS:
            case _ApexParser.VIEW:
            case _ApexParser.HAVING:
            case _ApexParser.ROLLUP:
            case _ApexParser.TOLABEL:
            case _ApexParser.OFFSET:
            case _ApexParser.DATA:
            case _ApexParser.CATEGORY:
            case _ApexParser.AT:
            case _ApexParser.ABOVE:
            case _ApexParser.BELOW:
            case _ApexParser.ABOVE_OR_BELOW:
            case _ApexParser.SECURITY_ENFORCED:
            case _ApexParser.SYSTEM_MODE:
            case _ApexParser.USER_MODE:
            case _ApexParser.REFERENCE:
            case _ApexParser.CUBE:
            case _ApexParser.FORMAT:
            case _ApexParser.TRACKING:
            case _ApexParser.VIEWSTAT:
            case _ApexParser.CUSTOM:
            case _ApexParser.STANDARD:
            case _ApexParser.DISTANCE:
            case _ApexParser.GEOLOCATION:
            case _ApexParser.GROUPING:
            case _ApexParser.CONVERT_CURRENCY:
            case _ApexParser.CALENDAR_MONTH:
            case _ApexParser.CALENDAR_QUARTER:
            case _ApexParser.CALENDAR_YEAR:
            case _ApexParser.DAY_IN_MONTH:
            case _ApexParser.DAY_IN_WEEK:
            case _ApexParser.DAY_IN_YEAR:
            case _ApexParser.DAY_ONLY:
            case _ApexParser.FISCAL_MONTH:
            case _ApexParser.FISCAL_QUARTER:
            case _ApexParser.FISCAL_YEAR:
            case _ApexParser.HOUR_IN_DAY:
            case _ApexParser.WEEK_IN_MONTH:
            case _ApexParser.WEEK_IN_YEAR:
            case _ApexParser.CONVERT_TIMEZONE:
            case _ApexParser.YESTERDAY:
            case _ApexParser.TODAY:
            case _ApexParser.TOMORROW:
            case _ApexParser.LAST_WEEK:
            case _ApexParser.THIS_WEEK:
            case _ApexParser.NEXT_WEEK:
            case _ApexParser.LAST_MONTH:
            case _ApexParser.THIS_MONTH:
            case _ApexParser.NEXT_MONTH:
            case _ApexParser.LAST_90_DAYS:
            case _ApexParser.NEXT_90_DAYS:
            case _ApexParser.LAST_N_DAYS_N:
            case _ApexParser.NEXT_N_DAYS_N:
            case _ApexParser.N_DAYS_AGO_N:
            case _ApexParser.NEXT_N_WEEKS_N:
            case _ApexParser.LAST_N_WEEKS_N:
            case _ApexParser.N_WEEKS_AGO_N:
            case _ApexParser.NEXT_N_MONTHS_N:
            case _ApexParser.LAST_N_MONTHS_N:
            case _ApexParser.N_MONTHS_AGO_N:
            case _ApexParser.THIS_QUARTER:
            case _ApexParser.LAST_QUARTER:
            case _ApexParser.NEXT_QUARTER:
            case _ApexParser.NEXT_N_QUARTERS_N:
            case _ApexParser.LAST_N_QUARTERS_N:
            case _ApexParser.N_QUARTERS_AGO_N:
            case _ApexParser.THIS_YEAR:
            case _ApexParser.LAST_YEAR:
            case _ApexParser.NEXT_YEAR:
            case _ApexParser.NEXT_N_YEARS_N:
            case _ApexParser.LAST_N_YEARS_N:
            case _ApexParser.N_YEARS_AGO_N:
            case _ApexParser.THIS_FISCAL_QUARTER:
            case _ApexParser.LAST_FISCAL_QUARTER:
            case _ApexParser.NEXT_FISCAL_QUARTER:
            case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
            case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
            case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
            case _ApexParser.THIS_FISCAL_YEAR:
            case _ApexParser.LAST_FISCAL_YEAR:
            case _ApexParser.NEXT_FISCAL_YEAR:
            case _ApexParser.NEXT_N_FISCAL_YEARS_N:
            case _ApexParser.LAST_N_FISCAL_YEARS_N:
            case _ApexParser.N_FISCAL_YEARS_AGO_N:
            case _ApexParser.IntegralCurrencyLiteral:
            case _ApexParser.FIND:
            case _ApexParser.EMAIL:
            case _ApexParser.NAME:
            case _ApexParser.PHONE:
            case _ApexParser.SIDEBAR:
            case _ApexParser.FIELDS:
            case _ApexParser.METADATA:
            case _ApexParser.PRICEBOOKID:
            case _ApexParser.NETWORK:
            case _ApexParser.SNIPPET:
            case _ApexParser.TARGET_LENGTH:
            case _ApexParser.DIVISION:
            case _ApexParser.RETURNING:
            case _ApexParser.LISTVIEW:
            case _ApexParser.FindLiteral:
            case _ApexParser.IntegerLiteral:
            case _ApexParser.LongLiteral:
            case _ApexParser.NumberLiteral:
            case _ApexParser.BooleanLiteral:
            case _ApexParser.StringLiteral:
            case _ApexParser.LPAREN:
            case _ApexParser.LBRACK:
            case _ApexParser.BANG:
            case _ApexParser.TILDE:
            case _ApexParser.INC:
            case _ApexParser.DEC:
            case _ApexParser.ADD:
            case _ApexParser.SUB:
            case _ApexParser.Identifier:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 643;
                this.expression(0);
              }
              break;
            case _ApexParser.ATSIGN:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 644;
                this.annotation();
              }
              break;
            case _ApexParser.LBRACE:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 645;
                this.elementValueArrayInitializer();
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      elementValueArrayInitializer() {
        let _localctx = new ElementValueArrayInitializerContext(this._ctx, this.state);
        this.enterRule(_localctx, 76, _ApexParser.RULE_elementValueArrayInitializer);
        let _la;
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 648;
            this.match(_ApexParser.LBRACE);
            this.state = 657;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACE - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.ATSIGN - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
              {
                this.state = 649;
                this.elementValue();
                this.state = 654;
                this._errHandler.sync(this);
                _alt = this.interpreter.adaptivePredict(this._input, 48, this._ctx);
                while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                  if (_alt === 1) {
                    {
                      {
                        this.state = 650;
                        this.match(_ApexParser.COMMA);
                        this.state = 651;
                        this.elementValue();
                      }
                    }
                  }
                  this.state = 656;
                  this._errHandler.sync(this);
                  _alt = this.interpreter.adaptivePredict(this._input, 48, this._ctx);
                }
              }
            }
            this.state = 660;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.COMMA) {
              {
                this.state = 659;
                this.match(_ApexParser.COMMA);
              }
            }
            this.state = 662;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      block() {
        let _localctx = new BlockContext(this._ctx, this.state);
        this.enterRule(_localctx, 78, _ApexParser.RULE_block);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 664;
            this.match(_ApexParser.LBRACE);
            this.state = 668;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.BREAK | 1 << _ApexParser.CONTINUE | 1 << _ApexParser.DELETE | 1 << _ApexParser.DO | 1 << _ApexParser.FINAL | 1 << _ApexParser.FOR | 1 << _ApexParser.GET | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.IF | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSERT | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.MERGE | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 32 & ~31) === 0 && (1 << _la - 32 & (1 << _ApexParser.RETURN - 32 | 1 << _ApexParser.SYSTEMRUNAS - 32 | 1 << _ApexParser.SET - 32 | 1 << _ApexParser.SHARING - 32 | 1 << _ApexParser.STATIC - 32 | 1 << _ApexParser.SUPER - 32 | 1 << _ApexParser.SWITCH - 32 | 1 << _ApexParser.TESTMETHOD - 32 | 1 << _ApexParser.THIS - 32 | 1 << _ApexParser.THROW - 32 | 1 << _ApexParser.TRANSIENT - 32 | 1 << _ApexParser.TRIGGER - 32 | 1 << _ApexParser.TRY - 32 | 1 << _ApexParser.UNDELETE - 32 | 1 << _ApexParser.UPDATE - 32 | 1 << _ApexParser.UPSERT - 32 | 1 << _ApexParser.VIRTUAL - 32 | 1 << _ApexParser.VOID - 32 | 1 << _ApexParser.WEBSERVICE - 32 | 1 << _ApexParser.WHEN - 32 | 1 << _ApexParser.WHILE - 32 | 1 << _ApexParser.WITH - 32 | 1 << _ApexParser.WITHOUT - 32 | 1 << _ApexParser.LIST - 32 | 1 << _ApexParser.MAP - 32 | 1 << _ApexParser.SYSTEM - 32 | 1 << _ApexParser.USER - 32 | 1 << _ApexParser.SELECT - 32 | 1 << _ApexParser.COUNT - 32 | 1 << _ApexParser.FROM - 32 | 1 << _ApexParser.AS - 32 | 1 << _ApexParser.USING - 32)) !== 0 || (_la - 64 & ~31) === 0 && (1 << _la - 64 & (1 << _ApexParser.SCOPE - 64 | 1 << _ApexParser.WHERE - 64 | 1 << _ApexParser.ORDER - 64 | 1 << _ApexParser.BY - 64 | 1 << _ApexParser.LIMIT - 64 | 1 << _ApexParser.SOQLAND - 64 | 1 << _ApexParser.SOQLOR - 64 | 1 << _ApexParser.NOT - 64 | 1 << _ApexParser.AVG - 64 | 1 << _ApexParser.COUNT_DISTINCT - 64 | 1 << _ApexParser.MIN - 64 | 1 << _ApexParser.MAX - 64 | 1 << _ApexParser.SUM - 64 | 1 << _ApexParser.TYPEOF - 64 | 1 << _ApexParser.END - 64 | 1 << _ApexParser.THEN - 64 | 1 << _ApexParser.LIKE - 64 | 1 << _ApexParser.IN - 64 | 1 << _ApexParser.INCLUDES - 64 | 1 << _ApexParser.EXCLUDES - 64 | 1 << _ApexParser.ASC - 64 | 1 << _ApexParser.DESC - 64 | 1 << _ApexParser.NULLS - 64 | 1 << _ApexParser.FIRST - 64 | 1 << _ApexParser.LAST - 64 | 1 << _ApexParser.GROUP - 64 | 1 << _ApexParser.ALL - 64 | 1 << _ApexParser.ROWS - 64 | 1 << _ApexParser.VIEW - 64 | 1 << _ApexParser.HAVING - 64 | 1 << _ApexParser.ROLLUP - 64 | 1 << _ApexParser.TOLABEL - 64)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _ApexParser.OFFSET - 96 | 1 << _ApexParser.DATA - 96 | 1 << _ApexParser.CATEGORY - 96 | 1 << _ApexParser.AT - 96 | 1 << _ApexParser.ABOVE - 96 | 1 << _ApexParser.BELOW - 96 | 1 << _ApexParser.ABOVE_OR_BELOW - 96 | 1 << _ApexParser.SECURITY_ENFORCED - 96 | 1 << _ApexParser.SYSTEM_MODE - 96 | 1 << _ApexParser.USER_MODE - 96 | 1 << _ApexParser.REFERENCE - 96 | 1 << _ApexParser.CUBE - 96 | 1 << _ApexParser.FORMAT - 96 | 1 << _ApexParser.TRACKING - 96 | 1 << _ApexParser.VIEWSTAT - 96 | 1 << _ApexParser.CUSTOM - 96 | 1 << _ApexParser.STANDARD - 96 | 1 << _ApexParser.DISTANCE - 96 | 1 << _ApexParser.GEOLOCATION - 96 | 1 << _ApexParser.GROUPING - 96 | 1 << _ApexParser.CONVERT_CURRENCY - 96 | 1 << _ApexParser.CALENDAR_MONTH - 96 | 1 << _ApexParser.CALENDAR_QUARTER - 96 | 1 << _ApexParser.CALENDAR_YEAR - 96 | 1 << _ApexParser.DAY_IN_MONTH - 96 | 1 << _ApexParser.DAY_IN_WEEK - 96 | 1 << _ApexParser.DAY_IN_YEAR - 96 | 1 << _ApexParser.DAY_ONLY - 96 | 1 << _ApexParser.FISCAL_MONTH - 96 | 1 << _ApexParser.FISCAL_QUARTER - 96 | 1 << _ApexParser.FISCAL_YEAR - 96 | 1 << _ApexParser.HOUR_IN_DAY - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _ApexParser.WEEK_IN_MONTH - 128 | 1 << _ApexParser.WEEK_IN_YEAR - 128 | 1 << _ApexParser.CONVERT_TIMEZONE - 128 | 1 << _ApexParser.YESTERDAY - 128 | 1 << _ApexParser.TODAY - 128 | 1 << _ApexParser.TOMORROW - 128 | 1 << _ApexParser.LAST_WEEK - 128 | 1 << _ApexParser.THIS_WEEK - 128 | 1 << _ApexParser.NEXT_WEEK - 128 | 1 << _ApexParser.LAST_MONTH - 128 | 1 << _ApexParser.THIS_MONTH - 128 | 1 << _ApexParser.NEXT_MONTH - 128 | 1 << _ApexParser.LAST_90_DAYS - 128 | 1 << _ApexParser.NEXT_90_DAYS - 128 | 1 << _ApexParser.LAST_N_DAYS_N - 128 | 1 << _ApexParser.NEXT_N_DAYS_N - 128 | 1 << _ApexParser.N_DAYS_AGO_N - 128 | 1 << _ApexParser.NEXT_N_WEEKS_N - 128 | 1 << _ApexParser.LAST_N_WEEKS_N - 128 | 1 << _ApexParser.N_WEEKS_AGO_N - 128 | 1 << _ApexParser.NEXT_N_MONTHS_N - 128 | 1 << _ApexParser.LAST_N_MONTHS_N - 128 | 1 << _ApexParser.N_MONTHS_AGO_N - 128 | 1 << _ApexParser.THIS_QUARTER - 128 | 1 << _ApexParser.LAST_QUARTER - 128 | 1 << _ApexParser.NEXT_QUARTER - 128 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 128 | 1 << _ApexParser.LAST_N_QUARTERS_N - 128 | 1 << _ApexParser.N_QUARTERS_AGO_N - 128 | 1 << _ApexParser.THIS_YEAR - 128 | 1 << _ApexParser.LAST_YEAR - 128 | 1 << _ApexParser.NEXT_YEAR - 128)) !== 0 || (_la - 160 & ~31) === 0 && (1 << _la - 160 & (1 << _ApexParser.NEXT_N_YEARS_N - 160 | 1 << _ApexParser.LAST_N_YEARS_N - 160 | 1 << _ApexParser.N_YEARS_AGO_N - 160 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 160 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 160 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 160 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 160 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 160 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 160 | 1 << _ApexParser.THIS_FISCAL_YEAR - 160 | 1 << _ApexParser.LAST_FISCAL_YEAR - 160 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 160 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 160 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 160 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 160 | 1 << _ApexParser.IntegralCurrencyLiteral - 160 | 1 << _ApexParser.FIND - 160 | 1 << _ApexParser.EMAIL - 160 | 1 << _ApexParser.NAME - 160 | 1 << _ApexParser.PHONE - 160 | 1 << _ApexParser.SIDEBAR - 160 | 1 << _ApexParser.FIELDS - 160 | 1 << _ApexParser.METADATA - 160 | 1 << _ApexParser.PRICEBOOKID - 160 | 1 << _ApexParser.NETWORK - 160 | 1 << _ApexParser.SNIPPET - 160 | 1 << _ApexParser.TARGET_LENGTH - 160 | 1 << _ApexParser.DIVISION - 160 | 1 << _ApexParser.RETURNING - 160)) !== 0 || (_la - 192 & ~31) === 0 && (1 << _la - 192 & (1 << _ApexParser.LISTVIEW - 192 | 1 << _ApexParser.FindLiteral - 192 | 1 << _ApexParser.IntegerLiteral - 192 | 1 << _ApexParser.LongLiteral - 192 | 1 << _ApexParser.NumberLiteral - 192 | 1 << _ApexParser.BooleanLiteral - 192 | 1 << _ApexParser.StringLiteral - 192 | 1 << _ApexParser.LPAREN - 192 | 1 << _ApexParser.LBRACE - 192 | 1 << _ApexParser.LBRACK - 192 | 1 << _ApexParser.BANG - 192 | 1 << _ApexParser.TILDE - 192)) !== 0 || (_la - 226 & ~31) === 0 && (1 << _la - 226 & (1 << _ApexParser.INC - 226 | 1 << _ApexParser.DEC - 226 | 1 << _ApexParser.ADD - 226 | 1 << _ApexParser.SUB - 226 | 1 << _ApexParser.ATSIGN - 226 | 1 << _ApexParser.Identifier - 226)) !== 0) {
              {
                {
                  this.state = 665;
                  this.statement();
                }
              }
              this.state = 670;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 671;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      localVariableDeclarationStatement() {
        let _localctx = new LocalVariableDeclarationStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 80, _ApexParser.RULE_localVariableDeclarationStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 673;
            this.localVariableDeclaration();
            this.state = 674;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      localVariableDeclaration() {
        let _localctx = new LocalVariableDeclarationContext(this._ctx, this.state);
        this.enterRule(_localctx, 82, _ApexParser.RULE_localVariableDeclaration);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 679;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 52, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 676;
                    this.modifier();
                  }
                }
              }
              this.state = 681;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 52, this._ctx);
            }
            this.state = 682;
            this.typeRef();
            this.state = 683;
            this.variableDeclarators();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      statement() {
        let _localctx = new StatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 84, _ApexParser.RULE_statement);
        try {
          this.state = 705;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 53, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 685;
                this.block();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 686;
                this.ifStatement();
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 687;
                this.switchStatement();
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 688;
                this.forStatement();
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 689;
                this.whileStatement();
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 690;
                this.doWhileStatement();
              }
              break;
            case 7:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 691;
                this.tryStatement();
              }
              break;
            case 8:
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 692;
                this.returnStatement();
              }
              break;
            case 9:
              this.enterOuterAlt(_localctx, 9);
              {
                this.state = 693;
                this.throwStatement();
              }
              break;
            case 10:
              this.enterOuterAlt(_localctx, 10);
              {
                this.state = 694;
                this.breakStatement();
              }
              break;
            case 11:
              this.enterOuterAlt(_localctx, 11);
              {
                this.state = 695;
                this.continueStatement();
              }
              break;
            case 12:
              this.enterOuterAlt(_localctx, 12);
              {
                this.state = 696;
                this.insertStatement();
              }
              break;
            case 13:
              this.enterOuterAlt(_localctx, 13);
              {
                this.state = 697;
                this.updateStatement();
              }
              break;
            case 14:
              this.enterOuterAlt(_localctx, 14);
              {
                this.state = 698;
                this.deleteStatement();
              }
              break;
            case 15:
              this.enterOuterAlt(_localctx, 15);
              {
                this.state = 699;
                this.undeleteStatement();
              }
              break;
            case 16:
              this.enterOuterAlt(_localctx, 16);
              {
                this.state = 700;
                this.upsertStatement();
              }
              break;
            case 17:
              this.enterOuterAlt(_localctx, 17);
              {
                this.state = 701;
                this.mergeStatement();
              }
              break;
            case 18:
              this.enterOuterAlt(_localctx, 18);
              {
                this.state = 702;
                this.runAsStatement();
              }
              break;
            case 19:
              this.enterOuterAlt(_localctx, 19);
              {
                this.state = 703;
                this.localVariableDeclarationStatement();
              }
              break;
            case 20:
              this.enterOuterAlt(_localctx, 20);
              {
                this.state = 704;
                this.expressionStatement();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      ifStatement() {
        let _localctx = new IfStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 86, _ApexParser.RULE_ifStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 707;
            this.match(_ApexParser.IF);
            this.state = 708;
            this.parExpression();
            this.state = 709;
            this.statement();
            this.state = 712;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 54, this._ctx)) {
              case 1:
                {
                  this.state = 710;
                  this.match(_ApexParser.ELSE);
                  this.state = 711;
                  this.statement();
                }
                break;
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      switchStatement() {
        let _localctx = new SwitchStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 88, _ApexParser.RULE_switchStatement);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 714;
            this.match(_ApexParser.SWITCH);
            this.state = 715;
            this.match(_ApexParser.ON);
            this.state = 716;
            this.expression(0);
            this.state = 717;
            this.match(_ApexParser.LBRACE);
            this.state = 719;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
              {
                {
                  this.state = 718;
                  this.whenControl();
                }
              }
              this.state = 721;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            } while (_la === _ApexParser.WHEN);
            this.state = 723;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      whenControl() {
        let _localctx = new WhenControlContext(this._ctx, this.state);
        this.enterRule(_localctx, 90, _ApexParser.RULE_whenControl);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 725;
            this.match(_ApexParser.WHEN);
            this.state = 726;
            this.whenValue();
            this.state = 727;
            this.block();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      whenValue() {
        let _localctx = new WhenValueContext(this._ctx, this.state);
        this.enterRule(_localctx, 92, _ApexParser.RULE_whenValue);
        let _la;
        try {
          this.state = 741;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 57, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 729;
                this.match(_ApexParser.ELSE);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 730;
                this.whenLiteral();
                this.state = 735;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.COMMA) {
                  {
                    {
                      this.state = 731;
                      this.match(_ApexParser.COMMA);
                      this.state = 732;
                      this.whenLiteral();
                    }
                  }
                  this.state = 737;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 738;
                this.typeRef();
                this.state = 739;
                this.id();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      whenLiteral() {
        let _localctx = new WhenLiteralContext(this._ctx, this.state);
        this.enterRule(_localctx, 94, _ApexParser.RULE_whenLiteral);
        let _la;
        try {
          this.state = 764;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 60, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 746;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.ADD || _la === _ApexParser.SUB) {
                  {
                    {
                      this.state = 743;
                      _la = this._input.LA(1);
                      if (!(_la === _ApexParser.ADD || _la === _ApexParser.SUB)) {
                        this._errHandler.recoverInline(this);
                      } else {
                        if (this._input.LA(1) === Token_1.Token.EOF) {
                          this.matchedEOF = true;
                        }
                        this._errHandler.reportMatch(this);
                        this.consume();
                      }
                    }
                  }
                  this.state = 748;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 749;
                this.match(_ApexParser.IntegerLiteral);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 753;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.ADD || _la === _ApexParser.SUB) {
                  {
                    {
                      this.state = 750;
                      _la = this._input.LA(1);
                      if (!(_la === _ApexParser.ADD || _la === _ApexParser.SUB)) {
                        this._errHandler.recoverInline(this);
                      } else {
                        if (this._input.LA(1) === Token_1.Token.EOF) {
                          this.matchedEOF = true;
                        }
                        this._errHandler.reportMatch(this);
                        this.consume();
                      }
                    }
                  }
                  this.state = 755;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 756;
                this.match(_ApexParser.LongLiteral);
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 757;
                this.match(_ApexParser.StringLiteral);
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 758;
                this.match(_ApexParser.NULL);
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 759;
                this.id();
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 760;
                this.match(_ApexParser.LPAREN);
                this.state = 761;
                this.whenLiteral();
                this.state = 762;
                this.match(_ApexParser.RPAREN);
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      forStatement() {
        let _localctx = new ForStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 96, _ApexParser.RULE_forStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 766;
            this.match(_ApexParser.FOR);
            this.state = 767;
            this.match(_ApexParser.LPAREN);
            this.state = 768;
            this.forControl();
            this.state = 769;
            this.match(_ApexParser.RPAREN);
            this.state = 772;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.ABSTRACT:
              case _ApexParser.AFTER:
              case _ApexParser.BEFORE:
              case _ApexParser.BREAK:
              case _ApexParser.CONTINUE:
              case _ApexParser.DELETE:
              case _ApexParser.DO:
              case _ApexParser.FINAL:
              case _ApexParser.FOR:
              case _ApexParser.GET:
              case _ApexParser.GLOBAL:
              case _ApexParser.IF:
              case _ApexParser.INHERITED:
              case _ApexParser.INSERT:
              case _ApexParser.INSTANCEOF:
              case _ApexParser.MERGE:
              case _ApexParser.NEW:
              case _ApexParser.NULL:
              case _ApexParser.OVERRIDE:
              case _ApexParser.PRIVATE:
              case _ApexParser.PROTECTED:
              case _ApexParser.PUBLIC:
              case _ApexParser.RETURN:
              case _ApexParser.SYSTEMRUNAS:
              case _ApexParser.SET:
              case _ApexParser.SHARING:
              case _ApexParser.STATIC:
              case _ApexParser.SUPER:
              case _ApexParser.SWITCH:
              case _ApexParser.TESTMETHOD:
              case _ApexParser.THIS:
              case _ApexParser.THROW:
              case _ApexParser.TRANSIENT:
              case _ApexParser.TRIGGER:
              case _ApexParser.TRY:
              case _ApexParser.UNDELETE:
              case _ApexParser.UPDATE:
              case _ApexParser.UPSERT:
              case _ApexParser.VIRTUAL:
              case _ApexParser.VOID:
              case _ApexParser.WEBSERVICE:
              case _ApexParser.WHEN:
              case _ApexParser.WHILE:
              case _ApexParser.WITH:
              case _ApexParser.WITHOUT:
              case _ApexParser.LIST:
              case _ApexParser.MAP:
              case _ApexParser.SYSTEM:
              case _ApexParser.USER:
              case _ApexParser.SELECT:
              case _ApexParser.COUNT:
              case _ApexParser.FROM:
              case _ApexParser.AS:
              case _ApexParser.USING:
              case _ApexParser.SCOPE:
              case _ApexParser.WHERE:
              case _ApexParser.ORDER:
              case _ApexParser.BY:
              case _ApexParser.LIMIT:
              case _ApexParser.SOQLAND:
              case _ApexParser.SOQLOR:
              case _ApexParser.NOT:
              case _ApexParser.AVG:
              case _ApexParser.COUNT_DISTINCT:
              case _ApexParser.MIN:
              case _ApexParser.MAX:
              case _ApexParser.SUM:
              case _ApexParser.TYPEOF:
              case _ApexParser.END:
              case _ApexParser.THEN:
              case _ApexParser.LIKE:
              case _ApexParser.IN:
              case _ApexParser.INCLUDES:
              case _ApexParser.EXCLUDES:
              case _ApexParser.ASC:
              case _ApexParser.DESC:
              case _ApexParser.NULLS:
              case _ApexParser.FIRST:
              case _ApexParser.LAST:
              case _ApexParser.GROUP:
              case _ApexParser.ALL:
              case _ApexParser.ROWS:
              case _ApexParser.VIEW:
              case _ApexParser.HAVING:
              case _ApexParser.ROLLUP:
              case _ApexParser.TOLABEL:
              case _ApexParser.OFFSET:
              case _ApexParser.DATA:
              case _ApexParser.CATEGORY:
              case _ApexParser.AT:
              case _ApexParser.ABOVE:
              case _ApexParser.BELOW:
              case _ApexParser.ABOVE_OR_BELOW:
              case _ApexParser.SECURITY_ENFORCED:
              case _ApexParser.SYSTEM_MODE:
              case _ApexParser.USER_MODE:
              case _ApexParser.REFERENCE:
              case _ApexParser.CUBE:
              case _ApexParser.FORMAT:
              case _ApexParser.TRACKING:
              case _ApexParser.VIEWSTAT:
              case _ApexParser.CUSTOM:
              case _ApexParser.STANDARD:
              case _ApexParser.DISTANCE:
              case _ApexParser.GEOLOCATION:
              case _ApexParser.GROUPING:
              case _ApexParser.CONVERT_CURRENCY:
              case _ApexParser.CALENDAR_MONTH:
              case _ApexParser.CALENDAR_QUARTER:
              case _ApexParser.CALENDAR_YEAR:
              case _ApexParser.DAY_IN_MONTH:
              case _ApexParser.DAY_IN_WEEK:
              case _ApexParser.DAY_IN_YEAR:
              case _ApexParser.DAY_ONLY:
              case _ApexParser.FISCAL_MONTH:
              case _ApexParser.FISCAL_QUARTER:
              case _ApexParser.FISCAL_YEAR:
              case _ApexParser.HOUR_IN_DAY:
              case _ApexParser.WEEK_IN_MONTH:
              case _ApexParser.WEEK_IN_YEAR:
              case _ApexParser.CONVERT_TIMEZONE:
              case _ApexParser.YESTERDAY:
              case _ApexParser.TODAY:
              case _ApexParser.TOMORROW:
              case _ApexParser.LAST_WEEK:
              case _ApexParser.THIS_WEEK:
              case _ApexParser.NEXT_WEEK:
              case _ApexParser.LAST_MONTH:
              case _ApexParser.THIS_MONTH:
              case _ApexParser.NEXT_MONTH:
              case _ApexParser.LAST_90_DAYS:
              case _ApexParser.NEXT_90_DAYS:
              case _ApexParser.LAST_N_DAYS_N:
              case _ApexParser.NEXT_N_DAYS_N:
              case _ApexParser.N_DAYS_AGO_N:
              case _ApexParser.NEXT_N_WEEKS_N:
              case _ApexParser.LAST_N_WEEKS_N:
              case _ApexParser.N_WEEKS_AGO_N:
              case _ApexParser.NEXT_N_MONTHS_N:
              case _ApexParser.LAST_N_MONTHS_N:
              case _ApexParser.N_MONTHS_AGO_N:
              case _ApexParser.THIS_QUARTER:
              case _ApexParser.LAST_QUARTER:
              case _ApexParser.NEXT_QUARTER:
              case _ApexParser.NEXT_N_QUARTERS_N:
              case _ApexParser.LAST_N_QUARTERS_N:
              case _ApexParser.N_QUARTERS_AGO_N:
              case _ApexParser.THIS_YEAR:
              case _ApexParser.LAST_YEAR:
              case _ApexParser.NEXT_YEAR:
              case _ApexParser.NEXT_N_YEARS_N:
              case _ApexParser.LAST_N_YEARS_N:
              case _ApexParser.N_YEARS_AGO_N:
              case _ApexParser.THIS_FISCAL_QUARTER:
              case _ApexParser.LAST_FISCAL_QUARTER:
              case _ApexParser.NEXT_FISCAL_QUARTER:
              case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
              case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
              case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
              case _ApexParser.THIS_FISCAL_YEAR:
              case _ApexParser.LAST_FISCAL_YEAR:
              case _ApexParser.NEXT_FISCAL_YEAR:
              case _ApexParser.NEXT_N_FISCAL_YEARS_N:
              case _ApexParser.LAST_N_FISCAL_YEARS_N:
              case _ApexParser.N_FISCAL_YEARS_AGO_N:
              case _ApexParser.IntegralCurrencyLiteral:
              case _ApexParser.FIND:
              case _ApexParser.EMAIL:
              case _ApexParser.NAME:
              case _ApexParser.PHONE:
              case _ApexParser.SIDEBAR:
              case _ApexParser.FIELDS:
              case _ApexParser.METADATA:
              case _ApexParser.PRICEBOOKID:
              case _ApexParser.NETWORK:
              case _ApexParser.SNIPPET:
              case _ApexParser.TARGET_LENGTH:
              case _ApexParser.DIVISION:
              case _ApexParser.RETURNING:
              case _ApexParser.LISTVIEW:
              case _ApexParser.FindLiteral:
              case _ApexParser.IntegerLiteral:
              case _ApexParser.LongLiteral:
              case _ApexParser.NumberLiteral:
              case _ApexParser.BooleanLiteral:
              case _ApexParser.StringLiteral:
              case _ApexParser.LPAREN:
              case _ApexParser.LBRACE:
              case _ApexParser.LBRACK:
              case _ApexParser.BANG:
              case _ApexParser.TILDE:
              case _ApexParser.INC:
              case _ApexParser.DEC:
              case _ApexParser.ADD:
              case _ApexParser.SUB:
              case _ApexParser.ATSIGN:
              case _ApexParser.Identifier:
                {
                  this.state = 770;
                  this.statement();
                }
                break;
              case _ApexParser.SEMI:
                {
                  this.state = 771;
                  this.match(_ApexParser.SEMI);
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      whileStatement() {
        let _localctx = new WhileStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 98, _ApexParser.RULE_whileStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 774;
            this.match(_ApexParser.WHILE);
            this.state = 775;
            this.parExpression();
            this.state = 778;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.ABSTRACT:
              case _ApexParser.AFTER:
              case _ApexParser.BEFORE:
              case _ApexParser.BREAK:
              case _ApexParser.CONTINUE:
              case _ApexParser.DELETE:
              case _ApexParser.DO:
              case _ApexParser.FINAL:
              case _ApexParser.FOR:
              case _ApexParser.GET:
              case _ApexParser.GLOBAL:
              case _ApexParser.IF:
              case _ApexParser.INHERITED:
              case _ApexParser.INSERT:
              case _ApexParser.INSTANCEOF:
              case _ApexParser.MERGE:
              case _ApexParser.NEW:
              case _ApexParser.NULL:
              case _ApexParser.OVERRIDE:
              case _ApexParser.PRIVATE:
              case _ApexParser.PROTECTED:
              case _ApexParser.PUBLIC:
              case _ApexParser.RETURN:
              case _ApexParser.SYSTEMRUNAS:
              case _ApexParser.SET:
              case _ApexParser.SHARING:
              case _ApexParser.STATIC:
              case _ApexParser.SUPER:
              case _ApexParser.SWITCH:
              case _ApexParser.TESTMETHOD:
              case _ApexParser.THIS:
              case _ApexParser.THROW:
              case _ApexParser.TRANSIENT:
              case _ApexParser.TRIGGER:
              case _ApexParser.TRY:
              case _ApexParser.UNDELETE:
              case _ApexParser.UPDATE:
              case _ApexParser.UPSERT:
              case _ApexParser.VIRTUAL:
              case _ApexParser.VOID:
              case _ApexParser.WEBSERVICE:
              case _ApexParser.WHEN:
              case _ApexParser.WHILE:
              case _ApexParser.WITH:
              case _ApexParser.WITHOUT:
              case _ApexParser.LIST:
              case _ApexParser.MAP:
              case _ApexParser.SYSTEM:
              case _ApexParser.USER:
              case _ApexParser.SELECT:
              case _ApexParser.COUNT:
              case _ApexParser.FROM:
              case _ApexParser.AS:
              case _ApexParser.USING:
              case _ApexParser.SCOPE:
              case _ApexParser.WHERE:
              case _ApexParser.ORDER:
              case _ApexParser.BY:
              case _ApexParser.LIMIT:
              case _ApexParser.SOQLAND:
              case _ApexParser.SOQLOR:
              case _ApexParser.NOT:
              case _ApexParser.AVG:
              case _ApexParser.COUNT_DISTINCT:
              case _ApexParser.MIN:
              case _ApexParser.MAX:
              case _ApexParser.SUM:
              case _ApexParser.TYPEOF:
              case _ApexParser.END:
              case _ApexParser.THEN:
              case _ApexParser.LIKE:
              case _ApexParser.IN:
              case _ApexParser.INCLUDES:
              case _ApexParser.EXCLUDES:
              case _ApexParser.ASC:
              case _ApexParser.DESC:
              case _ApexParser.NULLS:
              case _ApexParser.FIRST:
              case _ApexParser.LAST:
              case _ApexParser.GROUP:
              case _ApexParser.ALL:
              case _ApexParser.ROWS:
              case _ApexParser.VIEW:
              case _ApexParser.HAVING:
              case _ApexParser.ROLLUP:
              case _ApexParser.TOLABEL:
              case _ApexParser.OFFSET:
              case _ApexParser.DATA:
              case _ApexParser.CATEGORY:
              case _ApexParser.AT:
              case _ApexParser.ABOVE:
              case _ApexParser.BELOW:
              case _ApexParser.ABOVE_OR_BELOW:
              case _ApexParser.SECURITY_ENFORCED:
              case _ApexParser.SYSTEM_MODE:
              case _ApexParser.USER_MODE:
              case _ApexParser.REFERENCE:
              case _ApexParser.CUBE:
              case _ApexParser.FORMAT:
              case _ApexParser.TRACKING:
              case _ApexParser.VIEWSTAT:
              case _ApexParser.CUSTOM:
              case _ApexParser.STANDARD:
              case _ApexParser.DISTANCE:
              case _ApexParser.GEOLOCATION:
              case _ApexParser.GROUPING:
              case _ApexParser.CONVERT_CURRENCY:
              case _ApexParser.CALENDAR_MONTH:
              case _ApexParser.CALENDAR_QUARTER:
              case _ApexParser.CALENDAR_YEAR:
              case _ApexParser.DAY_IN_MONTH:
              case _ApexParser.DAY_IN_WEEK:
              case _ApexParser.DAY_IN_YEAR:
              case _ApexParser.DAY_ONLY:
              case _ApexParser.FISCAL_MONTH:
              case _ApexParser.FISCAL_QUARTER:
              case _ApexParser.FISCAL_YEAR:
              case _ApexParser.HOUR_IN_DAY:
              case _ApexParser.WEEK_IN_MONTH:
              case _ApexParser.WEEK_IN_YEAR:
              case _ApexParser.CONVERT_TIMEZONE:
              case _ApexParser.YESTERDAY:
              case _ApexParser.TODAY:
              case _ApexParser.TOMORROW:
              case _ApexParser.LAST_WEEK:
              case _ApexParser.THIS_WEEK:
              case _ApexParser.NEXT_WEEK:
              case _ApexParser.LAST_MONTH:
              case _ApexParser.THIS_MONTH:
              case _ApexParser.NEXT_MONTH:
              case _ApexParser.LAST_90_DAYS:
              case _ApexParser.NEXT_90_DAYS:
              case _ApexParser.LAST_N_DAYS_N:
              case _ApexParser.NEXT_N_DAYS_N:
              case _ApexParser.N_DAYS_AGO_N:
              case _ApexParser.NEXT_N_WEEKS_N:
              case _ApexParser.LAST_N_WEEKS_N:
              case _ApexParser.N_WEEKS_AGO_N:
              case _ApexParser.NEXT_N_MONTHS_N:
              case _ApexParser.LAST_N_MONTHS_N:
              case _ApexParser.N_MONTHS_AGO_N:
              case _ApexParser.THIS_QUARTER:
              case _ApexParser.LAST_QUARTER:
              case _ApexParser.NEXT_QUARTER:
              case _ApexParser.NEXT_N_QUARTERS_N:
              case _ApexParser.LAST_N_QUARTERS_N:
              case _ApexParser.N_QUARTERS_AGO_N:
              case _ApexParser.THIS_YEAR:
              case _ApexParser.LAST_YEAR:
              case _ApexParser.NEXT_YEAR:
              case _ApexParser.NEXT_N_YEARS_N:
              case _ApexParser.LAST_N_YEARS_N:
              case _ApexParser.N_YEARS_AGO_N:
              case _ApexParser.THIS_FISCAL_QUARTER:
              case _ApexParser.LAST_FISCAL_QUARTER:
              case _ApexParser.NEXT_FISCAL_QUARTER:
              case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
              case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
              case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
              case _ApexParser.THIS_FISCAL_YEAR:
              case _ApexParser.LAST_FISCAL_YEAR:
              case _ApexParser.NEXT_FISCAL_YEAR:
              case _ApexParser.NEXT_N_FISCAL_YEARS_N:
              case _ApexParser.LAST_N_FISCAL_YEARS_N:
              case _ApexParser.N_FISCAL_YEARS_AGO_N:
              case _ApexParser.IntegralCurrencyLiteral:
              case _ApexParser.FIND:
              case _ApexParser.EMAIL:
              case _ApexParser.NAME:
              case _ApexParser.PHONE:
              case _ApexParser.SIDEBAR:
              case _ApexParser.FIELDS:
              case _ApexParser.METADATA:
              case _ApexParser.PRICEBOOKID:
              case _ApexParser.NETWORK:
              case _ApexParser.SNIPPET:
              case _ApexParser.TARGET_LENGTH:
              case _ApexParser.DIVISION:
              case _ApexParser.RETURNING:
              case _ApexParser.LISTVIEW:
              case _ApexParser.FindLiteral:
              case _ApexParser.IntegerLiteral:
              case _ApexParser.LongLiteral:
              case _ApexParser.NumberLiteral:
              case _ApexParser.BooleanLiteral:
              case _ApexParser.StringLiteral:
              case _ApexParser.LPAREN:
              case _ApexParser.LBRACE:
              case _ApexParser.LBRACK:
              case _ApexParser.BANG:
              case _ApexParser.TILDE:
              case _ApexParser.INC:
              case _ApexParser.DEC:
              case _ApexParser.ADD:
              case _ApexParser.SUB:
              case _ApexParser.ATSIGN:
              case _ApexParser.Identifier:
                {
                  this.state = 776;
                  this.statement();
                }
                break;
              case _ApexParser.SEMI:
                {
                  this.state = 777;
                  this.match(_ApexParser.SEMI);
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      doWhileStatement() {
        let _localctx = new DoWhileStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 100, _ApexParser.RULE_doWhileStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 780;
            this.match(_ApexParser.DO);
            this.state = 781;
            this.block();
            this.state = 782;
            this.match(_ApexParser.WHILE);
            this.state = 783;
            this.parExpression();
            this.state = 784;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      tryStatement() {
        let _localctx = new TryStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 102, _ApexParser.RULE_tryStatement);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 786;
            this.match(_ApexParser.TRY);
            this.state = 787;
            this.block();
            this.state = 797;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.CATCH:
                {
                  this.state = 789;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  do {
                    {
                      {
                        this.state = 788;
                        this.catchClause();
                      }
                    }
                    this.state = 791;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  } while (_la === _ApexParser.CATCH);
                  this.state = 794;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  if (_la === _ApexParser.FINALLY) {
                    {
                      this.state = 793;
                      this.finallyBlock();
                    }
                  }
                }
                break;
              case _ApexParser.FINALLY:
                {
                  this.state = 796;
                  this.finallyBlock();
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      returnStatement() {
        let _localctx = new ReturnStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 104, _ApexParser.RULE_returnStatement);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 799;
            this.match(_ApexParser.RETURN);
            this.state = 801;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
              {
                this.state = 800;
                this.expression(0);
              }
            }
            this.state = 803;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      throwStatement() {
        let _localctx = new ThrowStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 106, _ApexParser.RULE_throwStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 805;
            this.match(_ApexParser.THROW);
            this.state = 806;
            this.expression(0);
            this.state = 807;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      breakStatement() {
        let _localctx = new BreakStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 108, _ApexParser.RULE_breakStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 809;
            this.match(_ApexParser.BREAK);
            this.state = 810;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      continueStatement() {
        let _localctx = new ContinueStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 110, _ApexParser.RULE_continueStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 812;
            this.match(_ApexParser.CONTINUE);
            this.state = 813;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      accessLevel() {
        let _localctx = new AccessLevelContext(this._ctx, this.state);
        this.enterRule(_localctx, 112, _ApexParser.RULE_accessLevel);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 815;
            this.match(_ApexParser.AS);
            this.state = 816;
            _la = this._input.LA(1);
            if (!(_la === _ApexParser.SYSTEM || _la === _ApexParser.USER)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      insertStatement() {
        let _localctx = new InsertStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 114, _ApexParser.RULE_insertStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 818;
            this.match(_ApexParser.INSERT);
            this.state = 820;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 67, this._ctx)) {
              case 1:
                {
                  this.state = 819;
                  this.accessLevel();
                }
                break;
            }
            this.state = 822;
            this.expression(0);
            this.state = 823;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      updateStatement() {
        let _localctx = new UpdateStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 116, _ApexParser.RULE_updateStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 825;
            this.match(_ApexParser.UPDATE);
            this.state = 827;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 68, this._ctx)) {
              case 1:
                {
                  this.state = 826;
                  this.accessLevel();
                }
                break;
            }
            this.state = 829;
            this.expression(0);
            this.state = 830;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      deleteStatement() {
        let _localctx = new DeleteStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 118, _ApexParser.RULE_deleteStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 832;
            this.match(_ApexParser.DELETE);
            this.state = 834;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 69, this._ctx)) {
              case 1:
                {
                  this.state = 833;
                  this.accessLevel();
                }
                break;
            }
            this.state = 836;
            this.expression(0);
            this.state = 837;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      undeleteStatement() {
        let _localctx = new UndeleteStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 120, _ApexParser.RULE_undeleteStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 839;
            this.match(_ApexParser.UNDELETE);
            this.state = 841;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 70, this._ctx)) {
              case 1:
                {
                  this.state = 840;
                  this.accessLevel();
                }
                break;
            }
            this.state = 843;
            this.expression(0);
            this.state = 844;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      upsertStatement() {
        let _localctx = new UpsertStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 122, _ApexParser.RULE_upsertStatement);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 846;
            this.match(_ApexParser.UPSERT);
            this.state = 848;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 71, this._ctx)) {
              case 1:
                {
                  this.state = 847;
                  this.accessLevel();
                }
                break;
            }
            this.state = 850;
            this.expression(0);
            this.state = 852;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.Identifier) {
              {
                this.state = 851;
                this.qualifiedName();
              }
            }
            this.state = 854;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      mergeStatement() {
        let _localctx = new MergeStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 124, _ApexParser.RULE_mergeStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 856;
            this.match(_ApexParser.MERGE);
            this.state = 858;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 73, this._ctx)) {
              case 1:
                {
                  this.state = 857;
                  this.accessLevel();
                }
                break;
            }
            this.state = 860;
            this.expression(0);
            this.state = 861;
            this.expression(0);
            this.state = 862;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      runAsStatement() {
        let _localctx = new RunAsStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 126, _ApexParser.RULE_runAsStatement);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 864;
            this.match(_ApexParser.SYSTEMRUNAS);
            this.state = 865;
            this.match(_ApexParser.LPAREN);
            this.state = 867;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
              {
                this.state = 866;
                this.expressionList();
              }
            }
            this.state = 869;
            this.match(_ApexParser.RPAREN);
            this.state = 870;
            this.block();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      expressionStatement() {
        let _localctx = new ExpressionStatementContext(this._ctx, this.state);
        this.enterRule(_localctx, 128, _ApexParser.RULE_expressionStatement);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 872;
            this.expression(0);
            this.state = 873;
            this.match(_ApexParser.SEMI);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      propertyBlock() {
        let _localctx = new PropertyBlockContext(this._ctx, this.state);
        this.enterRule(_localctx, 130, _ApexParser.RULE_propertyBlock);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 878;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.FINAL | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _ApexParser.STATIC - 36 | 1 << _ApexParser.TESTMETHOD - 36 | 1 << _ApexParser.TRANSIENT - 36 | 1 << _ApexParser.VIRTUAL - 36 | 1 << _ApexParser.WEBSERVICE - 36 | 1 << _ApexParser.WITH - 36 | 1 << _ApexParser.WITHOUT - 36)) !== 0 || _la === _ApexParser.ATSIGN) {
              {
                {
                  this.state = 875;
                  this.modifier();
                }
              }
              this.state = 880;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 883;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.GET:
                {
                  this.state = 881;
                  this.getter();
                }
                break;
              case _ApexParser.SET:
                {
                  this.state = 882;
                  this.setter();
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      getter() {
        let _localctx = new GetterContext(this._ctx, this.state);
        this.enterRule(_localctx, 132, _ApexParser.RULE_getter);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 885;
            this.match(_ApexParser.GET);
            this.state = 888;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.SEMI:
                {
                  this.state = 886;
                  this.match(_ApexParser.SEMI);
                }
                break;
              case _ApexParser.LBRACE:
                {
                  this.state = 887;
                  this.block();
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      setter() {
        let _localctx = new SetterContext(this._ctx, this.state);
        this.enterRule(_localctx, 134, _ApexParser.RULE_setter);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 890;
            this.match(_ApexParser.SET);
            this.state = 893;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _ApexParser.SEMI:
                {
                  this.state = 891;
                  this.match(_ApexParser.SEMI);
                }
                break;
              case _ApexParser.LBRACE:
                {
                  this.state = 892;
                  this.block();
                }
                break;
              default:
                throw new NoViableAltException_1.NoViableAltException(this);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      catchClause() {
        let _localctx = new CatchClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 136, _ApexParser.RULE_catchClause);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 895;
            this.match(_ApexParser.CATCH);
            this.state = 896;
            this.match(_ApexParser.LPAREN);
            this.state = 900;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 79, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 897;
                    this.modifier();
                  }
                }
              }
              this.state = 902;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 79, this._ctx);
            }
            this.state = 903;
            this.qualifiedName();
            this.state = 904;
            this.id();
            this.state = 905;
            this.match(_ApexParser.RPAREN);
            this.state = 906;
            this.block();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      finallyBlock() {
        let _localctx = new FinallyBlockContext(this._ctx, this.state);
        this.enterRule(_localctx, 138, _ApexParser.RULE_finallyBlock);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 908;
            this.match(_ApexParser.FINALLY);
            this.state = 909;
            this.block();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      forControl() {
        let _localctx = new ForControlContext(this._ctx, this.state);
        this.enterRule(_localctx, 140, _ApexParser.RULE_forControl);
        let _la;
        try {
          this.state = 923;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 83, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 911;
                this.enhancedForControl();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 913;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.ABSTRACT | 1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.FINAL | 1 << _ApexParser.GET | 1 << _ApexParser.GLOBAL | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL | 1 << _ApexParser.OVERRIDE | 1 << _ApexParser.PRIVATE | 1 << _ApexParser.PROTECTED | 1 << _ApexParser.PUBLIC)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.STATIC - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TESTMETHOD - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VIRTUAL - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WEBSERVICE - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.ATSIGN - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
                  {
                    this.state = 912;
                    this.forInit();
                  }
                }
                this.state = 915;
                this.match(_ApexParser.SEMI);
                this.state = 917;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
                  {
                    this.state = 916;
                    this.expression(0);
                  }
                }
                this.state = 919;
                this.match(_ApexParser.SEMI);
                this.state = 921;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
                  {
                    this.state = 920;
                    this.forUpdate();
                  }
                }
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      forInit() {
        let _localctx = new ForInitContext(this._ctx, this.state);
        this.enterRule(_localctx, 142, _ApexParser.RULE_forInit);
        try {
          this.state = 927;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 84, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 925;
                this.localVariableDeclaration();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 926;
                this.expressionList();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      enhancedForControl() {
        let _localctx = new EnhancedForControlContext(this._ctx, this.state);
        this.enterRule(_localctx, 144, _ApexParser.RULE_enhancedForControl);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 929;
            this.typeRef();
            this.state = 930;
            this.id();
            this.state = 931;
            this.match(_ApexParser.COLON);
            this.state = 932;
            this.expression(0);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      forUpdate() {
        let _localctx = new ForUpdateContext(this._ctx, this.state);
        this.enterRule(_localctx, 146, _ApexParser.RULE_forUpdate);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 934;
            this.expressionList();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      parExpression() {
        let _localctx = new ParExpressionContext(this._ctx, this.state);
        this.enterRule(_localctx, 148, _ApexParser.RULE_parExpression);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 936;
            this.match(_ApexParser.LPAREN);
            this.state = 937;
            this.expression(0);
            this.state = 938;
            this.match(_ApexParser.RPAREN);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      expressionList() {
        let _localctx = new ExpressionListContext(this._ctx, this.state);
        this.enterRule(_localctx, 150, _ApexParser.RULE_expressionList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 940;
            this.expression(0);
            this.state = 945;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 941;
                  this.match(_ApexParser.COMMA);
                  this.state = 942;
                  this.expression(0);
                }
              }
              this.state = 947;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      expression(_p) {
        if (_p === void 0) {
          _p = 0;
        }
        let _parentctx = this._ctx;
        let _parentState = this.state;
        let _localctx = new ExpressionContext(this._ctx, _parentState);
        let _prevctx = _localctx;
        let _startState = 152;
        this.enterRecursionRule(_localctx, 152, _ApexParser.RULE_expression, _p);
        let _la;
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 966;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 86, this._ctx)) {
              case 1:
                {
                  _localctx = new PrimaryExpressionContext(_localctx);
                  this._ctx = _localctx;
                  _prevctx = _localctx;
                  this.state = 949;
                  this.primary();
                }
                break;
              case 2:
                {
                  _localctx = new MethodCallExpressionContext(_localctx);
                  this._ctx = _localctx;
                  _prevctx = _localctx;
                  this.state = 950;
                  this.methodCall();
                }
                break;
              case 3:
                {
                  _localctx = new NewExpressionContext(_localctx);
                  this._ctx = _localctx;
                  _prevctx = _localctx;
                  this.state = 951;
                  this.match(_ApexParser.NEW);
                  this.state = 952;
                  this.creator();
                }
                break;
              case 4:
                {
                  _localctx = new CastExpressionContext(_localctx);
                  this._ctx = _localctx;
                  _prevctx = _localctx;
                  this.state = 953;
                  this.match(_ApexParser.LPAREN);
                  this.state = 954;
                  this.typeRef();
                  this.state = 955;
                  this.match(_ApexParser.RPAREN);
                  this.state = 956;
                  this.expression(19);
                }
                break;
              case 5:
                {
                  _localctx = new SubExpressionContext(_localctx);
                  this._ctx = _localctx;
                  _prevctx = _localctx;
                  this.state = 958;
                  this.match(_ApexParser.LPAREN);
                  this.state = 959;
                  this.expression(0);
                  this.state = 960;
                  this.match(_ApexParser.RPAREN);
                }
                break;
              case 6:
                {
                  _localctx = new PreOpExpressionContext(_localctx);
                  this._ctx = _localctx;
                  _prevctx = _localctx;
                  this.state = 962;
                  _la = this._input.LA(1);
                  if (!((_la - 226 & ~31) === 0 && (1 << _la - 226 & (1 << _ApexParser.INC - 226 | 1 << _ApexParser.DEC - 226 | 1 << _ApexParser.ADD - 226 | 1 << _ApexParser.SUB - 226)) !== 0)) {
                    this._errHandler.recoverInline(this);
                  } else {
                    if (this._input.LA(1) === Token_1.Token.EOF) {
                      this.matchedEOF = true;
                    }
                    this._errHandler.reportMatch(this);
                    this.consume();
                  }
                  this.state = 963;
                  this.expression(16);
                }
                break;
              case 7:
                {
                  _localctx = new NegExpressionContext(_localctx);
                  this._ctx = _localctx;
                  _prevctx = _localctx;
                  this.state = 964;
                  _la = this._input.LA(1);
                  if (!(_la === _ApexParser.BANG || _la === _ApexParser.TILDE)) {
                    this._errHandler.recoverInline(this);
                  } else {
                    if (this._input.LA(1) === Token_1.Token.EOF) {
                      this.matchedEOF = true;
                    }
                    this._errHandler.reportMatch(this);
                    this.consume();
                  }
                  this.state = 965;
                  this.expression(15);
                }
                break;
            }
            this._ctx._stop = this._input.tryLT(-1);
            this.state = 1039;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                if (this._parseListeners != null) {
                  this.triggerExitRuleEvent();
                }
                _prevctx = _localctx;
                {
                  this.state = 1037;
                  this._errHandler.sync(this);
                  switch (this.interpreter.adaptivePredict(this._input, 90, this._ctx)) {
                    case 1:
                      {
                        _localctx = new Arth1ExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 968;
                        if (!this.precpred(this._ctx, 14)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 14)");
                        }
                        this.state = 969;
                        _la = this._input.LA(1);
                        if (!(_la === _ApexParser.MUL || _la === _ApexParser.DIV)) {
                          this._errHandler.recoverInline(this);
                        } else {
                          if (this._input.LA(1) === Token_1.Token.EOF) {
                            this.matchedEOF = true;
                          }
                          this._errHandler.reportMatch(this);
                          this.consume();
                        }
                        this.state = 970;
                        this.expression(15);
                      }
                      break;
                    case 2:
                      {
                        _localctx = new Arth2ExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 971;
                        if (!this.precpred(this._ctx, 13)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 13)");
                        }
                        this.state = 972;
                        _la = this._input.LA(1);
                        if (!(_la === _ApexParser.ADD || _la === _ApexParser.SUB)) {
                          this._errHandler.recoverInline(this);
                        } else {
                          if (this._input.LA(1) === Token_1.Token.EOF) {
                            this.matchedEOF = true;
                          }
                          this._errHandler.reportMatch(this);
                          this.consume();
                        }
                        this.state = 973;
                        this.expression(14);
                      }
                      break;
                    case 3:
                      {
                        _localctx = new BitExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 974;
                        if (!this.precpred(this._ctx, 12)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 12)");
                        }
                        this.state = 982;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 87, this._ctx)) {
                          case 1:
                            {
                              this.state = 975;
                              this.match(_ApexParser.LT);
                              this.state = 976;
                              this.match(_ApexParser.LT);
                            }
                            break;
                          case 2:
                            {
                              this.state = 977;
                              this.match(_ApexParser.GT);
                              this.state = 978;
                              this.match(_ApexParser.GT);
                              this.state = 979;
                              this.match(_ApexParser.GT);
                            }
                            break;
                          case 3:
                            {
                              this.state = 980;
                              this.match(_ApexParser.GT);
                              this.state = 981;
                              this.match(_ApexParser.GT);
                            }
                            break;
                        }
                        this.state = 984;
                        this.expression(13);
                      }
                      break;
                    case 4:
                      {
                        _localctx = new CmpExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 985;
                        if (!this.precpred(this._ctx, 11)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 11)");
                        }
                        this.state = 986;
                        _la = this._input.LA(1);
                        if (!(_la === _ApexParser.GT || _la === _ApexParser.LT)) {
                          this._errHandler.recoverInline(this);
                        } else {
                          if (this._input.LA(1) === Token_1.Token.EOF) {
                            this.matchedEOF = true;
                          }
                          this._errHandler.reportMatch(this);
                          this.consume();
                        }
                        this.state = 988;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                        if (_la === _ApexParser.ASSIGN) {
                          {
                            this.state = 987;
                            this.match(_ApexParser.ASSIGN);
                          }
                        }
                        this.state = 990;
                        this.expression(12);
                      }
                      break;
                    case 5:
                      {
                        _localctx = new EqualityExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 991;
                        if (!this.precpred(this._ctx, 9)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 9)");
                        }
                        this.state = 992;
                        _la = this._input.LA(1);
                        if (!((_la - 218 & ~31) === 0 && (1 << _la - 218 & (1 << _ApexParser.EQUAL - 218 | 1 << _ApexParser.TRIPLEEQUAL - 218 | 1 << _ApexParser.NOTEQUAL - 218 | 1 << _ApexParser.LESSANDGREATER - 218 | 1 << _ApexParser.TRIPLENOTEQUAL - 218)) !== 0)) {
                          this._errHandler.recoverInline(this);
                        } else {
                          if (this._input.LA(1) === Token_1.Token.EOF) {
                            this.matchedEOF = true;
                          }
                          this._errHandler.reportMatch(this);
                          this.consume();
                        }
                        this.state = 993;
                        this.expression(10);
                      }
                      break;
                    case 6:
                      {
                        _localctx = new BitAndExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 994;
                        if (!this.precpred(this._ctx, 8)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 8)");
                        }
                        this.state = 995;
                        this.match(_ApexParser.BITAND);
                        this.state = 996;
                        this.expression(9);
                      }
                      break;
                    case 7:
                      {
                        _localctx = new BitNotExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 997;
                        if (!this.precpred(this._ctx, 7)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 7)");
                        }
                        this.state = 998;
                        this.match(_ApexParser.CARET);
                        this.state = 999;
                        this.expression(8);
                      }
                      break;
                    case 8:
                      {
                        _localctx = new BitOrExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1e3;
                        if (!this.precpred(this._ctx, 6)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 6)");
                        }
                        this.state = 1001;
                        this.match(_ApexParser.BITOR);
                        this.state = 1002;
                        this.expression(7);
                      }
                      break;
                    case 9:
                      {
                        _localctx = new LogAndExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1003;
                        if (!this.precpred(this._ctx, 5)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 5)");
                        }
                        this.state = 1004;
                        this.match(_ApexParser.AND);
                        this.state = 1005;
                        this.expression(6);
                      }
                      break;
                    case 10:
                      {
                        _localctx = new LogOrExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1006;
                        if (!this.precpred(this._ctx, 4)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 4)");
                        }
                        this.state = 1007;
                        this.match(_ApexParser.OR);
                        this.state = 1008;
                        this.expression(5);
                      }
                      break;
                    case 11:
                      {
                        _localctx = new CoalExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1009;
                        if (!this.precpred(this._ctx, 3)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 3)");
                        }
                        this.state = 1010;
                        this.match(_ApexParser.COAL);
                        this.state = 1011;
                        this.expression(4);
                      }
                      break;
                    case 12:
                      {
                        _localctx = new CondExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1012;
                        if (!this.precpred(this._ctx, 2)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 2)");
                        }
                        this.state = 1013;
                        this.match(_ApexParser.QUESTION);
                        this.state = 1014;
                        this.expression(0);
                        this.state = 1015;
                        this.match(_ApexParser.COLON);
                        this.state = 1016;
                        this.expression(2);
                      }
                      break;
                    case 13:
                      {
                        _localctx = new AssignExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1018;
                        if (!this.precpred(this._ctx, 1)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                        }
                        this.state = 1019;
                        _la = this._input.LA(1);
                        if (!((_la - 210 & ~31) === 0 && (1 << _la - 210 & (1 << _ApexParser.ASSIGN - 210 | 1 << _ApexParser.ADD_ASSIGN - 210 | 1 << _ApexParser.SUB_ASSIGN - 210 | 1 << _ApexParser.MUL_ASSIGN - 210 | 1 << _ApexParser.DIV_ASSIGN - 210 | 1 << _ApexParser.AND_ASSIGN - 210 | 1 << _ApexParser.OR_ASSIGN - 210)) !== 0 || (_la - 242 & ~31) === 0 && (1 << _la - 242 & (1 << _ApexParser.XOR_ASSIGN - 242 | 1 << _ApexParser.LSHIFT_ASSIGN - 242 | 1 << _ApexParser.RSHIFT_ASSIGN - 242 | 1 << _ApexParser.URSHIFT_ASSIGN - 242)) !== 0)) {
                          this._errHandler.recoverInline(this);
                        } else {
                          if (this._input.LA(1) === Token_1.Token.EOF) {
                            this.matchedEOF = true;
                          }
                          this._errHandler.reportMatch(this);
                          this.consume();
                        }
                        this.state = 1020;
                        this.expression(1);
                      }
                      break;
                    case 14:
                      {
                        _localctx = new DotExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1021;
                        if (!this.precpred(this._ctx, 23)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 23)");
                        }
                        this.state = 1022;
                        _la = this._input.LA(1);
                        if (!(_la === _ApexParser.DOT || _la === _ApexParser.QUESTIONDOT)) {
                          this._errHandler.recoverInline(this);
                        } else {
                          if (this._input.LA(1) === Token_1.Token.EOF) {
                            this.matchedEOF = true;
                          }
                          this._errHandler.reportMatch(this);
                          this.consume();
                        }
                        this.state = 1025;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 89, this._ctx)) {
                          case 1:
                            {
                              this.state = 1023;
                              this.dotMethodCall();
                            }
                            break;
                          case 2:
                            {
                              this.state = 1024;
                              this.anyId();
                            }
                            break;
                        }
                      }
                      break;
                    case 15:
                      {
                        _localctx = new ArrayExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1027;
                        if (!this.precpred(this._ctx, 22)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 22)");
                        }
                        this.state = 1028;
                        this.match(_ApexParser.LBRACK);
                        this.state = 1029;
                        this.expression(0);
                        this.state = 1030;
                        this.match(_ApexParser.RBRACK);
                      }
                      break;
                    case 16:
                      {
                        _localctx = new PostOpExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1032;
                        if (!this.precpred(this._ctx, 17)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 17)");
                        }
                        this.state = 1033;
                        _la = this._input.LA(1);
                        if (!(_la === _ApexParser.INC || _la === _ApexParser.DEC)) {
                          this._errHandler.recoverInline(this);
                        } else {
                          if (this._input.LA(1) === Token_1.Token.EOF) {
                            this.matchedEOF = true;
                          }
                          this._errHandler.reportMatch(this);
                          this.consume();
                        }
                      }
                      break;
                    case 17:
                      {
                        _localctx = new InstanceOfExpressionContext(new ExpressionContext(_parentctx, _parentState));
                        this.pushNewRecursionContext(_localctx, _startState, _ApexParser.RULE_expression);
                        this.state = 1034;
                        if (!this.precpred(this._ctx, 10)) {
                          throw this.createFailedPredicateException("this.precpred(this._ctx, 10)");
                        }
                        this.state = 1035;
                        this.match(_ApexParser.INSTANCEOF);
                        this.state = 1036;
                        this.typeRef();
                      }
                      break;
                  }
                }
              }
              this.state = 1041;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.unrollRecursionContexts(_parentctx);
        }
        return _localctx;
      }
      // @RuleVersion(0)
      primary() {
        let _localctx = new PrimaryContext(this._ctx, this.state);
        this.enterRule(_localctx, 154, _ApexParser.RULE_primary);
        try {
          this.state = 1055;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 92, this._ctx)) {
            case 1:
              _localctx = new ThisPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1042;
                this.match(_ApexParser.THIS);
              }
              break;
            case 2:
              _localctx = new SuperPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1043;
                this.match(_ApexParser.SUPER);
              }
              break;
            case 3:
              _localctx = new LiteralPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1044;
                this.literal();
              }
              break;
            case 4:
              _localctx = new TypeRefPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1045;
                this.typeRef();
                this.state = 1046;
                this.match(_ApexParser.DOT);
                this.state = 1047;
                this.match(_ApexParser.CLASS);
              }
              break;
            case 5:
              _localctx = new VoidPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 1049;
                this.match(_ApexParser.VOID);
                this.state = 1050;
                this.match(_ApexParser.DOT);
                this.state = 1051;
                this.match(_ApexParser.CLASS);
              }
              break;
            case 6:
              _localctx = new IdPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 1052;
                this.id();
              }
              break;
            case 7:
              _localctx = new SoqlPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 1053;
                this.soqlLiteral();
              }
              break;
            case 8:
              _localctx = new SoslPrimaryContext(_localctx);
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 1054;
                this.soslLiteral();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      methodCall() {
        let _localctx = new MethodCallContext(this._ctx, this.state);
        this.enterRule(_localctx, 156, _ApexParser.RULE_methodCall);
        let _la;
        try {
          this.state = 1076;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.AFTER:
            case _ApexParser.BEFORE:
            case _ApexParser.GET:
            case _ApexParser.INHERITED:
            case _ApexParser.INSTANCEOF:
            case _ApexParser.SET:
            case _ApexParser.SHARING:
            case _ApexParser.SWITCH:
            case _ApexParser.TRANSIENT:
            case _ApexParser.TRIGGER:
            case _ApexParser.WHEN:
            case _ApexParser.WITH:
            case _ApexParser.WITHOUT:
            case _ApexParser.SYSTEM:
            case _ApexParser.USER:
            case _ApexParser.SELECT:
            case _ApexParser.COUNT:
            case _ApexParser.FROM:
            case _ApexParser.AS:
            case _ApexParser.USING:
            case _ApexParser.SCOPE:
            case _ApexParser.WHERE:
            case _ApexParser.ORDER:
            case _ApexParser.BY:
            case _ApexParser.LIMIT:
            case _ApexParser.SOQLAND:
            case _ApexParser.SOQLOR:
            case _ApexParser.NOT:
            case _ApexParser.AVG:
            case _ApexParser.COUNT_DISTINCT:
            case _ApexParser.MIN:
            case _ApexParser.MAX:
            case _ApexParser.SUM:
            case _ApexParser.TYPEOF:
            case _ApexParser.END:
            case _ApexParser.THEN:
            case _ApexParser.LIKE:
            case _ApexParser.IN:
            case _ApexParser.INCLUDES:
            case _ApexParser.EXCLUDES:
            case _ApexParser.ASC:
            case _ApexParser.DESC:
            case _ApexParser.NULLS:
            case _ApexParser.FIRST:
            case _ApexParser.LAST:
            case _ApexParser.GROUP:
            case _ApexParser.ALL:
            case _ApexParser.ROWS:
            case _ApexParser.VIEW:
            case _ApexParser.HAVING:
            case _ApexParser.ROLLUP:
            case _ApexParser.TOLABEL:
            case _ApexParser.OFFSET:
            case _ApexParser.DATA:
            case _ApexParser.CATEGORY:
            case _ApexParser.AT:
            case _ApexParser.ABOVE:
            case _ApexParser.BELOW:
            case _ApexParser.ABOVE_OR_BELOW:
            case _ApexParser.SECURITY_ENFORCED:
            case _ApexParser.SYSTEM_MODE:
            case _ApexParser.USER_MODE:
            case _ApexParser.REFERENCE:
            case _ApexParser.CUBE:
            case _ApexParser.FORMAT:
            case _ApexParser.TRACKING:
            case _ApexParser.VIEWSTAT:
            case _ApexParser.CUSTOM:
            case _ApexParser.STANDARD:
            case _ApexParser.DISTANCE:
            case _ApexParser.GEOLOCATION:
            case _ApexParser.GROUPING:
            case _ApexParser.CONVERT_CURRENCY:
            case _ApexParser.CALENDAR_MONTH:
            case _ApexParser.CALENDAR_QUARTER:
            case _ApexParser.CALENDAR_YEAR:
            case _ApexParser.DAY_IN_MONTH:
            case _ApexParser.DAY_IN_WEEK:
            case _ApexParser.DAY_IN_YEAR:
            case _ApexParser.DAY_ONLY:
            case _ApexParser.FISCAL_MONTH:
            case _ApexParser.FISCAL_QUARTER:
            case _ApexParser.FISCAL_YEAR:
            case _ApexParser.HOUR_IN_DAY:
            case _ApexParser.WEEK_IN_MONTH:
            case _ApexParser.WEEK_IN_YEAR:
            case _ApexParser.CONVERT_TIMEZONE:
            case _ApexParser.YESTERDAY:
            case _ApexParser.TODAY:
            case _ApexParser.TOMORROW:
            case _ApexParser.LAST_WEEK:
            case _ApexParser.THIS_WEEK:
            case _ApexParser.NEXT_WEEK:
            case _ApexParser.LAST_MONTH:
            case _ApexParser.THIS_MONTH:
            case _ApexParser.NEXT_MONTH:
            case _ApexParser.LAST_90_DAYS:
            case _ApexParser.NEXT_90_DAYS:
            case _ApexParser.LAST_N_DAYS_N:
            case _ApexParser.NEXT_N_DAYS_N:
            case _ApexParser.N_DAYS_AGO_N:
            case _ApexParser.NEXT_N_WEEKS_N:
            case _ApexParser.LAST_N_WEEKS_N:
            case _ApexParser.N_WEEKS_AGO_N:
            case _ApexParser.NEXT_N_MONTHS_N:
            case _ApexParser.LAST_N_MONTHS_N:
            case _ApexParser.N_MONTHS_AGO_N:
            case _ApexParser.THIS_QUARTER:
            case _ApexParser.LAST_QUARTER:
            case _ApexParser.NEXT_QUARTER:
            case _ApexParser.NEXT_N_QUARTERS_N:
            case _ApexParser.LAST_N_QUARTERS_N:
            case _ApexParser.N_QUARTERS_AGO_N:
            case _ApexParser.THIS_YEAR:
            case _ApexParser.LAST_YEAR:
            case _ApexParser.NEXT_YEAR:
            case _ApexParser.NEXT_N_YEARS_N:
            case _ApexParser.LAST_N_YEARS_N:
            case _ApexParser.N_YEARS_AGO_N:
            case _ApexParser.THIS_FISCAL_QUARTER:
            case _ApexParser.LAST_FISCAL_QUARTER:
            case _ApexParser.NEXT_FISCAL_QUARTER:
            case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
            case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
            case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
            case _ApexParser.THIS_FISCAL_YEAR:
            case _ApexParser.LAST_FISCAL_YEAR:
            case _ApexParser.NEXT_FISCAL_YEAR:
            case _ApexParser.NEXT_N_FISCAL_YEARS_N:
            case _ApexParser.LAST_N_FISCAL_YEARS_N:
            case _ApexParser.N_FISCAL_YEARS_AGO_N:
            case _ApexParser.IntegralCurrencyLiteral:
            case _ApexParser.FIND:
            case _ApexParser.EMAIL:
            case _ApexParser.NAME:
            case _ApexParser.PHONE:
            case _ApexParser.SIDEBAR:
            case _ApexParser.FIELDS:
            case _ApexParser.METADATA:
            case _ApexParser.PRICEBOOKID:
            case _ApexParser.NETWORK:
            case _ApexParser.SNIPPET:
            case _ApexParser.TARGET_LENGTH:
            case _ApexParser.DIVISION:
            case _ApexParser.RETURNING:
            case _ApexParser.LISTVIEW:
            case _ApexParser.Identifier:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1057;
                this.id();
                this.state = 1058;
                this.match(_ApexParser.LPAREN);
                this.state = 1060;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
                  {
                    this.state = 1059;
                    this.expressionList();
                  }
                }
                this.state = 1062;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case _ApexParser.THIS:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1064;
                this.match(_ApexParser.THIS);
                this.state = 1065;
                this.match(_ApexParser.LPAREN);
                this.state = 1067;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
                  {
                    this.state = 1066;
                    this.expressionList();
                  }
                }
                this.state = 1069;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case _ApexParser.SUPER:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1070;
                this.match(_ApexParser.SUPER);
                this.state = 1071;
                this.match(_ApexParser.LPAREN);
                this.state = 1073;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
                  {
                    this.state = 1072;
                    this.expressionList();
                  }
                }
                this.state = 1075;
                this.match(_ApexParser.RPAREN);
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      dotMethodCall() {
        let _localctx = new DotMethodCallContext(this._ctx, this.state);
        this.enterRule(_localctx, 158, _ApexParser.RULE_dotMethodCall);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1078;
            this.anyId();
            this.state = 1079;
            this.match(_ApexParser.LPAREN);
            this.state = 1081;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
              {
                this.state = 1080;
                this.expressionList();
              }
            }
            this.state = 1083;
            this.match(_ApexParser.RPAREN);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      creator() {
        let _localctx = new CreatorContext(this._ctx, this.state);
        this.enterRule(_localctx, 160, _ApexParser.RULE_creator);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1085;
            this.createdName();
            this.state = 1091;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 98, this._ctx)) {
              case 1:
                {
                  this.state = 1086;
                  this.noRest();
                }
                break;
              case 2:
                {
                  this.state = 1087;
                  this.classCreatorRest();
                }
                break;
              case 3:
                {
                  this.state = 1088;
                  this.arrayCreatorRest();
                }
                break;
              case 4:
                {
                  this.state = 1089;
                  this.mapCreatorRest();
                }
                break;
              case 5:
                {
                  this.state = 1090;
                  this.setCreatorRest();
                }
                break;
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      createdName() {
        let _localctx = new CreatedNameContext(this._ctx, this.state);
        this.enterRule(_localctx, 162, _ApexParser.RULE_createdName);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1093;
            this.idCreatedNamePair();
            this.state = 1098;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.DOT) {
              {
                {
                  this.state = 1094;
                  this.match(_ApexParser.DOT);
                  this.state = 1095;
                  this.idCreatedNamePair();
                }
              }
              this.state = 1100;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      idCreatedNamePair() {
        let _localctx = new IdCreatedNamePairContext(this._ctx, this.state);
        this.enterRule(_localctx, 164, _ApexParser.RULE_idCreatedNamePair);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1101;
            this.anyId();
            this.state = 1106;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.LT) {
              {
                this.state = 1102;
                this.match(_ApexParser.LT);
                this.state = 1103;
                this.typeList();
                this.state = 1104;
                this.match(_ApexParser.GT);
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      noRest() {
        let _localctx = new NoRestContext(this._ctx, this.state);
        this.enterRule(_localctx, 166, _ApexParser.RULE_noRest);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1108;
            this.match(_ApexParser.LBRACE);
            this.state = 1109;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      classCreatorRest() {
        let _localctx = new ClassCreatorRestContext(this._ctx, this.state);
        this.enterRule(_localctx, 168, _ApexParser.RULE_classCreatorRest);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1111;
            this.arguments();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      arrayCreatorRest() {
        let _localctx = new ArrayCreatorRestContext(this._ctx, this.state);
        this.enterRule(_localctx, 170, _ApexParser.RULE_arrayCreatorRest);
        try {
          this.state = 1122;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 102, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1113;
                this.match(_ApexParser.LBRACK);
                this.state = 1114;
                this.expression(0);
                this.state = 1115;
                this.match(_ApexParser.RBRACK);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1117;
                this.match(_ApexParser.LBRACK);
                this.state = 1118;
                this.match(_ApexParser.RBRACK);
                this.state = 1120;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 101, this._ctx)) {
                  case 1:
                    {
                      this.state = 1119;
                      this.arrayInitializer();
                    }
                    break;
                }
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      mapCreatorRest() {
        let _localctx = new MapCreatorRestContext(this._ctx, this.state);
        this.enterRule(_localctx, 172, _ApexParser.RULE_mapCreatorRest);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1124;
            this.match(_ApexParser.LBRACE);
            this.state = 1125;
            this.mapCreatorRestPair();
            this.state = 1130;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1126;
                  this.match(_ApexParser.COMMA);
                  this.state = 1127;
                  this.mapCreatorRestPair();
                }
              }
              this.state = 1132;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1133;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      mapCreatorRestPair() {
        let _localctx = new MapCreatorRestPairContext(this._ctx, this.state);
        this.enterRule(_localctx, 174, _ApexParser.RULE_mapCreatorRestPair);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1135;
            this.expression(0);
            this.state = 1136;
            this.match(_ApexParser.MAPTO);
            this.state = 1137;
            this.expression(0);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      setCreatorRest() {
        let _localctx = new SetCreatorRestContext(this._ctx, this.state);
        this.enterRule(_localctx, 176, _ApexParser.RULE_setCreatorRest);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1139;
            this.match(_ApexParser.LBRACE);
            this.state = 1140;
            this.expression(0);
            this.state = 1145;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1141;
                  this.match(_ApexParser.COMMA);
                  {
                    this.state = 1142;
                    this.expression(0);
                  }
                }
              }
              this.state = 1147;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1148;
            this.match(_ApexParser.RBRACE);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      arguments() {
        let _localctx = new ArgumentsContext(this._ctx, this.state);
        this.enterRule(_localctx, 178, _ApexParser.RULE_arguments);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1150;
            this.match(_ApexParser.LPAREN);
            this.state = 1152;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF | 1 << _ApexParser.NEW | 1 << _ApexParser.NULL)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.VOID - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162 | 1 << _ApexParser.FindLiteral - 162)) !== 0 || (_la - 195 & ~31) === 0 && (1 << _la - 195 & (1 << _ApexParser.IntegerLiteral - 195 | 1 << _ApexParser.LongLiteral - 195 | 1 << _ApexParser.NumberLiteral - 195 | 1 << _ApexParser.BooleanLiteral - 195 | 1 << _ApexParser.StringLiteral - 195 | 1 << _ApexParser.LPAREN - 195 | 1 << _ApexParser.LBRACK - 195 | 1 << _ApexParser.BANG - 195 | 1 << _ApexParser.TILDE - 195 | 1 << _ApexParser.INC - 195)) !== 0 || (_la - 227 & ~31) === 0 && (1 << _la - 227 & (1 << _ApexParser.DEC - 227 | 1 << _ApexParser.ADD - 227 | 1 << _ApexParser.SUB - 227 | 1 << _ApexParser.Identifier - 227)) !== 0) {
              {
                this.state = 1151;
                this.expressionList();
              }
            }
            this.state = 1154;
            this.match(_ApexParser.RPAREN);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soqlLiteral() {
        let _localctx = new SoqlLiteralContext(this._ctx, this.state);
        this.enterRule(_localctx, 180, _ApexParser.RULE_soqlLiteral);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1156;
            this.match(_ApexParser.LBRACK);
            this.state = 1157;
            this.query();
            this.state = 1158;
            this.match(_ApexParser.RBRACK);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      query() {
        let _localctx = new QueryContext(this._ctx, this.state);
        this.enterRule(_localctx, 182, _ApexParser.RULE_query);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1160;
            this.match(_ApexParser.SELECT);
            this.state = 1161;
            this.selectList();
            this.state = 1162;
            this.match(_ApexParser.FROM);
            this.state = 1163;
            this.fromNameList();
            this.state = 1165;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.USING) {
              {
                this.state = 1164;
                this.usingScope();
              }
            }
            this.state = 1168;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.WHERE) {
              {
                this.state = 1167;
                this.whereClause();
              }
            }
            this.state = 1171;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.WITH) {
              {
                this.state = 1170;
                this.withClause();
              }
            }
            this.state = 1174;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.GROUP) {
              {
                this.state = 1173;
                this.groupByClause();
              }
            }
            this.state = 1177;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.ORDER) {
              {
                this.state = 1176;
                this.orderByClause();
              }
            }
            this.state = 1180;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.LIMIT) {
              {
                this.state = 1179;
                this.limitClause();
              }
            }
            this.state = 1183;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.OFFSET) {
              {
                this.state = 1182;
                this.offsetClause();
              }
            }
            this.state = 1186;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.ALL) {
              {
                this.state = 1185;
                this.allRowsClause();
              }
            }
            this.state = 1188;
            this.forClauses();
            this.state = 1191;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.UPDATE) {
              {
                this.state = 1189;
                this.match(_ApexParser.UPDATE);
                this.state = 1190;
                this.updateList();
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      subQuery() {
        let _localctx = new SubQueryContext(this._ctx, this.state);
        this.enterRule(_localctx, 184, _ApexParser.RULE_subQuery);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1193;
            this.match(_ApexParser.SELECT);
            this.state = 1194;
            this.subFieldList();
            this.state = 1195;
            this.match(_ApexParser.FROM);
            this.state = 1196;
            this.fromNameList();
            this.state = 1198;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.WHERE) {
              {
                this.state = 1197;
                this.whereClause();
              }
            }
            this.state = 1201;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.ORDER) {
              {
                this.state = 1200;
                this.orderByClause();
              }
            }
            this.state = 1204;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.LIMIT) {
              {
                this.state = 1203;
                this.limitClause();
              }
            }
            this.state = 1206;
            this.forClauses();
            this.state = 1209;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.UPDATE) {
              {
                this.state = 1207;
                this.match(_ApexParser.UPDATE);
                this.state = 1208;
                this.updateList();
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      selectList() {
        let _localctx = new SelectListContext(this._ctx, this.state);
        this.enterRule(_localctx, 186, _ApexParser.RULE_selectList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1211;
            this.selectEntry();
            this.state = 1216;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1212;
                  this.match(_ApexParser.COMMA);
                  this.state = 1213;
                  this.selectEntry();
                }
              }
              this.state = 1218;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      selectEntry() {
        let _localctx = new SelectEntryContext(this._ctx, this.state);
        this.enterRule(_localctx, 188, _ApexParser.RULE_selectEntry);
        try {
          this.state = 1234;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 123, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1219;
                this.fieldName();
                this.state = 1221;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 120, this._ctx)) {
                  case 1:
                    {
                      this.state = 1220;
                      this.soqlId();
                    }
                    break;
                }
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1223;
                this.soqlFunction();
                this.state = 1225;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 121, this._ctx)) {
                  case 1:
                    {
                      this.state = 1224;
                      this.soqlId();
                    }
                    break;
                }
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1227;
                this.match(_ApexParser.LPAREN);
                this.state = 1228;
                this.subQuery();
                this.state = 1229;
                this.match(_ApexParser.RPAREN);
                this.state = 1231;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 122, this._ctx)) {
                  case 1:
                    {
                      this.state = 1230;
                      this.soqlId();
                    }
                    break;
                }
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1233;
                this.typeOf();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldName() {
        let _localctx = new FieldNameContext(this._ctx, this.state);
        this.enterRule(_localctx, 190, _ApexParser.RULE_fieldName);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1236;
            this.soqlId();
            this.state = 1241;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.DOT) {
              {
                {
                  this.state = 1237;
                  this.match(_ApexParser.DOT);
                  this.state = 1238;
                  this.soqlId();
                }
              }
              this.state = 1243;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fromNameList() {
        let _localctx = new FromNameListContext(this._ctx, this.state);
        this.enterRule(_localctx, 192, _ApexParser.RULE_fromNameList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1244;
            this.fieldName();
            this.state = 1246;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 125, this._ctx)) {
              case 1:
                {
                  this.state = 1245;
                  this.soqlId();
                }
                break;
            }
            this.state = 1255;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1248;
                  this.match(_ApexParser.COMMA);
                  this.state = 1249;
                  this.fieldName();
                  this.state = 1251;
                  this._errHandler.sync(this);
                  switch (this.interpreter.adaptivePredict(this._input, 126, this._ctx)) {
                    case 1:
                      {
                        this.state = 1250;
                        this.soqlId();
                      }
                      break;
                  }
                }
              }
              this.state = 1257;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      subFieldList() {
        let _localctx = new SubFieldListContext(this._ctx, this.state);
        this.enterRule(_localctx, 194, _ApexParser.RULE_subFieldList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1258;
            this.subFieldEntry();
            this.state = 1263;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1259;
                  this.match(_ApexParser.COMMA);
                  this.state = 1260;
                  this.subFieldEntry();
                }
              }
              this.state = 1265;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      subFieldEntry() {
        let _localctx = new SubFieldEntryContext(this._ctx, this.state);
        this.enterRule(_localctx, 196, _ApexParser.RULE_subFieldEntry);
        try {
          this.state = 1281;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 132, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1266;
                this.fieldName();
                this.state = 1268;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 129, this._ctx)) {
                  case 1:
                    {
                      this.state = 1267;
                      this.soqlId();
                    }
                    break;
                }
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1270;
                this.soqlFunction();
                this.state = 1272;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 130, this._ctx)) {
                  case 1:
                    {
                      this.state = 1271;
                      this.soqlId();
                    }
                    break;
                }
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1274;
                this.match(_ApexParser.LPAREN);
                this.state = 1275;
                this.subQuery();
                this.state = 1276;
                this.match(_ApexParser.RPAREN);
                this.state = 1278;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 131, this._ctx)) {
                  case 1:
                    {
                      this.state = 1277;
                      this.soqlId();
                    }
                    break;
                }
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1280;
                this.typeOf();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soqlFieldsParameter() {
        let _localctx = new SoqlFieldsParameterContext(this._ctx, this.state);
        this.enterRule(_localctx, 198, _ApexParser.RULE_soqlFieldsParameter);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1283;
            _la = this._input.LA(1);
            if (!((_la - 90 & ~31) === 0 && (1 << _la - 90 & (1 << _ApexParser.ALL - 90 | 1 << _ApexParser.CUSTOM - 90 | 1 << _ApexParser.STANDARD - 90)) !== 0)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soqlFunction() {
        let _localctx = new SoqlFunctionContext(this._ctx, this.state);
        this.enterRule(_localctx, 200, _ApexParser.RULE_soqlFunction);
        try {
          this.state = 1420;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 134, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1285;
                this.match(_ApexParser.AVG);
                this.state = 1286;
                this.match(_ApexParser.LPAREN);
                this.state = 1287;
                this.fieldName();
                this.state = 1288;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1290;
                this.match(_ApexParser.COUNT);
                this.state = 1291;
                this.match(_ApexParser.LPAREN);
                this.state = 1292;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1293;
                this.match(_ApexParser.COUNT);
                this.state = 1294;
                this.match(_ApexParser.LPAREN);
                this.state = 1295;
                this.fieldName();
                this.state = 1296;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1298;
                this.match(_ApexParser.COUNT_DISTINCT);
                this.state = 1299;
                this.match(_ApexParser.LPAREN);
                this.state = 1300;
                this.fieldName();
                this.state = 1301;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 1303;
                this.match(_ApexParser.MIN);
                this.state = 1304;
                this.match(_ApexParser.LPAREN);
                this.state = 1305;
                this.fieldName();
                this.state = 1306;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 1308;
                this.match(_ApexParser.MAX);
                this.state = 1309;
                this.match(_ApexParser.LPAREN);
                this.state = 1310;
                this.fieldName();
                this.state = 1311;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 7:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 1313;
                this.match(_ApexParser.SUM);
                this.state = 1314;
                this.match(_ApexParser.LPAREN);
                this.state = 1315;
                this.fieldName();
                this.state = 1316;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 8:
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 1318;
                this.match(_ApexParser.TOLABEL);
                this.state = 1319;
                this.match(_ApexParser.LPAREN);
                this.state = 1320;
                this.fieldName();
                this.state = 1321;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 9:
              this.enterOuterAlt(_localctx, 9);
              {
                this.state = 1323;
                this.match(_ApexParser.FORMAT);
                this.state = 1324;
                this.match(_ApexParser.LPAREN);
                this.state = 1327;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 133, this._ctx)) {
                  case 1:
                    {
                      this.state = 1325;
                      this.fieldName();
                    }
                    break;
                  case 2:
                    {
                      this.state = 1326;
                      this.soqlFunction();
                    }
                    break;
                }
                this.state = 1329;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 10:
              this.enterOuterAlt(_localctx, 10);
              {
                this.state = 1331;
                this.match(_ApexParser.CALENDAR_MONTH);
                this.state = 1332;
                this.match(_ApexParser.LPAREN);
                this.state = 1333;
                this.dateFieldName();
                this.state = 1334;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 11:
              this.enterOuterAlt(_localctx, 11);
              {
                this.state = 1336;
                this.match(_ApexParser.CALENDAR_QUARTER);
                this.state = 1337;
                this.match(_ApexParser.LPAREN);
                this.state = 1338;
                this.dateFieldName();
                this.state = 1339;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 12:
              this.enterOuterAlt(_localctx, 12);
              {
                this.state = 1341;
                this.match(_ApexParser.CALENDAR_YEAR);
                this.state = 1342;
                this.match(_ApexParser.LPAREN);
                this.state = 1343;
                this.dateFieldName();
                this.state = 1344;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 13:
              this.enterOuterAlt(_localctx, 13);
              {
                this.state = 1346;
                this.match(_ApexParser.DAY_IN_MONTH);
                this.state = 1347;
                this.match(_ApexParser.LPAREN);
                this.state = 1348;
                this.dateFieldName();
                this.state = 1349;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 14:
              this.enterOuterAlt(_localctx, 14);
              {
                this.state = 1351;
                this.match(_ApexParser.DAY_IN_WEEK);
                this.state = 1352;
                this.match(_ApexParser.LPAREN);
                this.state = 1353;
                this.dateFieldName();
                this.state = 1354;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 15:
              this.enterOuterAlt(_localctx, 15);
              {
                this.state = 1356;
                this.match(_ApexParser.DAY_IN_YEAR);
                this.state = 1357;
                this.match(_ApexParser.LPAREN);
                this.state = 1358;
                this.dateFieldName();
                this.state = 1359;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 16:
              this.enterOuterAlt(_localctx, 16);
              {
                this.state = 1361;
                this.match(_ApexParser.DAY_ONLY);
                this.state = 1362;
                this.match(_ApexParser.LPAREN);
                this.state = 1363;
                this.dateFieldName();
                this.state = 1364;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 17:
              this.enterOuterAlt(_localctx, 17);
              {
                this.state = 1366;
                this.match(_ApexParser.FISCAL_MONTH);
                this.state = 1367;
                this.match(_ApexParser.LPAREN);
                this.state = 1368;
                this.dateFieldName();
                this.state = 1369;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 18:
              this.enterOuterAlt(_localctx, 18);
              {
                this.state = 1371;
                this.match(_ApexParser.FISCAL_QUARTER);
                this.state = 1372;
                this.match(_ApexParser.LPAREN);
                this.state = 1373;
                this.dateFieldName();
                this.state = 1374;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 19:
              this.enterOuterAlt(_localctx, 19);
              {
                this.state = 1376;
                this.match(_ApexParser.FISCAL_YEAR);
                this.state = 1377;
                this.match(_ApexParser.LPAREN);
                this.state = 1378;
                this.dateFieldName();
                this.state = 1379;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 20:
              this.enterOuterAlt(_localctx, 20);
              {
                this.state = 1381;
                this.match(_ApexParser.HOUR_IN_DAY);
                this.state = 1382;
                this.match(_ApexParser.LPAREN);
                this.state = 1383;
                this.dateFieldName();
                this.state = 1384;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 21:
              this.enterOuterAlt(_localctx, 21);
              {
                this.state = 1386;
                this.match(_ApexParser.WEEK_IN_MONTH);
                this.state = 1387;
                this.match(_ApexParser.LPAREN);
                this.state = 1388;
                this.dateFieldName();
                this.state = 1389;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 22:
              this.enterOuterAlt(_localctx, 22);
              {
                this.state = 1391;
                this.match(_ApexParser.WEEK_IN_YEAR);
                this.state = 1392;
                this.match(_ApexParser.LPAREN);
                this.state = 1393;
                this.dateFieldName();
                this.state = 1394;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 23:
              this.enterOuterAlt(_localctx, 23);
              {
                this.state = 1396;
                this.match(_ApexParser.FIELDS);
                this.state = 1397;
                this.match(_ApexParser.LPAREN);
                this.state = 1398;
                this.soqlFieldsParameter();
                this.state = 1399;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 24:
              this.enterOuterAlt(_localctx, 24);
              {
                this.state = 1401;
                this.match(_ApexParser.DISTANCE);
                this.state = 1402;
                this.match(_ApexParser.LPAREN);
                this.state = 1403;
                this.locationValue();
                this.state = 1404;
                this.match(_ApexParser.COMMA);
                this.state = 1405;
                this.locationValue();
                this.state = 1406;
                this.match(_ApexParser.COMMA);
                this.state = 1407;
                this.match(_ApexParser.StringLiteral);
                this.state = 1408;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 25:
              this.enterOuterAlt(_localctx, 25);
              {
                this.state = 1410;
                this.match(_ApexParser.GROUPING);
                this.state = 1411;
                this.match(_ApexParser.LPAREN);
                this.state = 1412;
                this.fieldName();
                this.state = 1413;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 26:
              this.enterOuterAlt(_localctx, 26);
              {
                this.state = 1415;
                this.match(_ApexParser.CONVERT_CURRENCY);
                this.state = 1416;
                this.match(_ApexParser.LPAREN);
                this.state = 1417;
                this.fieldName();
                this.state = 1418;
                this.match(_ApexParser.RPAREN);
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      dateFieldName() {
        let _localctx = new DateFieldNameContext(this._ctx, this.state);
        this.enterRule(_localctx, 202, _ApexParser.RULE_dateFieldName);
        try {
          this.state = 1428;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 135, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1422;
                this.match(_ApexParser.CONVERT_TIMEZONE);
                this.state = 1423;
                this.match(_ApexParser.LPAREN);
                this.state = 1424;
                this.fieldName();
                this.state = 1425;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1427;
                this.fieldName();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      locationValue() {
        let _localctx = new LocationValueContext(this._ctx, this.state);
        this.enterRule(_localctx, 204, _ApexParser.RULE_locationValue);
        try {
          this.state = 1439;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 136, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1430;
                this.fieldName();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1431;
                this.boundExpression();
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1432;
                this.match(_ApexParser.GEOLOCATION);
                this.state = 1433;
                this.match(_ApexParser.LPAREN);
                this.state = 1434;
                this.coordinateValue();
                this.state = 1435;
                this.match(_ApexParser.COMMA);
                this.state = 1436;
                this.coordinateValue();
                this.state = 1437;
                this.match(_ApexParser.RPAREN);
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      coordinateValue() {
        let _localctx = new CoordinateValueContext(this._ctx, this.state);
        this.enterRule(_localctx, 206, _ApexParser.RULE_coordinateValue);
        try {
          this.state = 1443;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.IntegerLiteral:
            case _ApexParser.NumberLiteral:
            case _ApexParser.ADD:
            case _ApexParser.SUB:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1441;
                this.signedNumber();
              }
              break;
            case _ApexParser.COLON:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1442;
                this.boundExpression();
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      typeOf() {
        let _localctx = new TypeOfContext(this._ctx, this.state);
        this.enterRule(_localctx, 208, _ApexParser.RULE_typeOf);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1445;
            this.match(_ApexParser.TYPEOF);
            this.state = 1446;
            this.fieldName();
            this.state = 1448;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
              {
                {
                  this.state = 1447;
                  this.whenClause();
                }
              }
              this.state = 1450;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            } while (_la === _ApexParser.WHEN);
            this.state = 1453;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.ELSE) {
              {
                this.state = 1452;
                this.elseClause();
              }
            }
            this.state = 1455;
            this.match(_ApexParser.END);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      whenClause() {
        let _localctx = new WhenClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 210, _ApexParser.RULE_whenClause);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1457;
            this.match(_ApexParser.WHEN);
            this.state = 1458;
            this.fieldName();
            this.state = 1459;
            this.match(_ApexParser.THEN);
            this.state = 1460;
            this.fieldNameList();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      elseClause() {
        let _localctx = new ElseClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 212, _ApexParser.RULE_elseClause);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1462;
            this.match(_ApexParser.ELSE);
            this.state = 1463;
            this.fieldNameList();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldNameList() {
        let _localctx = new FieldNameListContext(this._ctx, this.state);
        this.enterRule(_localctx, 214, _ApexParser.RULE_fieldNameList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1465;
            this.fieldName();
            this.state = 1470;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1466;
                  this.match(_ApexParser.COMMA);
                  this.state = 1467;
                  this.fieldName();
                }
              }
              this.state = 1472;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      usingScope() {
        let _localctx = new UsingScopeContext(this._ctx, this.state);
        this.enterRule(_localctx, 216, _ApexParser.RULE_usingScope);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1473;
            this.match(_ApexParser.USING);
            this.state = 1474;
            this.match(_ApexParser.SCOPE);
            this.state = 1475;
            this.soqlId();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      whereClause() {
        let _localctx = new WhereClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 218, _ApexParser.RULE_whereClause);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1477;
            this.match(_ApexParser.WHERE);
            this.state = 1478;
            this.logicalExpression();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      logicalExpression() {
        let _localctx = new LogicalExpressionContext(this._ctx, this.state);
        this.enterRule(_localctx, 220, _ApexParser.RULE_logicalExpression);
        let _la;
        try {
          this.state = 1498;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 143, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1480;
                this.conditionalExpression();
                this.state = 1485;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.SOQLAND) {
                  {
                    {
                      this.state = 1481;
                      this.match(_ApexParser.SOQLAND);
                      this.state = 1482;
                      this.conditionalExpression();
                    }
                  }
                  this.state = 1487;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1488;
                this.conditionalExpression();
                this.state = 1493;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.SOQLOR) {
                  {
                    {
                      this.state = 1489;
                      this.match(_ApexParser.SOQLOR);
                      this.state = 1490;
                      this.conditionalExpression();
                    }
                  }
                  this.state = 1495;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1496;
                this.match(_ApexParser.NOT);
                this.state = 1497;
                this.conditionalExpression();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      conditionalExpression() {
        let _localctx = new ConditionalExpressionContext(this._ctx, this.state);
        this.enterRule(_localctx, 222, _ApexParser.RULE_conditionalExpression);
        try {
          this.state = 1505;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.LPAREN:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1500;
                this.match(_ApexParser.LPAREN);
                this.state = 1501;
                this.logicalExpression();
                this.state = 1502;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case _ApexParser.AFTER:
            case _ApexParser.BEFORE:
            case _ApexParser.GET:
            case _ApexParser.INHERITED:
            case _ApexParser.INSTANCEOF:
            case _ApexParser.SET:
            case _ApexParser.SHARING:
            case _ApexParser.SWITCH:
            case _ApexParser.TRANSIENT:
            case _ApexParser.TRIGGER:
            case _ApexParser.WHEN:
            case _ApexParser.WITH:
            case _ApexParser.WITHOUT:
            case _ApexParser.SYSTEM:
            case _ApexParser.USER:
            case _ApexParser.SELECT:
            case _ApexParser.COUNT:
            case _ApexParser.FROM:
            case _ApexParser.AS:
            case _ApexParser.USING:
            case _ApexParser.SCOPE:
            case _ApexParser.WHERE:
            case _ApexParser.ORDER:
            case _ApexParser.BY:
            case _ApexParser.LIMIT:
            case _ApexParser.SOQLAND:
            case _ApexParser.SOQLOR:
            case _ApexParser.NOT:
            case _ApexParser.AVG:
            case _ApexParser.COUNT_DISTINCT:
            case _ApexParser.MIN:
            case _ApexParser.MAX:
            case _ApexParser.SUM:
            case _ApexParser.TYPEOF:
            case _ApexParser.END:
            case _ApexParser.THEN:
            case _ApexParser.LIKE:
            case _ApexParser.IN:
            case _ApexParser.INCLUDES:
            case _ApexParser.EXCLUDES:
            case _ApexParser.ASC:
            case _ApexParser.DESC:
            case _ApexParser.NULLS:
            case _ApexParser.FIRST:
            case _ApexParser.LAST:
            case _ApexParser.GROUP:
            case _ApexParser.ALL:
            case _ApexParser.ROWS:
            case _ApexParser.VIEW:
            case _ApexParser.HAVING:
            case _ApexParser.ROLLUP:
            case _ApexParser.TOLABEL:
            case _ApexParser.OFFSET:
            case _ApexParser.DATA:
            case _ApexParser.CATEGORY:
            case _ApexParser.AT:
            case _ApexParser.ABOVE:
            case _ApexParser.BELOW:
            case _ApexParser.ABOVE_OR_BELOW:
            case _ApexParser.SECURITY_ENFORCED:
            case _ApexParser.SYSTEM_MODE:
            case _ApexParser.USER_MODE:
            case _ApexParser.REFERENCE:
            case _ApexParser.CUBE:
            case _ApexParser.FORMAT:
            case _ApexParser.TRACKING:
            case _ApexParser.VIEWSTAT:
            case _ApexParser.CUSTOM:
            case _ApexParser.STANDARD:
            case _ApexParser.DISTANCE:
            case _ApexParser.GEOLOCATION:
            case _ApexParser.GROUPING:
            case _ApexParser.CONVERT_CURRENCY:
            case _ApexParser.CALENDAR_MONTH:
            case _ApexParser.CALENDAR_QUARTER:
            case _ApexParser.CALENDAR_YEAR:
            case _ApexParser.DAY_IN_MONTH:
            case _ApexParser.DAY_IN_WEEK:
            case _ApexParser.DAY_IN_YEAR:
            case _ApexParser.DAY_ONLY:
            case _ApexParser.FISCAL_MONTH:
            case _ApexParser.FISCAL_QUARTER:
            case _ApexParser.FISCAL_YEAR:
            case _ApexParser.HOUR_IN_DAY:
            case _ApexParser.WEEK_IN_MONTH:
            case _ApexParser.WEEK_IN_YEAR:
            case _ApexParser.CONVERT_TIMEZONE:
            case _ApexParser.YESTERDAY:
            case _ApexParser.TODAY:
            case _ApexParser.TOMORROW:
            case _ApexParser.LAST_WEEK:
            case _ApexParser.THIS_WEEK:
            case _ApexParser.NEXT_WEEK:
            case _ApexParser.LAST_MONTH:
            case _ApexParser.THIS_MONTH:
            case _ApexParser.NEXT_MONTH:
            case _ApexParser.LAST_90_DAYS:
            case _ApexParser.NEXT_90_DAYS:
            case _ApexParser.LAST_N_DAYS_N:
            case _ApexParser.NEXT_N_DAYS_N:
            case _ApexParser.N_DAYS_AGO_N:
            case _ApexParser.NEXT_N_WEEKS_N:
            case _ApexParser.LAST_N_WEEKS_N:
            case _ApexParser.N_WEEKS_AGO_N:
            case _ApexParser.NEXT_N_MONTHS_N:
            case _ApexParser.LAST_N_MONTHS_N:
            case _ApexParser.N_MONTHS_AGO_N:
            case _ApexParser.THIS_QUARTER:
            case _ApexParser.LAST_QUARTER:
            case _ApexParser.NEXT_QUARTER:
            case _ApexParser.NEXT_N_QUARTERS_N:
            case _ApexParser.LAST_N_QUARTERS_N:
            case _ApexParser.N_QUARTERS_AGO_N:
            case _ApexParser.THIS_YEAR:
            case _ApexParser.LAST_YEAR:
            case _ApexParser.NEXT_YEAR:
            case _ApexParser.NEXT_N_YEARS_N:
            case _ApexParser.LAST_N_YEARS_N:
            case _ApexParser.N_YEARS_AGO_N:
            case _ApexParser.THIS_FISCAL_QUARTER:
            case _ApexParser.LAST_FISCAL_QUARTER:
            case _ApexParser.NEXT_FISCAL_QUARTER:
            case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
            case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
            case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
            case _ApexParser.THIS_FISCAL_YEAR:
            case _ApexParser.LAST_FISCAL_YEAR:
            case _ApexParser.NEXT_FISCAL_YEAR:
            case _ApexParser.NEXT_N_FISCAL_YEARS_N:
            case _ApexParser.LAST_N_FISCAL_YEARS_N:
            case _ApexParser.N_FISCAL_YEARS_AGO_N:
            case _ApexParser.IntegralCurrencyLiteral:
            case _ApexParser.FIND:
            case _ApexParser.EMAIL:
            case _ApexParser.NAME:
            case _ApexParser.PHONE:
            case _ApexParser.SIDEBAR:
            case _ApexParser.FIELDS:
            case _ApexParser.METADATA:
            case _ApexParser.PRICEBOOKID:
            case _ApexParser.NETWORK:
            case _ApexParser.SNIPPET:
            case _ApexParser.TARGET_LENGTH:
            case _ApexParser.DIVISION:
            case _ApexParser.RETURNING:
            case _ApexParser.LISTVIEW:
            case _ApexParser.Identifier:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1504;
                this.fieldExpression();
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldExpression() {
        let _localctx = new FieldExpressionContext(this._ctx, this.state);
        this.enterRule(_localctx, 224, _ApexParser.RULE_fieldExpression);
        try {
          this.state = 1515;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 145, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1507;
                this.fieldName();
                this.state = 1508;
                this.comparisonOperator();
                this.state = 1509;
                this.value();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1511;
                this.soqlFunction();
                this.state = 1512;
                this.comparisonOperator();
                this.state = 1513;
                this.value();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      comparisonOperator() {
        let _localctx = new ComparisonOperatorContext(this._ctx, this.state);
        this.enterRule(_localctx, 226, _ApexParser.RULE_comparisonOperator);
        try {
          this.state = 1532;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 146, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1517;
                this.match(_ApexParser.ASSIGN);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1518;
                this.match(_ApexParser.NOTEQUAL);
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1519;
                this.match(_ApexParser.LT);
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1520;
                this.match(_ApexParser.GT);
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 1521;
                this.match(_ApexParser.LT);
                this.state = 1522;
                this.match(_ApexParser.ASSIGN);
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 1523;
                this.match(_ApexParser.GT);
                this.state = 1524;
                this.match(_ApexParser.ASSIGN);
              }
              break;
            case 7:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 1525;
                this.match(_ApexParser.LESSANDGREATER);
              }
              break;
            case 8:
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 1526;
                this.match(_ApexParser.LIKE);
              }
              break;
            case 9:
              this.enterOuterAlt(_localctx, 9);
              {
                this.state = 1527;
                this.match(_ApexParser.IN);
              }
              break;
            case 10:
              this.enterOuterAlt(_localctx, 10);
              {
                this.state = 1528;
                this.match(_ApexParser.NOT);
                this.state = 1529;
                this.match(_ApexParser.IN);
              }
              break;
            case 11:
              this.enterOuterAlt(_localctx, 11);
              {
                this.state = 1530;
                this.match(_ApexParser.INCLUDES);
              }
              break;
            case 12:
              this.enterOuterAlt(_localctx, 12);
              {
                this.state = 1531;
                this.match(_ApexParser.EXCLUDES);
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      value() {
        let _localctx = new ValueContext(this._ctx, this.state);
        this.enterRule(_localctx, 228, _ApexParser.RULE_value);
        let _la;
        try {
          this.state = 1555;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 149, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1534;
                this.match(_ApexParser.NULL);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1535;
                this.match(_ApexParser.BooleanLiteral);
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1536;
                this.signedNumber();
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1537;
                this.match(_ApexParser.StringLiteral);
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 1538;
                this.match(_ApexParser.DateLiteral);
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 1539;
                this.match(_ApexParser.TimeLiteral);
              }
              break;
            case 7:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 1540;
                this.match(_ApexParser.DateTimeLiteral);
              }
              break;
            case 8:
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 1541;
                this.dateFormula();
              }
              break;
            case 9:
              this.enterOuterAlt(_localctx, 9);
              {
                this.state = 1542;
                this.match(_ApexParser.IntegralCurrencyLiteral);
                this.state = 1547;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.DOT) {
                  {
                    this.state = 1543;
                    this.match(_ApexParser.DOT);
                    this.state = 1545;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if (_la === _ApexParser.IntegerLiteral) {
                      {
                        this.state = 1544;
                        this.match(_ApexParser.IntegerLiteral);
                      }
                    }
                  }
                }
              }
              break;
            case 10:
              this.enterOuterAlt(_localctx, 10);
              {
                this.state = 1549;
                this.match(_ApexParser.LPAREN);
                this.state = 1550;
                this.subQuery();
                this.state = 1551;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 11:
              this.enterOuterAlt(_localctx, 11);
              {
                this.state = 1553;
                this.valueList();
              }
              break;
            case 12:
              this.enterOuterAlt(_localctx, 12);
              {
                this.state = 1554;
                this.boundExpression();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      valueList() {
        let _localctx = new ValueListContext(this._ctx, this.state);
        this.enterRule(_localctx, 230, _ApexParser.RULE_valueList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1557;
            this.match(_ApexParser.LPAREN);
            this.state = 1558;
            this.value();
            this.state = 1563;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1559;
                  this.match(_ApexParser.COMMA);
                  this.state = 1560;
                  this.value();
                }
              }
              this.state = 1565;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1566;
            this.match(_ApexParser.RPAREN);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      signedNumber() {
        let _localctx = new SignedNumberContext(this._ctx, this.state);
        this.enterRule(_localctx, 232, _ApexParser.RULE_signedNumber);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1569;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.ADD || _la === _ApexParser.SUB) {
              {
                this.state = 1568;
                _la = this._input.LA(1);
                if (!(_la === _ApexParser.ADD || _la === _ApexParser.SUB)) {
                  this._errHandler.recoverInline(this);
                } else {
                  if (this._input.LA(1) === Token_1.Token.EOF) {
                    this.matchedEOF = true;
                  }
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
              }
            }
            this.state = 1571;
            _la = this._input.LA(1);
            if (!(_la === _ApexParser.IntegerLiteral || _la === _ApexParser.NumberLiteral)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      withClause() {
        let _localctx = new WithClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 234, _ApexParser.RULE_withClause);
        try {
          this.state = 1585;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 152, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1573;
                this.match(_ApexParser.WITH);
                this.state = 1574;
                this.match(_ApexParser.DATA);
                this.state = 1575;
                this.match(_ApexParser.CATEGORY);
                this.state = 1576;
                this.filteringExpression();
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1577;
                this.match(_ApexParser.WITH);
                this.state = 1578;
                this.match(_ApexParser.SECURITY_ENFORCED);
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1579;
                this.match(_ApexParser.WITH);
                this.state = 1580;
                this.match(_ApexParser.SYSTEM_MODE);
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1581;
                this.match(_ApexParser.WITH);
                this.state = 1582;
                this.match(_ApexParser.USER_MODE);
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 1583;
                this.match(_ApexParser.WITH);
                this.state = 1584;
                this.logicalExpression();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      filteringExpression() {
        let _localctx = new FilteringExpressionContext(this._ctx, this.state);
        this.enterRule(_localctx, 236, _ApexParser.RULE_filteringExpression);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1587;
            this.dataCategorySelection();
            this.state = 1592;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.AND) {
              {
                {
                  this.state = 1588;
                  this.match(_ApexParser.AND);
                  this.state = 1589;
                  this.dataCategorySelection();
                }
              }
              this.state = 1594;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      dataCategorySelection() {
        let _localctx = new DataCategorySelectionContext(this._ctx, this.state);
        this.enterRule(_localctx, 238, _ApexParser.RULE_dataCategorySelection);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1595;
            this.soqlId();
            this.state = 1596;
            this.filteringSelector();
            this.state = 1597;
            this.dataCategoryName();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      dataCategoryName() {
        let _localctx = new DataCategoryNameContext(this._ctx, this.state);
        this.enterRule(_localctx, 240, _ApexParser.RULE_dataCategoryName);
        let _la;
        try {
          this.state = 1611;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.AFTER:
            case _ApexParser.BEFORE:
            case _ApexParser.GET:
            case _ApexParser.INHERITED:
            case _ApexParser.INSTANCEOF:
            case _ApexParser.SET:
            case _ApexParser.SHARING:
            case _ApexParser.SWITCH:
            case _ApexParser.TRANSIENT:
            case _ApexParser.TRIGGER:
            case _ApexParser.WHEN:
            case _ApexParser.WITH:
            case _ApexParser.WITHOUT:
            case _ApexParser.SYSTEM:
            case _ApexParser.USER:
            case _ApexParser.SELECT:
            case _ApexParser.COUNT:
            case _ApexParser.FROM:
            case _ApexParser.AS:
            case _ApexParser.USING:
            case _ApexParser.SCOPE:
            case _ApexParser.WHERE:
            case _ApexParser.ORDER:
            case _ApexParser.BY:
            case _ApexParser.LIMIT:
            case _ApexParser.SOQLAND:
            case _ApexParser.SOQLOR:
            case _ApexParser.NOT:
            case _ApexParser.AVG:
            case _ApexParser.COUNT_DISTINCT:
            case _ApexParser.MIN:
            case _ApexParser.MAX:
            case _ApexParser.SUM:
            case _ApexParser.TYPEOF:
            case _ApexParser.END:
            case _ApexParser.THEN:
            case _ApexParser.LIKE:
            case _ApexParser.IN:
            case _ApexParser.INCLUDES:
            case _ApexParser.EXCLUDES:
            case _ApexParser.ASC:
            case _ApexParser.DESC:
            case _ApexParser.NULLS:
            case _ApexParser.FIRST:
            case _ApexParser.LAST:
            case _ApexParser.GROUP:
            case _ApexParser.ALL:
            case _ApexParser.ROWS:
            case _ApexParser.VIEW:
            case _ApexParser.HAVING:
            case _ApexParser.ROLLUP:
            case _ApexParser.TOLABEL:
            case _ApexParser.OFFSET:
            case _ApexParser.DATA:
            case _ApexParser.CATEGORY:
            case _ApexParser.AT:
            case _ApexParser.ABOVE:
            case _ApexParser.BELOW:
            case _ApexParser.ABOVE_OR_BELOW:
            case _ApexParser.SECURITY_ENFORCED:
            case _ApexParser.SYSTEM_MODE:
            case _ApexParser.USER_MODE:
            case _ApexParser.REFERENCE:
            case _ApexParser.CUBE:
            case _ApexParser.FORMAT:
            case _ApexParser.TRACKING:
            case _ApexParser.VIEWSTAT:
            case _ApexParser.CUSTOM:
            case _ApexParser.STANDARD:
            case _ApexParser.DISTANCE:
            case _ApexParser.GEOLOCATION:
            case _ApexParser.GROUPING:
            case _ApexParser.CONVERT_CURRENCY:
            case _ApexParser.CALENDAR_MONTH:
            case _ApexParser.CALENDAR_QUARTER:
            case _ApexParser.CALENDAR_YEAR:
            case _ApexParser.DAY_IN_MONTH:
            case _ApexParser.DAY_IN_WEEK:
            case _ApexParser.DAY_IN_YEAR:
            case _ApexParser.DAY_ONLY:
            case _ApexParser.FISCAL_MONTH:
            case _ApexParser.FISCAL_QUARTER:
            case _ApexParser.FISCAL_YEAR:
            case _ApexParser.HOUR_IN_DAY:
            case _ApexParser.WEEK_IN_MONTH:
            case _ApexParser.WEEK_IN_YEAR:
            case _ApexParser.CONVERT_TIMEZONE:
            case _ApexParser.YESTERDAY:
            case _ApexParser.TODAY:
            case _ApexParser.TOMORROW:
            case _ApexParser.LAST_WEEK:
            case _ApexParser.THIS_WEEK:
            case _ApexParser.NEXT_WEEK:
            case _ApexParser.LAST_MONTH:
            case _ApexParser.THIS_MONTH:
            case _ApexParser.NEXT_MONTH:
            case _ApexParser.LAST_90_DAYS:
            case _ApexParser.NEXT_90_DAYS:
            case _ApexParser.LAST_N_DAYS_N:
            case _ApexParser.NEXT_N_DAYS_N:
            case _ApexParser.N_DAYS_AGO_N:
            case _ApexParser.NEXT_N_WEEKS_N:
            case _ApexParser.LAST_N_WEEKS_N:
            case _ApexParser.N_WEEKS_AGO_N:
            case _ApexParser.NEXT_N_MONTHS_N:
            case _ApexParser.LAST_N_MONTHS_N:
            case _ApexParser.N_MONTHS_AGO_N:
            case _ApexParser.THIS_QUARTER:
            case _ApexParser.LAST_QUARTER:
            case _ApexParser.NEXT_QUARTER:
            case _ApexParser.NEXT_N_QUARTERS_N:
            case _ApexParser.LAST_N_QUARTERS_N:
            case _ApexParser.N_QUARTERS_AGO_N:
            case _ApexParser.THIS_YEAR:
            case _ApexParser.LAST_YEAR:
            case _ApexParser.NEXT_YEAR:
            case _ApexParser.NEXT_N_YEARS_N:
            case _ApexParser.LAST_N_YEARS_N:
            case _ApexParser.N_YEARS_AGO_N:
            case _ApexParser.THIS_FISCAL_QUARTER:
            case _ApexParser.LAST_FISCAL_QUARTER:
            case _ApexParser.NEXT_FISCAL_QUARTER:
            case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
            case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
            case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
            case _ApexParser.THIS_FISCAL_YEAR:
            case _ApexParser.LAST_FISCAL_YEAR:
            case _ApexParser.NEXT_FISCAL_YEAR:
            case _ApexParser.NEXT_N_FISCAL_YEARS_N:
            case _ApexParser.LAST_N_FISCAL_YEARS_N:
            case _ApexParser.N_FISCAL_YEARS_AGO_N:
            case _ApexParser.IntegralCurrencyLiteral:
            case _ApexParser.FIND:
            case _ApexParser.EMAIL:
            case _ApexParser.NAME:
            case _ApexParser.PHONE:
            case _ApexParser.SIDEBAR:
            case _ApexParser.FIELDS:
            case _ApexParser.METADATA:
            case _ApexParser.PRICEBOOKID:
            case _ApexParser.NETWORK:
            case _ApexParser.SNIPPET:
            case _ApexParser.TARGET_LENGTH:
            case _ApexParser.DIVISION:
            case _ApexParser.RETURNING:
            case _ApexParser.LISTVIEW:
            case _ApexParser.Identifier:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1599;
                this.soqlId();
              }
              break;
            case _ApexParser.LPAREN:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1600;
                this.match(_ApexParser.LPAREN);
                this.state = 1601;
                this.soqlId();
                this.state = 1606;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.COMMA) {
                  {
                    {
                      this.state = 1602;
                      this.match(_ApexParser.COMMA);
                      this.state = 1603;
                      this.soqlId();
                    }
                  }
                  this.state = 1608;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 1609;
                this.match(_ApexParser.LPAREN);
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      filteringSelector() {
        let _localctx = new FilteringSelectorContext(this._ctx, this.state);
        this.enterRule(_localctx, 242, _ApexParser.RULE_filteringSelector);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1613;
            _la = this._input.LA(1);
            if (!((_la - 99 & ~31) === 0 && (1 << _la - 99 & (1 << _ApexParser.AT - 99 | 1 << _ApexParser.ABOVE - 99 | 1 << _ApexParser.BELOW - 99 | 1 << _ApexParser.ABOVE_OR_BELOW - 99)) !== 0)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      groupByClause() {
        let _localctx = new GroupByClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 244, _ApexParser.RULE_groupByClause);
        let _la;
        try {
          this.state = 1650;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 159, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1615;
                this.match(_ApexParser.GROUP);
                this.state = 1616;
                this.match(_ApexParser.BY);
                this.state = 1617;
                this.selectList();
                this.state = 1620;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.HAVING) {
                  {
                    this.state = 1618;
                    this.match(_ApexParser.HAVING);
                    this.state = 1619;
                    this.logicalExpression();
                  }
                }
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1622;
                this.match(_ApexParser.GROUP);
                this.state = 1623;
                this.match(_ApexParser.BY);
                this.state = 1624;
                this.match(_ApexParser.ROLLUP);
                this.state = 1625;
                this.match(_ApexParser.LPAREN);
                this.state = 1626;
                this.fieldName();
                this.state = 1631;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.COMMA) {
                  {
                    {
                      this.state = 1627;
                      this.match(_ApexParser.COMMA);
                      this.state = 1628;
                      this.fieldName();
                    }
                  }
                  this.state = 1633;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 1634;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1636;
                this.match(_ApexParser.GROUP);
                this.state = 1637;
                this.match(_ApexParser.BY);
                this.state = 1638;
                this.match(_ApexParser.CUBE);
                this.state = 1639;
                this.match(_ApexParser.LPAREN);
                this.state = 1640;
                this.fieldName();
                this.state = 1645;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _ApexParser.COMMA) {
                  {
                    {
                      this.state = 1641;
                      this.match(_ApexParser.COMMA);
                      this.state = 1642;
                      this.fieldName();
                    }
                  }
                  this.state = 1647;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 1648;
                this.match(_ApexParser.RPAREN);
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      orderByClause() {
        let _localctx = new OrderByClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 246, _ApexParser.RULE_orderByClause);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1652;
            this.match(_ApexParser.ORDER);
            this.state = 1653;
            this.match(_ApexParser.BY);
            this.state = 1654;
            this.fieldOrderList();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldOrderList() {
        let _localctx = new FieldOrderListContext(this._ctx, this.state);
        this.enterRule(_localctx, 248, _ApexParser.RULE_fieldOrderList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1656;
            this.fieldOrder();
            this.state = 1661;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.COMMA) {
              {
                {
                  this.state = 1657;
                  this.match(_ApexParser.COMMA);
                  this.state = 1658;
                  this.fieldOrder();
                }
              }
              this.state = 1663;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldOrder() {
        let _localctx = new FieldOrderContext(this._ctx, this.state);
        this.enterRule(_localctx, 250, _ApexParser.RULE_fieldOrder);
        let _la;
        try {
          this.state = 1680;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 165, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1664;
                this.fieldName();
                this.state = 1666;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.ASC || _la === _ApexParser.DESC) {
                  {
                    this.state = 1665;
                    _la = this._input.LA(1);
                    if (!(_la === _ApexParser.ASC || _la === _ApexParser.DESC)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === Token_1.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                  }
                }
                this.state = 1670;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.NULLS) {
                  {
                    this.state = 1668;
                    this.match(_ApexParser.NULLS);
                    this.state = 1669;
                    _la = this._input.LA(1);
                    if (!(_la === _ApexParser.FIRST || _la === _ApexParser.LAST)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === Token_1.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                  }
                }
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1672;
                this.soqlFunction();
                this.state = 1674;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.ASC || _la === _ApexParser.DESC) {
                  {
                    this.state = 1673;
                    _la = this._input.LA(1);
                    if (!(_la === _ApexParser.ASC || _la === _ApexParser.DESC)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === Token_1.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                  }
                }
                this.state = 1678;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.NULLS) {
                  {
                    this.state = 1676;
                    this.match(_ApexParser.NULLS);
                    this.state = 1677;
                    _la = this._input.LA(1);
                    if (!(_la === _ApexParser.FIRST || _la === _ApexParser.LAST)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === Token_1.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                  }
                }
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      limitClause() {
        let _localctx = new LimitClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 252, _ApexParser.RULE_limitClause);
        try {
          this.state = 1686;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 166, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1682;
                this.match(_ApexParser.LIMIT);
                this.state = 1683;
                this.match(_ApexParser.IntegerLiteral);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1684;
                this.match(_ApexParser.LIMIT);
                this.state = 1685;
                this.boundExpression();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      offsetClause() {
        let _localctx = new OffsetClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 254, _ApexParser.RULE_offsetClause);
        try {
          this.state = 1692;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 167, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1688;
                this.match(_ApexParser.OFFSET);
                this.state = 1689;
                this.match(_ApexParser.IntegerLiteral);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1690;
                this.match(_ApexParser.OFFSET);
                this.state = 1691;
                this.boundExpression();
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      allRowsClause() {
        let _localctx = new AllRowsClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 256, _ApexParser.RULE_allRowsClause);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1694;
            this.match(_ApexParser.ALL);
            this.state = 1695;
            this.match(_ApexParser.ROWS);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      forClauses() {
        let _localctx = new ForClausesContext(this._ctx, this.state);
        this.enterRule(_localctx, 258, _ApexParser.RULE_forClauses);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1701;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.FOR) {
              {
                {
                  this.state = 1697;
                  this.match(_ApexParser.FOR);
                  this.state = 1698;
                  _la = this._input.LA(1);
                  if (!(_la === _ApexParser.UPDATE || _la === _ApexParser.VIEW || _la === _ApexParser.REFERENCE)) {
                    this._errHandler.recoverInline(this);
                  } else {
                    if (this._input.LA(1) === Token_1.Token.EOF) {
                      this.matchedEOF = true;
                    }
                    this._errHandler.reportMatch(this);
                    this.consume();
                  }
                }
              }
              this.state = 1703;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      boundExpression() {
        let _localctx = new BoundExpressionContext(this._ctx, this.state);
        this.enterRule(_localctx, 260, _ApexParser.RULE_boundExpression);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1704;
            this.match(_ApexParser.COLON);
            this.state = 1705;
            this.expression(0);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      dateFormula() {
        let _localctx = new DateFormulaContext(this._ctx, this.state);
        this.enterRule(_localctx, 262, _ApexParser.RULE_dateFormula);
        try {
          this.state = 1793;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.YESTERDAY:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1707;
                this.match(_ApexParser.YESTERDAY);
              }
              break;
            case _ApexParser.TODAY:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1708;
                this.match(_ApexParser.TODAY);
              }
              break;
            case _ApexParser.TOMORROW:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1709;
                this.match(_ApexParser.TOMORROW);
              }
              break;
            case _ApexParser.LAST_WEEK:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1710;
                this.match(_ApexParser.LAST_WEEK);
              }
              break;
            case _ApexParser.THIS_WEEK:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 1711;
                this.match(_ApexParser.THIS_WEEK);
              }
              break;
            case _ApexParser.NEXT_WEEK:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 1712;
                this.match(_ApexParser.NEXT_WEEK);
              }
              break;
            case _ApexParser.LAST_MONTH:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 1713;
                this.match(_ApexParser.LAST_MONTH);
              }
              break;
            case _ApexParser.THIS_MONTH:
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 1714;
                this.match(_ApexParser.THIS_MONTH);
              }
              break;
            case _ApexParser.NEXT_MONTH:
              this.enterOuterAlt(_localctx, 9);
              {
                this.state = 1715;
                this.match(_ApexParser.NEXT_MONTH);
              }
              break;
            case _ApexParser.LAST_90_DAYS:
              this.enterOuterAlt(_localctx, 10);
              {
                this.state = 1716;
                this.match(_ApexParser.LAST_90_DAYS);
              }
              break;
            case _ApexParser.NEXT_90_DAYS:
              this.enterOuterAlt(_localctx, 11);
              {
                this.state = 1717;
                this.match(_ApexParser.NEXT_90_DAYS);
              }
              break;
            case _ApexParser.LAST_N_DAYS_N:
              this.enterOuterAlt(_localctx, 12);
              {
                this.state = 1718;
                this.match(_ApexParser.LAST_N_DAYS_N);
                this.state = 1719;
                this.match(_ApexParser.COLON);
                this.state = 1720;
                this.signedInteger();
              }
              break;
            case _ApexParser.NEXT_N_DAYS_N:
              this.enterOuterAlt(_localctx, 13);
              {
                this.state = 1721;
                this.match(_ApexParser.NEXT_N_DAYS_N);
                this.state = 1722;
                this.match(_ApexParser.COLON);
                this.state = 1723;
                this.signedInteger();
              }
              break;
            case _ApexParser.N_DAYS_AGO_N:
              this.enterOuterAlt(_localctx, 14);
              {
                this.state = 1724;
                this.match(_ApexParser.N_DAYS_AGO_N);
                this.state = 1725;
                this.match(_ApexParser.COLON);
                this.state = 1726;
                this.signedInteger();
              }
              break;
            case _ApexParser.NEXT_N_WEEKS_N:
              this.enterOuterAlt(_localctx, 15);
              {
                this.state = 1727;
                this.match(_ApexParser.NEXT_N_WEEKS_N);
                this.state = 1728;
                this.match(_ApexParser.COLON);
                this.state = 1729;
                this.signedInteger();
              }
              break;
            case _ApexParser.LAST_N_WEEKS_N:
              this.enterOuterAlt(_localctx, 16);
              {
                this.state = 1730;
                this.match(_ApexParser.LAST_N_WEEKS_N);
                this.state = 1731;
                this.match(_ApexParser.COLON);
                this.state = 1732;
                this.signedInteger();
              }
              break;
            case _ApexParser.N_WEEKS_AGO_N:
              this.enterOuterAlt(_localctx, 17);
              {
                this.state = 1733;
                this.match(_ApexParser.N_WEEKS_AGO_N);
                this.state = 1734;
                this.match(_ApexParser.COLON);
                this.state = 1735;
                this.signedInteger();
              }
              break;
            case _ApexParser.NEXT_N_MONTHS_N:
              this.enterOuterAlt(_localctx, 18);
              {
                this.state = 1736;
                this.match(_ApexParser.NEXT_N_MONTHS_N);
                this.state = 1737;
                this.match(_ApexParser.COLON);
                this.state = 1738;
                this.signedInteger();
              }
              break;
            case _ApexParser.LAST_N_MONTHS_N:
              this.enterOuterAlt(_localctx, 19);
              {
                this.state = 1739;
                this.match(_ApexParser.LAST_N_MONTHS_N);
                this.state = 1740;
                this.match(_ApexParser.COLON);
                this.state = 1741;
                this.signedInteger();
              }
              break;
            case _ApexParser.N_MONTHS_AGO_N:
              this.enterOuterAlt(_localctx, 20);
              {
                this.state = 1742;
                this.match(_ApexParser.N_MONTHS_AGO_N);
                this.state = 1743;
                this.match(_ApexParser.COLON);
                this.state = 1744;
                this.signedInteger();
              }
              break;
            case _ApexParser.THIS_QUARTER:
              this.enterOuterAlt(_localctx, 21);
              {
                this.state = 1745;
                this.match(_ApexParser.THIS_QUARTER);
              }
              break;
            case _ApexParser.LAST_QUARTER:
              this.enterOuterAlt(_localctx, 22);
              {
                this.state = 1746;
                this.match(_ApexParser.LAST_QUARTER);
              }
              break;
            case _ApexParser.NEXT_QUARTER:
              this.enterOuterAlt(_localctx, 23);
              {
                this.state = 1747;
                this.match(_ApexParser.NEXT_QUARTER);
              }
              break;
            case _ApexParser.NEXT_N_QUARTERS_N:
              this.enterOuterAlt(_localctx, 24);
              {
                this.state = 1748;
                this.match(_ApexParser.NEXT_N_QUARTERS_N);
                this.state = 1749;
                this.match(_ApexParser.COLON);
                this.state = 1750;
                this.signedInteger();
              }
              break;
            case _ApexParser.LAST_N_QUARTERS_N:
              this.enterOuterAlt(_localctx, 25);
              {
                this.state = 1751;
                this.match(_ApexParser.LAST_N_QUARTERS_N);
                this.state = 1752;
                this.match(_ApexParser.COLON);
                this.state = 1753;
                this.signedInteger();
              }
              break;
            case _ApexParser.N_QUARTERS_AGO_N:
              this.enterOuterAlt(_localctx, 26);
              {
                this.state = 1754;
                this.match(_ApexParser.N_QUARTERS_AGO_N);
                this.state = 1755;
                this.match(_ApexParser.COLON);
                this.state = 1756;
                this.signedInteger();
              }
              break;
            case _ApexParser.THIS_YEAR:
              this.enterOuterAlt(_localctx, 27);
              {
                this.state = 1757;
                this.match(_ApexParser.THIS_YEAR);
              }
              break;
            case _ApexParser.LAST_YEAR:
              this.enterOuterAlt(_localctx, 28);
              {
                this.state = 1758;
                this.match(_ApexParser.LAST_YEAR);
              }
              break;
            case _ApexParser.NEXT_YEAR:
              this.enterOuterAlt(_localctx, 29);
              {
                this.state = 1759;
                this.match(_ApexParser.NEXT_YEAR);
              }
              break;
            case _ApexParser.NEXT_N_YEARS_N:
              this.enterOuterAlt(_localctx, 30);
              {
                this.state = 1760;
                this.match(_ApexParser.NEXT_N_YEARS_N);
                this.state = 1761;
                this.match(_ApexParser.COLON);
                this.state = 1762;
                this.signedInteger();
              }
              break;
            case _ApexParser.LAST_N_YEARS_N:
              this.enterOuterAlt(_localctx, 31);
              {
                this.state = 1763;
                this.match(_ApexParser.LAST_N_YEARS_N);
                this.state = 1764;
                this.match(_ApexParser.COLON);
                this.state = 1765;
                this.signedInteger();
              }
              break;
            case _ApexParser.N_YEARS_AGO_N:
              this.enterOuterAlt(_localctx, 32);
              {
                this.state = 1766;
                this.match(_ApexParser.N_YEARS_AGO_N);
                this.state = 1767;
                this.match(_ApexParser.COLON);
                this.state = 1768;
                this.signedInteger();
              }
              break;
            case _ApexParser.THIS_FISCAL_QUARTER:
              this.enterOuterAlt(_localctx, 33);
              {
                this.state = 1769;
                this.match(_ApexParser.THIS_FISCAL_QUARTER);
              }
              break;
            case _ApexParser.LAST_FISCAL_QUARTER:
              this.enterOuterAlt(_localctx, 34);
              {
                this.state = 1770;
                this.match(_ApexParser.LAST_FISCAL_QUARTER);
              }
              break;
            case _ApexParser.NEXT_FISCAL_QUARTER:
              this.enterOuterAlt(_localctx, 35);
              {
                this.state = 1771;
                this.match(_ApexParser.NEXT_FISCAL_QUARTER);
              }
              break;
            case _ApexParser.NEXT_N_FISCAL_QUARTERS_N:
              this.enterOuterAlt(_localctx, 36);
              {
                this.state = 1772;
                this.match(_ApexParser.NEXT_N_FISCAL_QUARTERS_N);
                this.state = 1773;
                this.match(_ApexParser.COLON);
                this.state = 1774;
                this.signedInteger();
              }
              break;
            case _ApexParser.LAST_N_FISCAL_QUARTERS_N:
              this.enterOuterAlt(_localctx, 37);
              {
                this.state = 1775;
                this.match(_ApexParser.LAST_N_FISCAL_QUARTERS_N);
                this.state = 1776;
                this.match(_ApexParser.COLON);
                this.state = 1777;
                this.signedInteger();
              }
              break;
            case _ApexParser.N_FISCAL_QUARTERS_AGO_N:
              this.enterOuterAlt(_localctx, 38);
              {
                this.state = 1778;
                this.match(_ApexParser.N_FISCAL_QUARTERS_AGO_N);
                this.state = 1779;
                this.match(_ApexParser.COLON);
                this.state = 1780;
                this.signedInteger();
              }
              break;
            case _ApexParser.THIS_FISCAL_YEAR:
              this.enterOuterAlt(_localctx, 39);
              {
                this.state = 1781;
                this.match(_ApexParser.THIS_FISCAL_YEAR);
              }
              break;
            case _ApexParser.LAST_FISCAL_YEAR:
              this.enterOuterAlt(_localctx, 40);
              {
                this.state = 1782;
                this.match(_ApexParser.LAST_FISCAL_YEAR);
              }
              break;
            case _ApexParser.NEXT_FISCAL_YEAR:
              this.enterOuterAlt(_localctx, 41);
              {
                this.state = 1783;
                this.match(_ApexParser.NEXT_FISCAL_YEAR);
              }
              break;
            case _ApexParser.NEXT_N_FISCAL_YEARS_N:
              this.enterOuterAlt(_localctx, 42);
              {
                this.state = 1784;
                this.match(_ApexParser.NEXT_N_FISCAL_YEARS_N);
                this.state = 1785;
                this.match(_ApexParser.COLON);
                this.state = 1786;
                this.signedInteger();
              }
              break;
            case _ApexParser.LAST_N_FISCAL_YEARS_N:
              this.enterOuterAlt(_localctx, 43);
              {
                this.state = 1787;
                this.match(_ApexParser.LAST_N_FISCAL_YEARS_N);
                this.state = 1788;
                this.match(_ApexParser.COLON);
                this.state = 1789;
                this.signedInteger();
              }
              break;
            case _ApexParser.N_FISCAL_YEARS_AGO_N:
              this.enterOuterAlt(_localctx, 44);
              {
                this.state = 1790;
                this.match(_ApexParser.N_FISCAL_YEARS_AGO_N);
                this.state = 1791;
                this.match(_ApexParser.COLON);
                this.state = 1792;
                this.signedInteger();
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      signedInteger() {
        let _localctx = new SignedIntegerContext(this._ctx, this.state);
        this.enterRule(_localctx, 264, _ApexParser.RULE_signedInteger);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1796;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.ADD || _la === _ApexParser.SUB) {
              {
                this.state = 1795;
                _la = this._input.LA(1);
                if (!(_la === _ApexParser.ADD || _la === _ApexParser.SUB)) {
                  this._errHandler.recoverInline(this);
                } else {
                  if (this._input.LA(1) === Token_1.Token.EOF) {
                    this.matchedEOF = true;
                  }
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
              }
            }
            this.state = 1798;
            this.match(_ApexParser.IntegerLiteral);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soqlId() {
        let _localctx = new SoqlIdContext(this._ctx, this.state);
        this.enterRule(_localctx, 266, _ApexParser.RULE_soqlId);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1800;
            this.id();
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soslLiteral() {
        let _localctx = new SoslLiteralContext(this._ctx, this.state);
        this.enterRule(_localctx, 268, _ApexParser.RULE_soslLiteral);
        try {
          this.state = 1812;
          this._errHandler.sync(this);
          switch (this._input.LA(1)) {
            case _ApexParser.FindLiteral:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1802;
                this.match(_ApexParser.FindLiteral);
                this.state = 1803;
                this.soslClauses();
                this.state = 1804;
                this.match(_ApexParser.RBRACK);
              }
              break;
            case _ApexParser.LBRACK:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1806;
                this.match(_ApexParser.LBRACK);
                this.state = 1807;
                this.match(_ApexParser.FIND);
                this.state = 1808;
                this.boundExpression();
                this.state = 1809;
                this.soslClauses();
                this.state = 1810;
                this.match(_ApexParser.RBRACK);
              }
              break;
            default:
              throw new NoViableAltException_1.NoViableAltException(this);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soslLiteralAlt() {
        let _localctx = new SoslLiteralAltContext(this._ctx, this.state);
        this.enterRule(_localctx, 270, _ApexParser.RULE_soslLiteralAlt);
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1814;
            this.match(_ApexParser.FindLiteralAlt);
            this.state = 1815;
            this.soslClauses();
            this.state = 1816;
            this.match(_ApexParser.RBRACK);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soslClauses() {
        let _localctx = new SoslClausesContext(this._ctx, this.state);
        this.enterRule(_localctx, 272, _ApexParser.RULE_soslClauses);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1820;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.IN) {
              {
                this.state = 1818;
                this.match(_ApexParser.IN);
                this.state = 1819;
                this.searchGroup();
              }
            }
            this.state = 1824;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.RETURNING) {
              {
                this.state = 1822;
                this.match(_ApexParser.RETURNING);
                this.state = 1823;
                this.fieldSpecList();
              }
            }
            this.state = 1829;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _ApexParser.WITH) {
              {
                {
                  this.state = 1826;
                  this.soslWithClause();
                }
              }
              this.state = 1831;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1833;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.LIMIT) {
              {
                this.state = 1832;
                this.limitClause();
              }
            }
            this.state = 1837;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.UPDATE) {
              {
                this.state = 1835;
                this.match(_ApexParser.UPDATE);
                this.state = 1836;
                this.updateList();
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soslWithClause() {
        let _localctx = new SoslWithClauseContext(this._ctx, this.state);
        this.enterRule(_localctx, 274, _ApexParser.RULE_soslWithClause);
        let _la;
        try {
          this.state = 1879;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 178, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1839;
                this.match(_ApexParser.WITH);
                this.state = 1840;
                this.match(_ApexParser.DIVISION);
                this.state = 1841;
                this.match(_ApexParser.ASSIGN);
                this.state = 1842;
                this.match(_ApexParser.StringLiteral);
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1843;
                this.match(_ApexParser.WITH);
                this.state = 1844;
                this.match(_ApexParser.DATA);
                this.state = 1845;
                this.match(_ApexParser.CATEGORY);
                this.state = 1846;
                this.filteringExpression();
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1847;
                this.match(_ApexParser.WITH);
                this.state = 1848;
                this.match(_ApexParser.SNIPPET);
                this.state = 1854;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.LPAREN) {
                  {
                    this.state = 1849;
                    this.match(_ApexParser.LPAREN);
                    this.state = 1850;
                    this.match(_ApexParser.TARGET_LENGTH);
                    this.state = 1851;
                    this.match(_ApexParser.ASSIGN);
                    this.state = 1852;
                    this.match(_ApexParser.IntegerLiteral);
                    this.state = 1853;
                    this.match(_ApexParser.RPAREN);
                  }
                }
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1856;
                this.match(_ApexParser.WITH);
                this.state = 1857;
                this.match(_ApexParser.NETWORK);
                this.state = 1858;
                this.match(_ApexParser.IN);
                this.state = 1859;
                this.match(_ApexParser.LPAREN);
                this.state = 1860;
                this.networkList();
                this.state = 1861;
                this.match(_ApexParser.RPAREN);
              }
              break;
            case 5:
              this.enterOuterAlt(_localctx, 5);
              {
                this.state = 1863;
                this.match(_ApexParser.WITH);
                this.state = 1864;
                this.match(_ApexParser.NETWORK);
                this.state = 1865;
                this.match(_ApexParser.ASSIGN);
                this.state = 1866;
                this.match(_ApexParser.StringLiteral);
              }
              break;
            case 6:
              this.enterOuterAlt(_localctx, 6);
              {
                this.state = 1867;
                this.match(_ApexParser.WITH);
                this.state = 1868;
                this.match(_ApexParser.PRICEBOOKID);
                this.state = 1869;
                this.match(_ApexParser.ASSIGN);
                this.state = 1870;
                this.match(_ApexParser.StringLiteral);
              }
              break;
            case 7:
              this.enterOuterAlt(_localctx, 7);
              {
                this.state = 1871;
                this.match(_ApexParser.WITH);
                this.state = 1872;
                this.match(_ApexParser.METADATA);
                this.state = 1873;
                this.match(_ApexParser.ASSIGN);
                this.state = 1874;
                this.match(_ApexParser.StringLiteral);
              }
              break;
            case 8:
              this.enterOuterAlt(_localctx, 8);
              {
                this.state = 1875;
                this.match(_ApexParser.WITH);
                this.state = 1876;
                this.match(_ApexParser.USER_MODE);
              }
              break;
            case 9:
              this.enterOuterAlt(_localctx, 9);
              {
                this.state = 1877;
                this.match(_ApexParser.WITH);
                this.state = 1878;
                this.match(_ApexParser.SYSTEM_MODE);
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      searchGroup() {
        let _localctx = new SearchGroupContext(this._ctx, this.state);
        this.enterRule(_localctx, 276, _ApexParser.RULE_searchGroup);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1881;
            _la = this._input.LA(1);
            if (!(_la === _ApexParser.ALL || (_la - 180 & ~31) === 0 && (1 << _la - 180 & (1 << _ApexParser.EMAIL - 180 | 1 << _ApexParser.NAME - 180 | 1 << _ApexParser.PHONE - 180 | 1 << _ApexParser.SIDEBAR - 180)) !== 0)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 1882;
            this.match(_ApexParser.FIELDS);
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldSpecList() {
        let _localctx = new FieldSpecListContext(this._ctx, this.state);
        this.enterRule(_localctx, 278, _ApexParser.RULE_fieldSpecList);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1884;
            this.fieldSpec();
            this.state = 1889;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 179, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 1885;
                    this.match(_ApexParser.COMMA);
                    this.state = 1886;
                    this.fieldSpecList();
                  }
                }
              }
              this.state = 1891;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 179, this._ctx);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldSpec() {
        let _localctx = new FieldSpecContext(this._ctx, this.state);
        this.enterRule(_localctx, 280, _ApexParser.RULE_fieldSpec);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1892;
            this.soslId();
            this.state = 1918;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.LPAREN) {
              {
                this.state = 1893;
                this.match(_ApexParser.LPAREN);
                this.state = 1894;
                this.fieldList();
                this.state = 1897;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.WHERE) {
                  {
                    this.state = 1895;
                    this.match(_ApexParser.WHERE);
                    this.state = 1896;
                    this.logicalExpression();
                  }
                }
                this.state = 1903;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.USING) {
                  {
                    this.state = 1899;
                    this.match(_ApexParser.USING);
                    this.state = 1900;
                    this.match(_ApexParser.LISTVIEW);
                    this.state = 1901;
                    this.match(_ApexParser.ASSIGN);
                    this.state = 1902;
                    this.soslId();
                  }
                }
                this.state = 1908;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.ORDER) {
                  {
                    this.state = 1905;
                    this.match(_ApexParser.ORDER);
                    this.state = 1906;
                    this.match(_ApexParser.BY);
                    this.state = 1907;
                    this.fieldOrderList();
                  }
                }
                this.state = 1911;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.LIMIT) {
                  {
                    this.state = 1910;
                    this.limitClause();
                  }
                }
                this.state = 1914;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _ApexParser.OFFSET) {
                  {
                    this.state = 1913;
                    this.offsetClause();
                  }
                }
                this.state = 1916;
                this.match(_ApexParser.RPAREN);
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      fieldList() {
        let _localctx = new FieldListContext(this._ctx, this.state);
        this.enterRule(_localctx, 282, _ApexParser.RULE_fieldList);
        try {
          let _alt;
          this.state = 1952;
          this._errHandler.sync(this);
          switch (this.interpreter.adaptivePredict(this._input, 191, this._ctx)) {
            case 1:
              this.enterOuterAlt(_localctx, 1);
              {
                this.state = 1920;
                this.soslId();
                this.state = 1925;
                this._errHandler.sync(this);
                _alt = this.interpreter.adaptivePredict(this._input, 186, this._ctx);
                while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                  if (_alt === 1) {
                    {
                      {
                        this.state = 1921;
                        this.match(_ApexParser.COMMA);
                        this.state = 1922;
                        this.fieldList();
                      }
                    }
                  }
                  this.state = 1927;
                  this._errHandler.sync(this);
                  _alt = this.interpreter.adaptivePredict(this._input, 186, this._ctx);
                }
              }
              break;
            case 2:
              this.enterOuterAlt(_localctx, 2);
              {
                this.state = 1928;
                this.match(_ApexParser.TOLABEL);
                this.state = 1929;
                this.match(_ApexParser.LPAREN);
                this.state = 1930;
                this.soslId();
                this.state = 1931;
                this.match(_ApexParser.RPAREN);
                this.state = 1933;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 187, this._ctx)) {
                  case 1:
                    {
                      this.state = 1932;
                      this.soslId();
                    }
                    break;
                }
              }
              break;
            case 3:
              this.enterOuterAlt(_localctx, 3);
              {
                this.state = 1935;
                this.match(_ApexParser.CONVERT_CURRENCY);
                this.state = 1936;
                this.match(_ApexParser.LPAREN);
                this.state = 1937;
                this.soslId();
                this.state = 1938;
                this.match(_ApexParser.RPAREN);
                this.state = 1940;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 188, this._ctx)) {
                  case 1:
                    {
                      this.state = 1939;
                      this.soslId();
                    }
                    break;
                }
              }
              break;
            case 4:
              this.enterOuterAlt(_localctx, 4);
              {
                this.state = 1942;
                this.match(_ApexParser.FORMAT);
                this.state = 1943;
                this.match(_ApexParser.LPAREN);
                this.state = 1946;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 189, this._ctx)) {
                  case 1:
                    {
                      this.state = 1944;
                      this.soslId();
                    }
                    break;
                  case 2:
                    {
                      this.state = 1945;
                      this.soqlFunction();
                    }
                    break;
                }
                this.state = 1948;
                this.match(_ApexParser.RPAREN);
                this.state = 1950;
                this._errHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this._input, 190, this._ctx)) {
                  case 1:
                    {
                      this.state = 1949;
                      this.soslId();
                    }
                    break;
                }
              }
              break;
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      updateList() {
        let _localctx = new UpdateListContext(this._ctx, this.state);
        this.enterRule(_localctx, 284, _ApexParser.RULE_updateList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1954;
            this.updateType();
            this.state = 1957;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.COMMA) {
              {
                this.state = 1955;
                this.match(_ApexParser.COMMA);
                this.state = 1956;
                this.updateList();
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      updateType() {
        let _localctx = new UpdateTypeContext(this._ctx, this.state);
        this.enterRule(_localctx, 286, _ApexParser.RULE_updateType);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1959;
            _la = this._input.LA(1);
            if (!(_la === _ApexParser.TRACKING || _la === _ApexParser.VIEWSTAT)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      networkList() {
        let _localctx = new NetworkListContext(this._ctx, this.state);
        this.enterRule(_localctx, 288, _ApexParser.RULE_networkList);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1961;
            this.match(_ApexParser.StringLiteral);
            this.state = 1964;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _ApexParser.COMMA) {
              {
                this.state = 1962;
                this.match(_ApexParser.COMMA);
                this.state = 1963;
                this.networkList();
              }
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      soslId() {
        let _localctx = new SoslIdContext(this._ctx, this.state);
        this.enterRule(_localctx, 290, _ApexParser.RULE_soslId);
        try {
          let _alt;
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1966;
            this.id();
            this.state = 1971;
            this._errHandler.sync(this);
            _alt = this.interpreter.adaptivePredict(this._input, 194, this._ctx);
            while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                {
                  {
                    this.state = 1967;
                    this.match(_ApexParser.DOT);
                    this.state = 1968;
                    this.soslId();
                  }
                }
              }
              this.state = 1973;
              this._errHandler.sync(this);
              _alt = this.interpreter.adaptivePredict(this._input, 194, this._ctx);
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      id() {
        let _localctx = new IdContext(this._ctx, this.state);
        this.enterRule(_localctx, 292, _ApexParser.RULE_id);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1974;
            _la = this._input.LA(1);
            if (!((_la & ~31) === 0 && (1 << _la & (1 << _ApexParser.AFTER | 1 << _ApexParser.BEFORE | 1 << _ApexParser.GET | 1 << _ApexParser.INHERITED | 1 << _ApexParser.INSTANCEOF)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.Identifier)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      // @RuleVersion(0)
      anyId() {
        let _localctx = new AnyIdContext(this._ctx, this.state);
        this.enterRule(_localctx, 294, _ApexParser.RULE_anyId);
        let _la;
        try {
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1976;
            _la = this._input.LA(1);
            if (!((_la - 1 & ~31) === 0 && (1 << _la - 1 & (1 << _ApexParser.ABSTRACT - 1 | 1 << _ApexParser.AFTER - 1 | 1 << _ApexParser.BEFORE - 1 | 1 << _ApexParser.BREAK - 1 | 1 << _ApexParser.CATCH - 1 | 1 << _ApexParser.CLASS - 1 | 1 << _ApexParser.CONTINUE - 1 | 1 << _ApexParser.DELETE - 1 | 1 << _ApexParser.DO - 1 | 1 << _ApexParser.ELSE - 1 | 1 << _ApexParser.ENUM - 1 | 1 << _ApexParser.EXTENDS - 1 | 1 << _ApexParser.FINAL - 1 | 1 << _ApexParser.FINALLY - 1 | 1 << _ApexParser.FOR - 1 | 1 << _ApexParser.GET - 1 | 1 << _ApexParser.GLOBAL - 1 | 1 << _ApexParser.IF - 1 | 1 << _ApexParser.IMPLEMENTS - 1 | 1 << _ApexParser.INHERITED - 1 | 1 << _ApexParser.INSERT - 1 | 1 << _ApexParser.INSTANCEOF - 1 | 1 << _ApexParser.INTERFACE - 1 | 1 << _ApexParser.MERGE - 1 | 1 << _ApexParser.NEW - 1 | 1 << _ApexParser.NULL - 1 | 1 << _ApexParser.ON - 1 | 1 << _ApexParser.OVERRIDE - 1 | 1 << _ApexParser.PRIVATE - 1 | 1 << _ApexParser.PROTECTED - 1 | 1 << _ApexParser.PUBLIC - 1 | 1 << _ApexParser.RETURN - 1)) !== 0 || (_la - 34 & ~31) === 0 && (1 << _la - 34 & (1 << _ApexParser.SET - 34 | 1 << _ApexParser.SHARING - 34 | 1 << _ApexParser.STATIC - 34 | 1 << _ApexParser.SUPER - 34 | 1 << _ApexParser.SWITCH - 34 | 1 << _ApexParser.TESTMETHOD - 34 | 1 << _ApexParser.THIS - 34 | 1 << _ApexParser.THROW - 34 | 1 << _ApexParser.TRANSIENT - 34 | 1 << _ApexParser.TRIGGER - 34 | 1 << _ApexParser.TRY - 34 | 1 << _ApexParser.UNDELETE - 34 | 1 << _ApexParser.UPDATE - 34 | 1 << _ApexParser.UPSERT - 34 | 1 << _ApexParser.VIRTUAL - 34 | 1 << _ApexParser.WEBSERVICE - 34 | 1 << _ApexParser.WHEN - 34 | 1 << _ApexParser.WHILE - 34 | 1 << _ApexParser.WITH - 34 | 1 << _ApexParser.WITHOUT - 34 | 1 << _ApexParser.LIST - 34 | 1 << _ApexParser.MAP - 34 | 1 << _ApexParser.SYSTEM - 34 | 1 << _ApexParser.USER - 34 | 1 << _ApexParser.SELECT - 34 | 1 << _ApexParser.COUNT - 34 | 1 << _ApexParser.FROM - 34 | 1 << _ApexParser.AS - 34 | 1 << _ApexParser.USING - 34 | 1 << _ApexParser.SCOPE - 34 | 1 << _ApexParser.WHERE - 34)) !== 0 || (_la - 66 & ~31) === 0 && (1 << _la - 66 & (1 << _ApexParser.ORDER - 66 | 1 << _ApexParser.BY - 66 | 1 << _ApexParser.LIMIT - 66 | 1 << _ApexParser.SOQLAND - 66 | 1 << _ApexParser.SOQLOR - 66 | 1 << _ApexParser.NOT - 66 | 1 << _ApexParser.AVG - 66 | 1 << _ApexParser.COUNT_DISTINCT - 66 | 1 << _ApexParser.MIN - 66 | 1 << _ApexParser.MAX - 66 | 1 << _ApexParser.SUM - 66 | 1 << _ApexParser.TYPEOF - 66 | 1 << _ApexParser.END - 66 | 1 << _ApexParser.THEN - 66 | 1 << _ApexParser.LIKE - 66 | 1 << _ApexParser.IN - 66 | 1 << _ApexParser.INCLUDES - 66 | 1 << _ApexParser.EXCLUDES - 66 | 1 << _ApexParser.ASC - 66 | 1 << _ApexParser.DESC - 66 | 1 << _ApexParser.NULLS - 66 | 1 << _ApexParser.FIRST - 66 | 1 << _ApexParser.LAST - 66 | 1 << _ApexParser.GROUP - 66 | 1 << _ApexParser.ALL - 66 | 1 << _ApexParser.ROWS - 66 | 1 << _ApexParser.VIEW - 66 | 1 << _ApexParser.HAVING - 66 | 1 << _ApexParser.ROLLUP - 66 | 1 << _ApexParser.TOLABEL - 66 | 1 << _ApexParser.OFFSET - 66 | 1 << _ApexParser.DATA - 66)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _ApexParser.CATEGORY - 98 | 1 << _ApexParser.AT - 98 | 1 << _ApexParser.ABOVE - 98 | 1 << _ApexParser.BELOW - 98 | 1 << _ApexParser.ABOVE_OR_BELOW - 98 | 1 << _ApexParser.SECURITY_ENFORCED - 98 | 1 << _ApexParser.SYSTEM_MODE - 98 | 1 << _ApexParser.USER_MODE - 98 | 1 << _ApexParser.REFERENCE - 98 | 1 << _ApexParser.CUBE - 98 | 1 << _ApexParser.FORMAT - 98 | 1 << _ApexParser.TRACKING - 98 | 1 << _ApexParser.VIEWSTAT - 98 | 1 << _ApexParser.CUSTOM - 98 | 1 << _ApexParser.STANDARD - 98 | 1 << _ApexParser.DISTANCE - 98 | 1 << _ApexParser.GEOLOCATION - 98 | 1 << _ApexParser.GROUPING - 98 | 1 << _ApexParser.CONVERT_CURRENCY - 98 | 1 << _ApexParser.CALENDAR_MONTH - 98 | 1 << _ApexParser.CALENDAR_QUARTER - 98 | 1 << _ApexParser.CALENDAR_YEAR - 98 | 1 << _ApexParser.DAY_IN_MONTH - 98 | 1 << _ApexParser.DAY_IN_WEEK - 98 | 1 << _ApexParser.DAY_IN_YEAR - 98 | 1 << _ApexParser.DAY_ONLY - 98 | 1 << _ApexParser.FISCAL_MONTH - 98 | 1 << _ApexParser.FISCAL_QUARTER - 98 | 1 << _ApexParser.FISCAL_YEAR - 98 | 1 << _ApexParser.HOUR_IN_DAY - 98 | 1 << _ApexParser.WEEK_IN_MONTH - 98 | 1 << _ApexParser.WEEK_IN_YEAR - 98)) !== 0 || (_la - 130 & ~31) === 0 && (1 << _la - 130 & (1 << _ApexParser.CONVERT_TIMEZONE - 130 | 1 << _ApexParser.YESTERDAY - 130 | 1 << _ApexParser.TODAY - 130 | 1 << _ApexParser.TOMORROW - 130 | 1 << _ApexParser.LAST_WEEK - 130 | 1 << _ApexParser.THIS_WEEK - 130 | 1 << _ApexParser.NEXT_WEEK - 130 | 1 << _ApexParser.LAST_MONTH - 130 | 1 << _ApexParser.THIS_MONTH - 130 | 1 << _ApexParser.NEXT_MONTH - 130 | 1 << _ApexParser.LAST_90_DAYS - 130 | 1 << _ApexParser.NEXT_90_DAYS - 130 | 1 << _ApexParser.LAST_N_DAYS_N - 130 | 1 << _ApexParser.NEXT_N_DAYS_N - 130 | 1 << _ApexParser.N_DAYS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_WEEKS_N - 130 | 1 << _ApexParser.LAST_N_WEEKS_N - 130 | 1 << _ApexParser.N_WEEKS_AGO_N - 130 | 1 << _ApexParser.NEXT_N_MONTHS_N - 130 | 1 << _ApexParser.LAST_N_MONTHS_N - 130 | 1 << _ApexParser.N_MONTHS_AGO_N - 130 | 1 << _ApexParser.THIS_QUARTER - 130 | 1 << _ApexParser.LAST_QUARTER - 130 | 1 << _ApexParser.NEXT_QUARTER - 130 | 1 << _ApexParser.NEXT_N_QUARTERS_N - 130 | 1 << _ApexParser.LAST_N_QUARTERS_N - 130 | 1 << _ApexParser.N_QUARTERS_AGO_N - 130 | 1 << _ApexParser.THIS_YEAR - 130 | 1 << _ApexParser.LAST_YEAR - 130 | 1 << _ApexParser.NEXT_YEAR - 130 | 1 << _ApexParser.NEXT_N_YEARS_N - 130 | 1 << _ApexParser.LAST_N_YEARS_N - 130)) !== 0 || (_la - 162 & ~31) === 0 && (1 << _la - 162 & (1 << _ApexParser.N_YEARS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_QUARTER - 162 | 1 << _ApexParser.LAST_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_FISCAL_QUARTER - 162 | 1 << _ApexParser.NEXT_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_QUARTERS_N - 162 | 1 << _ApexParser.N_FISCAL_QUARTERS_AGO_N - 162 | 1 << _ApexParser.THIS_FISCAL_YEAR - 162 | 1 << _ApexParser.LAST_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_FISCAL_YEAR - 162 | 1 << _ApexParser.NEXT_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.LAST_N_FISCAL_YEARS_N - 162 | 1 << _ApexParser.N_FISCAL_YEARS_AGO_N - 162 | 1 << _ApexParser.IntegralCurrencyLiteral - 162 | 1 << _ApexParser.FIND - 162 | 1 << _ApexParser.EMAIL - 162 | 1 << _ApexParser.NAME - 162 | 1 << _ApexParser.PHONE - 162 | 1 << _ApexParser.SIDEBAR - 162 | 1 << _ApexParser.FIELDS - 162 | 1 << _ApexParser.METADATA - 162 | 1 << _ApexParser.PRICEBOOKID - 162 | 1 << _ApexParser.NETWORK - 162 | 1 << _ApexParser.SNIPPET - 162 | 1 << _ApexParser.TARGET_LENGTH - 162 | 1 << _ApexParser.DIVISION - 162 | 1 << _ApexParser.RETURNING - 162 | 1 << _ApexParser.LISTVIEW - 162)) !== 0 || _la === _ApexParser.Identifier)) {
              this._errHandler.recoverInline(this);
            } else {
              if (this._input.LA(1) === Token_1.Token.EOF) {
                this.matchedEOF = true;
              }
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
        } catch (re) {
          if (re instanceof RecognitionException_1.RecognitionException) {
            _localctx.exception = re;
            this._errHandler.reportError(this, re);
            this._errHandler.recover(this, re);
          } else {
            throw re;
          }
        } finally {
          this.exitRule();
        }
        return _localctx;
      }
      sempred(_localctx, ruleIndex, predIndex) {
        switch (ruleIndex) {
          case 76:
            return this.expression_sempred(_localctx, predIndex);
        }
        return true;
      }
      expression_sempred(_localctx, predIndex) {
        switch (predIndex) {
          case 0:
            return this.precpred(this._ctx, 14);
          case 1:
            return this.precpred(this._ctx, 13);
          case 2:
            return this.precpred(this._ctx, 12);
          case 3:
            return this.precpred(this._ctx, 11);
          case 4:
            return this.precpred(this._ctx, 9);
          case 5:
            return this.precpred(this._ctx, 8);
          case 6:
            return this.precpred(this._ctx, 7);
          case 7:
            return this.precpred(this._ctx, 6);
          case 8:
            return this.precpred(this._ctx, 5);
          case 9:
            return this.precpred(this._ctx, 4);
          case 10:
            return this.precpred(this._ctx, 3);
          case 11:
            return this.precpred(this._ctx, 2);
          case 12:
            return this.precpred(this._ctx, 1);
          case 13:
            return this.precpred(this._ctx, 23);
          case 14:
            return this.precpred(this._ctx, 22);
          case 15:
            return this.precpred(this._ctx, 17);
          case 16:
            return this.precpred(this._ctx, 10);
        }
        return true;
      }
      static get _ATN() {
        if (!_ApexParser.__ATN) {
          _ApexParser.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(_ApexParser._serializedATN));
        }
        return _ApexParser.__ATN;
      }
    };
    exports2.ApexParser = ApexParser2;
    ApexParser2.ABSTRACT = 1;
    ApexParser2.AFTER = 2;
    ApexParser2.BEFORE = 3;
    ApexParser2.BREAK = 4;
    ApexParser2.CATCH = 5;
    ApexParser2.CLASS = 6;
    ApexParser2.CONTINUE = 7;
    ApexParser2.DELETE = 8;
    ApexParser2.DO = 9;
    ApexParser2.ELSE = 10;
    ApexParser2.ENUM = 11;
    ApexParser2.EXTENDS = 12;
    ApexParser2.FINAL = 13;
    ApexParser2.FINALLY = 14;
    ApexParser2.FOR = 15;
    ApexParser2.GET = 16;
    ApexParser2.GLOBAL = 17;
    ApexParser2.IF = 18;
    ApexParser2.IMPLEMENTS = 19;
    ApexParser2.INHERITED = 20;
    ApexParser2.INSERT = 21;
    ApexParser2.INSTANCEOF = 22;
    ApexParser2.INTERFACE = 23;
    ApexParser2.MERGE = 24;
    ApexParser2.NEW = 25;
    ApexParser2.NULL = 26;
    ApexParser2.ON = 27;
    ApexParser2.OVERRIDE = 28;
    ApexParser2.PRIVATE = 29;
    ApexParser2.PROTECTED = 30;
    ApexParser2.PUBLIC = 31;
    ApexParser2.RETURN = 32;
    ApexParser2.SYSTEMRUNAS = 33;
    ApexParser2.SET = 34;
    ApexParser2.SHARING = 35;
    ApexParser2.STATIC = 36;
    ApexParser2.SUPER = 37;
    ApexParser2.SWITCH = 38;
    ApexParser2.TESTMETHOD = 39;
    ApexParser2.THIS = 40;
    ApexParser2.THROW = 41;
    ApexParser2.TRANSIENT = 42;
    ApexParser2.TRIGGER = 43;
    ApexParser2.TRY = 44;
    ApexParser2.UNDELETE = 45;
    ApexParser2.UPDATE = 46;
    ApexParser2.UPSERT = 47;
    ApexParser2.VIRTUAL = 48;
    ApexParser2.VOID = 49;
    ApexParser2.WEBSERVICE = 50;
    ApexParser2.WHEN = 51;
    ApexParser2.WHILE = 52;
    ApexParser2.WITH = 53;
    ApexParser2.WITHOUT = 54;
    ApexParser2.LIST = 55;
    ApexParser2.MAP = 56;
    ApexParser2.SYSTEM = 57;
    ApexParser2.USER = 58;
    ApexParser2.SELECT = 59;
    ApexParser2.COUNT = 60;
    ApexParser2.FROM = 61;
    ApexParser2.AS = 62;
    ApexParser2.USING = 63;
    ApexParser2.SCOPE = 64;
    ApexParser2.WHERE = 65;
    ApexParser2.ORDER = 66;
    ApexParser2.BY = 67;
    ApexParser2.LIMIT = 68;
    ApexParser2.SOQLAND = 69;
    ApexParser2.SOQLOR = 70;
    ApexParser2.NOT = 71;
    ApexParser2.AVG = 72;
    ApexParser2.COUNT_DISTINCT = 73;
    ApexParser2.MIN = 74;
    ApexParser2.MAX = 75;
    ApexParser2.SUM = 76;
    ApexParser2.TYPEOF = 77;
    ApexParser2.END = 78;
    ApexParser2.THEN = 79;
    ApexParser2.LIKE = 80;
    ApexParser2.IN = 81;
    ApexParser2.INCLUDES = 82;
    ApexParser2.EXCLUDES = 83;
    ApexParser2.ASC = 84;
    ApexParser2.DESC = 85;
    ApexParser2.NULLS = 86;
    ApexParser2.FIRST = 87;
    ApexParser2.LAST = 88;
    ApexParser2.GROUP = 89;
    ApexParser2.ALL = 90;
    ApexParser2.ROWS = 91;
    ApexParser2.VIEW = 92;
    ApexParser2.HAVING = 93;
    ApexParser2.ROLLUP = 94;
    ApexParser2.TOLABEL = 95;
    ApexParser2.OFFSET = 96;
    ApexParser2.DATA = 97;
    ApexParser2.CATEGORY = 98;
    ApexParser2.AT = 99;
    ApexParser2.ABOVE = 100;
    ApexParser2.BELOW = 101;
    ApexParser2.ABOVE_OR_BELOW = 102;
    ApexParser2.SECURITY_ENFORCED = 103;
    ApexParser2.SYSTEM_MODE = 104;
    ApexParser2.USER_MODE = 105;
    ApexParser2.REFERENCE = 106;
    ApexParser2.CUBE = 107;
    ApexParser2.FORMAT = 108;
    ApexParser2.TRACKING = 109;
    ApexParser2.VIEWSTAT = 110;
    ApexParser2.CUSTOM = 111;
    ApexParser2.STANDARD = 112;
    ApexParser2.DISTANCE = 113;
    ApexParser2.GEOLOCATION = 114;
    ApexParser2.GROUPING = 115;
    ApexParser2.CONVERT_CURRENCY = 116;
    ApexParser2.CALENDAR_MONTH = 117;
    ApexParser2.CALENDAR_QUARTER = 118;
    ApexParser2.CALENDAR_YEAR = 119;
    ApexParser2.DAY_IN_MONTH = 120;
    ApexParser2.DAY_IN_WEEK = 121;
    ApexParser2.DAY_IN_YEAR = 122;
    ApexParser2.DAY_ONLY = 123;
    ApexParser2.FISCAL_MONTH = 124;
    ApexParser2.FISCAL_QUARTER = 125;
    ApexParser2.FISCAL_YEAR = 126;
    ApexParser2.HOUR_IN_DAY = 127;
    ApexParser2.WEEK_IN_MONTH = 128;
    ApexParser2.WEEK_IN_YEAR = 129;
    ApexParser2.CONVERT_TIMEZONE = 130;
    ApexParser2.YESTERDAY = 131;
    ApexParser2.TODAY = 132;
    ApexParser2.TOMORROW = 133;
    ApexParser2.LAST_WEEK = 134;
    ApexParser2.THIS_WEEK = 135;
    ApexParser2.NEXT_WEEK = 136;
    ApexParser2.LAST_MONTH = 137;
    ApexParser2.THIS_MONTH = 138;
    ApexParser2.NEXT_MONTH = 139;
    ApexParser2.LAST_90_DAYS = 140;
    ApexParser2.NEXT_90_DAYS = 141;
    ApexParser2.LAST_N_DAYS_N = 142;
    ApexParser2.NEXT_N_DAYS_N = 143;
    ApexParser2.N_DAYS_AGO_N = 144;
    ApexParser2.NEXT_N_WEEKS_N = 145;
    ApexParser2.LAST_N_WEEKS_N = 146;
    ApexParser2.N_WEEKS_AGO_N = 147;
    ApexParser2.NEXT_N_MONTHS_N = 148;
    ApexParser2.LAST_N_MONTHS_N = 149;
    ApexParser2.N_MONTHS_AGO_N = 150;
    ApexParser2.THIS_QUARTER = 151;
    ApexParser2.LAST_QUARTER = 152;
    ApexParser2.NEXT_QUARTER = 153;
    ApexParser2.NEXT_N_QUARTERS_N = 154;
    ApexParser2.LAST_N_QUARTERS_N = 155;
    ApexParser2.N_QUARTERS_AGO_N = 156;
    ApexParser2.THIS_YEAR = 157;
    ApexParser2.LAST_YEAR = 158;
    ApexParser2.NEXT_YEAR = 159;
    ApexParser2.NEXT_N_YEARS_N = 160;
    ApexParser2.LAST_N_YEARS_N = 161;
    ApexParser2.N_YEARS_AGO_N = 162;
    ApexParser2.THIS_FISCAL_QUARTER = 163;
    ApexParser2.LAST_FISCAL_QUARTER = 164;
    ApexParser2.NEXT_FISCAL_QUARTER = 165;
    ApexParser2.NEXT_N_FISCAL_QUARTERS_N = 166;
    ApexParser2.LAST_N_FISCAL_QUARTERS_N = 167;
    ApexParser2.N_FISCAL_QUARTERS_AGO_N = 168;
    ApexParser2.THIS_FISCAL_YEAR = 169;
    ApexParser2.LAST_FISCAL_YEAR = 170;
    ApexParser2.NEXT_FISCAL_YEAR = 171;
    ApexParser2.NEXT_N_FISCAL_YEARS_N = 172;
    ApexParser2.LAST_N_FISCAL_YEARS_N = 173;
    ApexParser2.N_FISCAL_YEARS_AGO_N = 174;
    ApexParser2.DateLiteral = 175;
    ApexParser2.TimeLiteral = 176;
    ApexParser2.DateTimeLiteral = 177;
    ApexParser2.IntegralCurrencyLiteral = 178;
    ApexParser2.FIND = 179;
    ApexParser2.EMAIL = 180;
    ApexParser2.NAME = 181;
    ApexParser2.PHONE = 182;
    ApexParser2.SIDEBAR = 183;
    ApexParser2.FIELDS = 184;
    ApexParser2.METADATA = 185;
    ApexParser2.PRICEBOOKID = 186;
    ApexParser2.NETWORK = 187;
    ApexParser2.SNIPPET = 188;
    ApexParser2.TARGET_LENGTH = 189;
    ApexParser2.DIVISION = 190;
    ApexParser2.RETURNING = 191;
    ApexParser2.LISTVIEW = 192;
    ApexParser2.FindLiteral = 193;
    ApexParser2.FindLiteralAlt = 194;
    ApexParser2.IntegerLiteral = 195;
    ApexParser2.LongLiteral = 196;
    ApexParser2.NumberLiteral = 197;
    ApexParser2.BooleanLiteral = 198;
    ApexParser2.StringLiteral = 199;
    ApexParser2.NullLiteral = 200;
    ApexParser2.LPAREN = 201;
    ApexParser2.RPAREN = 202;
    ApexParser2.LBRACE = 203;
    ApexParser2.RBRACE = 204;
    ApexParser2.LBRACK = 205;
    ApexParser2.RBRACK = 206;
    ApexParser2.SEMI = 207;
    ApexParser2.COMMA = 208;
    ApexParser2.DOT = 209;
    ApexParser2.ASSIGN = 210;
    ApexParser2.GT = 211;
    ApexParser2.LT = 212;
    ApexParser2.BANG = 213;
    ApexParser2.TILDE = 214;
    ApexParser2.QUESTIONDOT = 215;
    ApexParser2.QUESTION = 216;
    ApexParser2.COLON = 217;
    ApexParser2.EQUAL = 218;
    ApexParser2.TRIPLEEQUAL = 219;
    ApexParser2.NOTEQUAL = 220;
    ApexParser2.LESSANDGREATER = 221;
    ApexParser2.TRIPLENOTEQUAL = 222;
    ApexParser2.AND = 223;
    ApexParser2.OR = 224;
    ApexParser2.COAL = 225;
    ApexParser2.INC = 226;
    ApexParser2.DEC = 227;
    ApexParser2.ADD = 228;
    ApexParser2.SUB = 229;
    ApexParser2.MUL = 230;
    ApexParser2.DIV = 231;
    ApexParser2.BITAND = 232;
    ApexParser2.BITOR = 233;
    ApexParser2.CARET = 234;
    ApexParser2.MAPTO = 235;
    ApexParser2.ADD_ASSIGN = 236;
    ApexParser2.SUB_ASSIGN = 237;
    ApexParser2.MUL_ASSIGN = 238;
    ApexParser2.DIV_ASSIGN = 239;
    ApexParser2.AND_ASSIGN = 240;
    ApexParser2.OR_ASSIGN = 241;
    ApexParser2.XOR_ASSIGN = 242;
    ApexParser2.LSHIFT_ASSIGN = 243;
    ApexParser2.RSHIFT_ASSIGN = 244;
    ApexParser2.URSHIFT_ASSIGN = 245;
    ApexParser2.ATSIGN = 246;
    ApexParser2.Identifier = 247;
    ApexParser2.WS = 248;
    ApexParser2.DOC_COMMENT = 249;
    ApexParser2.COMMENT = 250;
    ApexParser2.LINE_COMMENT = 251;
    ApexParser2.RULE_triggerUnit = 0;
    ApexParser2.RULE_triggerCase = 1;
    ApexParser2.RULE_triggerBlock = 2;
    ApexParser2.RULE_triggerBlockMember = 3;
    ApexParser2.RULE_compilationUnit = 4;
    ApexParser2.RULE_typeDeclaration = 5;
    ApexParser2.RULE_classDeclaration = 6;
    ApexParser2.RULE_enumDeclaration = 7;
    ApexParser2.RULE_enumConstants = 8;
    ApexParser2.RULE_interfaceDeclaration = 9;
    ApexParser2.RULE_typeList = 10;
    ApexParser2.RULE_classBody = 11;
    ApexParser2.RULE_interfaceBody = 12;
    ApexParser2.RULE_classBodyDeclaration = 13;
    ApexParser2.RULE_modifier = 14;
    ApexParser2.RULE_memberDeclaration = 15;
    ApexParser2.RULE_triggerMemberDeclaration = 16;
    ApexParser2.RULE_methodDeclaration = 17;
    ApexParser2.RULE_constructorDeclaration = 18;
    ApexParser2.RULE_fieldDeclaration = 19;
    ApexParser2.RULE_propertyDeclaration = 20;
    ApexParser2.RULE_interfaceMethodDeclaration = 21;
    ApexParser2.RULE_variableDeclarators = 22;
    ApexParser2.RULE_variableDeclarator = 23;
    ApexParser2.RULE_arrayInitializer = 24;
    ApexParser2.RULE_typeRef = 25;
    ApexParser2.RULE_arraySubscripts = 26;
    ApexParser2.RULE_typeName = 27;
    ApexParser2.RULE_typeArguments = 28;
    ApexParser2.RULE_formalParameters = 29;
    ApexParser2.RULE_formalParameterList = 30;
    ApexParser2.RULE_formalParameter = 31;
    ApexParser2.RULE_qualifiedName = 32;
    ApexParser2.RULE_literal = 33;
    ApexParser2.RULE_annotation = 34;
    ApexParser2.RULE_elementValuePairs = 35;
    ApexParser2.RULE_elementValuePair = 36;
    ApexParser2.RULE_elementValue = 37;
    ApexParser2.RULE_elementValueArrayInitializer = 38;
    ApexParser2.RULE_block = 39;
    ApexParser2.RULE_localVariableDeclarationStatement = 40;
    ApexParser2.RULE_localVariableDeclaration = 41;
    ApexParser2.RULE_statement = 42;
    ApexParser2.RULE_ifStatement = 43;
    ApexParser2.RULE_switchStatement = 44;
    ApexParser2.RULE_whenControl = 45;
    ApexParser2.RULE_whenValue = 46;
    ApexParser2.RULE_whenLiteral = 47;
    ApexParser2.RULE_forStatement = 48;
    ApexParser2.RULE_whileStatement = 49;
    ApexParser2.RULE_doWhileStatement = 50;
    ApexParser2.RULE_tryStatement = 51;
    ApexParser2.RULE_returnStatement = 52;
    ApexParser2.RULE_throwStatement = 53;
    ApexParser2.RULE_breakStatement = 54;
    ApexParser2.RULE_continueStatement = 55;
    ApexParser2.RULE_accessLevel = 56;
    ApexParser2.RULE_insertStatement = 57;
    ApexParser2.RULE_updateStatement = 58;
    ApexParser2.RULE_deleteStatement = 59;
    ApexParser2.RULE_undeleteStatement = 60;
    ApexParser2.RULE_upsertStatement = 61;
    ApexParser2.RULE_mergeStatement = 62;
    ApexParser2.RULE_runAsStatement = 63;
    ApexParser2.RULE_expressionStatement = 64;
    ApexParser2.RULE_propertyBlock = 65;
    ApexParser2.RULE_getter = 66;
    ApexParser2.RULE_setter = 67;
    ApexParser2.RULE_catchClause = 68;
    ApexParser2.RULE_finallyBlock = 69;
    ApexParser2.RULE_forControl = 70;
    ApexParser2.RULE_forInit = 71;
    ApexParser2.RULE_enhancedForControl = 72;
    ApexParser2.RULE_forUpdate = 73;
    ApexParser2.RULE_parExpression = 74;
    ApexParser2.RULE_expressionList = 75;
    ApexParser2.RULE_expression = 76;
    ApexParser2.RULE_primary = 77;
    ApexParser2.RULE_methodCall = 78;
    ApexParser2.RULE_dotMethodCall = 79;
    ApexParser2.RULE_creator = 80;
    ApexParser2.RULE_createdName = 81;
    ApexParser2.RULE_idCreatedNamePair = 82;
    ApexParser2.RULE_noRest = 83;
    ApexParser2.RULE_classCreatorRest = 84;
    ApexParser2.RULE_arrayCreatorRest = 85;
    ApexParser2.RULE_mapCreatorRest = 86;
    ApexParser2.RULE_mapCreatorRestPair = 87;
    ApexParser2.RULE_setCreatorRest = 88;
    ApexParser2.RULE_arguments = 89;
    ApexParser2.RULE_soqlLiteral = 90;
    ApexParser2.RULE_query = 91;
    ApexParser2.RULE_subQuery = 92;
    ApexParser2.RULE_selectList = 93;
    ApexParser2.RULE_selectEntry = 94;
    ApexParser2.RULE_fieldName = 95;
    ApexParser2.RULE_fromNameList = 96;
    ApexParser2.RULE_subFieldList = 97;
    ApexParser2.RULE_subFieldEntry = 98;
    ApexParser2.RULE_soqlFieldsParameter = 99;
    ApexParser2.RULE_soqlFunction = 100;
    ApexParser2.RULE_dateFieldName = 101;
    ApexParser2.RULE_locationValue = 102;
    ApexParser2.RULE_coordinateValue = 103;
    ApexParser2.RULE_typeOf = 104;
    ApexParser2.RULE_whenClause = 105;
    ApexParser2.RULE_elseClause = 106;
    ApexParser2.RULE_fieldNameList = 107;
    ApexParser2.RULE_usingScope = 108;
    ApexParser2.RULE_whereClause = 109;
    ApexParser2.RULE_logicalExpression = 110;
    ApexParser2.RULE_conditionalExpression = 111;
    ApexParser2.RULE_fieldExpression = 112;
    ApexParser2.RULE_comparisonOperator = 113;
    ApexParser2.RULE_value = 114;
    ApexParser2.RULE_valueList = 115;
    ApexParser2.RULE_signedNumber = 116;
    ApexParser2.RULE_withClause = 117;
    ApexParser2.RULE_filteringExpression = 118;
    ApexParser2.RULE_dataCategorySelection = 119;
    ApexParser2.RULE_dataCategoryName = 120;
    ApexParser2.RULE_filteringSelector = 121;
    ApexParser2.RULE_groupByClause = 122;
    ApexParser2.RULE_orderByClause = 123;
    ApexParser2.RULE_fieldOrderList = 124;
    ApexParser2.RULE_fieldOrder = 125;
    ApexParser2.RULE_limitClause = 126;
    ApexParser2.RULE_offsetClause = 127;
    ApexParser2.RULE_allRowsClause = 128;
    ApexParser2.RULE_forClauses = 129;
    ApexParser2.RULE_boundExpression = 130;
    ApexParser2.RULE_dateFormula = 131;
    ApexParser2.RULE_signedInteger = 132;
    ApexParser2.RULE_soqlId = 133;
    ApexParser2.RULE_soslLiteral = 134;
    ApexParser2.RULE_soslLiteralAlt = 135;
    ApexParser2.RULE_soslClauses = 136;
    ApexParser2.RULE_soslWithClause = 137;
    ApexParser2.RULE_searchGroup = 138;
    ApexParser2.RULE_fieldSpecList = 139;
    ApexParser2.RULE_fieldSpec = 140;
    ApexParser2.RULE_fieldList = 141;
    ApexParser2.RULE_updateList = 142;
    ApexParser2.RULE_updateType = 143;
    ApexParser2.RULE_networkList = 144;
    ApexParser2.RULE_soslId = 145;
    ApexParser2.RULE_id = 146;
    ApexParser2.RULE_anyId = 147;
    ApexParser2.ruleNames = [
      "triggerUnit",
      "triggerCase",
      "triggerBlock",
      "triggerBlockMember",
      "compilationUnit",
      "typeDeclaration",
      "classDeclaration",
      "enumDeclaration",
      "enumConstants",
      "interfaceDeclaration",
      "typeList",
      "classBody",
      "interfaceBody",
      "classBodyDeclaration",
      "modifier",
      "memberDeclaration",
      "triggerMemberDeclaration",
      "methodDeclaration",
      "constructorDeclaration",
      "fieldDeclaration",
      "propertyDeclaration",
      "interfaceMethodDeclaration",
      "variableDeclarators",
      "variableDeclarator",
      "arrayInitializer",
      "typeRef",
      "arraySubscripts",
      "typeName",
      "typeArguments",
      "formalParameters",
      "formalParameterList",
      "formalParameter",
      "qualifiedName",
      "literal",
      "annotation",
      "elementValuePairs",
      "elementValuePair",
      "elementValue",
      "elementValueArrayInitializer",
      "block",
      "localVariableDeclarationStatement",
      "localVariableDeclaration",
      "statement",
      "ifStatement",
      "switchStatement",
      "whenControl",
      "whenValue",
      "whenLiteral",
      "forStatement",
      "whileStatement",
      "doWhileStatement",
      "tryStatement",
      "returnStatement",
      "throwStatement",
      "breakStatement",
      "continueStatement",
      "accessLevel",
      "insertStatement",
      "updateStatement",
      "deleteStatement",
      "undeleteStatement",
      "upsertStatement",
      "mergeStatement",
      "runAsStatement",
      "expressionStatement",
      "propertyBlock",
      "getter",
      "setter",
      "catchClause",
      "finallyBlock",
      "forControl",
      "forInit",
      "enhancedForControl",
      "forUpdate",
      "parExpression",
      "expressionList",
      "expression",
      "primary",
      "methodCall",
      "dotMethodCall",
      "creator",
      "createdName",
      "idCreatedNamePair",
      "noRest",
      "classCreatorRest",
      "arrayCreatorRest",
      "mapCreatorRest",
      "mapCreatorRestPair",
      "setCreatorRest",
      "arguments",
      "soqlLiteral",
      "query",
      "subQuery",
      "selectList",
      "selectEntry",
      "fieldName",
      "fromNameList",
      "subFieldList",
      "subFieldEntry",
      "soqlFieldsParameter",
      "soqlFunction",
      "dateFieldName",
      "locationValue",
      "coordinateValue",
      "typeOf",
      "whenClause",
      "elseClause",
      "fieldNameList",
      "usingScope",
      "whereClause",
      "logicalExpression",
      "conditionalExpression",
      "fieldExpression",
      "comparisonOperator",
      "value",
      "valueList",
      "signedNumber",
      "withClause",
      "filteringExpression",
      "dataCategorySelection",
      "dataCategoryName",
      "filteringSelector",
      "groupByClause",
      "orderByClause",
      "fieldOrderList",
      "fieldOrder",
      "limitClause",
      "offsetClause",
      "allRowsClause",
      "forClauses",
      "boundExpression",
      "dateFormula",
      "signedInteger",
      "soqlId",
      "soslLiteral",
      "soslLiteralAlt",
      "soslClauses",
      "soslWithClause",
      "searchGroup",
      "fieldSpecList",
      "fieldSpec",
      "fieldList",
      "updateList",
      "updateType",
      "networkList",
      "soslId",
      "id",
      "anyId"
    ];
    ApexParser2._LITERAL_NAMES = [
      void 0,
      "'abstract'",
      "'after'",
      "'before'",
      "'break'",
      "'catch'",
      "'class'",
      "'continue'",
      "'delete'",
      "'do'",
      "'else'",
      "'enum'",
      "'extends'",
      "'final'",
      "'finally'",
      "'for'",
      "'get'",
      "'global'",
      "'if'",
      "'implements'",
      "'inherited'",
      "'insert'",
      "'instanceof'",
      "'interface'",
      "'merge'",
      "'new'",
      "'null'",
      "'on'",
      "'override'",
      "'private'",
      "'protected'",
      "'public'",
      "'return'",
      "'system.runas'",
      "'set'",
      "'sharing'",
      "'static'",
      "'super'",
      "'switch'",
      "'testmethod'",
      "'this'",
      "'throw'",
      "'transient'",
      "'trigger'",
      "'try'",
      "'undelete'",
      "'update'",
      "'upsert'",
      "'virtual'",
      "'void'",
      "'webservice'",
      "'when'",
      "'while'",
      "'with'",
      "'without'",
      "'list'",
      "'map'",
      "'system'",
      "'user'",
      "'select'",
      "'count'",
      "'from'",
      "'as'",
      "'using'",
      "'scope'",
      "'where'",
      "'order'",
      "'by'",
      "'limit'",
      "'and'",
      "'or'",
      "'not'",
      "'avg'",
      "'count_distinct'",
      "'min'",
      "'max'",
      "'sum'",
      "'typeof'",
      "'end'",
      "'then'",
      "'like'",
      "'in'",
      "'includes'",
      "'excludes'",
      "'asc'",
      "'desc'",
      "'nulls'",
      "'first'",
      "'last'",
      "'group'",
      "'all'",
      "'rows'",
      "'view'",
      "'having'",
      "'rollup'",
      "'tolabel'",
      "'offset'",
      "'data'",
      "'category'",
      "'at'",
      "'above'",
      "'below'",
      "'above_or_below'",
      "'security_enforced'",
      "'system_mode'",
      "'user_mode'",
      "'reference'",
      "'cube'",
      "'format'",
      "'tracking'",
      "'viewstat'",
      "'custom'",
      "'standard'",
      "'distance'",
      "'geolocation'",
      "'grouping'",
      "'convertcurrency'",
      "'calendar_month'",
      "'calendar_quarter'",
      "'calendar_year'",
      "'day_in_month'",
      "'day_in_week'",
      "'day_in_year'",
      "'day_only'",
      "'fiscal_month'",
      "'fiscal_quarter'",
      "'fiscal_year'",
      "'hour_in_day'",
      "'week_in_month'",
      "'week_in_year'",
      "'converttimezone'",
      "'yesterday'",
      "'today'",
      "'tomorrow'",
      "'last_week'",
      "'this_week'",
      "'next_week'",
      "'last_month'",
      "'this_month'",
      "'next_month'",
      "'last_90_days'",
      "'next_90_days'",
      "'last_n_days'",
      "'next_n_days'",
      "'n_days_ago'",
      "'next_n_weeks'",
      "'last_n_weeks'",
      "'n_weeks_ago'",
      "'next_n_months'",
      "'last_n_months'",
      "'n_months_ago'",
      "'this_quarter'",
      "'last_quarter'",
      "'next_quarter'",
      "'next_n_quarters'",
      "'last_n_quarters'",
      "'n_quarters_ago'",
      "'this_year'",
      "'last_year'",
      "'next_year'",
      "'next_n_years'",
      "'last_n_years'",
      "'n_years_ago'",
      "'this_fiscal_quarter'",
      "'last_fiscal_quarter'",
      "'next_fiscal_quarter'",
      "'next_n_fiscal_quarters'",
      "'last_n_fiscal_quarters'",
      "'n_fiscal_quarters_ago'",
      "'this_fiscal_year'",
      "'last_fiscal_year'",
      "'next_fiscal_year'",
      "'next_n_fiscal_years'",
      "'last_n_fiscal_years'",
      "'n_fiscal_years_ago'",
      void 0,
      void 0,
      void 0,
      void 0,
      "'find'",
      "'email'",
      "'name'",
      "'phone'",
      "'sidebar'",
      "'fields'",
      "'metadata'",
      "'pricebookid'",
      "'network'",
      "'snippet'",
      "'target_length'",
      "'division'",
      "'returning'",
      "'listview'",
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      "'('",
      "')'",
      "'{'",
      "'}'",
      "'['",
      "']'",
      "';'",
      "','",
      "'.'",
      "'='",
      "'>'",
      "'<'",
      "'!'",
      "'~'",
      "'?.'",
      "'?'",
      "':'",
      "'=='",
      "'==='",
      "'!='",
      "'<>'",
      "'!=='",
      "'&&'",
      "'||'",
      "'??'",
      "'++'",
      "'--'",
      "'+'",
      "'-'",
      "'*'",
      "'/'",
      "'&'",
      "'|'",
      "'^'",
      "'=>'",
      "'+='",
      "'-='",
      "'*='",
      "'/='",
      "'&='",
      "'|='",
      "'^='",
      "'<<='",
      "'>>='",
      "'>>>='",
      "'@'"
    ];
    ApexParser2._SYMBOLIC_NAMES = [
      void 0,
      "ABSTRACT",
      "AFTER",
      "BEFORE",
      "BREAK",
      "CATCH",
      "CLASS",
      "CONTINUE",
      "DELETE",
      "DO",
      "ELSE",
      "ENUM",
      "EXTENDS",
      "FINAL",
      "FINALLY",
      "FOR",
      "GET",
      "GLOBAL",
      "IF",
      "IMPLEMENTS",
      "INHERITED",
      "INSERT",
      "INSTANCEOF",
      "INTERFACE",
      "MERGE",
      "NEW",
      "NULL",
      "ON",
      "OVERRIDE",
      "PRIVATE",
      "PROTECTED",
      "PUBLIC",
      "RETURN",
      "SYSTEMRUNAS",
      "SET",
      "SHARING",
      "STATIC",
      "SUPER",
      "SWITCH",
      "TESTMETHOD",
      "THIS",
      "THROW",
      "TRANSIENT",
      "TRIGGER",
      "TRY",
      "UNDELETE",
      "UPDATE",
      "UPSERT",
      "VIRTUAL",
      "VOID",
      "WEBSERVICE",
      "WHEN",
      "WHILE",
      "WITH",
      "WITHOUT",
      "LIST",
      "MAP",
      "SYSTEM",
      "USER",
      "SELECT",
      "COUNT",
      "FROM",
      "AS",
      "USING",
      "SCOPE",
      "WHERE",
      "ORDER",
      "BY",
      "LIMIT",
      "SOQLAND",
      "SOQLOR",
      "NOT",
      "AVG",
      "COUNT_DISTINCT",
      "MIN",
      "MAX",
      "SUM",
      "TYPEOF",
      "END",
      "THEN",
      "LIKE",
      "IN",
      "INCLUDES",
      "EXCLUDES",
      "ASC",
      "DESC",
      "NULLS",
      "FIRST",
      "LAST",
      "GROUP",
      "ALL",
      "ROWS",
      "VIEW",
      "HAVING",
      "ROLLUP",
      "TOLABEL",
      "OFFSET",
      "DATA",
      "CATEGORY",
      "AT",
      "ABOVE",
      "BELOW",
      "ABOVE_OR_BELOW",
      "SECURITY_ENFORCED",
      "SYSTEM_MODE",
      "USER_MODE",
      "REFERENCE",
      "CUBE",
      "FORMAT",
      "TRACKING",
      "VIEWSTAT",
      "CUSTOM",
      "STANDARD",
      "DISTANCE",
      "GEOLOCATION",
      "GROUPING",
      "CONVERT_CURRENCY",
      "CALENDAR_MONTH",
      "CALENDAR_QUARTER",
      "CALENDAR_YEAR",
      "DAY_IN_MONTH",
      "DAY_IN_WEEK",
      "DAY_IN_YEAR",
      "DAY_ONLY",
      "FISCAL_MONTH",
      "FISCAL_QUARTER",
      "FISCAL_YEAR",
      "HOUR_IN_DAY",
      "WEEK_IN_MONTH",
      "WEEK_IN_YEAR",
      "CONVERT_TIMEZONE",
      "YESTERDAY",
      "TODAY",
      "TOMORROW",
      "LAST_WEEK",
      "THIS_WEEK",
      "NEXT_WEEK",
      "LAST_MONTH",
      "THIS_MONTH",
      "NEXT_MONTH",
      "LAST_90_DAYS",
      "NEXT_90_DAYS",
      "LAST_N_DAYS_N",
      "NEXT_N_DAYS_N",
      "N_DAYS_AGO_N",
      "NEXT_N_WEEKS_N",
      "LAST_N_WEEKS_N",
      "N_WEEKS_AGO_N",
      "NEXT_N_MONTHS_N",
      "LAST_N_MONTHS_N",
      "N_MONTHS_AGO_N",
      "THIS_QUARTER",
      "LAST_QUARTER",
      "NEXT_QUARTER",
      "NEXT_N_QUARTERS_N",
      "LAST_N_QUARTERS_N",
      "N_QUARTERS_AGO_N",
      "THIS_YEAR",
      "LAST_YEAR",
      "NEXT_YEAR",
      "NEXT_N_YEARS_N",
      "LAST_N_YEARS_N",
      "N_YEARS_AGO_N",
      "THIS_FISCAL_QUARTER",
      "LAST_FISCAL_QUARTER",
      "NEXT_FISCAL_QUARTER",
      "NEXT_N_FISCAL_QUARTERS_N",
      "LAST_N_FISCAL_QUARTERS_N",
      "N_FISCAL_QUARTERS_AGO_N",
      "THIS_FISCAL_YEAR",
      "LAST_FISCAL_YEAR",
      "NEXT_FISCAL_YEAR",
      "NEXT_N_FISCAL_YEARS_N",
      "LAST_N_FISCAL_YEARS_N",
      "N_FISCAL_YEARS_AGO_N",
      "DateLiteral",
      "TimeLiteral",
      "DateTimeLiteral",
      "IntegralCurrencyLiteral",
      "FIND",
      "EMAIL",
      "NAME",
      "PHONE",
      "SIDEBAR",
      "FIELDS",
      "METADATA",
      "PRICEBOOKID",
      "NETWORK",
      "SNIPPET",
      "TARGET_LENGTH",
      "DIVISION",
      "RETURNING",
      "LISTVIEW",
      "FindLiteral",
      "FindLiteralAlt",
      "IntegerLiteral",
      "LongLiteral",
      "NumberLiteral",
      "BooleanLiteral",
      "StringLiteral",
      "NullLiteral",
      "LPAREN",
      "RPAREN",
      "LBRACE",
      "RBRACE",
      "LBRACK",
      "RBRACK",
      "SEMI",
      "COMMA",
      "DOT",
      "ASSIGN",
      "GT",
      "LT",
      "BANG",
      "TILDE",
      "QUESTIONDOT",
      "QUESTION",
      "COLON",
      "EQUAL",
      "TRIPLEEQUAL",
      "NOTEQUAL",
      "LESSANDGREATER",
      "TRIPLENOTEQUAL",
      "AND",
      "OR",
      "COAL",
      "INC",
      "DEC",
      "ADD",
      "SUB",
      "MUL",
      "DIV",
      "BITAND",
      "BITOR",
      "CARET",
      "MAPTO",
      "ADD_ASSIGN",
      "SUB_ASSIGN",
      "MUL_ASSIGN",
      "DIV_ASSIGN",
      "AND_ASSIGN",
      "OR_ASSIGN",
      "XOR_ASSIGN",
      "LSHIFT_ASSIGN",
      "RSHIFT_ASSIGN",
      "URSHIFT_ASSIGN",
      "ATSIGN",
      "Identifier",
      "WS",
      "DOC_COMMENT",
      "COMMENT",
      "LINE_COMMENT"
    ];
    ApexParser2.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(ApexParser2._LITERAL_NAMES, ApexParser2._SYMBOLIC_NAMES, []);
    ApexParser2._serializedATNSegments = 4;
    ApexParser2._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\xFD\u07BD					\x07	\x07\b	\b			\n	\n\v	\v\f	\f\r	\r													\x1B	\x1B				 	 !	!"	"#	#$	$%	%&	&\'	\'(	()	)*	*+	+,	,-	-.	./	/0	01	12	23	34	45	56	67	78	89	9:	:;	;<	<=	=>	>?	?@	@A	AB	BC	CD	DE	EF	FG	GH	HI	IJ	JK	KL	LM	MN	NO	OP	PQ	QR	RS	ST	TU	UV	VW	WX	XY	YZ	Z[	[\\	\\]	]^	^_	_`	`a	ab	bc	cd	de	ef	fg	gh	hi	ij	jk	kl	lm	mn	no	op	pq	qr	rs	st	tu	uv	vw	wx	xy	yz	z{	{|	|}	}~	~\x7F	\x7F\x80	\x80\x81	\x81\x82	\x82\x83	\x83\x84	\x84\x85	\x85\x86	\x86\x87	\x87\x88	\x88\x89	\x89\x8A	\x8A\x8B	\x8B\x8C	\x8C\x8D	\x8D\x8E	\x8E\x8F	\x8F\x90	\x90\x91	\x91\x92	\x92\x93	\x93\x94	\x94\x95	\x95\x07\u0133\n\f\u0136\v\x07\u0141\n\f\u0144\v\x07\u0149\n\f\u014C\v\u0150\n\x07\x07\x07\u0156\n\x07\f\x07\x07\u0159\v\x07\x07\x07\x07\x07\u015D\n\x07\f\x07\x07\u0160\v\x07\x07\x07\x07\x07\u0164\n\x07\f\x07\x07\u0167\v\x07\x07\x07\u016A\n\x07\b\b\b\b\b\u0170\n\b\b\b\b\u0174\n\b\b\b					\u017C\n			\n\n\n\x07\n\u0183\n\n\f\n\n\u0186\v\n\v\v\v\v\v\u018C\n\v\v\v\f\f\f\x07\f\u0193\n\f\f\f\f\u0196\v\f\r\r\x07\r\u019A\n\r\f\r\r\u019D\v\r\r\r\x07\u01A3\n\f\u01A6\v\u01AC\n\x07\u01B0\n\f\u01B3\v\u01B6\n\u01CB\n\u01D4\n\u01DC\n\u01E0\n\u01E6\n\x07\u01F4\n\f\u01F7\v\x07\u01FC\n\f\u01FF\v\u0203\n\x07\u020C\n\f\u020F\v\u0214\n\x07\u021A\n\f\u021D\v\u0220\n\u0222\n\x1B\x1B\x1B\x07\x1B\u0229\n\x1B\f\x1B\x1B\u022C\v\x1B\x1B\x1B\x07\u0232\n\f\u0235\v\u0239\n\u023D\n\u0241\n\u0245\n\u0247\n\u024F\n   \x07 \u0256\n \f  \u0259\v !\x07!\u025C\n!\f!!\u025F\v!!!!"""\x07"\u0267\n"\f""\u026A\v"##$$$$$$\u0273\n$$$\u0276\n$%%%\u027A\n%%\x07%\u027D\n%\f%%\u0280\v%&&&&\'\'\'\'\u0289\n\'((((\x07(\u028F\n(\f((\u0292\v((\u0294\n(((\u0297\n((())\x07)\u029D\n)\f))\u02A0\v)))***+\x07+\u02A8\n+\f++\u02AB\v++++,,,,,,,,,,,,,,,,,,,,,\u02C4\n,------\u02CB\n-......\u02D2\n.\r..\u02D3..////0000\x070\u02E0\n0\f00\u02E3\v00000\u02E8\n01\x071\u02EB\n1\f11\u02EE\v111\x071\u02F2\n1\f11\u02F5\v1111111111\u02FF\n12222222\u0307\n233333\u030D\n34444445555\u0318\n5\r55\u031955\u031D\n555\u0320\n5666\u0324\n6667777888999:::;;;\u0337\n;;;;<<<\u033E\n<<<<===\u0345\n====>>>\u034C\n>>>>???\u0353\n????\u0357\n???@@@\u035D\n@@@@@AAAA\u0366\nAAAABBBC\x07C\u036F\nC\fCC\u0372\vCCCC\u0376\nCDDDD\u037B\nDEEEE\u0380\nEFFF\x07F\u0385\nF\fFF\u0388\vFFFFFFGGGHHH\u0394\nHHHH\u0398\nHHHH\u039C\nHH\u039E\nHIII\u03A2\nIJJJJJKKLLLLMMM\x07M\u03B2\nM\fMM\u03B5\vMNNNNNNNNNNNNNNNNNNN\u03C9\nNNNNNNNNNNNNNNNN\u03D9\nNNNNNN\u03DF\nNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\u0404\nNNNNNNNNNNN\x07N\u0410\nN\fNN\u0413\vNOOOOOOOOOOOOOO\u0422\nOPPPP\u0427\nPPPPPPP\u042E\nPPPPPP\u0434\nPPP\u0437\nPQQQQ\u043C\nQQQRRRRRRR\u0446\nRSSS\x07S\u044B\nS\fSS\u044E\vSTTTTTT\u0455\nTUUUVVWWWWWWWW\u0463\nWW\u0465\nWXXXX\x07X\u046B\nX\fXX\u046E\vXXXYYYYZZZZ\x07Z\u047A\nZ\fZZ\u047D\vZZZ[[[\u0483\n[[[\\\\\\\\]]]]]]\u0490\n]]]\u0493\n]]]\u0496\n]]]\u0499\n]]]\u049C\n]]]\u049F\n]]]\u04A2\n]]]\u04A5\n]]]]]\u04AA\n]^^^^^^\u04B1\n^^^\u04B4\n^^^\u04B7\n^^^^^\u04BC\n^___\x07_\u04C1\n_\f__\u04C4\v_```\u04C8\n````\u04CC\n``````\u04D2\n```\u04D5\n`aaa\x07a\u04DA\na\faa\u04DD\vabbb\u04E1\nbbbbb\u04E6\nb\x07b\u04E8\nb\fbb\u04EB\vbccc\x07c\u04F0\nc\fcc\u04F3\vcddd\u04F7\ndddd\u04FB\ndddddd\u0501\nddd\u0504\ndeefffffffffffffffffffffffffffffffffffffffffff\u0532\nfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u058F\nfggggggg\u0597\nghhhhhhhhhh\u05A2\nhiii\u05A6\nijjjj\u05AB\nj\rjj\u05ACjj\u05B0\njjjkkkkklllmmm\x07m\u05BF\nm\fmm\u05C2\vmnnnnoooppp\x07p\u05CE\np\fpp\u05D1\vpppp\x07p\u05D6\np\fpp\u05D9\vpppp\u05DD\npqqqqqq\u05E4\nqrrrrrrrrr\u05EE\nrssssssssssssssss\u05FF\nstttttttttttt\u060C\ntt\u060E\ntttttttt\u0616\ntuuuu\x07u\u061C\nu\fuu\u061F\vuuuvv\u0624\nvvvwwwwwwwwwwwww\u0634\nwxxx\x07x\u0639\nx\fxx\u063C\vxyyyyzzzzz\x07z\u0647\nz\fzz\u064A\vzzzz\u064E\nz{{||||||\u0657\n||||||||\x07|\u0660\n|\f||\u0663\v||||||||||\x07|\u066E\n|\f||\u0671\v||||\u0675\n|}}}}~~~\x07~\u067E\n~\f~~\u0681\v~\x7F\x7F\x7F\u0685\n\x7F\x7F\x7F\x7F\u0689\n\x7F\x7F\x7F\x7F\u068D\n\x7F\x7F\x7F\x7F\u0691\n\x7F\x7F\u0693\n\x7F\x80\x80\x80\x80\x80\u0699\n\x80\x81\x81\x81\x81\x81\u069F\n\x81\x82\x82\x82\x83\x83\x07\x83\u06A6\n\x83\f\x83\x83\u06A9\v\x83\x84\x84\x84\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\x85\u0704\n\x85\x86\x86\u0707\n\x86\x86\x86\x87\x87\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\u0717\n\x88\x89\x89\x89\x89\x8A\x8A\x8A\u071F\n\x8A\x8A\x8A\x8A\u0723\n\x8A\x8A\x07\x8A\u0726\n\x8A\f\x8A\x8A\u0729\v\x8A\x8A\x8A\u072C\n\x8A\x8A\x8A\x8A\u0730\n\x8A\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\u0741\n\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\x8B\u075A\n\x8B\x8C\x8C\x8C\x8D\x8D\x8D\x07\x8D\u0762\n\x8D\f\x8D\x8D\u0765\v\x8D\x8E\x8E\x8E\x8E\x8E\x8E\u076C\n\x8E\x8E\x8E\x8E\x8E\x8E\u0772\n\x8E\x8E\x8E\x8E\x8E\u0777\n\x8E\x8E\x8E\u077A\n\x8E\x8E\x8E\u077D\n\x8E\x8E\x8E\x8E\u0781\n\x8E\x8F\x8F\x8F\x07\x8F\u0786\n\x8F\f\x8F\x8F\u0789\v\x8F\x8F\x8F\x8F\x8F\x8F\x8F\u0790\n\x8F\x8F\x8F\x8F\x8F\x8F\x8F\u0797\n\x8F\x8F\x8F\x8F\x8F\x8F\u079D\n\x8F\x8F\x8F\x8F\u07A1\n\x8F\x8F\u07A3\n\x8F\x90\x90\x90\x90\u07A8\n\x90\x91\x91\x92\x92\x92\x92\u07AF\n\x92\x93\x93\x93\x07\x93\u07B4\n\x93\f\x93\x93\u07B7\v\x93\x94\x94\x95\x95\x95\x9A\x96\b\n\f "$&(*,.02468:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\x80\x82\x84\x86\x88\x8A\x8C\x8E\x90\x92\x94\x96\x98\x9A\x9C\x9E\xA0\xA2\xA4\xA6\xA8\xAA\xAC\xAE\xB0\xB2\xB4\xB6\xB8\xBA\xBC\xBE\xC0\xC2\xC4\xC6\xC8\xCA\xCC\xCE\xD0\xD2\xD4\xD6\xD8\xDA\xDC\xDE\xE0\xE2\xE4\xE6\xE8\xEA\xEC\xEE\xF0\xF2\xF4\xF6\xF8\xFA\xFC\xFE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\n\n/0\xC5\xC9\xE6\xE7;<\xE4\xE7\xD7\xD8\xE8\xE9\xD5\xD6\xDC\xE0\xD4\xD4\xEE\xF7\xD3\xD3\xD9\xD9\xE4\xE5\\\\qr\xC5\xC5\xC7\xC7ehVWYZ00^^ll\\\\\xB6\xB9op$%((,-5578;\xB0\xB4\xC2\xF9\xF9\x07"$24\xB0\xB4\xC2\xF9\xF9\u08A7\u012A\u013B\u013E\b\u014F\n\u0151\f\u0169\u016B\u0177\u017F\u0187\u018F\u0197\u01A0\u01B5\u01CA \u01D3"\u01DB$\u01DF&\u01E7(\u01EB*\u01EF,\u01FD.\u02080\u02102\u02154\u02256\u02338\u0246:\u0248<\u024C>\u0252@\u025DB\u0263D\u026BF\u026DH\u0277J\u0281L\u0288N\u028AP\u029AR\u02A3T\u02A9V\u02C3X\u02C5Z\u02CC\\\u02D7^\u02E7`\u02FEb\u0300d\u0308f\u030Eh\u0314j\u0321l\u0327n\u032Bp\u032E';
    ApexParser2._serializedATNSegment1 = `r\u0331t\u0334v\u033Bx\u0342z\u0349|\u0350~\u035A\x80\u0362\x82\u036A\x84\u0370\x86\u0377\x88\u037C\x8A\u0381\x8C\u038E\x8E\u039D\x90\u03A1\x92\u03A3\x94\u03A8\x96\u03AA\x98\u03AE\x9A\u03C8\x9C\u0421\x9E\u0436\xA0\u0438\xA2\u043F\xA4\u0447\xA6\u044F\xA8\u0456\xAA\u0459\xAC\u0464\xAE\u0466\xB0\u0471\xB2\u0475\xB4\u0480\xB6\u0486\xB8\u048A\xBA\u04AB\xBC\u04BD\xBE\u04D4\xC0\u04D6\xC2\u04DE\xC4\u04EC\xC6\u0503\xC8\u0505\xCA\u058E\xCC\u0596\xCE\u05A1\xD0\u05A5\xD2\u05A7\xD4\u05B3\xD6\u05B8\xD8\u05BB\xDA\u05C3\xDC\u05C7\xDE\u05DC\xE0\u05E3\xE2\u05ED\xE4\u05FE\xE6\u0615\xE8\u0617\xEA\u0623\xEC\u0633\xEE\u0635\xF0\u063D\xF2\u064D\xF4\u064F\xF6\u0674\xF8\u0676\xFA\u067A\xFC\u0692\xFE\u0698\u0100\u069E\u0102\u06A0\u0104\u06A7\u0106\u06AA\u0108\u0703\u010A\u0706\u010C\u070A\u010E\u0716\u0110\u0718\u0112\u071E\u0114\u0759\u0116\u075B\u0118\u075E\u011A\u0766\u011C\u07A2\u011E\u07A4\u0120\u07A9\u0122\u07AB\u0124\u07B0\u0126\u07B8\u0128\u07BA\u012A\u012B\x07-\u012B\u012C\u0126\x94\u012C\u012D\x07\u012D\u012E\u0126\x94\u012E\u012F\x07\xCB\u012F\u0134\u0130\u0131\x07\xD2\u0131\u0133\u0132\u0130\u0133\u0136\u0134\u0132\u0134\u0135\u0135\u0137\u0136\u0134\u0137\u0138\x07\xCC\u0138\u0139\u0139\u013A\x07\u013A\u013B\u013C	\u013C\u013D	\u013D\u013E\u0142\x07\xCD\u013F\u0141\b\u0140\u013F\u0141\u0144\u0142\u0140\u0142\u0143\u0143\u0145\u0144\u0142\u0145\u0146\x07\xCE\u0146\x07\u0147\u0149\u0148\u0147\u0149\u014C\u014A\u0148\u014A\u014B\u014B\u014D\u014C\u014A\u014D\u0150"\u014E\u0150V,\u014F\u014A\u014F\u014E\u0150	\u0151\u0152\f\x07\u0152\u0153\x07\u0153\v\u0154\u0156\u0155\u0154\u0156\u0159\u0157\u0155\u0157\u0158\u0158\u015A\u0159\u0157\u015A\u016A\b\u015B\u015D\u015C\u015B\u015D\u0160\u015E\u015C\u015E\u015F\u015F\u0161\u0160\u015E\u0161\u016A	\u0162\u0164\u0163\u0162\u0164\u0167\u0165\u0163\u0165\u0166\u0166\u0168\u0167\u0165\u0168\u016A\v\u0169\u0157\u0169\u015E\u0169\u0165\u016A\r\u016B\u016C\x07\b\u016C\u016F\u0126\x94\u016D\u016E\x07\u016E\u01704\x1B\u016F\u016D\u016F\u0170\u0170\u0173\u0171\u0172\x07\u0172\u0174\f\u0173\u0171\u0173\u0174\u0174\u0175\u0175\u0176\r\u0176\u0177\u0178\x07\r\u0178\u0179\u0126\x94\u0179\u017B\x07\xCD\u017A\u017C
\u017B\u017A\u017B\u017C\u017C\u017D\u017D\u017E\x07\xCE\u017E\u017F\u0184\u0126\x94\u0180\u0181\x07\xD2\u0181\u0183\u0126\x94\u0182\u0180\u0183\u0186\u0184\u0182\u0184\u0185\u0185\u0186\u0184\u0187\u0188\x07\u0188\u018B\u0126\x94\u0189\u018A\x07\u018A\u018C\f\u018B\u0189\u018B\u018C\u018C\u018D\u018D\u018E\u018E\u018F\u01944\x1B\u0190\u0191\x07\xD2\u0191\u01934\x1B\u0192\u0190\u0193\u0196\u0194\u0192\u0194\u0195\u0195\u0196\u0194\u0197\u019B\x07\xCD\u0198\u019A\u0199\u0198\u019A\u019D\u019B\u0199\u019B\u019C\u019C\u019E\u019D\u019B\u019E\u019F\x07\xCE\u019F\u01A0\u01A4\x07\xCD\u01A1\u01A3,\u01A2\u01A1\u01A3\u01A6\u01A4\u01A2\u01A4\u01A5\u01A5\u01A7\u01A6\u01A4\u01A7\u01A8\x07\xCE\u01A8\x1B\u01A9\u01B6\x07\xD1\u01AA\u01AC\x07&\u01AB\u01AA\u01AB\u01AC\u01AC\u01AD\u01AD\u01B6P)\u01AE\u01B0\u01AF\u01AE\u01B0\u01B3\u01B1\u01AF\u01B1\u01B2\u01B2\u01B4\u01B3\u01B1\u01B4\u01B6 \u01B5\u01A9\u01B5\u01AB\u01B5\u01B1\u01B6\u01B7\u01CBF$\u01B8\u01CB\x07\u01B9\u01CB\x07!\u01BA\u01CB\x07 \u01BB\u01CB\x07\u01BC\u01CB\x07,\u01BD\u01CB\x07&\u01BE\u01CB\x07\u01BF\u01CB\x07\u01C0\u01CB\x074\u01C1\u01CB\x07\u01C2\u01CB\x072\u01C3\u01CB\x07)\u01C4\u01C5\x077\u01C5\u01CB\x07%\u01C6\u01C7\x078\u01C7\u01CB\x07%\u01C8\u01C9\x07\u01C9\u01CB\x07%\u01CA\u01B7\u01CA\u01B8\u01CA\u01B9\u01CA\u01BA\u01CA\u01BB\u01CA\u01BC\u01CA\u01BD\u01CA\u01BE\u01CA\u01BF\u01CA\u01C0\u01CA\u01C1\u01CA\u01C2\u01CA\u01C3\u01CA\u01C4\u01CA\u01C6\u01CA\u01C8\u01CB\u01CC\u01D4$\u01CD\u01D4&\u01CE\u01D4\v\u01CF\u01D4\b\u01D0\u01D4	\u01D1\u01D4*\u01D2\u01D4(\u01D3\u01CC\u01D3\u01CD\u01D3\u01CE\u01D3\u01CF\u01D3\u01D0\u01D3\u01D1\u01D3\u01D2\u01D4!\u01D5\u01DC$\u01D6\u01DC\v\u01D7\u01DC\b\u01D8\u01DC	\u01D9\u01DC*\u01DA\u01DC(\u01DB\u01D5\u01DB\u01D6\u01DB\u01D7\u01DB\u01D8\u01DB\u01D9\u01DB\u01DA\u01DC#\u01DD\u01E04\x1B\u01DE\u01E0\x073\u01DF\u01DD\u01DF\u01DE\u01E0\u01E1\u01E1\u01E2\u0126\x94\u01E2\u01E5<\u01E3\u01E6P)\u01E4\u01E6\x07\xD1\u01E5\u01E3\u01E5\u01E4\u01E6%\u01E7\u01E8B"\u01E8\u01E9<\u01E9\u01EAP)\u01EA'\u01EB\u01EC4\x1B\u01EC\u01ED.\u01ED\u01EE\x07\xD1\u01EE)\u01EF\u01F04\x1B\u01F0\u01F1\u0126\x94\u01F1\u01F5\x07\xCD\u01F2\u01F4\x84C\u01F3\u01F2\u01F4\u01F7\u01F5\u01F3\u01F5\u01F6\u01F6\u01F8\u01F7\u01F5\u01F8\u01F9\x07\xCE\u01F9+\u01FA\u01FC\u01FB\u01FA\u01FC\u01FF\u01FD\u01FB\u01FD\u01FE\u01FE\u0202\u01FF\u01FD\u0200\u02034\x1B\u0201\u0203\x073\u0202\u0200\u0202\u0201\u0203\u0204\u0204\u0205\u0126\x94\u0205\u0206<\u0206\u0207\x07\xD1\u0207-\u0208\u020D0\u0209\u020A\x07\xD2\u020A\u020C0\u020B\u0209\u020C\u020F\u020D\u020B\u020D\u020E\u020E/\u020F\u020D\u0210\u0213\u0126\x94\u0211\u0212\x07\xD4\u0212\u0214\x9AN\u0213\u0211\u0213\u0214\u02141\u0215\u0221\x07\xCD\u0216\u021B\x9AN\u0217\u0218\x07\xD2\u0218\u021A\x9AN\u0219\u0217\u021A\u021D\u021B\u0219\u021B\u021C\u021C\u021F\u021D\u021B\u021E\u0220\x07\xD2\u021F\u021E\u021F\u0220\u0220\u0222\u0221\u0216\u0221\u0222\u0222\u0223\u0223\u0224\x07\xCE\u02243\u0225\u022A8\u0226\u0227\x07\xD3\u0227\u02298\u0228\u0226\u0229\u022C\u022A\u0228\u022A\u022B\u022B\u022D\u022C\u022A\u022D\u022E6\u022E5\u022F\u0230\x07\xCF\u0230\u0232\x07\xD0\u0231\u022F\u0232\u0235\u0233\u0231\u0233\u0234\u02347\u0235\u0233\u0236\u0238\x079\u0237\u0239:\u0238\u0237\u0238\u0239\u0239\u0247\u023A\u023C\x07$\u023B\u023D:\u023C\u023B\u023C\u023D\u023D\u0247\u023E\u0240\x07:\u023F\u0241:\u0240\u023F\u0240\u0241\u0241\u0247\u0242\u0244\u0126\x94\u0243\u0245:\u0244\u0243\u0244\u0245\u0245\u0247\u0246\u0236\u0246\u023A\u0246\u023E\u0246\u0242\u02479\u0248\u0249\x07\xD6\u0249\u024A\f\u024A\u024B\x07\xD5\u024B;\u024C\u024E\x07\xCB\u024D\u024F> \u024E\u024D\u024E\u024F\u024F\u0250\u0250\u0251\x07\xCC\u0251=\u0252\u0257@!\u0253\u0254\x07\xD2\u0254\u0256@!\u0255\u0253\u0256\u0259\u0257\u0255\u0257\u0258\u0258?\u0259\u0257\u025A\u025C\u025B\u025A\u025C\u025F\u025D\u025B\u025D\u025E\u025E\u0260\u025F\u025D\u0260\u02614\x1B\u0261\u0262\u0126\x94\u0262A\u0263\u0268\u0126\x94\u0264\u0265\x07\xD3\u0265\u0267\u0126\x94\u0266\u0264\u0267\u026A\u0268\u0266\u0268\u0269\u0269C\u026A\u0268\u026B\u026C	\u026CE\u026D\u026E\x07\xF8\u026E\u0275B"\u026F\u0272\x07\xCB\u0270\u0273H%\u0271\u0273L'\u0272\u0270\u0272\u0271\u0272\u0273\u0273\u0274\u0274\u0276\x07\xCC\u0275\u026F\u0275\u0276\u0276G\u0277\u027EJ&\u0278\u027A\x07\xD2\u0279\u0278\u0279\u027A\u027A\u027B\u027B\u027DJ&\u027C\u0279\u027D\u0280\u027E\u027C\u027E\u027F\u027FI\u0280\u027E\u0281\u0282\u0126\x94\u0282\u0283\x07\xD4\u0283\u0284L'\u0284K\u0285\u0289\x9AN\u0286\u0289F$\u0287\u0289N(\u0288\u0285\u0288\u0286\u0288\u0287\u0289M\u028A\u0293\x07\xCD\u028B\u0290L'\u028C\u028D\x07\xD2\u028D\u028FL'\u028E\u028C\u028F\u0292\u0290\u028E\u0290\u0291\u0291\u0294\u0292\u0290\u0293\u028B\u0293\u0294\u0294\u0296\u0295\u0297\x07\xD2\u0296\u0295\u0296\u0297\u0297\u0298\u0298\u0299\x07\xCE\u0299O\u029A\u029E\x07\xCD\u029B\u029DV,\u029C\u029B\u029D\u02A0\u029E\u029C\u029E\u029F\u029F\u02A1\u02A0\u029E\u02A1\u02A2\x07\xCE\u02A2Q\u02A3\u02A4T+\u02A4\u02A5\x07\xD1\u02A5S\u02A6\u02A8\u02A7\u02A6\u02A8\u02AB\u02A9\u02A7\u02A9\u02AA\u02AA\u02AC\u02AB\u02A9\u02AC\u02AD4\x1B\u02AD\u02AE.\u02AEU\u02AF\u02C4P)\u02B0\u02C4X-\u02B1\u02C4Z.\u02B2\u02C4b2\u02B3\u02C4d3\u02B4\u02C4f4\u02B5\u02C4h5\u02B6\u02C4j6\u02B7\u02C4l7\u02B8\u02C4n8\u02B9\u02C4p9\u02BA\u02C4t;\u02BB\u02C4v<\u02BC\u02C4x=\u02BD\u02C4z>\u02BE\u02C4|?\u02BF\u02C4~@\u02C0\u02C4\x80A\u02C1\u02C4R*\u02C2\u02C4\x82B\u02C3\u02AF\u02C3\u02B0\u02C3\u02B1\u02C3\u02B2\u02C3\u02B3\u02C3\u02B4\u02C3\u02B5\u02C3\u02B6\u02C3\u02B7\u02C3\u02B8\u02C3\u02B9\u02C3\u02BA\u02C3\u02BB\u02C3\u02BC\u02C3\u02BD\u02C3\u02BE\u02C3\u02BF\u02C3\u02C0\u02C3\u02C1\u02C3\u02C2\u02C4W\u02C5\u02C6\x07\u02C6\u02C7\x96L\u02C7\u02CAV,\u02C8\u02C9\x07\f\u02C9\u02CBV,\u02CA\u02C8\u02CA\u02CB\u02CBY\u02CC\u02CD\x07(\u02CD\u02CE\x07\u02CE\u02CF\x9AN\u02CF\u02D1\x07\xCD\u02D0\u02D2\\/\u02D1\u02D0\u02D2\u02D3\u02D3\u02D1\u02D3\u02D4\u02D4\u02D5\u02D5\u02D6\x07\xCE\u02D6[\u02D7\u02D8\x075\u02D8\u02D9^0\u02D9\u02DAP)\u02DA]\u02DB\u02E8\x07\f\u02DC\u02E1\`1\u02DD\u02DE\x07\xD2\u02DE\u02E0\`1\u02DF\u02DD\u02E0\u02E3\u02E1\u02DF\u02E1\u02E2\u02E2\u02E8\u02E3\u02E1\u02E4\u02E54\x1B\u02E5\u02E6\u0126\x94\u02E6\u02E8\u02E7\u02DB\u02E7\u02DC\u02E7\u02E4\u02E8_\u02E9\u02EB	\u02EA\u02E9\u02EB\u02EE\u02EC\u02EA\u02EC\u02ED\u02ED\u02EF\u02EE\u02EC\u02EF\u02FF\x07\xC5\u02F0\u02F2	\u02F1\u02F0\u02F2\u02F5\u02F3\u02F1\u02F3\u02F4\u02F4\u02F6\u02F5\u02F3\u02F6\u02FF\x07\xC6\u02F7\u02FF\x07\xC9\u02F8\u02FF\x07\u02F9\u02FF\u0126\x94\u02FA\u02FB\x07\xCB\u02FB\u02FC\`1\u02FC\u02FD\x07\xCC\u02FD\u02FF\u02FE\u02EC\u02FE\u02F3\u02FE\u02F7\u02FE\u02F8\u02FE\u02F9\u02FE\u02FA\u02FFa\u0300\u0301\x07\u0301\u0302\x07\xCB\u0302\u0303\x8EH\u0303\u0306\x07\xCC\u0304\u0307V,\u0305\u0307\x07\xD1\u0306\u0304\u0306\u0305\u0307c\u0308\u0309\x076\u0309\u030C\x96L\u030A\u030DV,\u030B\u030D\x07\xD1\u030C\u030A\u030C\u030B\u030De\u030E\u030F\x07\v\u030F\u0310P)\u0310\u0311\x076\u0311\u0312\x96L\u0312\u0313\x07\xD1\u0313g\u0314\u0315\x07.\u0315\u031FP)\u0316\u0318\x8AF\u0317\u0316\u0318\u0319\u0319\u0317\u0319\u031A\u031A\u031C\u031B\u031D\x8CG\u031C\u031B\u031C\u031D\u031D\u0320\u031E\u0320\x8CG\u031F\u0317\u031F\u031E\u0320i\u0321\u0323\x07"\u0322\u0324\x9AN\u0323\u0322\u0323\u0324\u0324\u0325\u0325\u0326\x07\xD1\u0326k\u0327\u0328\x07+\u0328\u0329\x9AN\u0329\u032A\x07\xD1\u032Am\u032B\u032C\x07\u032C\u032D\x07\xD1\u032Do\u032E\u032F\x07	\u032F\u0330\x07\xD1\u0330q\u0331\u0332\x07@\u0332\u0333	\u0333s\u0334\u0336\x07\u0335\u0337r:\u0336\u0335\u0336\u0337\u0337\u0338\u0338\u0339\x9AN\u0339\u033A\x07\xD1\u033Au\u033B\u033D\x070\u033C\u033Er:\u033D\u033C\u033D\u033E\u033E\u033F\u033F\u0340\x9AN\u0340\u0341\x07\xD1\u0341w\u0342\u0344\x07
\u0343\u0345r:\u0344\u0343\u0344\u0345\u0345\u0346\u0346\u0347\x9AN\u0347\u0348\x07\xD1\u0348y\u0349\u034B\x07/\u034A\u034Cr:\u034B\u034A\u034B\u034C\u034C\u034D\u034D\u034E\x9AN\u034E\u034F\x07\xD1\u034F{\u0350\u0352\x071\u0351\u0353r:\u0352\u0351\u0352\u0353\u0353\u0354\u0354\u0356\x9AN\u0355\u0357B"\u0356\u0355\u0356\u0357\u0357\u0358\u0358\u0359\x07\xD1\u0359}\u035A\u035C\x07\u035B\u035Dr:\u035C\u035B\u035C\u035D\u035D\u035E\u035E\u035F\x9AN\u035F\u0360\x9AN\u0360\u0361\x07\xD1\u0361\x7F\u0362\u0363\x07#\u0363\u0365\x07\xCB\u0364\u0366\x98M\u0365\u0364\u0365\u0366\u0366\u0367\u0367\u0368\x07\xCC\u0368\u0369P)\u0369\x81\u036A\u036B\x9AN\u036B\u036C\x07\xD1\u036C\x83\u036D\u036F\u036E\u036D\u036F\u0372\u0370\u036E\u0370\u0371\u0371\u0375\u0372\u0370\u0373\u0376\x86D\u0374\u0376\x88E\u0375\u0373\u0375\u0374\u0376\x85\u0377\u037A\x07\u0378\u037B\x07\xD1\u0379\u037BP)\u037A\u0378\u037A\u0379\u037B\x87\u037C\u037F\x07$\u037D\u0380\x07\xD1\u037E\u0380P)\u037F\u037D\u037F\u037E\u0380\x89\u0381\u0382\x07\x07\u0382\u0386\x07\xCB\u0383\u0385\u0384\u0383\u0385\u0388\u0386\u0384\u0386\u0387\u0387\u0389\u0388\u0386\u0389\u038AB"\u038A\u038B\u0126\x94`;
    ApexParser2._serializedATNSegment2 = "\u038B\u038C\x07\xCC\u038C\u038DP)\u038D\x8B\u038E\u038F\x07\u038F\u0390P)\u0390\x8D\u0391\u039E\x92J\u0392\u0394\x90I\u0393\u0392\u0393\u0394\u0394\u0395\u0395\u0397\x07\xD1\u0396\u0398\x9AN\u0397\u0396\u0397\u0398\u0398\u0399\u0399\u039B\x07\xD1\u039A\u039C\x94K\u039B\u039A\u039B\u039C\u039C\u039E\u039D\u0391\u039D\u0393\u039E\x8F\u039F\u03A2T+\u03A0\u03A2\x98M\u03A1\u039F\u03A1\u03A0\u03A2\x91\u03A3\u03A44\x1B\u03A4\u03A5\u0126\x94\u03A5\u03A6\x07\xDB\u03A6\u03A7\x9AN\u03A7\x93\u03A8\u03A9\x98M\u03A9\x95\u03AA\u03AB\x07\xCB\u03AB\u03AC\x9AN\u03AC\u03AD\x07\xCC\u03AD\x97\u03AE\u03B3\x9AN\u03AF\u03B0\x07\xD2\u03B0\u03B2\x9AN\u03B1\u03AF\u03B2\u03B5\u03B3\u03B1\u03B3\u03B4\u03B4\x99\u03B5\u03B3\u03B6\u03B7\bN\u03B7\u03C9\x9CO\u03B8\u03C9\x9EP\u03B9\u03BA\x07\x1B\u03BA\u03C9\xA2R\u03BB\u03BC\x07\xCB\u03BC\u03BD4\x1B\u03BD\u03BE\x07\xCC\u03BE\u03BF\x9AN\u03BF\u03C9\u03C0\u03C1\x07\xCB\u03C1\u03C2\x9AN\u03C2\u03C3\x07\xCC\u03C3\u03C9\u03C4\u03C5	\x07\u03C5\u03C9\x9AN\u03C6\u03C7	\b\u03C7\u03C9\x9AN\u03C8\u03B6\u03C8\u03B8\u03C8\u03B9\u03C8\u03BB\u03C8\u03C0\u03C8\u03C4\u03C8\u03C6\u03C9\u0411\u03CA\u03CB\f\u03CB\u03CC		\u03CC\u0410\x9AN\u03CD\u03CE\f\u03CE\u03CF	\u03CF\u0410\x9AN\u03D0\u03D8\f\u03D1\u03D2\x07\xD6\u03D2\u03D9\x07\xD6\u03D3\u03D4\x07\xD5\u03D4\u03D5\x07\xD5\u03D5\u03D9\x07\xD5\u03D6\u03D7\x07\xD5\u03D7\u03D9\x07\xD5\u03D8\u03D1\u03D8\u03D3\u03D8\u03D6\u03D9\u03DA\u03DA\u0410\x9AN\u03DB\u03DC\f\r\u03DC\u03DE	\n\u03DD\u03DF\x07\xD4\u03DE\u03DD\u03DE\u03DF\u03DF\u03E0\u03E0\u0410\x9AN\u03E1\u03E2\f\v\u03E2\u03E3	\v\u03E3\u0410\x9AN\f\u03E4\u03E5\f\n\u03E5\u03E6\x07\xEA\u03E6\u0410\x9AN\v\u03E7\u03E8\f	\u03E8\u03E9\x07\xEC\u03E9\u0410\x9AN\n\u03EA\u03EB\f\b\u03EB\u03EC\x07\xEB\u03EC\u0410\x9AN	\u03ED\u03EE\f\x07\u03EE\u03EF\x07\xE1\u03EF\u0410\x9AN\b\u03F0\u03F1\f\u03F1\u03F2\x07\xE2\u03F2\u0410\x9AN\x07\u03F3\u03F4\f\u03F4\u03F5\x07\xE3\u03F5\u0410\x9AN\u03F6\u03F7\f\u03F7\u03F8\x07\xDA\u03F8\u03F9\x9AN\u03F9\u03FA\x07\xDB\u03FA\u03FB\x9AN\u03FB\u0410\u03FC\u03FD\f\u03FD\u03FE	\f\u03FE\u0410\x9AN\u03FF\u0400\f\u0400\u0403	\r\u0401\u0404\xA0Q\u0402\u0404\u0128\x95\u0403\u0401\u0403\u0402\u0404\u0410\u0405\u0406\f\u0406\u0407\x07\xCF\u0407\u0408\x9AN\u0408\u0409\x07\xD0\u0409\u0410\u040A\u040B\f\u040B\u0410	\u040C\u040D\f\f\u040D\u040E\x07\u040E\u04104\x1B\u040F\u03CA\u040F\u03CD\u040F\u03D0\u040F\u03DB\u040F\u03E1\u040F\u03E4\u040F\u03E7\u040F\u03EA\u040F\u03ED\u040F\u03F0\u040F\u03F3\u040F\u03F6\u040F\u03FC\u040F\u03FF\u040F\u0405\u040F\u040A\u040F\u040C\u0410\u0413\u0411\u040F\u0411\u0412\u0412\x9B\u0413\u0411\u0414\u0422\x07*\u0415\u0422\x07'\u0416\u0422D#\u0417\u04184\x1B\u0418\u0419\x07\xD3\u0419\u041A\x07\b\u041A\u0422\u041B\u041C\x073\u041C\u041D\x07\xD3\u041D\u0422\x07\b\u041E\u0422\u0126\x94\u041F\u0422\xB6\\\u0420\u0422\u010E\x88\u0421\u0414\u0421\u0415\u0421\u0416\u0421\u0417\u0421\u041B\u0421\u041E\u0421\u041F\u0421\u0420\u0422\x9D\u0423\u0424\u0126\x94\u0424\u0426\x07\xCB\u0425\u0427\x98M\u0426\u0425\u0426\u0427\u0427\u0428\u0428\u0429\x07\xCC\u0429\u0437\u042A\u042B\x07*\u042B\u042D\x07\xCB\u042C\u042E\x98M\u042D\u042C\u042D\u042E\u042E\u042F\u042F\u0437\x07\xCC\u0430\u0431\x07'\u0431\u0433\x07\xCB\u0432\u0434\x98M\u0433\u0432\u0433\u0434\u0434\u0435\u0435\u0437\x07\xCC\u0436\u0423\u0436\u042A\u0436\u0430\u0437\x9F\u0438\u0439\u0128\x95\u0439\u043B\x07\xCB\u043A\u043C\x98M\u043B\u043A\u043B\u043C\u043C\u043D\u043D\u043E\x07\xCC\u043E\xA1\u043F\u0445\xA4S\u0440\u0446\xA8U\u0441\u0446\xAAV\u0442\u0446\xACW\u0443\u0446\xAEX\u0444\u0446\xB2Z\u0445\u0440\u0445\u0441\u0445\u0442\u0445\u0443\u0445\u0444\u0446\xA3\u0447\u044C\xA6T\u0448\u0449\x07\xD3\u0449\u044B\xA6T\u044A\u0448\u044B\u044E\u044C\u044A\u044C\u044D\u044D\xA5\u044E\u044C\u044F\u0454\u0128\x95\u0450\u0451\x07\xD6\u0451\u0452\f\u0452\u0453\x07\xD5\u0453\u0455\u0454\u0450\u0454\u0455\u0455\xA7\u0456\u0457\x07\xCD\u0457\u0458\x07\xCE\u0458\xA9\u0459\u045A\xB4[\u045A\xAB\u045B\u045C\x07\xCF\u045C\u045D\x9AN\u045D\u045E\x07\xD0\u045E\u0465\u045F\u0460\x07\xCF\u0460\u0462\x07\xD0\u0461\u04632\u0462\u0461\u0462\u0463\u0463\u0465\u0464\u045B\u0464\u045F\u0465\xAD\u0466\u0467\x07\xCD\u0467\u046C\xB0Y\u0468\u0469\x07\xD2\u0469\u046B\xB0Y\u046A\u0468\u046B\u046E\u046C\u046A\u046C\u046D\u046D\u046F\u046E\u046C\u046F\u0470\x07\xCE\u0470\xAF\u0471\u0472\x9AN\u0472\u0473\x07\xED\u0473\u0474\x9AN\u0474\xB1\u0475\u0476\x07\xCD\u0476\u047B\x9AN\u0477\u0478\x07\xD2\u0478\u047A\x9AN\u0479\u0477\u047A\u047D\u047B\u0479\u047B\u047C\u047C\u047E\u047D\u047B\u047E\u047F\x07\xCE\u047F\xB3\u0480\u0482\x07\xCB\u0481\u0483\x98M\u0482\u0481\u0482\u0483\u0483\u0484\u0484\u0485\x07\xCC\u0485\xB5\u0486\u0487\x07\xCF\u0487\u0488\xB8]\u0488\u0489\x07\xD0\u0489\xB7\u048A\u048B\x07=\u048B\u048C\xBC_\u048C\u048D\x07?\u048D\u048F\xC2b\u048E\u0490\xDAn\u048F\u048E\u048F\u0490\u0490\u0492\u0491\u0493\xDCo\u0492\u0491\u0492\u0493\u0493\u0495\u0494\u0496\xECw\u0495\u0494\u0495\u0496\u0496\u0498\u0497\u0499\xF6|\u0498\u0497\u0498\u0499\u0499\u049B\u049A\u049C\xF8}\u049B\u049A\u049B\u049C\u049C\u049E\u049D\u049F\xFE\x80\u049E\u049D\u049E\u049F\u049F\u04A1\u04A0\u04A2\u0100\x81\u04A1\u04A0\u04A1\u04A2\u04A2\u04A4\u04A3\u04A5\u0102\x82\u04A4\u04A3\u04A4\u04A5\u04A5\u04A6\u04A6\u04A9\u0104\x83\u04A7\u04A8\x070\u04A8\u04AA\u011E\x90\u04A9\u04A7\u04A9\u04AA\u04AA\xB9\u04AB\u04AC\x07=\u04AC\u04AD\xC4c\u04AD\u04AE\x07?\u04AE\u04B0\xC2b\u04AF\u04B1\xDCo\u04B0\u04AF\u04B0\u04B1\u04B1\u04B3\u04B2\u04B4\xF8}\u04B3\u04B2\u04B3\u04B4\u04B4\u04B6\u04B5\u04B7\xFE\x80\u04B6\u04B5\u04B6\u04B7\u04B7\u04B8\u04B8\u04BB\u0104\x83\u04B9\u04BA\x070\u04BA\u04BC\u011E\x90\u04BB\u04B9\u04BB\u04BC\u04BC\xBB\u04BD\u04C2\xBE`\u04BE\u04BF\x07\xD2\u04BF\u04C1\xBE`\u04C0\u04BE\u04C1\u04C4\u04C2\u04C0\u04C2\u04C3\u04C3\xBD\u04C4\u04C2\u04C5\u04C7\xC0a\u04C6\u04C8\u010C\x87\u04C7\u04C6\u04C7\u04C8\u04C8\u04D5\u04C9\u04CB\xCAf\u04CA\u04CC\u010C\x87\u04CB\u04CA\u04CB\u04CC\u04CC\u04D5\u04CD\u04CE\x07\xCB\u04CE\u04CF\xBA^\u04CF\u04D1\x07\xCC\u04D0\u04D2\u010C\x87\u04D1\u04D0\u04D1\u04D2\u04D2\u04D5\u04D3\u04D5\xD2j\u04D4\u04C5\u04D4\u04C9\u04D4\u04CD\u04D4\u04D3\u04D5\xBF\u04D6\u04DB\u010C\x87\u04D7\u04D8\x07\xD3\u04D8\u04DA\u010C\x87\u04D9\u04D7\u04DA\u04DD\u04DB\u04D9\u04DB\u04DC\u04DC\xC1\u04DD\u04DB\u04DE\u04E0\xC0a\u04DF\u04E1\u010C\x87\u04E0\u04DF\u04E0\u04E1\u04E1\u04E9\u04E2\u04E3\x07\xD2\u04E3\u04E5\xC0a\u04E4\u04E6\u010C\x87\u04E5\u04E4\u04E5\u04E6\u04E6\u04E8\u04E7\u04E2\u04E8\u04EB\u04E9\u04E7\u04E9\u04EA\u04EA\xC3\u04EB\u04E9\u04EC\u04F1\xC6d\u04ED\u04EE\x07\xD2\u04EE\u04F0\xC6d\u04EF\u04ED\u04F0\u04F3\u04F1\u04EF\u04F1\u04F2\u04F2\xC5\u04F3\u04F1\u04F4\u04F6\xC0a\u04F5\u04F7\u010C\x87\u04F6\u04F5\u04F6\u04F7\u04F7\u0504\u04F8\u04FA\xCAf\u04F9\u04FB\u010C\x87\u04FA\u04F9\u04FA\u04FB\u04FB\u0504\u04FC\u04FD\x07\xCB\u04FD\u04FE\xBA^\u04FE\u0500\x07\xCC\u04FF\u0501\u010C\x87\u0500\u04FF\u0500\u0501\u0501\u0504\u0502\u0504\xD2j\u0503\u04F4\u0503\u04F8\u0503\u04FC\u0503\u0502\u0504\xC7\u0505\u0506	\u0506\xC9\u0507\u0508\x07J\u0508\u0509\x07\xCB\u0509\u050A\xC0a\u050A\u050B\x07\xCC\u050B\u058F\u050C\u050D\x07>\u050D\u050E\x07\xCB\u050E\u058F\x07\xCC\u050F\u0510\x07>\u0510\u0511\x07\xCB\u0511\u0512\xC0a\u0512\u0513\x07\xCC\u0513\u058F\u0514\u0515\x07K\u0515\u0516\x07\xCB\u0516\u0517\xC0a\u0517\u0518\x07\xCC\u0518\u058F\u0519\u051A\x07L\u051A\u051B\x07\xCB\u051B\u051C\xC0a\u051C\u051D\x07\xCC\u051D\u058F\u051E\u051F\x07M\u051F\u0520\x07\xCB\u0520\u0521\xC0a\u0521\u0522\x07\xCC\u0522\u058F\u0523\u0524\x07N\u0524\u0525\x07\xCB\u0525\u0526\xC0a\u0526\u0527\x07\xCC\u0527\u058F\u0528\u0529\x07a\u0529\u052A\x07\xCB\u052A\u052B\xC0a\u052B\u052C\x07\xCC\u052C\u058F\u052D\u052E\x07n\u052E\u0531\x07\xCB\u052F\u0532\xC0a\u0530\u0532\xCAf\u0531\u052F\u0531\u0530\u0532\u0533\u0533\u0534\x07\xCC\u0534\u058F\u0535\u0536\x07w\u0536\u0537\x07\xCB\u0537\u0538\xCCg\u0538\u0539\x07\xCC\u0539\u058F\u053A\u053B\x07x\u053B\u053C\x07\xCB\u053C\u053D\xCCg\u053D\u053E\x07\xCC\u053E\u058F\u053F\u0540\x07y\u0540\u0541\x07\xCB\u0541\u0542\xCCg\u0542\u0543\x07\xCC\u0543\u058F\u0544\u0545\x07z\u0545\u0546\x07\xCB\u0546\u0547\xCCg\u0547\u0548\x07\xCC\u0548\u058F\u0549\u054A\x07{\u054A\u054B\x07\xCB\u054B\u054C\xCCg\u054C\u054D\x07\xCC\u054D\u058F\u054E\u054F\x07|\u054F\u0550\x07\xCB\u0550\u0551\xCCg\u0551\u0552\x07\xCC\u0552\u058F\u0553\u0554\x07}\u0554\u0555\x07\xCB\u0555\u0556\xCCg\u0556\u0557\x07\xCC\u0557\u058F\u0558\u0559\x07~\u0559\u055A\x07\xCB\u055A\u055B\xCCg\u055B\u055C\x07\xCC\u055C\u058F\u055D\u055E\x07\x7F\u055E\u055F\x07\xCB\u055F\u0560\xCCg\u0560\u0561\x07\xCC\u0561\u058F\u0562\u0563\x07\x80\u0563\u0564\x07\xCB\u0564\u0565\xCCg\u0565\u0566\x07\xCC\u0566\u058F\u0567\u0568\x07\x81\u0568\u0569\x07\xCB\u0569\u056A\xCCg\u056A\u056B\x07\xCC\u056B\u058F\u056C\u056D\x07\x82\u056D\u056E\x07\xCB\u056E\u056F\xCCg\u056F\u0570\x07\xCC\u0570\u058F\u0571\u0572\x07\x83\u0572\u0573\x07\xCB\u0573\u0574\xCCg\u0574\u0575\x07\xCC\u0575\u058F\u0576\u0577\x07\xBA\u0577\u0578\x07\xCB\u0578\u0579\xC8e\u0579\u057A\x07\xCC\u057A\u058F\u057B\u057C\x07s\u057C\u057D\x07\xCB\u057D\u057E\xCEh\u057E\u057F\x07\xD2\u057F\u0580\xCEh\u0580\u0581\x07\xD2\u0581\u0582\x07\xC9\u0582\u0583\x07\xCC\u0583\u058F\u0584\u0585\x07u\u0585\u0586\x07\xCB\u0586\u0587\xC0a\u0587\u0588\x07\xCC\u0588\u058F\u0589\u058A\x07v\u058A\u058B\x07\xCB\u058B\u058C\xC0a\u058C\u058D\x07\xCC\u058D\u058F\u058E\u0507\u058E\u050C\u058E\u050F\u058E\u0514\u058E\u0519\u058E\u051E\u058E\u0523\u058E\u0528\u058E\u052D\u058E\u0535\u058E\u053A\u058E\u053F\u058E\u0544\u058E\u0549\u058E\u054E\u058E\u0553\u058E\u0558\u058E\u055D\u058E\u0562\u058E\u0567\u058E\u056C\u058E\u0571\u058E\u0576\u058E\u057B\u058E\u0584\u058E\u0589\u058F\xCB\u0590\u0591\x07\x84\u0591\u0592\x07\xCB\u0592\u0593\xC0a\u0593\u0594\x07\xCC\u0594\u0597\u0595\u0597\xC0a\u0596\u0590\u0596\u0595\u0597\xCD\u0598\u05A2\xC0a\u0599\u05A2\u0106\x84\u059A\u059B\x07t\u059B\u059C\x07\xCB\u059C\u059D\xD0i\u059D\u059E\x07\xD2\u059E\u059F\xD0i\u059F\u05A0\x07\xCC\u05A0\u05A2\u05A1\u0598\u05A1\u0599\u05A1\u059A\u05A2\xCF\u05A3\u05A6\xEAv\u05A4\u05A6\u0106\x84\u05A5\u05A3\u05A5\u05A4\u05A6\xD1\u05A7\u05A8\x07O\u05A8\u05AA\xC0a\u05A9\u05AB\xD4k\u05AA\u05A9\u05AB\u05AC\u05AC\u05AA\u05AC\u05AD\u05AD\u05AF\u05AE\u05B0\xD6l\u05AF\u05AE\u05AF\u05B0\u05B0\u05B1\u05B1\u05B2\x07P\u05B2\xD3\u05B3\u05B4\x075\u05B4\u05B5\xC0a\u05B5\u05B6\x07Q\u05B6\u05B7\xD8m\u05B7\xD5\u05B8\u05B9\x07\f\u05B9\u05BA\xD8m\u05BA\xD7\u05BB\u05C0\xC0a\u05BC\u05BD\x07\xD2\u05BD\u05BF\xC0a\u05BE\u05BC\u05BF\u05C2\u05C0\u05BE\u05C0\u05C1\u05C1\xD9\u05C2\u05C0\u05C3\u05C4\x07A\u05C4\u05C5\x07B\u05C5\u05C6\u010C\x87\u05C6\xDB\u05C7\u05C8\x07C\u05C8\u05C9\xDEp\u05C9\xDD\u05CA\u05CF\xE0q\u05CB\u05CC\x07G\u05CC\u05CE\xE0q\u05CD\u05CB\u05CE\u05D1\u05CF\u05CD\u05CF\u05D0\u05D0\u05DD\u05D1\u05CF\u05D2\u05D7\xE0q\u05D3\u05D4\x07H\u05D4\u05D6\xE0q\u05D5\u05D3\u05D6\u05D9\u05D7\u05D5\u05D7\u05D8\u05D8\u05DD\u05D9\u05D7\u05DA\u05DB\x07I\u05DB\u05DD\xE0q\u05DC\u05CA\u05DC\u05D2\u05DC\u05DA\u05DD\xDF\u05DE\u05DF\x07\xCB\u05DF\u05E0\xDEp\u05E0\u05E1\x07\xCC\u05E1\u05E4\u05E2\u05E4\xE2r\u05E3\u05DE\u05E3\u05E2\u05E4\xE1\u05E5\u05E6\xC0a\u05E6\u05E7\xE4s\u05E7\u05E8\xE6t\u05E8\u05EE\u05E9\u05EA\xCAf\u05EA\u05EB\xE4s\u05EB\u05EC\xE6t\u05EC\u05EE\u05ED\u05E5\u05ED\u05E9\u05EE\xE3\u05EF\u05FF\x07\xD4\u05F0\u05FF\x07\xDE\u05F1\u05FF\x07\xD6\u05F2\u05FF\x07\xD5\u05F3\u05F4\x07\xD6\u05F4\u05FF\x07\xD4\u05F5\u05F6\x07\xD5\u05F6\u05FF\x07\xD4\u05F7\u05FF\x07\xDF\u05F8\u05FF\x07R\u05F9\u05FF\x07S\u05FA\u05FB\x07I\u05FB\u05FF\x07S\u05FC\u05FF\x07T\u05FD\u05FF\x07U\u05FE\u05EF\u05FE\u05F0\u05FE\u05F1\u05FE\u05F2\u05FE\u05F3\u05FE\u05F5\u05FE\u05F7\u05FE\u05F8\u05FE\u05F9\u05FE\u05FA\u05FE\u05FC\u05FE\u05FD\u05FF\xE5\u0600\u0616\x07\u0601\u0616\x07\xC8\u0602\u0616\xEAv\u0603\u0616\x07\xC9\u0604\u0616\x07\xB1\u0605\u0616\x07\xB2\u0606\u0616\x07\xB3\u0607\u0616\u0108\x85\u0608\u060D\x07\xB4\u0609\u060B\x07\xD3\u060A\u060C\x07\xC5\u060B\u060A\u060B\u060C\u060C\u060E\u060D\u0609\u060D\u060E\u060E\u0616\u060F\u0610\x07\xCB\u0610\u0611\xBA^\u0611\u0612\x07\xCC\u0612\u0616\u0613\u0616\xE8u\u0614\u0616\u0106\x84\u0615\u0600\u0615\u0601\u0615\u0602\u0615\u0603\u0615\u0604\u0615\u0605\u0615\u0606\u0615\u0607\u0615\u0608\u0615\u060F\u0615\u0613\u0615\u0614\u0616\xE7\u0617\u0618\x07\xCB\u0618\u061D\xE6t\u0619\u061A\x07\xD2\u061A\u061C\xE6t\u061B\u0619\u061C\u061F\u061D\u061B\u061D\u061E\u061E\u0620\u061F\u061D\u0620\u0621\x07\xCC\u0621\xE9\u0622\u0624	\u0623\u0622\u0623\u0624\u0624\u0625\u0625\u0626	\u0626\xEB\u0627\u0628\x077\u0628\u0629\x07c\u0629\u062A\x07d\u062A\u0634\xEEx\u062B\u062C\x077\u062C\u0634\x07i\u062D\u062E\x077\u062E\u0634\x07j\u062F\u0630\x077\u0630\u0634\x07k\u0631\u0632\x077\u0632\u0634\xDEp\u0633\u0627";
    ApexParser2._serializedATNSegment3 = "\u0633\u062B\u0633\u062D\u0633\u062F\u0633\u0631\u0634\xED\u0635\u063A\xF0y\u0636\u0637\x07\xE1\u0637\u0639\xF0y\u0638\u0636\u0639\u063C\u063A\u0638\u063A\u063B\u063B\xEF\u063C\u063A\u063D\u063E\u010C\x87\u063E\u063F\xF4{\u063F\u0640\xF2z\u0640\xF1\u0641\u064E\u010C\x87\u0642\u0643\x07\xCB\u0643\u0648\u010C\x87\u0644\u0645\x07\xD2\u0645\u0647\u010C\x87\u0646\u0644\u0647\u064A\u0648\u0646\u0648\u0649\u0649\u064B\u064A\u0648\u064B\u064C\x07\xCB\u064C\u064E\u064D\u0641\u064D\u0642\u064E\xF3\u064F\u0650	\u0650\xF5\u0651\u0652\x07[\u0652\u0653\x07E\u0653\u0656\xBC_\u0654\u0655\x07_\u0655\u0657\xDEp\u0656\u0654\u0656\u0657\u0657\u0675\u0658\u0659\x07[\u0659\u065A\x07E\u065A\u065B\x07`\u065B\u065C\x07\xCB\u065C\u0661\xC0a\u065D\u065E\x07\xD2\u065E\u0660\xC0a\u065F\u065D\u0660\u0663\u0661\u065F\u0661\u0662\u0662\u0664\u0663\u0661\u0664\u0665\x07\xCC\u0665\u0675\u0666\u0667\x07[\u0667\u0668\x07E\u0668\u0669\x07m\u0669\u066A\x07\xCB\u066A\u066F\xC0a\u066B\u066C\x07\xD2\u066C\u066E\xC0a\u066D\u066B\u066E\u0671\u066F\u066D\u066F\u0670\u0670\u0672\u0671\u066F\u0672\u0673\x07\xCC\u0673\u0675\u0674\u0651\u0674\u0658\u0674\u0666\u0675\xF7\u0676\u0677\x07D\u0677\u0678\x07E\u0678\u0679\xFA~\u0679\xF9\u067A\u067F\xFC\x7F\u067B\u067C\x07\xD2\u067C\u067E\xFC\x7F\u067D\u067B\u067E\u0681\u067F\u067D\u067F\u0680\u0680\xFB\u0681\u067F\u0682\u0684\xC0a\u0683\u0685	\u0684\u0683\u0684\u0685\u0685\u0688\u0686\u0687\x07X\u0687\u0689	\u0688\u0686\u0688\u0689\u0689\u0693\u068A\u068C\xCAf\u068B\u068D	\u068C\u068B\u068C\u068D\u068D\u0690\u068E\u068F\x07X\u068F\u0691	\u0690\u068E\u0690\u0691\u0691\u0693\u0692\u0682\u0692\u068A\u0693\xFD\u0694\u0695\x07F\u0695\u0699\x07\xC5\u0696\u0697\x07F\u0697\u0699\u0106\x84\u0698\u0694\u0698\u0696\u0699\xFF\u069A\u069B\x07b\u069B\u069F\x07\xC5\u069C\u069D\x07b\u069D\u069F\u0106\x84\u069E\u069A\u069E\u069C\u069F\u0101\u06A0\u06A1\x07\\\u06A1\u06A2\x07]\u06A2\u0103\u06A3\u06A4\x07\u06A4\u06A6	\u06A5\u06A3\u06A6\u06A9\u06A7\u06A5\u06A7\u06A8\u06A8\u0105\u06A9\u06A7\u06AA\u06AB\x07\xDB\u06AB\u06AC\x9AN\u06AC\u0107\u06AD\u0704\x07\x85\u06AE\u0704\x07\x86\u06AF\u0704\x07\x87\u06B0\u0704\x07\x88\u06B1\u0704\x07\x89\u06B2\u0704\x07\x8A\u06B3\u0704\x07\x8B\u06B4\u0704\x07\x8C\u06B5\u0704\x07\x8D\u06B6\u0704\x07\x8E\u06B7\u0704\x07\x8F\u06B8\u06B9\x07\x90\u06B9\u06BA\x07\xDB\u06BA\u0704\u010A\x86\u06BB\u06BC\x07\x91\u06BC\u06BD\x07\xDB\u06BD\u0704\u010A\x86\u06BE\u06BF\x07\x92\u06BF\u06C0\x07\xDB\u06C0\u0704\u010A\x86\u06C1\u06C2\x07\x93\u06C2\u06C3\x07\xDB\u06C3\u0704\u010A\x86\u06C4\u06C5\x07\x94\u06C5\u06C6\x07\xDB\u06C6\u0704\u010A\x86\u06C7\u06C8\x07\x95\u06C8\u06C9\x07\xDB\u06C9\u0704\u010A\x86\u06CA\u06CB\x07\x96\u06CB\u06CC\x07\xDB\u06CC\u0704\u010A\x86\u06CD\u06CE\x07\x97\u06CE\u06CF\x07\xDB\u06CF\u0704\u010A\x86\u06D0\u06D1\x07\x98\u06D1\u06D2\x07\xDB\u06D2\u0704\u010A\x86\u06D3\u0704\x07\x99\u06D4\u0704\x07\x9A\u06D5\u0704\x07\x9B\u06D6\u06D7\x07\x9C\u06D7\u06D8\x07\xDB\u06D8\u0704\u010A\x86\u06D9\u06DA\x07\x9D\u06DA\u06DB\x07\xDB\u06DB\u0704\u010A\x86\u06DC\u06DD\x07\x9E\u06DD\u06DE\x07\xDB\u06DE\u0704\u010A\x86\u06DF\u0704\x07\x9F\u06E0\u0704\x07\xA0\u06E1\u0704\x07\xA1\u06E2\u06E3\x07\xA2\u06E3\u06E4\x07\xDB\u06E4\u0704\u010A\x86\u06E5\u06E6\x07\xA3\u06E6\u06E7\x07\xDB\u06E7\u0704\u010A\x86\u06E8\u06E9\x07\xA4\u06E9\u06EA\x07\xDB\u06EA\u0704\u010A\x86\u06EB\u0704\x07\xA5\u06EC\u0704\x07\xA6\u06ED\u0704\x07\xA7\u06EE\u06EF\x07\xA8\u06EF\u06F0\x07\xDB\u06F0\u0704\u010A\x86\u06F1\u06F2\x07\xA9\u06F2\u06F3\x07\xDB\u06F3\u0704\u010A\x86\u06F4\u06F5\x07\xAA\u06F5\u06F6\x07\xDB\u06F6\u0704\u010A\x86\u06F7\u0704\x07\xAB\u06F8\u0704\x07\xAC\u06F9\u0704\x07\xAD\u06FA\u06FB\x07\xAE\u06FB\u06FC\x07\xDB\u06FC\u0704\u010A\x86\u06FD\u06FE\x07\xAF\u06FE\u06FF\x07\xDB\u06FF\u0704\u010A\x86\u0700\u0701\x07\xB0\u0701\u0702\x07\xDB\u0702\u0704\u010A\x86\u0703\u06AD\u0703\u06AE\u0703\u06AF\u0703\u06B0\u0703\u06B1\u0703\u06B2\u0703\u06B3\u0703\u06B4\u0703\u06B5\u0703\u06B6\u0703\u06B7\u0703\u06B8\u0703\u06BB\u0703\u06BE\u0703\u06C1\u0703\u06C4\u0703\u06C7\u0703\u06CA\u0703\u06CD\u0703\u06D0\u0703\u06D3\u0703\u06D4\u0703\u06D5\u0703\u06D6\u0703\u06D9\u0703\u06DC\u0703\u06DF\u0703\u06E0\u0703\u06E1\u0703\u06E2\u0703\u06E5\u0703\u06E8\u0703\u06EB\u0703\u06EC\u0703\u06ED\u0703\u06EE\u0703\u06F1\u0703\u06F4\u0703\u06F7\u0703\u06F8\u0703\u06F9\u0703\u06FA\u0703\u06FD\u0703\u0700\u0704\u0109\u0705\u0707	\u0706\u0705\u0706\u0707\u0707\u0708\u0708\u0709\x07\xC5\u0709\u010B\u070A\u070B\u0126\x94\u070B\u010D\u070C\u070D\x07\xC3\u070D\u070E\u0112\x8A\u070E\u070F\x07\xD0\u070F\u0717\u0710\u0711\x07\xCF\u0711\u0712\x07\xB5\u0712\u0713\u0106\x84\u0713\u0714\u0112\x8A\u0714\u0715\x07\xD0\u0715\u0717\u0716\u070C\u0716\u0710\u0717\u010F\u0718\u0719\x07\xC4\u0719\u071A\u0112\x8A\u071A\u071B\x07\xD0\u071B\u0111\u071C\u071D\x07S\u071D\u071F\u0116\x8C\u071E\u071C\u071E\u071F\u071F\u0722\u0720\u0721\x07\xC1\u0721\u0723\u0118\x8D\u0722\u0720\u0722\u0723\u0723\u0727\u0724\u0726\u0114\x8B\u0725\u0724\u0726\u0729\u0727\u0725\u0727\u0728\u0728\u072B\u0729\u0727\u072A\u072C\xFE\x80\u072B\u072A\u072B\u072C\u072C\u072F\u072D\u072E\x070\u072E\u0730\u011E\x90\u072F\u072D\u072F\u0730\u0730\u0113\u0731\u0732\x077\u0732\u0733\x07\xC0\u0733\u0734\x07\xD4\u0734\u075A\x07\xC9\u0735\u0736\x077\u0736\u0737\x07c\u0737\u0738\x07d\u0738\u075A\xEEx\u0739\u073A\x077\u073A\u0740\x07\xBE\u073B\u073C\x07\xCB\u073C\u073D\x07\xBF\u073D\u073E\x07\xD4\u073E\u073F\x07\xC5\u073F\u0741\x07\xCC\u0740\u073B\u0740\u0741\u0741\u075A\u0742\u0743\x077\u0743\u0744\x07\xBD\u0744\u0745\x07S\u0745\u0746\x07\xCB\u0746\u0747\u0122\x92\u0747\u0748\x07\xCC\u0748\u075A\u0749\u074A\x077\u074A\u074B\x07\xBD\u074B\u074C\x07\xD4\u074C\u075A\x07\xC9\u074D\u074E\x077\u074E\u074F\x07\xBC\u074F\u0750\x07\xD4\u0750\u075A\x07\xC9\u0751\u0752\x077\u0752\u0753\x07\xBB\u0753\u0754\x07\xD4\u0754\u075A\x07\xC9\u0755\u0756\x077\u0756\u075A\x07k\u0757\u0758\x077\u0758\u075A\x07j\u0759\u0731\u0759\u0735\u0759\u0739\u0759\u0742\u0759\u0749\u0759\u074D\u0759\u0751\u0759\u0755\u0759\u0757\u075A\u0115\u075B\u075C	\u075C\u075D\x07\xBA\u075D\u0117\u075E\u0763\u011A\x8E\u075F\u0760\x07\xD2\u0760\u0762\u0118\x8D\u0761\u075F\u0762\u0765\u0763\u0761\u0763\u0764\u0764\u0119\u0765\u0763\u0766\u0780\u0124\x93\u0767\u0768\x07\xCB\u0768\u076B\u011C\x8F\u0769\u076A\x07C\u076A\u076C\xDEp\u076B\u0769\u076B\u076C\u076C\u0771\u076D\u076E\x07A\u076E\u076F\x07\xC2\u076F\u0770\x07\xD4\u0770\u0772\u0124\x93\u0771\u076D\u0771\u0772\u0772\u0776\u0773\u0774\x07D\u0774\u0775\x07E\u0775\u0777\xFA~\u0776\u0773\u0776\u0777\u0777\u0779\u0778\u077A\xFE\x80\u0779\u0778\u0779\u077A\u077A\u077C\u077B\u077D\u0100\x81\u077C\u077B\u077C\u077D\u077D\u077E\u077E\u077F\x07\xCC\u077F\u0781\u0780\u0767\u0780\u0781\u0781\u011B\u0782\u0787\u0124\x93\u0783\u0784\x07\xD2\u0784\u0786\u011C\x8F\u0785\u0783\u0786\u0789\u0787\u0785\u0787\u0788\u0788\u07A3\u0789\u0787\u078A\u078B\x07a\u078B\u078C\x07\xCB\u078C\u078D\u0124\x93\u078D\u078F\x07\xCC\u078E\u0790\u0124\x93\u078F\u078E\u078F\u0790\u0790\u07A3\u0791\u0792\x07v\u0792\u0793\x07\xCB\u0793\u0794\u0124\x93\u0794\u0796\x07\xCC\u0795\u0797\u0124\x93\u0796\u0795\u0796\u0797\u0797\u07A3\u0798\u0799\x07n\u0799\u079C\x07\xCB\u079A\u079D\u0124\x93\u079B\u079D\xCAf\u079C\u079A\u079C\u079B\u079D\u079E\u079E\u07A0\x07\xCC\u079F\u07A1\u0124\x93\u07A0\u079F\u07A0\u07A1\u07A1\u07A3\u07A2\u0782\u07A2\u078A\u07A2\u0791\u07A2\u0798\u07A3\u011D\u07A4\u07A7\u0120\x91\u07A5\u07A6\x07\xD2\u07A6\u07A8\u011E\x90\u07A7\u07A5\u07A7\u07A8\u07A8\u011F\u07A9\u07AA	\u07AA\u0121\u07AB\u07AE\x07\xC9\u07AC\u07AD\x07\xD2\u07AD\u07AF\u0122\x92\u07AE\u07AC\u07AE\u07AF\u07AF\u0123\u07B0\u07B5\u0126\x94\u07B1\u07B2\x07\xD3\u07B2\u07B4\u0124\x93\u07B3\u07B1\u07B4\u07B7\u07B5\u07B3\u07B5\u07B6\u07B6\u0125\u07B7\u07B5\u07B8\u07B9	\u07B9\u0127\u07BA\u07BB	\u07BB\u0129\xC5\u0134\u0142\u014A\u014F\u0157\u015E\u0165\u0169\u016F\u0173\u017B\u0184\u018B\u0194\u019B\u01A4\u01AB\u01B1\u01B5\u01CA\u01D3\u01DB\u01DF\u01E5\u01F5\u01FD\u0202\u020D\u0213\u021B\u021F\u0221\u022A\u0233\u0238\u023C\u0240\u0244\u0246\u024E\u0257\u025D\u0268\u0272\u0275\u0279\u027E\u0288\u0290\u0293\u0296\u029E\u02A9\u02C3\u02CA\u02D3\u02E1\u02E7\u02EC\u02F3\u02FE\u0306\u030C\u0319\u031C\u031F\u0323\u0336\u033D\u0344\u034B\u0352\u0356\u035C\u0365\u0370\u0375\u037A\u037F\u0386\u0393\u0397\u039B\u039D\u03A1\u03B3\u03C8\u03D8\u03DE\u0403\u040F\u0411\u0421\u0426\u042D\u0433\u0436\u043B\u0445\u044C\u0454\u0462\u0464\u046C\u047B\u0482\u048F\u0492\u0495\u0498\u049B\u049E\u04A1\u04A4\u04A9\u04B0\u04B3\u04B6\u04BB\u04C2\u04C7\u04CB\u04D1\u04D4\u04DB\u04E0\u04E5\u04E9\u04F1\u04F6\u04FA\u0500\u0503\u0531\u058E\u0596\u05A1\u05A5\u05AC\u05AF\u05C0\u05CF\u05D7\u05DC\u05E3\u05ED\u05FE\u060B\u060D\u0615\u061D\u0623\u0633\u063A\u0648\u064D\u0656\u0661\u066F\u0674\u067F\u0684\u0688\u068C\u0690\u0692\u0698\u069E\u06A7\u0703\u0706\u0716\u071E\u0722\u0727\u072B\u072F\u0740\u0759\u0763\u076B\u0771\u0776\u0779\u077C\u0780\u0787\u078F\u0796\u079C\u07A0\u07A2\u07A7\u07AE\u07B5";
    ApexParser2._serializedATN = Utils.join([
      ApexParser2._serializedATNSegment0,
      ApexParser2._serializedATNSegment1,
      ApexParser2._serializedATNSegment2,
      ApexParser2._serializedATNSegment3
    ], "");
    var TriggerUnitContext = class extends ParserRuleContext_1.ParserRuleContext {
      TRIGGER() {
        return this.getToken(ApexParser2.TRIGGER, 0);
      }
      id(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(IdContext);
        } else {
          return this.getRuleContext(i2, IdContext);
        }
      }
      ON() {
        return this.getToken(ApexParser2.ON, 0);
      }
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      triggerCase(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(TriggerCaseContext);
        } else {
          return this.getRuleContext(i2, TriggerCaseContext);
        }
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      triggerBlock() {
        return this.getRuleContext(0, TriggerBlockContext);
      }
      EOF() {
        return this.getToken(ApexParser2.EOF, 0);
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_triggerUnit;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTriggerUnit) {
          listener.enterTriggerUnit(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTriggerUnit) {
          listener.exitTriggerUnit(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTriggerUnit) {
          return visitor.visitTriggerUnit(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TriggerUnitContext = TriggerUnitContext;
    var TriggerCaseContext = class extends ParserRuleContext_1.ParserRuleContext {
      BEFORE() {
        return this.tryGetToken(ApexParser2.BEFORE, 0);
      }
      AFTER() {
        return this.tryGetToken(ApexParser2.AFTER, 0);
      }
      INSERT() {
        return this.tryGetToken(ApexParser2.INSERT, 0);
      }
      UPDATE() {
        return this.tryGetToken(ApexParser2.UPDATE, 0);
      }
      DELETE() {
        return this.tryGetToken(ApexParser2.DELETE, 0);
      }
      UNDELETE() {
        return this.tryGetToken(ApexParser2.UNDELETE, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_triggerCase;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTriggerCase) {
          listener.enterTriggerCase(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTriggerCase) {
          listener.exitTriggerCase(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTriggerCase) {
          return visitor.visitTriggerCase(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TriggerCaseContext = TriggerCaseContext;
    var TriggerBlockContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      triggerBlockMember(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(TriggerBlockMemberContext);
        } else {
          return this.getRuleContext(i2, TriggerBlockMemberContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_triggerBlock;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTriggerBlock) {
          listener.enterTriggerBlock(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTriggerBlock) {
          listener.exitTriggerBlock(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTriggerBlock) {
          return visitor.visitTriggerBlock(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TriggerBlockContext = TriggerBlockContext;
    var TriggerBlockMemberContext = class extends ParserRuleContext_1.ParserRuleContext {
      triggerMemberDeclaration() {
        return this.tryGetRuleContext(0, TriggerMemberDeclarationContext);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      statement() {
        return this.tryGetRuleContext(0, StatementContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_triggerBlockMember;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTriggerBlockMember) {
          listener.enterTriggerBlockMember(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTriggerBlockMember) {
          listener.exitTriggerBlockMember(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTriggerBlockMember) {
          return visitor.visitTriggerBlockMember(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TriggerBlockMemberContext = TriggerBlockMemberContext;
    var CompilationUnitContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeDeclaration() {
        return this.getRuleContext(0, TypeDeclarationContext);
      }
      EOF() {
        return this.getToken(ApexParser2.EOF, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_compilationUnit;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCompilationUnit) {
          listener.enterCompilationUnit(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCompilationUnit) {
          listener.exitCompilationUnit(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCompilationUnit) {
          return visitor.visitCompilationUnit(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CompilationUnitContext = CompilationUnitContext;
    var TypeDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      classDeclaration() {
        return this.tryGetRuleContext(0, ClassDeclarationContext);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      enumDeclaration() {
        return this.tryGetRuleContext(0, EnumDeclarationContext);
      }
      interfaceDeclaration() {
        return this.tryGetRuleContext(0, InterfaceDeclarationContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_typeDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTypeDeclaration) {
          listener.enterTypeDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTypeDeclaration) {
          listener.exitTypeDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTypeDeclaration) {
          return visitor.visitTypeDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TypeDeclarationContext = TypeDeclarationContext;
    var ClassDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      CLASS() {
        return this.getToken(ApexParser2.CLASS, 0);
      }
      id() {
        return this.getRuleContext(0, IdContext);
      }
      classBody() {
        return this.getRuleContext(0, ClassBodyContext);
      }
      EXTENDS() {
        return this.tryGetToken(ApexParser2.EXTENDS, 0);
      }
      typeRef() {
        return this.tryGetRuleContext(0, TypeRefContext);
      }
      IMPLEMENTS() {
        return this.tryGetToken(ApexParser2.IMPLEMENTS, 0);
      }
      typeList() {
        return this.tryGetRuleContext(0, TypeListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_classDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterClassDeclaration) {
          listener.enterClassDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitClassDeclaration) {
          listener.exitClassDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitClassDeclaration) {
          return visitor.visitClassDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ClassDeclarationContext = ClassDeclarationContext;
    var EnumDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      ENUM() {
        return this.getToken(ApexParser2.ENUM, 0);
      }
      id() {
        return this.getRuleContext(0, IdContext);
      }
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      enumConstants() {
        return this.tryGetRuleContext(0, EnumConstantsContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_enumDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterEnumDeclaration) {
          listener.enterEnumDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitEnumDeclaration) {
          listener.exitEnumDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitEnumDeclaration) {
          return visitor.visitEnumDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.EnumDeclarationContext = EnumDeclarationContext;
    var EnumConstantsContext = class extends ParserRuleContext_1.ParserRuleContext {
      id(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(IdContext);
        } else {
          return this.getRuleContext(i2, IdContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_enumConstants;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterEnumConstants) {
          listener.enterEnumConstants(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitEnumConstants) {
          listener.exitEnumConstants(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitEnumConstants) {
          return visitor.visitEnumConstants(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.EnumConstantsContext = EnumConstantsContext;
    var InterfaceDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      INTERFACE() {
        return this.getToken(ApexParser2.INTERFACE, 0);
      }
      id() {
        return this.getRuleContext(0, IdContext);
      }
      interfaceBody() {
        return this.getRuleContext(0, InterfaceBodyContext);
      }
      EXTENDS() {
        return this.tryGetToken(ApexParser2.EXTENDS, 0);
      }
      typeList() {
        return this.tryGetRuleContext(0, TypeListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_interfaceDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterInterfaceDeclaration) {
          listener.enterInterfaceDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitInterfaceDeclaration) {
          listener.exitInterfaceDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitInterfaceDeclaration) {
          return visitor.visitInterfaceDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.InterfaceDeclarationContext = InterfaceDeclarationContext;
    var TypeListContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeRef(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(TypeRefContext);
        } else {
          return this.getRuleContext(i2, TypeRefContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_typeList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTypeList) {
          listener.enterTypeList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTypeList) {
          listener.exitTypeList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTypeList) {
          return visitor.visitTypeList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TypeListContext = TypeListContext;
    var ClassBodyContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      classBodyDeclaration(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ClassBodyDeclarationContext);
        } else {
          return this.getRuleContext(i2, ClassBodyDeclarationContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_classBody;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterClassBody) {
          listener.enterClassBody(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitClassBody) {
          listener.exitClassBody(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitClassBody) {
          return visitor.visitClassBody(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ClassBodyContext = ClassBodyContext;
    var InterfaceBodyContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      interfaceMethodDeclaration(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(InterfaceMethodDeclarationContext);
        } else {
          return this.getRuleContext(i2, InterfaceMethodDeclarationContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_interfaceBody;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterInterfaceBody) {
          listener.enterInterfaceBody(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitInterfaceBody) {
          listener.exitInterfaceBody(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitInterfaceBody) {
          return visitor.visitInterfaceBody(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.InterfaceBodyContext = InterfaceBodyContext;
    var ClassBodyDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      SEMI() {
        return this.tryGetToken(ApexParser2.SEMI, 0);
      }
      block() {
        return this.tryGetRuleContext(0, BlockContext);
      }
      STATIC() {
        return this.tryGetToken(ApexParser2.STATIC, 0);
      }
      memberDeclaration() {
        return this.tryGetRuleContext(0, MemberDeclarationContext);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_classBodyDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterClassBodyDeclaration) {
          listener.enterClassBodyDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitClassBodyDeclaration) {
          listener.exitClassBodyDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitClassBodyDeclaration) {
          return visitor.visitClassBodyDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ClassBodyDeclarationContext = ClassBodyDeclarationContext;
    var ModifierContext = class extends ParserRuleContext_1.ParserRuleContext {
      annotation() {
        return this.tryGetRuleContext(0, AnnotationContext);
      }
      GLOBAL() {
        return this.tryGetToken(ApexParser2.GLOBAL, 0);
      }
      PUBLIC() {
        return this.tryGetToken(ApexParser2.PUBLIC, 0);
      }
      PROTECTED() {
        return this.tryGetToken(ApexParser2.PROTECTED, 0);
      }
      PRIVATE() {
        return this.tryGetToken(ApexParser2.PRIVATE, 0);
      }
      TRANSIENT() {
        return this.tryGetToken(ApexParser2.TRANSIENT, 0);
      }
      STATIC() {
        return this.tryGetToken(ApexParser2.STATIC, 0);
      }
      ABSTRACT() {
        return this.tryGetToken(ApexParser2.ABSTRACT, 0);
      }
      FINAL() {
        return this.tryGetToken(ApexParser2.FINAL, 0);
      }
      WEBSERVICE() {
        return this.tryGetToken(ApexParser2.WEBSERVICE, 0);
      }
      OVERRIDE() {
        return this.tryGetToken(ApexParser2.OVERRIDE, 0);
      }
      VIRTUAL() {
        return this.tryGetToken(ApexParser2.VIRTUAL, 0);
      }
      TESTMETHOD() {
        return this.tryGetToken(ApexParser2.TESTMETHOD, 0);
      }
      WITH() {
        return this.tryGetToken(ApexParser2.WITH, 0);
      }
      SHARING() {
        return this.tryGetToken(ApexParser2.SHARING, 0);
      }
      WITHOUT() {
        return this.tryGetToken(ApexParser2.WITHOUT, 0);
      }
      INHERITED() {
        return this.tryGetToken(ApexParser2.INHERITED, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_modifier;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterModifier) {
          listener.enterModifier(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitModifier) {
          listener.exitModifier(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitModifier) {
          return visitor.visitModifier(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ModifierContext = ModifierContext;
    var MemberDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      methodDeclaration() {
        return this.tryGetRuleContext(0, MethodDeclarationContext);
      }
      constructorDeclaration() {
        return this.tryGetRuleContext(0, ConstructorDeclarationContext);
      }
      interfaceDeclaration() {
        return this.tryGetRuleContext(0, InterfaceDeclarationContext);
      }
      classDeclaration() {
        return this.tryGetRuleContext(0, ClassDeclarationContext);
      }
      enumDeclaration() {
        return this.tryGetRuleContext(0, EnumDeclarationContext);
      }
      propertyDeclaration() {
        return this.tryGetRuleContext(0, PropertyDeclarationContext);
      }
      fieldDeclaration() {
        return this.tryGetRuleContext(0, FieldDeclarationContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_memberDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterMemberDeclaration) {
          listener.enterMemberDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitMemberDeclaration) {
          listener.exitMemberDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitMemberDeclaration) {
          return visitor.visitMemberDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MemberDeclarationContext = MemberDeclarationContext;
    var TriggerMemberDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      methodDeclaration() {
        return this.tryGetRuleContext(0, MethodDeclarationContext);
      }
      interfaceDeclaration() {
        return this.tryGetRuleContext(0, InterfaceDeclarationContext);
      }
      classDeclaration() {
        return this.tryGetRuleContext(0, ClassDeclarationContext);
      }
      enumDeclaration() {
        return this.tryGetRuleContext(0, EnumDeclarationContext);
      }
      propertyDeclaration() {
        return this.tryGetRuleContext(0, PropertyDeclarationContext);
      }
      fieldDeclaration() {
        return this.tryGetRuleContext(0, FieldDeclarationContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_triggerMemberDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTriggerMemberDeclaration) {
          listener.enterTriggerMemberDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTriggerMemberDeclaration) {
          listener.exitTriggerMemberDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTriggerMemberDeclaration) {
          return visitor.visitTriggerMemberDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TriggerMemberDeclarationContext = TriggerMemberDeclarationContext;
    var MethodDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      id() {
        return this.getRuleContext(0, IdContext);
      }
      formalParameters() {
        return this.getRuleContext(0, FormalParametersContext);
      }
      typeRef() {
        return this.tryGetRuleContext(0, TypeRefContext);
      }
      VOID() {
        return this.tryGetToken(ApexParser2.VOID, 0);
      }
      block() {
        return this.tryGetRuleContext(0, BlockContext);
      }
      SEMI() {
        return this.tryGetToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_methodDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterMethodDeclaration) {
          listener.enterMethodDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitMethodDeclaration) {
          listener.exitMethodDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitMethodDeclaration) {
          return visitor.visitMethodDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MethodDeclarationContext = MethodDeclarationContext;
    var ConstructorDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      qualifiedName() {
        return this.getRuleContext(0, QualifiedNameContext);
      }
      formalParameters() {
        return this.getRuleContext(0, FormalParametersContext);
      }
      block() {
        return this.getRuleContext(0, BlockContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_constructorDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterConstructorDeclaration) {
          listener.enterConstructorDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitConstructorDeclaration) {
          listener.exitConstructorDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitConstructorDeclaration) {
          return visitor.visitConstructorDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ConstructorDeclarationContext = ConstructorDeclarationContext;
    var FieldDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      variableDeclarators() {
        return this.getRuleContext(0, VariableDeclaratorsContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldDeclaration) {
          listener.enterFieldDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldDeclaration) {
          listener.exitFieldDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldDeclaration) {
          return visitor.visitFieldDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldDeclarationContext = FieldDeclarationContext;
    var PropertyDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      id() {
        return this.getRuleContext(0, IdContext);
      }
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      propertyBlock(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(PropertyBlockContext);
        } else {
          return this.getRuleContext(i2, PropertyBlockContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_propertyDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterPropertyDeclaration) {
          listener.enterPropertyDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitPropertyDeclaration) {
          listener.exitPropertyDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitPropertyDeclaration) {
          return visitor.visitPropertyDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.PropertyDeclarationContext = PropertyDeclarationContext;
    var InterfaceMethodDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      id() {
        return this.getRuleContext(0, IdContext);
      }
      formalParameters() {
        return this.getRuleContext(0, FormalParametersContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      typeRef() {
        return this.tryGetRuleContext(0, TypeRefContext);
      }
      VOID() {
        return this.tryGetToken(ApexParser2.VOID, 0);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_interfaceMethodDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterInterfaceMethodDeclaration) {
          listener.enterInterfaceMethodDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitInterfaceMethodDeclaration) {
          listener.exitInterfaceMethodDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitInterfaceMethodDeclaration) {
          return visitor.visitInterfaceMethodDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.InterfaceMethodDeclarationContext = InterfaceMethodDeclarationContext;
    var VariableDeclaratorsContext = class extends ParserRuleContext_1.ParserRuleContext {
      variableDeclarator(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(VariableDeclaratorContext);
        } else {
          return this.getRuleContext(i2, VariableDeclaratorContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_variableDeclarators;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterVariableDeclarators) {
          listener.enterVariableDeclarators(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitVariableDeclarators) {
          listener.exitVariableDeclarators(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitVariableDeclarators) {
          return visitor.visitVariableDeclarators(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.VariableDeclaratorsContext = VariableDeclaratorsContext;
    var VariableDeclaratorContext = class extends ParserRuleContext_1.ParserRuleContext {
      id() {
        return this.getRuleContext(0, IdContext);
      }
      ASSIGN() {
        return this.tryGetToken(ApexParser2.ASSIGN, 0);
      }
      expression() {
        return this.tryGetRuleContext(0, ExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_variableDeclarator;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterVariableDeclarator) {
          listener.enterVariableDeclarator(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitVariableDeclarator) {
          listener.exitVariableDeclarator(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitVariableDeclarator) {
          return visitor.visitVariableDeclarator(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.VariableDeclaratorContext = VariableDeclaratorContext;
    var ArrayInitializerContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_arrayInitializer;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterArrayInitializer) {
          listener.enterArrayInitializer(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitArrayInitializer) {
          listener.exitArrayInitializer(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitArrayInitializer) {
          return visitor.visitArrayInitializer(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ArrayInitializerContext = ArrayInitializerContext;
    var TypeRefContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeName(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(TypeNameContext);
        } else {
          return this.getRuleContext(i2, TypeNameContext);
        }
      }
      arraySubscripts() {
        return this.getRuleContext(0, ArraySubscriptsContext);
      }
      DOT(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.DOT);
        } else {
          return this.getToken(ApexParser2.DOT, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_typeRef;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTypeRef) {
          listener.enterTypeRef(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTypeRef) {
          listener.exitTypeRef(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTypeRef) {
          return visitor.visitTypeRef(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TypeRefContext = TypeRefContext;
    var ArraySubscriptsContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACK(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.LBRACK);
        } else {
          return this.getToken(ApexParser2.LBRACK, i2);
        }
      }
      RBRACK(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.RBRACK);
        } else {
          return this.getToken(ApexParser2.RBRACK, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_arraySubscripts;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterArraySubscripts) {
          listener.enterArraySubscripts(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitArraySubscripts) {
          listener.exitArraySubscripts(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitArraySubscripts) {
          return visitor.visitArraySubscripts(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ArraySubscriptsContext = ArraySubscriptsContext;
    var TypeNameContext = class extends ParserRuleContext_1.ParserRuleContext {
      LIST() {
        return this.tryGetToken(ApexParser2.LIST, 0);
      }
      typeArguments() {
        return this.tryGetRuleContext(0, TypeArgumentsContext);
      }
      SET() {
        return this.tryGetToken(ApexParser2.SET, 0);
      }
      MAP() {
        return this.tryGetToken(ApexParser2.MAP, 0);
      }
      id() {
        return this.tryGetRuleContext(0, IdContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_typeName;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTypeName) {
          listener.enterTypeName(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTypeName) {
          listener.exitTypeName(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTypeName) {
          return visitor.visitTypeName(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TypeNameContext = TypeNameContext;
    var TypeArgumentsContext = class extends ParserRuleContext_1.ParserRuleContext {
      LT() {
        return this.getToken(ApexParser2.LT, 0);
      }
      typeList() {
        return this.getRuleContext(0, TypeListContext);
      }
      GT() {
        return this.getToken(ApexParser2.GT, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_typeArguments;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTypeArguments) {
          listener.enterTypeArguments(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTypeArguments) {
          listener.exitTypeArguments(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTypeArguments) {
          return visitor.visitTypeArguments(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TypeArgumentsContext = TypeArgumentsContext;
    var FormalParametersContext = class extends ParserRuleContext_1.ParserRuleContext {
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      formalParameterList() {
        return this.tryGetRuleContext(0, FormalParameterListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_formalParameters;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFormalParameters) {
          listener.enterFormalParameters(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFormalParameters) {
          listener.exitFormalParameters(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFormalParameters) {
          return visitor.visitFormalParameters(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FormalParametersContext = FormalParametersContext;
    var FormalParameterListContext = class extends ParserRuleContext_1.ParserRuleContext {
      formalParameter(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(FormalParameterContext);
        } else {
          return this.getRuleContext(i2, FormalParameterContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_formalParameterList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFormalParameterList) {
          listener.enterFormalParameterList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFormalParameterList) {
          listener.exitFormalParameterList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFormalParameterList) {
          return visitor.visitFormalParameterList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FormalParameterListContext = FormalParameterListContext;
    var FormalParameterContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      id() {
        return this.getRuleContext(0, IdContext);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_formalParameter;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFormalParameter) {
          listener.enterFormalParameter(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFormalParameter) {
          listener.exitFormalParameter(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFormalParameter) {
          return visitor.visitFormalParameter(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FormalParameterContext = FormalParameterContext;
    var QualifiedNameContext = class extends ParserRuleContext_1.ParserRuleContext {
      id(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(IdContext);
        } else {
          return this.getRuleContext(i2, IdContext);
        }
      }
      DOT(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.DOT);
        } else {
          return this.getToken(ApexParser2.DOT, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_qualifiedName;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterQualifiedName) {
          listener.enterQualifiedName(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitQualifiedName) {
          listener.exitQualifiedName(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitQualifiedName) {
          return visitor.visitQualifiedName(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.QualifiedNameContext = QualifiedNameContext;
    var LiteralContext = class extends ParserRuleContext_1.ParserRuleContext {
      IntegerLiteral() {
        return this.tryGetToken(ApexParser2.IntegerLiteral, 0);
      }
      LongLiteral() {
        return this.tryGetToken(ApexParser2.LongLiteral, 0);
      }
      NumberLiteral() {
        return this.tryGetToken(ApexParser2.NumberLiteral, 0);
      }
      StringLiteral() {
        return this.tryGetToken(ApexParser2.StringLiteral, 0);
      }
      BooleanLiteral() {
        return this.tryGetToken(ApexParser2.BooleanLiteral, 0);
      }
      NULL() {
        return this.tryGetToken(ApexParser2.NULL, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_literal;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLiteral) {
          listener.enterLiteral(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLiteral) {
          listener.exitLiteral(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLiteral) {
          return visitor.visitLiteral(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LiteralContext = LiteralContext;
    var AnnotationContext = class extends ParserRuleContext_1.ParserRuleContext {
      ATSIGN() {
        return this.getToken(ApexParser2.ATSIGN, 0);
      }
      qualifiedName() {
        return this.getRuleContext(0, QualifiedNameContext);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      elementValuePairs() {
        return this.tryGetRuleContext(0, ElementValuePairsContext);
      }
      elementValue() {
        return this.tryGetRuleContext(0, ElementValueContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_annotation;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterAnnotation) {
          listener.enterAnnotation(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitAnnotation) {
          listener.exitAnnotation(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitAnnotation) {
          return visitor.visitAnnotation(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.AnnotationContext = AnnotationContext;
    var ElementValuePairsContext = class extends ParserRuleContext_1.ParserRuleContext {
      elementValuePair(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ElementValuePairContext);
        } else {
          return this.getRuleContext(i2, ElementValuePairContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_elementValuePairs;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterElementValuePairs) {
          listener.enterElementValuePairs(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitElementValuePairs) {
          listener.exitElementValuePairs(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitElementValuePairs) {
          return visitor.visitElementValuePairs(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ElementValuePairsContext = ElementValuePairsContext;
    var ElementValuePairContext = class extends ParserRuleContext_1.ParserRuleContext {
      id() {
        return this.getRuleContext(0, IdContext);
      }
      ASSIGN() {
        return this.getToken(ApexParser2.ASSIGN, 0);
      }
      elementValue() {
        return this.getRuleContext(0, ElementValueContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_elementValuePair;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterElementValuePair) {
          listener.enterElementValuePair(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitElementValuePair) {
          listener.exitElementValuePair(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitElementValuePair) {
          return visitor.visitElementValuePair(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ElementValuePairContext = ElementValuePairContext;
    var ElementValueContext = class extends ParserRuleContext_1.ParserRuleContext {
      expression() {
        return this.tryGetRuleContext(0, ExpressionContext);
      }
      annotation() {
        return this.tryGetRuleContext(0, AnnotationContext);
      }
      elementValueArrayInitializer() {
        return this.tryGetRuleContext(0, ElementValueArrayInitializerContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_elementValue;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterElementValue) {
          listener.enterElementValue(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitElementValue) {
          listener.exitElementValue(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitElementValue) {
          return visitor.visitElementValue(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ElementValueContext = ElementValueContext;
    var ElementValueArrayInitializerContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      elementValue(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ElementValueContext);
        } else {
          return this.getRuleContext(i2, ElementValueContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_elementValueArrayInitializer;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterElementValueArrayInitializer) {
          listener.enterElementValueArrayInitializer(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitElementValueArrayInitializer) {
          listener.exitElementValueArrayInitializer(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitElementValueArrayInitializer) {
          return visitor.visitElementValueArrayInitializer(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ElementValueArrayInitializerContext = ElementValueArrayInitializerContext;
    var BlockContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      statement(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(StatementContext);
        } else {
          return this.getRuleContext(i2, StatementContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_block;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterBlock) {
          listener.enterBlock(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitBlock) {
          listener.exitBlock(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitBlock) {
          return visitor.visitBlock(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BlockContext = BlockContext;
    var LocalVariableDeclarationStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      localVariableDeclaration() {
        return this.getRuleContext(0, LocalVariableDeclarationContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_localVariableDeclarationStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLocalVariableDeclarationStatement) {
          listener.enterLocalVariableDeclarationStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLocalVariableDeclarationStatement) {
          listener.exitLocalVariableDeclarationStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLocalVariableDeclarationStatement) {
          return visitor.visitLocalVariableDeclarationStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LocalVariableDeclarationStatementContext = LocalVariableDeclarationStatementContext;
    var LocalVariableDeclarationContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      variableDeclarators() {
        return this.getRuleContext(0, VariableDeclaratorsContext);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_localVariableDeclaration;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLocalVariableDeclaration) {
          listener.enterLocalVariableDeclaration(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLocalVariableDeclaration) {
          listener.exitLocalVariableDeclaration(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLocalVariableDeclaration) {
          return visitor.visitLocalVariableDeclaration(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LocalVariableDeclarationContext = LocalVariableDeclarationContext;
    var StatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      block() {
        return this.tryGetRuleContext(0, BlockContext);
      }
      ifStatement() {
        return this.tryGetRuleContext(0, IfStatementContext);
      }
      switchStatement() {
        return this.tryGetRuleContext(0, SwitchStatementContext);
      }
      forStatement() {
        return this.tryGetRuleContext(0, ForStatementContext);
      }
      whileStatement() {
        return this.tryGetRuleContext(0, WhileStatementContext);
      }
      doWhileStatement() {
        return this.tryGetRuleContext(0, DoWhileStatementContext);
      }
      tryStatement() {
        return this.tryGetRuleContext(0, TryStatementContext);
      }
      returnStatement() {
        return this.tryGetRuleContext(0, ReturnStatementContext);
      }
      throwStatement() {
        return this.tryGetRuleContext(0, ThrowStatementContext);
      }
      breakStatement() {
        return this.tryGetRuleContext(0, BreakStatementContext);
      }
      continueStatement() {
        return this.tryGetRuleContext(0, ContinueStatementContext);
      }
      insertStatement() {
        return this.tryGetRuleContext(0, InsertStatementContext);
      }
      updateStatement() {
        return this.tryGetRuleContext(0, UpdateStatementContext);
      }
      deleteStatement() {
        return this.tryGetRuleContext(0, DeleteStatementContext);
      }
      undeleteStatement() {
        return this.tryGetRuleContext(0, UndeleteStatementContext);
      }
      upsertStatement() {
        return this.tryGetRuleContext(0, UpsertStatementContext);
      }
      mergeStatement() {
        return this.tryGetRuleContext(0, MergeStatementContext);
      }
      runAsStatement() {
        return this.tryGetRuleContext(0, RunAsStatementContext);
      }
      localVariableDeclarationStatement() {
        return this.tryGetRuleContext(0, LocalVariableDeclarationStatementContext);
      }
      expressionStatement() {
        return this.tryGetRuleContext(0, ExpressionStatementContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_statement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterStatement) {
          listener.enterStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitStatement) {
          listener.exitStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitStatement) {
          return visitor.visitStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.StatementContext = StatementContext;
    var IfStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      IF() {
        return this.getToken(ApexParser2.IF, 0);
      }
      parExpression() {
        return this.getRuleContext(0, ParExpressionContext);
      }
      statement(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(StatementContext);
        } else {
          return this.getRuleContext(i2, StatementContext);
        }
      }
      ELSE() {
        return this.tryGetToken(ApexParser2.ELSE, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_ifStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterIfStatement) {
          listener.enterIfStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitIfStatement) {
          listener.exitIfStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitIfStatement) {
          return visitor.visitIfStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.IfStatementContext = IfStatementContext;
    var SwitchStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      SWITCH() {
        return this.getToken(ApexParser2.SWITCH, 0);
      }
      ON() {
        return this.getToken(ApexParser2.ON, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      whenControl(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(WhenControlContext);
        } else {
          return this.getRuleContext(i2, WhenControlContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_switchStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSwitchStatement) {
          listener.enterSwitchStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSwitchStatement) {
          listener.exitSwitchStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSwitchStatement) {
          return visitor.visitSwitchStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SwitchStatementContext = SwitchStatementContext;
    var WhenControlContext = class extends ParserRuleContext_1.ParserRuleContext {
      WHEN() {
        return this.getToken(ApexParser2.WHEN, 0);
      }
      whenValue() {
        return this.getRuleContext(0, WhenValueContext);
      }
      block() {
        return this.getRuleContext(0, BlockContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_whenControl;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterWhenControl) {
          listener.enterWhenControl(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitWhenControl) {
          listener.exitWhenControl(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitWhenControl) {
          return visitor.visitWhenControl(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.WhenControlContext = WhenControlContext;
    var WhenValueContext = class extends ParserRuleContext_1.ParserRuleContext {
      ELSE() {
        return this.tryGetToken(ApexParser2.ELSE, 0);
      }
      whenLiteral(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(WhenLiteralContext);
        } else {
          return this.getRuleContext(i2, WhenLiteralContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      typeRef() {
        return this.tryGetRuleContext(0, TypeRefContext);
      }
      id() {
        return this.tryGetRuleContext(0, IdContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_whenValue;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterWhenValue) {
          listener.enterWhenValue(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitWhenValue) {
          listener.exitWhenValue(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitWhenValue) {
          return visitor.visitWhenValue(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.WhenValueContext = WhenValueContext;
    var WhenLiteralContext = class _WhenLiteralContext extends ParserRuleContext_1.ParserRuleContext {
      IntegerLiteral() {
        return this.tryGetToken(ApexParser2.IntegerLiteral, 0);
      }
      SUB(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.SUB);
        } else {
          return this.getToken(ApexParser2.SUB, i2);
        }
      }
      ADD(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.ADD);
        } else {
          return this.getToken(ApexParser2.ADD, i2);
        }
      }
      LongLiteral() {
        return this.tryGetToken(ApexParser2.LongLiteral, 0);
      }
      StringLiteral() {
        return this.tryGetToken(ApexParser2.StringLiteral, 0);
      }
      NULL() {
        return this.tryGetToken(ApexParser2.NULL, 0);
      }
      id() {
        return this.tryGetRuleContext(0, IdContext);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      whenLiteral() {
        return this.tryGetRuleContext(0, _WhenLiteralContext);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_whenLiteral;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterWhenLiteral) {
          listener.enterWhenLiteral(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitWhenLiteral) {
          listener.exitWhenLiteral(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitWhenLiteral) {
          return visitor.visitWhenLiteral(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.WhenLiteralContext = WhenLiteralContext;
    var ForStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      FOR() {
        return this.getToken(ApexParser2.FOR, 0);
      }
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      forControl() {
        return this.getRuleContext(0, ForControlContext);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      statement() {
        return this.tryGetRuleContext(0, StatementContext);
      }
      SEMI() {
        return this.tryGetToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_forStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterForStatement) {
          listener.enterForStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitForStatement) {
          listener.exitForStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitForStatement) {
          return visitor.visitForStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ForStatementContext = ForStatementContext;
    var WhileStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      WHILE() {
        return this.getToken(ApexParser2.WHILE, 0);
      }
      parExpression() {
        return this.getRuleContext(0, ParExpressionContext);
      }
      statement() {
        return this.tryGetRuleContext(0, StatementContext);
      }
      SEMI() {
        return this.tryGetToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_whileStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterWhileStatement) {
          listener.enterWhileStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitWhileStatement) {
          listener.exitWhileStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitWhileStatement) {
          return visitor.visitWhileStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.WhileStatementContext = WhileStatementContext;
    var DoWhileStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      DO() {
        return this.getToken(ApexParser2.DO, 0);
      }
      block() {
        return this.getRuleContext(0, BlockContext);
      }
      WHILE() {
        return this.getToken(ApexParser2.WHILE, 0);
      }
      parExpression() {
        return this.getRuleContext(0, ParExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_doWhileStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDoWhileStatement) {
          listener.enterDoWhileStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDoWhileStatement) {
          listener.exitDoWhileStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDoWhileStatement) {
          return visitor.visitDoWhileStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DoWhileStatementContext = DoWhileStatementContext;
    var TryStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      TRY() {
        return this.getToken(ApexParser2.TRY, 0);
      }
      block() {
        return this.getRuleContext(0, BlockContext);
      }
      finallyBlock() {
        return this.tryGetRuleContext(0, FinallyBlockContext);
      }
      catchClause(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(CatchClauseContext);
        } else {
          return this.getRuleContext(i2, CatchClauseContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_tryStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTryStatement) {
          listener.enterTryStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTryStatement) {
          listener.exitTryStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTryStatement) {
          return visitor.visitTryStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TryStatementContext = TryStatementContext;
    var ReturnStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      RETURN() {
        return this.getToken(ApexParser2.RETURN, 0);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      expression() {
        return this.tryGetRuleContext(0, ExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_returnStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterReturnStatement) {
          listener.enterReturnStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitReturnStatement) {
          listener.exitReturnStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitReturnStatement) {
          return visitor.visitReturnStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ReturnStatementContext = ReturnStatementContext;
    var ThrowStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      THROW() {
        return this.getToken(ApexParser2.THROW, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_throwStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterThrowStatement) {
          listener.enterThrowStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitThrowStatement) {
          listener.exitThrowStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitThrowStatement) {
          return visitor.visitThrowStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ThrowStatementContext = ThrowStatementContext;
    var BreakStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      BREAK() {
        return this.getToken(ApexParser2.BREAK, 0);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_breakStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterBreakStatement) {
          listener.enterBreakStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitBreakStatement) {
          listener.exitBreakStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitBreakStatement) {
          return visitor.visitBreakStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BreakStatementContext = BreakStatementContext;
    var ContinueStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      CONTINUE() {
        return this.getToken(ApexParser2.CONTINUE, 0);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_continueStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterContinueStatement) {
          listener.enterContinueStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitContinueStatement) {
          listener.exitContinueStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitContinueStatement) {
          return visitor.visitContinueStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ContinueStatementContext = ContinueStatementContext;
    var AccessLevelContext = class extends ParserRuleContext_1.ParserRuleContext {
      AS() {
        return this.getToken(ApexParser2.AS, 0);
      }
      SYSTEM() {
        return this.tryGetToken(ApexParser2.SYSTEM, 0);
      }
      USER() {
        return this.tryGetToken(ApexParser2.USER, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_accessLevel;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterAccessLevel) {
          listener.enterAccessLevel(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitAccessLevel) {
          listener.exitAccessLevel(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitAccessLevel) {
          return visitor.visitAccessLevel(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.AccessLevelContext = AccessLevelContext;
    var InsertStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      INSERT() {
        return this.getToken(ApexParser2.INSERT, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      accessLevel() {
        return this.tryGetRuleContext(0, AccessLevelContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_insertStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterInsertStatement) {
          listener.enterInsertStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitInsertStatement) {
          listener.exitInsertStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitInsertStatement) {
          return visitor.visitInsertStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.InsertStatementContext = InsertStatementContext;
    var UpdateStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      UPDATE() {
        return this.getToken(ApexParser2.UPDATE, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      accessLevel() {
        return this.tryGetRuleContext(0, AccessLevelContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_updateStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterUpdateStatement) {
          listener.enterUpdateStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitUpdateStatement) {
          listener.exitUpdateStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitUpdateStatement) {
          return visitor.visitUpdateStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.UpdateStatementContext = UpdateStatementContext;
    var DeleteStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      DELETE() {
        return this.getToken(ApexParser2.DELETE, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      accessLevel() {
        return this.tryGetRuleContext(0, AccessLevelContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_deleteStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDeleteStatement) {
          listener.enterDeleteStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDeleteStatement) {
          listener.exitDeleteStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDeleteStatement) {
          return visitor.visitDeleteStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DeleteStatementContext = DeleteStatementContext;
    var UndeleteStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      UNDELETE() {
        return this.getToken(ApexParser2.UNDELETE, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      accessLevel() {
        return this.tryGetRuleContext(0, AccessLevelContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_undeleteStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterUndeleteStatement) {
          listener.enterUndeleteStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitUndeleteStatement) {
          listener.exitUndeleteStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitUndeleteStatement) {
          return visitor.visitUndeleteStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.UndeleteStatementContext = UndeleteStatementContext;
    var UpsertStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      UPSERT() {
        return this.getToken(ApexParser2.UPSERT, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      accessLevel() {
        return this.tryGetRuleContext(0, AccessLevelContext);
      }
      qualifiedName() {
        return this.tryGetRuleContext(0, QualifiedNameContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_upsertStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterUpsertStatement) {
          listener.enterUpsertStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitUpsertStatement) {
          listener.exitUpsertStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitUpsertStatement) {
          return visitor.visitUpsertStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.UpsertStatementContext = UpsertStatementContext;
    var MergeStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      MERGE() {
        return this.getToken(ApexParser2.MERGE, 0);
      }
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      accessLevel() {
        return this.tryGetRuleContext(0, AccessLevelContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_mergeStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterMergeStatement) {
          listener.enterMergeStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitMergeStatement) {
          listener.exitMergeStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitMergeStatement) {
          return visitor.visitMergeStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MergeStatementContext = MergeStatementContext;
    var RunAsStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      SYSTEMRUNAS() {
        return this.getToken(ApexParser2.SYSTEMRUNAS, 0);
      }
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      block() {
        return this.getRuleContext(0, BlockContext);
      }
      expressionList() {
        return this.tryGetRuleContext(0, ExpressionListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_runAsStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterRunAsStatement) {
          listener.enterRunAsStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitRunAsStatement) {
          listener.exitRunAsStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitRunAsStatement) {
          return visitor.visitRunAsStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.RunAsStatementContext = RunAsStatementContext;
    var ExpressionStatementContext = class extends ParserRuleContext_1.ParserRuleContext {
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      SEMI() {
        return this.getToken(ApexParser2.SEMI, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_expressionStatement;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterExpressionStatement) {
          listener.enterExpressionStatement(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitExpressionStatement) {
          listener.exitExpressionStatement(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitExpressionStatement) {
          return visitor.visitExpressionStatement(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ExpressionStatementContext = ExpressionStatementContext;
    var PropertyBlockContext = class extends ParserRuleContext_1.ParserRuleContext {
      getter() {
        return this.tryGetRuleContext(0, GetterContext);
      }
      setter() {
        return this.tryGetRuleContext(0, SetterContext);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_propertyBlock;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterPropertyBlock) {
          listener.enterPropertyBlock(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitPropertyBlock) {
          listener.exitPropertyBlock(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitPropertyBlock) {
          return visitor.visitPropertyBlock(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.PropertyBlockContext = PropertyBlockContext;
    var GetterContext = class extends ParserRuleContext_1.ParserRuleContext {
      GET() {
        return this.getToken(ApexParser2.GET, 0);
      }
      SEMI() {
        return this.tryGetToken(ApexParser2.SEMI, 0);
      }
      block() {
        return this.tryGetRuleContext(0, BlockContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_getter;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterGetter) {
          listener.enterGetter(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitGetter) {
          listener.exitGetter(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitGetter) {
          return visitor.visitGetter(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.GetterContext = GetterContext;
    var SetterContext = class extends ParserRuleContext_1.ParserRuleContext {
      SET() {
        return this.getToken(ApexParser2.SET, 0);
      }
      SEMI() {
        return this.tryGetToken(ApexParser2.SEMI, 0);
      }
      block() {
        return this.tryGetRuleContext(0, BlockContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_setter;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSetter) {
          listener.enterSetter(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSetter) {
          listener.exitSetter(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSetter) {
          return visitor.visitSetter(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SetterContext = SetterContext;
    var CatchClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      CATCH() {
        return this.getToken(ApexParser2.CATCH, 0);
      }
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      qualifiedName() {
        return this.getRuleContext(0, QualifiedNameContext);
      }
      id() {
        return this.getRuleContext(0, IdContext);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      block() {
        return this.getRuleContext(0, BlockContext);
      }
      modifier(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ModifierContext);
        } else {
          return this.getRuleContext(i2, ModifierContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_catchClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCatchClause) {
          listener.enterCatchClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCatchClause) {
          listener.exitCatchClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCatchClause) {
          return visitor.visitCatchClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CatchClauseContext = CatchClauseContext;
    var FinallyBlockContext = class extends ParserRuleContext_1.ParserRuleContext {
      FINALLY() {
        return this.getToken(ApexParser2.FINALLY, 0);
      }
      block() {
        return this.getRuleContext(0, BlockContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_finallyBlock;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFinallyBlock) {
          listener.enterFinallyBlock(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFinallyBlock) {
          listener.exitFinallyBlock(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFinallyBlock) {
          return visitor.visitFinallyBlock(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FinallyBlockContext = FinallyBlockContext;
    var ForControlContext = class extends ParserRuleContext_1.ParserRuleContext {
      enhancedForControl() {
        return this.tryGetRuleContext(0, EnhancedForControlContext);
      }
      SEMI(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.SEMI);
        } else {
          return this.getToken(ApexParser2.SEMI, i2);
        }
      }
      forInit() {
        return this.tryGetRuleContext(0, ForInitContext);
      }
      expression() {
        return this.tryGetRuleContext(0, ExpressionContext);
      }
      forUpdate() {
        return this.tryGetRuleContext(0, ForUpdateContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_forControl;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterForControl) {
          listener.enterForControl(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitForControl) {
          listener.exitForControl(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitForControl) {
          return visitor.visitForControl(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ForControlContext = ForControlContext;
    var ForInitContext = class extends ParserRuleContext_1.ParserRuleContext {
      localVariableDeclaration() {
        return this.tryGetRuleContext(0, LocalVariableDeclarationContext);
      }
      expressionList() {
        return this.tryGetRuleContext(0, ExpressionListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_forInit;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterForInit) {
          listener.enterForInit(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitForInit) {
          listener.exitForInit(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitForInit) {
          return visitor.visitForInit(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ForInitContext = ForInitContext;
    var EnhancedForControlContext = class extends ParserRuleContext_1.ParserRuleContext {
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      id() {
        return this.getRuleContext(0, IdContext);
      }
      COLON() {
        return this.getToken(ApexParser2.COLON, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_enhancedForControl;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterEnhancedForControl) {
          listener.enterEnhancedForControl(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitEnhancedForControl) {
          listener.exitEnhancedForControl(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitEnhancedForControl) {
          return visitor.visitEnhancedForControl(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.EnhancedForControlContext = EnhancedForControlContext;
    var ForUpdateContext = class extends ParserRuleContext_1.ParserRuleContext {
      expressionList() {
        return this.getRuleContext(0, ExpressionListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_forUpdate;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterForUpdate) {
          listener.enterForUpdate(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitForUpdate) {
          listener.exitForUpdate(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitForUpdate) {
          return visitor.visitForUpdate(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ForUpdateContext = ForUpdateContext;
    var ParExpressionContext = class extends ParserRuleContext_1.ParserRuleContext {
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_parExpression;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterParExpression) {
          listener.enterParExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitParExpression) {
          listener.exitParExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitParExpression) {
          return visitor.visitParExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ParExpressionContext = ParExpressionContext;
    var ExpressionListContext = class extends ParserRuleContext_1.ParserRuleContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_expressionList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterExpressionList) {
          listener.enterExpressionList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitExpressionList) {
          listener.exitExpressionList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitExpressionList) {
          return visitor.visitExpressionList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ExpressionListContext = ExpressionListContext;
    var ExpressionContext = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_expression;
      }
      copyFrom(ctx) {
        super.copyFrom(ctx);
      }
    };
    exports2.ExpressionContext = ExpressionContext;
    var PrimaryExpressionContext = class extends ExpressionContext {
      primary() {
        return this.getRuleContext(0, PrimaryContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterPrimaryExpression) {
          listener.enterPrimaryExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitPrimaryExpression) {
          listener.exitPrimaryExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitPrimaryExpression) {
          return visitor.visitPrimaryExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.PrimaryExpressionContext = PrimaryExpressionContext;
    var DotExpressionContext = class extends ExpressionContext {
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      DOT() {
        return this.tryGetToken(ApexParser2.DOT, 0);
      }
      QUESTIONDOT() {
        return this.tryGetToken(ApexParser2.QUESTIONDOT, 0);
      }
      dotMethodCall() {
        return this.tryGetRuleContext(0, DotMethodCallContext);
      }
      anyId() {
        return this.tryGetRuleContext(0, AnyIdContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDotExpression) {
          listener.enterDotExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDotExpression) {
          listener.exitDotExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDotExpression) {
          return visitor.visitDotExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DotExpressionContext = DotExpressionContext;
    var ArrayExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      LBRACK() {
        return this.getToken(ApexParser2.LBRACK, 0);
      }
      RBRACK() {
        return this.getToken(ApexParser2.RBRACK, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterArrayExpression) {
          listener.enterArrayExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitArrayExpression) {
          listener.exitArrayExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitArrayExpression) {
          return visitor.visitArrayExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ArrayExpressionContext = ArrayExpressionContext;
    var MethodCallExpressionContext = class extends ExpressionContext {
      methodCall() {
        return this.getRuleContext(0, MethodCallContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterMethodCallExpression) {
          listener.enterMethodCallExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitMethodCallExpression) {
          listener.exitMethodCallExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitMethodCallExpression) {
          return visitor.visitMethodCallExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MethodCallExpressionContext = MethodCallExpressionContext;
    var NewExpressionContext = class extends ExpressionContext {
      NEW() {
        return this.getToken(ApexParser2.NEW, 0);
      }
      creator() {
        return this.getRuleContext(0, CreatorContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterNewExpression) {
          listener.enterNewExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitNewExpression) {
          listener.exitNewExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitNewExpression) {
          return visitor.visitNewExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.NewExpressionContext = NewExpressionContext;
    var CastExpressionContext = class extends ExpressionContext {
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCastExpression) {
          listener.enterCastExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCastExpression) {
          listener.exitCastExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCastExpression) {
          return visitor.visitCastExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CastExpressionContext = CastExpressionContext;
    var SubExpressionContext = class extends ExpressionContext {
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSubExpression) {
          listener.enterSubExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSubExpression) {
          listener.exitSubExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSubExpression) {
          return visitor.visitSubExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SubExpressionContext = SubExpressionContext;
    var PostOpExpressionContext = class extends ExpressionContext {
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      INC() {
        return this.tryGetToken(ApexParser2.INC, 0);
      }
      DEC() {
        return this.tryGetToken(ApexParser2.DEC, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterPostOpExpression) {
          listener.enterPostOpExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitPostOpExpression) {
          listener.exitPostOpExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitPostOpExpression) {
          return visitor.visitPostOpExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.PostOpExpressionContext = PostOpExpressionContext;
    var PreOpExpressionContext = class extends ExpressionContext {
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      ADD() {
        return this.tryGetToken(ApexParser2.ADD, 0);
      }
      SUB() {
        return this.tryGetToken(ApexParser2.SUB, 0);
      }
      INC() {
        return this.tryGetToken(ApexParser2.INC, 0);
      }
      DEC() {
        return this.tryGetToken(ApexParser2.DEC, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterPreOpExpression) {
          listener.enterPreOpExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitPreOpExpression) {
          listener.exitPreOpExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitPreOpExpression) {
          return visitor.visitPreOpExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.PreOpExpressionContext = PreOpExpressionContext;
    var NegExpressionContext = class extends ExpressionContext {
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      TILDE() {
        return this.tryGetToken(ApexParser2.TILDE, 0);
      }
      BANG() {
        return this.tryGetToken(ApexParser2.BANG, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterNegExpression) {
          listener.enterNegExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitNegExpression) {
          listener.exitNegExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitNegExpression) {
          return visitor.visitNegExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.NegExpressionContext = NegExpressionContext;
    var Arth1ExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      MUL() {
        return this.tryGetToken(ApexParser2.MUL, 0);
      }
      DIV() {
        return this.tryGetToken(ApexParser2.DIV, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterArth1Expression) {
          listener.enterArth1Expression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitArth1Expression) {
          listener.exitArth1Expression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitArth1Expression) {
          return visitor.visitArth1Expression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.Arth1ExpressionContext = Arth1ExpressionContext;
    var Arth2ExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      ADD() {
        return this.tryGetToken(ApexParser2.ADD, 0);
      }
      SUB() {
        return this.tryGetToken(ApexParser2.SUB, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterArth2Expression) {
          listener.enterArth2Expression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitArth2Expression) {
          listener.exitArth2Expression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitArth2Expression) {
          return visitor.visitArth2Expression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.Arth2ExpressionContext = Arth2ExpressionContext;
    var BitExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      LT(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.LT);
        } else {
          return this.getToken(ApexParser2.LT, i2);
        }
      }
      GT(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.GT);
        } else {
          return this.getToken(ApexParser2.GT, i2);
        }
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterBitExpression) {
          listener.enterBitExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitBitExpression) {
          listener.exitBitExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitBitExpression) {
          return visitor.visitBitExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BitExpressionContext = BitExpressionContext;
    var CmpExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      GT() {
        return this.tryGetToken(ApexParser2.GT, 0);
      }
      LT() {
        return this.tryGetToken(ApexParser2.LT, 0);
      }
      ASSIGN() {
        return this.tryGetToken(ApexParser2.ASSIGN, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCmpExpression) {
          listener.enterCmpExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCmpExpression) {
          listener.exitCmpExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCmpExpression) {
          return visitor.visitCmpExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CmpExpressionContext = CmpExpressionContext;
    var InstanceOfExpressionContext = class extends ExpressionContext {
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      INSTANCEOF() {
        return this.getToken(ApexParser2.INSTANCEOF, 0);
      }
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterInstanceOfExpression) {
          listener.enterInstanceOfExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitInstanceOfExpression) {
          listener.exitInstanceOfExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitInstanceOfExpression) {
          return visitor.visitInstanceOfExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.InstanceOfExpressionContext = InstanceOfExpressionContext;
    var EqualityExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      TRIPLEEQUAL() {
        return this.tryGetToken(ApexParser2.TRIPLEEQUAL, 0);
      }
      TRIPLENOTEQUAL() {
        return this.tryGetToken(ApexParser2.TRIPLENOTEQUAL, 0);
      }
      EQUAL() {
        return this.tryGetToken(ApexParser2.EQUAL, 0);
      }
      NOTEQUAL() {
        return this.tryGetToken(ApexParser2.NOTEQUAL, 0);
      }
      LESSANDGREATER() {
        return this.tryGetToken(ApexParser2.LESSANDGREATER, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterEqualityExpression) {
          listener.enterEqualityExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitEqualityExpression) {
          listener.exitEqualityExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitEqualityExpression) {
          return visitor.visitEqualityExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.EqualityExpressionContext = EqualityExpressionContext;
    var BitAndExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      BITAND() {
        return this.getToken(ApexParser2.BITAND, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterBitAndExpression) {
          listener.enterBitAndExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitBitAndExpression) {
          listener.exitBitAndExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitBitAndExpression) {
          return visitor.visitBitAndExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BitAndExpressionContext = BitAndExpressionContext;
    var BitNotExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      CARET() {
        return this.getToken(ApexParser2.CARET, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterBitNotExpression) {
          listener.enterBitNotExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitBitNotExpression) {
          listener.exitBitNotExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitBitNotExpression) {
          return visitor.visitBitNotExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BitNotExpressionContext = BitNotExpressionContext;
    var BitOrExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      BITOR() {
        return this.getToken(ApexParser2.BITOR, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterBitOrExpression) {
          listener.enterBitOrExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitBitOrExpression) {
          listener.exitBitOrExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitBitOrExpression) {
          return visitor.visitBitOrExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BitOrExpressionContext = BitOrExpressionContext;
    var LogAndExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      AND() {
        return this.getToken(ApexParser2.AND, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLogAndExpression) {
          listener.enterLogAndExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLogAndExpression) {
          listener.exitLogAndExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLogAndExpression) {
          return visitor.visitLogAndExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LogAndExpressionContext = LogAndExpressionContext;
    var LogOrExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      OR() {
        return this.getToken(ApexParser2.OR, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLogOrExpression) {
          listener.enterLogOrExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLogOrExpression) {
          listener.exitLogOrExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLogOrExpression) {
          return visitor.visitLogOrExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LogOrExpressionContext = LogOrExpressionContext;
    var CoalExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      COAL() {
        return this.getToken(ApexParser2.COAL, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCoalExpression) {
          listener.enterCoalExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCoalExpression) {
          listener.exitCoalExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCoalExpression) {
          return visitor.visitCoalExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CoalExpressionContext = CoalExpressionContext;
    var CondExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      QUESTION() {
        return this.getToken(ApexParser2.QUESTION, 0);
      }
      COLON() {
        return this.getToken(ApexParser2.COLON, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCondExpression) {
          listener.enterCondExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCondExpression) {
          listener.exitCondExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCondExpression) {
          return visitor.visitCondExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CondExpressionContext = CondExpressionContext;
    var AssignExpressionContext = class extends ExpressionContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      ASSIGN() {
        return this.tryGetToken(ApexParser2.ASSIGN, 0);
      }
      ADD_ASSIGN() {
        return this.tryGetToken(ApexParser2.ADD_ASSIGN, 0);
      }
      SUB_ASSIGN() {
        return this.tryGetToken(ApexParser2.SUB_ASSIGN, 0);
      }
      MUL_ASSIGN() {
        return this.tryGetToken(ApexParser2.MUL_ASSIGN, 0);
      }
      DIV_ASSIGN() {
        return this.tryGetToken(ApexParser2.DIV_ASSIGN, 0);
      }
      AND_ASSIGN() {
        return this.tryGetToken(ApexParser2.AND_ASSIGN, 0);
      }
      OR_ASSIGN() {
        return this.tryGetToken(ApexParser2.OR_ASSIGN, 0);
      }
      XOR_ASSIGN() {
        return this.tryGetToken(ApexParser2.XOR_ASSIGN, 0);
      }
      RSHIFT_ASSIGN() {
        return this.tryGetToken(ApexParser2.RSHIFT_ASSIGN, 0);
      }
      URSHIFT_ASSIGN() {
        return this.tryGetToken(ApexParser2.URSHIFT_ASSIGN, 0);
      }
      LSHIFT_ASSIGN() {
        return this.tryGetToken(ApexParser2.LSHIFT_ASSIGN, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterAssignExpression) {
          listener.enterAssignExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitAssignExpression) {
          listener.exitAssignExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitAssignExpression) {
          return visitor.visitAssignExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.AssignExpressionContext = AssignExpressionContext;
    var PrimaryContext = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_primary;
      }
      copyFrom(ctx) {
        super.copyFrom(ctx);
      }
    };
    exports2.PrimaryContext = PrimaryContext;
    var ThisPrimaryContext = class extends PrimaryContext {
      THIS() {
        return this.getToken(ApexParser2.THIS, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterThisPrimary) {
          listener.enterThisPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitThisPrimary) {
          listener.exitThisPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitThisPrimary) {
          return visitor.visitThisPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ThisPrimaryContext = ThisPrimaryContext;
    var SuperPrimaryContext = class extends PrimaryContext {
      SUPER() {
        return this.getToken(ApexParser2.SUPER, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSuperPrimary) {
          listener.enterSuperPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSuperPrimary) {
          listener.exitSuperPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSuperPrimary) {
          return visitor.visitSuperPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SuperPrimaryContext = SuperPrimaryContext;
    var LiteralPrimaryContext = class extends PrimaryContext {
      literal() {
        return this.getRuleContext(0, LiteralContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLiteralPrimary) {
          listener.enterLiteralPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLiteralPrimary) {
          listener.exitLiteralPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLiteralPrimary) {
          return visitor.visitLiteralPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LiteralPrimaryContext = LiteralPrimaryContext;
    var TypeRefPrimaryContext = class extends PrimaryContext {
      typeRef() {
        return this.getRuleContext(0, TypeRefContext);
      }
      DOT() {
        return this.getToken(ApexParser2.DOT, 0);
      }
      CLASS() {
        return this.getToken(ApexParser2.CLASS, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTypeRefPrimary) {
          listener.enterTypeRefPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTypeRefPrimary) {
          listener.exitTypeRefPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTypeRefPrimary) {
          return visitor.visitTypeRefPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TypeRefPrimaryContext = TypeRefPrimaryContext;
    var VoidPrimaryContext = class extends PrimaryContext {
      VOID() {
        return this.getToken(ApexParser2.VOID, 0);
      }
      DOT() {
        return this.getToken(ApexParser2.DOT, 0);
      }
      CLASS() {
        return this.getToken(ApexParser2.CLASS, 0);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterVoidPrimary) {
          listener.enterVoidPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitVoidPrimary) {
          listener.exitVoidPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitVoidPrimary) {
          return visitor.visitVoidPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.VoidPrimaryContext = VoidPrimaryContext;
    var IdPrimaryContext = class extends PrimaryContext {
      id() {
        return this.getRuleContext(0, IdContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterIdPrimary) {
          listener.enterIdPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitIdPrimary) {
          listener.exitIdPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitIdPrimary) {
          return visitor.visitIdPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.IdPrimaryContext = IdPrimaryContext;
    var SoqlPrimaryContext = class extends PrimaryContext {
      soqlLiteral() {
        return this.getRuleContext(0, SoqlLiteralContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoqlPrimary) {
          listener.enterSoqlPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoqlPrimary) {
          listener.exitSoqlPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoqlPrimary) {
          return visitor.visitSoqlPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoqlPrimaryContext = SoqlPrimaryContext;
    var SoslPrimaryContext = class extends PrimaryContext {
      soslLiteral() {
        return this.getRuleContext(0, SoslLiteralContext);
      }
      constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this.copyFrom(ctx);
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoslPrimary) {
          listener.enterSoslPrimary(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoslPrimary) {
          listener.exitSoslPrimary(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoslPrimary) {
          return visitor.visitSoslPrimary(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoslPrimaryContext = SoslPrimaryContext;
    var MethodCallContext = class extends ParserRuleContext_1.ParserRuleContext {
      id() {
        return this.tryGetRuleContext(0, IdContext);
      }
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      expressionList() {
        return this.tryGetRuleContext(0, ExpressionListContext);
      }
      THIS() {
        return this.tryGetToken(ApexParser2.THIS, 0);
      }
      SUPER() {
        return this.tryGetToken(ApexParser2.SUPER, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_methodCall;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterMethodCall) {
          listener.enterMethodCall(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitMethodCall) {
          listener.exitMethodCall(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitMethodCall) {
          return visitor.visitMethodCall(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MethodCallContext = MethodCallContext;
    var DotMethodCallContext = class extends ParserRuleContext_1.ParserRuleContext {
      anyId() {
        return this.getRuleContext(0, AnyIdContext);
      }
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      expressionList() {
        return this.tryGetRuleContext(0, ExpressionListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_dotMethodCall;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDotMethodCall) {
          listener.enterDotMethodCall(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDotMethodCall) {
          listener.exitDotMethodCall(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDotMethodCall) {
          return visitor.visitDotMethodCall(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DotMethodCallContext = DotMethodCallContext;
    var CreatorContext = class extends ParserRuleContext_1.ParserRuleContext {
      createdName() {
        return this.getRuleContext(0, CreatedNameContext);
      }
      noRest() {
        return this.tryGetRuleContext(0, NoRestContext);
      }
      classCreatorRest() {
        return this.tryGetRuleContext(0, ClassCreatorRestContext);
      }
      arrayCreatorRest() {
        return this.tryGetRuleContext(0, ArrayCreatorRestContext);
      }
      mapCreatorRest() {
        return this.tryGetRuleContext(0, MapCreatorRestContext);
      }
      setCreatorRest() {
        return this.tryGetRuleContext(0, SetCreatorRestContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_creator;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCreator) {
          listener.enterCreator(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCreator) {
          listener.exitCreator(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCreator) {
          return visitor.visitCreator(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CreatorContext = CreatorContext;
    var CreatedNameContext = class extends ParserRuleContext_1.ParserRuleContext {
      idCreatedNamePair(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(IdCreatedNamePairContext);
        } else {
          return this.getRuleContext(i2, IdCreatedNamePairContext);
        }
      }
      DOT(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.DOT);
        } else {
          return this.getToken(ApexParser2.DOT, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_createdName;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCreatedName) {
          listener.enterCreatedName(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCreatedName) {
          listener.exitCreatedName(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCreatedName) {
          return visitor.visitCreatedName(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CreatedNameContext = CreatedNameContext;
    var IdCreatedNamePairContext = class extends ParserRuleContext_1.ParserRuleContext {
      anyId() {
        return this.getRuleContext(0, AnyIdContext);
      }
      LT() {
        return this.tryGetToken(ApexParser2.LT, 0);
      }
      typeList() {
        return this.tryGetRuleContext(0, TypeListContext);
      }
      GT() {
        return this.tryGetToken(ApexParser2.GT, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_idCreatedNamePair;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterIdCreatedNamePair) {
          listener.enterIdCreatedNamePair(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitIdCreatedNamePair) {
          listener.exitIdCreatedNamePair(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitIdCreatedNamePair) {
          return visitor.visitIdCreatedNamePair(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.IdCreatedNamePairContext = IdCreatedNamePairContext;
    var NoRestContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_noRest;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterNoRest) {
          listener.enterNoRest(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitNoRest) {
          listener.exitNoRest(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitNoRest) {
          return visitor.visitNoRest(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.NoRestContext = NoRestContext;
    var ClassCreatorRestContext = class extends ParserRuleContext_1.ParserRuleContext {
      arguments() {
        return this.getRuleContext(0, ArgumentsContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_classCreatorRest;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterClassCreatorRest) {
          listener.enterClassCreatorRest(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitClassCreatorRest) {
          listener.exitClassCreatorRest(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitClassCreatorRest) {
          return visitor.visitClassCreatorRest(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ClassCreatorRestContext = ClassCreatorRestContext;
    var ArrayCreatorRestContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACK() {
        return this.getToken(ApexParser2.LBRACK, 0);
      }
      expression() {
        return this.tryGetRuleContext(0, ExpressionContext);
      }
      RBRACK() {
        return this.getToken(ApexParser2.RBRACK, 0);
      }
      arrayInitializer() {
        return this.tryGetRuleContext(0, ArrayInitializerContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_arrayCreatorRest;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterArrayCreatorRest) {
          listener.enterArrayCreatorRest(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitArrayCreatorRest) {
          listener.exitArrayCreatorRest(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitArrayCreatorRest) {
          return visitor.visitArrayCreatorRest(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ArrayCreatorRestContext = ArrayCreatorRestContext;
    var MapCreatorRestContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      mapCreatorRestPair(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(MapCreatorRestPairContext);
        } else {
          return this.getRuleContext(i2, MapCreatorRestPairContext);
        }
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_mapCreatorRest;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterMapCreatorRest) {
          listener.enterMapCreatorRest(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitMapCreatorRest) {
          listener.exitMapCreatorRest(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitMapCreatorRest) {
          return visitor.visitMapCreatorRest(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MapCreatorRestContext = MapCreatorRestContext;
    var MapCreatorRestPairContext = class extends ParserRuleContext_1.ParserRuleContext {
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      MAPTO() {
        return this.getToken(ApexParser2.MAPTO, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_mapCreatorRestPair;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterMapCreatorRestPair) {
          listener.enterMapCreatorRestPair(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitMapCreatorRestPair) {
          listener.exitMapCreatorRestPair(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitMapCreatorRestPair) {
          return visitor.visitMapCreatorRestPair(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.MapCreatorRestPairContext = MapCreatorRestPairContext;
    var SetCreatorRestContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACE() {
        return this.getToken(ApexParser2.LBRACE, 0);
      }
      expression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ExpressionContext);
        } else {
          return this.getRuleContext(i2, ExpressionContext);
        }
      }
      RBRACE() {
        return this.getToken(ApexParser2.RBRACE, 0);
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_setCreatorRest;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSetCreatorRest) {
          listener.enterSetCreatorRest(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSetCreatorRest) {
          listener.exitSetCreatorRest(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSetCreatorRest) {
          return visitor.visitSetCreatorRest(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SetCreatorRestContext = SetCreatorRestContext;
    var ArgumentsContext = class extends ParserRuleContext_1.ParserRuleContext {
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      expressionList() {
        return this.tryGetRuleContext(0, ExpressionListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_arguments;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterArguments) {
          listener.enterArguments(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitArguments) {
          listener.exitArguments(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitArguments) {
          return visitor.visitArguments(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ArgumentsContext = ArgumentsContext;
    var SoqlLiteralContext = class extends ParserRuleContext_1.ParserRuleContext {
      LBRACK() {
        return this.getToken(ApexParser2.LBRACK, 0);
      }
      query() {
        return this.getRuleContext(0, QueryContext);
      }
      RBRACK() {
        return this.getToken(ApexParser2.RBRACK, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soqlLiteral;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoqlLiteral) {
          listener.enterSoqlLiteral(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoqlLiteral) {
          listener.exitSoqlLiteral(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoqlLiteral) {
          return visitor.visitSoqlLiteral(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoqlLiteralContext = SoqlLiteralContext;
    var QueryContext = class extends ParserRuleContext_1.ParserRuleContext {
      SELECT() {
        return this.getToken(ApexParser2.SELECT, 0);
      }
      selectList() {
        return this.getRuleContext(0, SelectListContext);
      }
      FROM() {
        return this.getToken(ApexParser2.FROM, 0);
      }
      fromNameList() {
        return this.getRuleContext(0, FromNameListContext);
      }
      forClauses() {
        return this.getRuleContext(0, ForClausesContext);
      }
      usingScope() {
        return this.tryGetRuleContext(0, UsingScopeContext);
      }
      whereClause() {
        return this.tryGetRuleContext(0, WhereClauseContext);
      }
      withClause() {
        return this.tryGetRuleContext(0, WithClauseContext);
      }
      groupByClause() {
        return this.tryGetRuleContext(0, GroupByClauseContext);
      }
      orderByClause() {
        return this.tryGetRuleContext(0, OrderByClauseContext);
      }
      limitClause() {
        return this.tryGetRuleContext(0, LimitClauseContext);
      }
      offsetClause() {
        return this.tryGetRuleContext(0, OffsetClauseContext);
      }
      allRowsClause() {
        return this.tryGetRuleContext(0, AllRowsClauseContext);
      }
      UPDATE() {
        return this.tryGetToken(ApexParser2.UPDATE, 0);
      }
      updateList() {
        return this.tryGetRuleContext(0, UpdateListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_query;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterQuery) {
          listener.enterQuery(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitQuery) {
          listener.exitQuery(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitQuery) {
          return visitor.visitQuery(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.QueryContext = QueryContext;
    var SubQueryContext = class extends ParserRuleContext_1.ParserRuleContext {
      SELECT() {
        return this.getToken(ApexParser2.SELECT, 0);
      }
      subFieldList() {
        return this.getRuleContext(0, SubFieldListContext);
      }
      FROM() {
        return this.getToken(ApexParser2.FROM, 0);
      }
      fromNameList() {
        return this.getRuleContext(0, FromNameListContext);
      }
      forClauses() {
        return this.getRuleContext(0, ForClausesContext);
      }
      whereClause() {
        return this.tryGetRuleContext(0, WhereClauseContext);
      }
      orderByClause() {
        return this.tryGetRuleContext(0, OrderByClauseContext);
      }
      limitClause() {
        return this.tryGetRuleContext(0, LimitClauseContext);
      }
      UPDATE() {
        return this.tryGetToken(ApexParser2.UPDATE, 0);
      }
      updateList() {
        return this.tryGetRuleContext(0, UpdateListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_subQuery;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSubQuery) {
          listener.enterSubQuery(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSubQuery) {
          listener.exitSubQuery(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSubQuery) {
          return visitor.visitSubQuery(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SubQueryContext = SubQueryContext;
    var SelectListContext = class extends ParserRuleContext_1.ParserRuleContext {
      selectEntry(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SelectEntryContext);
        } else {
          return this.getRuleContext(i2, SelectEntryContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_selectList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSelectList) {
          listener.enterSelectList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSelectList) {
          listener.exitSelectList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSelectList) {
          return visitor.visitSelectList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SelectListContext = SelectListContext;
    var SelectEntryContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldName() {
        return this.tryGetRuleContext(0, FieldNameContext);
      }
      soqlId() {
        return this.tryGetRuleContext(0, SoqlIdContext);
      }
      soqlFunction() {
        return this.tryGetRuleContext(0, SoqlFunctionContext);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      subQuery() {
        return this.tryGetRuleContext(0, SubQueryContext);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      typeOf() {
        return this.tryGetRuleContext(0, TypeOfContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_selectEntry;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSelectEntry) {
          listener.enterSelectEntry(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSelectEntry) {
          listener.exitSelectEntry(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSelectEntry) {
          return visitor.visitSelectEntry(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SelectEntryContext = SelectEntryContext;
    var FieldNameContext = class extends ParserRuleContext_1.ParserRuleContext {
      soqlId(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SoqlIdContext);
        } else {
          return this.getRuleContext(i2, SoqlIdContext);
        }
      }
      DOT(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.DOT);
        } else {
          return this.getToken(ApexParser2.DOT, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldName;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldName) {
          listener.enterFieldName(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldName) {
          listener.exitFieldName(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldName) {
          return visitor.visitFieldName(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldNameContext = FieldNameContext;
    var FromNameListContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldName(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(FieldNameContext);
        } else {
          return this.getRuleContext(i2, FieldNameContext);
        }
      }
      soqlId(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SoqlIdContext);
        } else {
          return this.getRuleContext(i2, SoqlIdContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fromNameList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFromNameList) {
          listener.enterFromNameList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFromNameList) {
          listener.exitFromNameList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFromNameList) {
          return visitor.visitFromNameList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FromNameListContext = FromNameListContext;
    var SubFieldListContext = class extends ParserRuleContext_1.ParserRuleContext {
      subFieldEntry(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SubFieldEntryContext);
        } else {
          return this.getRuleContext(i2, SubFieldEntryContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_subFieldList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSubFieldList) {
          listener.enterSubFieldList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSubFieldList) {
          listener.exitSubFieldList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSubFieldList) {
          return visitor.visitSubFieldList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SubFieldListContext = SubFieldListContext;
    var SubFieldEntryContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldName() {
        return this.tryGetRuleContext(0, FieldNameContext);
      }
      soqlId() {
        return this.tryGetRuleContext(0, SoqlIdContext);
      }
      soqlFunction() {
        return this.tryGetRuleContext(0, SoqlFunctionContext);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      subQuery() {
        return this.tryGetRuleContext(0, SubQueryContext);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      typeOf() {
        return this.tryGetRuleContext(0, TypeOfContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_subFieldEntry;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSubFieldEntry) {
          listener.enterSubFieldEntry(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSubFieldEntry) {
          listener.exitSubFieldEntry(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSubFieldEntry) {
          return visitor.visitSubFieldEntry(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SubFieldEntryContext = SubFieldEntryContext;
    var SoqlFieldsParameterContext = class extends ParserRuleContext_1.ParserRuleContext {
      ALL() {
        return this.tryGetToken(ApexParser2.ALL, 0);
      }
      CUSTOM() {
        return this.tryGetToken(ApexParser2.CUSTOM, 0);
      }
      STANDARD() {
        return this.tryGetToken(ApexParser2.STANDARD, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soqlFieldsParameter;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoqlFieldsParameter) {
          listener.enterSoqlFieldsParameter(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoqlFieldsParameter) {
          listener.exitSoqlFieldsParameter(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoqlFieldsParameter) {
          return visitor.visitSoqlFieldsParameter(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoqlFieldsParameterContext = SoqlFieldsParameterContext;
    var SoqlFunctionContext = class _SoqlFunctionContext extends ParserRuleContext_1.ParserRuleContext {
      AVG() {
        return this.tryGetToken(ApexParser2.AVG, 0);
      }
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      fieldName() {
        return this.tryGetRuleContext(0, FieldNameContext);
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      COUNT() {
        return this.tryGetToken(ApexParser2.COUNT, 0);
      }
      COUNT_DISTINCT() {
        return this.tryGetToken(ApexParser2.COUNT_DISTINCT, 0);
      }
      MIN() {
        return this.tryGetToken(ApexParser2.MIN, 0);
      }
      MAX() {
        return this.tryGetToken(ApexParser2.MAX, 0);
      }
      SUM() {
        return this.tryGetToken(ApexParser2.SUM, 0);
      }
      TOLABEL() {
        return this.tryGetToken(ApexParser2.TOLABEL, 0);
      }
      FORMAT() {
        return this.tryGetToken(ApexParser2.FORMAT, 0);
      }
      soqlFunction() {
        return this.tryGetRuleContext(0, _SoqlFunctionContext);
      }
      CALENDAR_MONTH() {
        return this.tryGetToken(ApexParser2.CALENDAR_MONTH, 0);
      }
      dateFieldName() {
        return this.tryGetRuleContext(0, DateFieldNameContext);
      }
      CALENDAR_QUARTER() {
        return this.tryGetToken(ApexParser2.CALENDAR_QUARTER, 0);
      }
      CALENDAR_YEAR() {
        return this.tryGetToken(ApexParser2.CALENDAR_YEAR, 0);
      }
      DAY_IN_MONTH() {
        return this.tryGetToken(ApexParser2.DAY_IN_MONTH, 0);
      }
      DAY_IN_WEEK() {
        return this.tryGetToken(ApexParser2.DAY_IN_WEEK, 0);
      }
      DAY_IN_YEAR() {
        return this.tryGetToken(ApexParser2.DAY_IN_YEAR, 0);
      }
      DAY_ONLY() {
        return this.tryGetToken(ApexParser2.DAY_ONLY, 0);
      }
      FISCAL_MONTH() {
        return this.tryGetToken(ApexParser2.FISCAL_MONTH, 0);
      }
      FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.FISCAL_QUARTER, 0);
      }
      FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.FISCAL_YEAR, 0);
      }
      HOUR_IN_DAY() {
        return this.tryGetToken(ApexParser2.HOUR_IN_DAY, 0);
      }
      WEEK_IN_MONTH() {
        return this.tryGetToken(ApexParser2.WEEK_IN_MONTH, 0);
      }
      WEEK_IN_YEAR() {
        return this.tryGetToken(ApexParser2.WEEK_IN_YEAR, 0);
      }
      FIELDS() {
        return this.tryGetToken(ApexParser2.FIELDS, 0);
      }
      soqlFieldsParameter() {
        return this.tryGetRuleContext(0, SoqlFieldsParameterContext);
      }
      DISTANCE() {
        return this.tryGetToken(ApexParser2.DISTANCE, 0);
      }
      locationValue(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(LocationValueContext);
        } else {
          return this.getRuleContext(i2, LocationValueContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      StringLiteral() {
        return this.tryGetToken(ApexParser2.StringLiteral, 0);
      }
      GROUPING() {
        return this.tryGetToken(ApexParser2.GROUPING, 0);
      }
      CONVERT_CURRENCY() {
        return this.tryGetToken(ApexParser2.CONVERT_CURRENCY, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soqlFunction;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoqlFunction) {
          listener.enterSoqlFunction(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoqlFunction) {
          listener.exitSoqlFunction(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoqlFunction) {
          return visitor.visitSoqlFunction(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoqlFunctionContext = SoqlFunctionContext;
    var DateFieldNameContext = class extends ParserRuleContext_1.ParserRuleContext {
      CONVERT_TIMEZONE() {
        return this.tryGetToken(ApexParser2.CONVERT_TIMEZONE, 0);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      fieldName() {
        return this.getRuleContext(0, FieldNameContext);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_dateFieldName;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDateFieldName) {
          listener.enterDateFieldName(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDateFieldName) {
          listener.exitDateFieldName(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDateFieldName) {
          return visitor.visitDateFieldName(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DateFieldNameContext = DateFieldNameContext;
    var LocationValueContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldName() {
        return this.tryGetRuleContext(0, FieldNameContext);
      }
      boundExpression() {
        return this.tryGetRuleContext(0, BoundExpressionContext);
      }
      GEOLOCATION() {
        return this.tryGetToken(ApexParser2.GEOLOCATION, 0);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      coordinateValue(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(CoordinateValueContext);
        } else {
          return this.getRuleContext(i2, CoordinateValueContext);
        }
      }
      COMMA() {
        return this.tryGetToken(ApexParser2.COMMA, 0);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_locationValue;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLocationValue) {
          listener.enterLocationValue(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLocationValue) {
          listener.exitLocationValue(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLocationValue) {
          return visitor.visitLocationValue(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LocationValueContext = LocationValueContext;
    var CoordinateValueContext = class extends ParserRuleContext_1.ParserRuleContext {
      signedNumber() {
        return this.tryGetRuleContext(0, SignedNumberContext);
      }
      boundExpression() {
        return this.tryGetRuleContext(0, BoundExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_coordinateValue;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterCoordinateValue) {
          listener.enterCoordinateValue(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitCoordinateValue) {
          listener.exitCoordinateValue(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitCoordinateValue) {
          return visitor.visitCoordinateValue(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.CoordinateValueContext = CoordinateValueContext;
    var TypeOfContext = class extends ParserRuleContext_1.ParserRuleContext {
      TYPEOF() {
        return this.getToken(ApexParser2.TYPEOF, 0);
      }
      fieldName() {
        return this.getRuleContext(0, FieldNameContext);
      }
      END() {
        return this.getToken(ApexParser2.END, 0);
      }
      whenClause(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(WhenClauseContext);
        } else {
          return this.getRuleContext(i2, WhenClauseContext);
        }
      }
      elseClause() {
        return this.tryGetRuleContext(0, ElseClauseContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_typeOf;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterTypeOf) {
          listener.enterTypeOf(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitTypeOf) {
          listener.exitTypeOf(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitTypeOf) {
          return visitor.visitTypeOf(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.TypeOfContext = TypeOfContext;
    var WhenClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      WHEN() {
        return this.getToken(ApexParser2.WHEN, 0);
      }
      fieldName() {
        return this.getRuleContext(0, FieldNameContext);
      }
      THEN() {
        return this.getToken(ApexParser2.THEN, 0);
      }
      fieldNameList() {
        return this.getRuleContext(0, FieldNameListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_whenClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterWhenClause) {
          listener.enterWhenClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitWhenClause) {
          listener.exitWhenClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitWhenClause) {
          return visitor.visitWhenClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.WhenClauseContext = WhenClauseContext;
    var ElseClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      ELSE() {
        return this.getToken(ApexParser2.ELSE, 0);
      }
      fieldNameList() {
        return this.getRuleContext(0, FieldNameListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_elseClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterElseClause) {
          listener.enterElseClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitElseClause) {
          listener.exitElseClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitElseClause) {
          return visitor.visitElseClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ElseClauseContext = ElseClauseContext;
    var FieldNameListContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldName(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(FieldNameContext);
        } else {
          return this.getRuleContext(i2, FieldNameContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldNameList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldNameList) {
          listener.enterFieldNameList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldNameList) {
          listener.exitFieldNameList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldNameList) {
          return visitor.visitFieldNameList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldNameListContext = FieldNameListContext;
    var UsingScopeContext = class extends ParserRuleContext_1.ParserRuleContext {
      USING() {
        return this.getToken(ApexParser2.USING, 0);
      }
      SCOPE() {
        return this.getToken(ApexParser2.SCOPE, 0);
      }
      soqlId() {
        return this.getRuleContext(0, SoqlIdContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_usingScope;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterUsingScope) {
          listener.enterUsingScope(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitUsingScope) {
          listener.exitUsingScope(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitUsingScope) {
          return visitor.visitUsingScope(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.UsingScopeContext = UsingScopeContext;
    var WhereClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      WHERE() {
        return this.getToken(ApexParser2.WHERE, 0);
      }
      logicalExpression() {
        return this.getRuleContext(0, LogicalExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_whereClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterWhereClause) {
          listener.enterWhereClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitWhereClause) {
          listener.exitWhereClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitWhereClause) {
          return visitor.visitWhereClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.WhereClauseContext = WhereClauseContext;
    var LogicalExpressionContext = class extends ParserRuleContext_1.ParserRuleContext {
      conditionalExpression(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ConditionalExpressionContext);
        } else {
          return this.getRuleContext(i2, ConditionalExpressionContext);
        }
      }
      SOQLAND(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.SOQLAND);
        } else {
          return this.getToken(ApexParser2.SOQLAND, i2);
        }
      }
      SOQLOR(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.SOQLOR);
        } else {
          return this.getToken(ApexParser2.SOQLOR, i2);
        }
      }
      NOT() {
        return this.tryGetToken(ApexParser2.NOT, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_logicalExpression;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLogicalExpression) {
          listener.enterLogicalExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLogicalExpression) {
          listener.exitLogicalExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLogicalExpression) {
          return visitor.visitLogicalExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LogicalExpressionContext = LogicalExpressionContext;
    var ConditionalExpressionContext = class extends ParserRuleContext_1.ParserRuleContext {
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      logicalExpression() {
        return this.tryGetRuleContext(0, LogicalExpressionContext);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      fieldExpression() {
        return this.tryGetRuleContext(0, FieldExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_conditionalExpression;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterConditionalExpression) {
          listener.enterConditionalExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitConditionalExpression) {
          listener.exitConditionalExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitConditionalExpression) {
          return visitor.visitConditionalExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ConditionalExpressionContext = ConditionalExpressionContext;
    var FieldExpressionContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldName() {
        return this.tryGetRuleContext(0, FieldNameContext);
      }
      comparisonOperator() {
        return this.getRuleContext(0, ComparisonOperatorContext);
      }
      value() {
        return this.getRuleContext(0, ValueContext);
      }
      soqlFunction() {
        return this.tryGetRuleContext(0, SoqlFunctionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldExpression;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldExpression) {
          listener.enterFieldExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldExpression) {
          listener.exitFieldExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldExpression) {
          return visitor.visitFieldExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldExpressionContext = FieldExpressionContext;
    var ComparisonOperatorContext = class extends ParserRuleContext_1.ParserRuleContext {
      ASSIGN() {
        return this.tryGetToken(ApexParser2.ASSIGN, 0);
      }
      NOTEQUAL() {
        return this.tryGetToken(ApexParser2.NOTEQUAL, 0);
      }
      LT() {
        return this.tryGetToken(ApexParser2.LT, 0);
      }
      GT() {
        return this.tryGetToken(ApexParser2.GT, 0);
      }
      LESSANDGREATER() {
        return this.tryGetToken(ApexParser2.LESSANDGREATER, 0);
      }
      LIKE() {
        return this.tryGetToken(ApexParser2.LIKE, 0);
      }
      IN() {
        return this.tryGetToken(ApexParser2.IN, 0);
      }
      NOT() {
        return this.tryGetToken(ApexParser2.NOT, 0);
      }
      INCLUDES() {
        return this.tryGetToken(ApexParser2.INCLUDES, 0);
      }
      EXCLUDES() {
        return this.tryGetToken(ApexParser2.EXCLUDES, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_comparisonOperator;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterComparisonOperator) {
          listener.enterComparisonOperator(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitComparisonOperator) {
          listener.exitComparisonOperator(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitComparisonOperator) {
          return visitor.visitComparisonOperator(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ComparisonOperatorContext = ComparisonOperatorContext;
    var ValueContext = class extends ParserRuleContext_1.ParserRuleContext {
      NULL() {
        return this.tryGetToken(ApexParser2.NULL, 0);
      }
      BooleanLiteral() {
        return this.tryGetToken(ApexParser2.BooleanLiteral, 0);
      }
      signedNumber() {
        return this.tryGetRuleContext(0, SignedNumberContext);
      }
      StringLiteral() {
        return this.tryGetToken(ApexParser2.StringLiteral, 0);
      }
      DateLiteral() {
        return this.tryGetToken(ApexParser2.DateLiteral, 0);
      }
      TimeLiteral() {
        return this.tryGetToken(ApexParser2.TimeLiteral, 0);
      }
      DateTimeLiteral() {
        return this.tryGetToken(ApexParser2.DateTimeLiteral, 0);
      }
      dateFormula() {
        return this.tryGetRuleContext(0, DateFormulaContext);
      }
      IntegralCurrencyLiteral() {
        return this.tryGetToken(ApexParser2.IntegralCurrencyLiteral, 0);
      }
      DOT() {
        return this.tryGetToken(ApexParser2.DOT, 0);
      }
      IntegerLiteral() {
        return this.tryGetToken(ApexParser2.IntegerLiteral, 0);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      subQuery() {
        return this.tryGetRuleContext(0, SubQueryContext);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      valueList() {
        return this.tryGetRuleContext(0, ValueListContext);
      }
      boundExpression() {
        return this.tryGetRuleContext(0, BoundExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_value;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterValue) {
          listener.enterValue(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitValue) {
          listener.exitValue(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitValue) {
          return visitor.visitValue(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ValueContext = ValueContext;
    var ValueListContext = class extends ParserRuleContext_1.ParserRuleContext {
      LPAREN() {
        return this.getToken(ApexParser2.LPAREN, 0);
      }
      value(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(ValueContext);
        } else {
          return this.getRuleContext(i2, ValueContext);
        }
      }
      RPAREN() {
        return this.getToken(ApexParser2.RPAREN, 0);
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_valueList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterValueList) {
          listener.enterValueList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitValueList) {
          listener.exitValueList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitValueList) {
          return visitor.visitValueList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ValueListContext = ValueListContext;
    var SignedNumberContext = class extends ParserRuleContext_1.ParserRuleContext {
      IntegerLiteral() {
        return this.tryGetToken(ApexParser2.IntegerLiteral, 0);
      }
      NumberLiteral() {
        return this.tryGetToken(ApexParser2.NumberLiteral, 0);
      }
      ADD() {
        return this.tryGetToken(ApexParser2.ADD, 0);
      }
      SUB() {
        return this.tryGetToken(ApexParser2.SUB, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_signedNumber;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSignedNumber) {
          listener.enterSignedNumber(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSignedNumber) {
          listener.exitSignedNumber(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSignedNumber) {
          return visitor.visitSignedNumber(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SignedNumberContext = SignedNumberContext;
    var WithClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      WITH() {
        return this.getToken(ApexParser2.WITH, 0);
      }
      DATA() {
        return this.tryGetToken(ApexParser2.DATA, 0);
      }
      CATEGORY() {
        return this.tryGetToken(ApexParser2.CATEGORY, 0);
      }
      filteringExpression() {
        return this.tryGetRuleContext(0, FilteringExpressionContext);
      }
      SECURITY_ENFORCED() {
        return this.tryGetToken(ApexParser2.SECURITY_ENFORCED, 0);
      }
      SYSTEM_MODE() {
        return this.tryGetToken(ApexParser2.SYSTEM_MODE, 0);
      }
      USER_MODE() {
        return this.tryGetToken(ApexParser2.USER_MODE, 0);
      }
      logicalExpression() {
        return this.tryGetRuleContext(0, LogicalExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_withClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterWithClause) {
          listener.enterWithClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitWithClause) {
          listener.exitWithClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitWithClause) {
          return visitor.visitWithClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.WithClauseContext = WithClauseContext;
    var FilteringExpressionContext = class extends ParserRuleContext_1.ParserRuleContext {
      dataCategorySelection(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(DataCategorySelectionContext);
        } else {
          return this.getRuleContext(i2, DataCategorySelectionContext);
        }
      }
      AND(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.AND);
        } else {
          return this.getToken(ApexParser2.AND, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_filteringExpression;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFilteringExpression) {
          listener.enterFilteringExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFilteringExpression) {
          listener.exitFilteringExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFilteringExpression) {
          return visitor.visitFilteringExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FilteringExpressionContext = FilteringExpressionContext;
    var DataCategorySelectionContext = class extends ParserRuleContext_1.ParserRuleContext {
      soqlId() {
        return this.getRuleContext(0, SoqlIdContext);
      }
      filteringSelector() {
        return this.getRuleContext(0, FilteringSelectorContext);
      }
      dataCategoryName() {
        return this.getRuleContext(0, DataCategoryNameContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_dataCategorySelection;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDataCategorySelection) {
          listener.enterDataCategorySelection(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDataCategorySelection) {
          listener.exitDataCategorySelection(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDataCategorySelection) {
          return visitor.visitDataCategorySelection(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DataCategorySelectionContext = DataCategorySelectionContext;
    var DataCategoryNameContext = class extends ParserRuleContext_1.ParserRuleContext {
      soqlId(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SoqlIdContext);
        } else {
          return this.getRuleContext(i2, SoqlIdContext);
        }
      }
      LPAREN(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.LPAREN);
        } else {
          return this.getToken(ApexParser2.LPAREN, i2);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_dataCategoryName;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDataCategoryName) {
          listener.enterDataCategoryName(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDataCategoryName) {
          listener.exitDataCategoryName(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDataCategoryName) {
          return visitor.visitDataCategoryName(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DataCategoryNameContext = DataCategoryNameContext;
    var FilteringSelectorContext = class extends ParserRuleContext_1.ParserRuleContext {
      AT() {
        return this.tryGetToken(ApexParser2.AT, 0);
      }
      ABOVE() {
        return this.tryGetToken(ApexParser2.ABOVE, 0);
      }
      BELOW() {
        return this.tryGetToken(ApexParser2.BELOW, 0);
      }
      ABOVE_OR_BELOW() {
        return this.tryGetToken(ApexParser2.ABOVE_OR_BELOW, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_filteringSelector;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFilteringSelector) {
          listener.enterFilteringSelector(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFilteringSelector) {
          listener.exitFilteringSelector(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFilteringSelector) {
          return visitor.visitFilteringSelector(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FilteringSelectorContext = FilteringSelectorContext;
    var GroupByClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      GROUP() {
        return this.getToken(ApexParser2.GROUP, 0);
      }
      BY() {
        return this.getToken(ApexParser2.BY, 0);
      }
      selectList() {
        return this.tryGetRuleContext(0, SelectListContext);
      }
      HAVING() {
        return this.tryGetToken(ApexParser2.HAVING, 0);
      }
      logicalExpression() {
        return this.tryGetRuleContext(0, LogicalExpressionContext);
      }
      ROLLUP() {
        return this.tryGetToken(ApexParser2.ROLLUP, 0);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      fieldName(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(FieldNameContext);
        } else {
          return this.getRuleContext(i2, FieldNameContext);
        }
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      CUBE() {
        return this.tryGetToken(ApexParser2.CUBE, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_groupByClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterGroupByClause) {
          listener.enterGroupByClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitGroupByClause) {
          listener.exitGroupByClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitGroupByClause) {
          return visitor.visitGroupByClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.GroupByClauseContext = GroupByClauseContext;
    var OrderByClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      ORDER() {
        return this.getToken(ApexParser2.ORDER, 0);
      }
      BY() {
        return this.getToken(ApexParser2.BY, 0);
      }
      fieldOrderList() {
        return this.getRuleContext(0, FieldOrderListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_orderByClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterOrderByClause) {
          listener.enterOrderByClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitOrderByClause) {
          listener.exitOrderByClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitOrderByClause) {
          return visitor.visitOrderByClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.OrderByClauseContext = OrderByClauseContext;
    var FieldOrderListContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldOrder(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(FieldOrderContext);
        } else {
          return this.getRuleContext(i2, FieldOrderContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldOrderList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldOrderList) {
          listener.enterFieldOrderList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldOrderList) {
          listener.exitFieldOrderList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldOrderList) {
          return visitor.visitFieldOrderList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldOrderListContext = FieldOrderListContext;
    var FieldOrderContext = class extends ParserRuleContext_1.ParserRuleContext {
      fieldName() {
        return this.tryGetRuleContext(0, FieldNameContext);
      }
      NULLS() {
        return this.tryGetToken(ApexParser2.NULLS, 0);
      }
      ASC() {
        return this.tryGetToken(ApexParser2.ASC, 0);
      }
      DESC() {
        return this.tryGetToken(ApexParser2.DESC, 0);
      }
      FIRST() {
        return this.tryGetToken(ApexParser2.FIRST, 0);
      }
      LAST() {
        return this.tryGetToken(ApexParser2.LAST, 0);
      }
      soqlFunction() {
        return this.tryGetRuleContext(0, SoqlFunctionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldOrder;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldOrder) {
          listener.enterFieldOrder(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldOrder) {
          listener.exitFieldOrder(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldOrder) {
          return visitor.visitFieldOrder(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldOrderContext = FieldOrderContext;
    var LimitClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      LIMIT() {
        return this.getToken(ApexParser2.LIMIT, 0);
      }
      IntegerLiteral() {
        return this.tryGetToken(ApexParser2.IntegerLiteral, 0);
      }
      boundExpression() {
        return this.tryGetRuleContext(0, BoundExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_limitClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterLimitClause) {
          listener.enterLimitClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitLimitClause) {
          listener.exitLimitClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitLimitClause) {
          return visitor.visitLimitClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.LimitClauseContext = LimitClauseContext;
    var OffsetClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      OFFSET() {
        return this.getToken(ApexParser2.OFFSET, 0);
      }
      IntegerLiteral() {
        return this.tryGetToken(ApexParser2.IntegerLiteral, 0);
      }
      boundExpression() {
        return this.tryGetRuleContext(0, BoundExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_offsetClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterOffsetClause) {
          listener.enterOffsetClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitOffsetClause) {
          listener.exitOffsetClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitOffsetClause) {
          return visitor.visitOffsetClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.OffsetClauseContext = OffsetClauseContext;
    var AllRowsClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      ALL() {
        return this.getToken(ApexParser2.ALL, 0);
      }
      ROWS() {
        return this.getToken(ApexParser2.ROWS, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_allRowsClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterAllRowsClause) {
          listener.enterAllRowsClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitAllRowsClause) {
          listener.exitAllRowsClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitAllRowsClause) {
          return visitor.visitAllRowsClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.AllRowsClauseContext = AllRowsClauseContext;
    var ForClausesContext = class extends ParserRuleContext_1.ParserRuleContext {
      FOR(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.FOR);
        } else {
          return this.getToken(ApexParser2.FOR, i2);
        }
      }
      VIEW(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.VIEW);
        } else {
          return this.getToken(ApexParser2.VIEW, i2);
        }
      }
      UPDATE(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.UPDATE);
        } else {
          return this.getToken(ApexParser2.UPDATE, i2);
        }
      }
      REFERENCE(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.REFERENCE);
        } else {
          return this.getToken(ApexParser2.REFERENCE, i2);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_forClauses;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterForClauses) {
          listener.enterForClauses(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitForClauses) {
          listener.exitForClauses(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitForClauses) {
          return visitor.visitForClauses(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.ForClausesContext = ForClausesContext;
    var BoundExpressionContext = class extends ParserRuleContext_1.ParserRuleContext {
      COLON() {
        return this.getToken(ApexParser2.COLON, 0);
      }
      expression() {
        return this.getRuleContext(0, ExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_boundExpression;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterBoundExpression) {
          listener.enterBoundExpression(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitBoundExpression) {
          listener.exitBoundExpression(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitBoundExpression) {
          return visitor.visitBoundExpression(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.BoundExpressionContext = BoundExpressionContext;
    var DateFormulaContext = class extends ParserRuleContext_1.ParserRuleContext {
      YESTERDAY() {
        return this.tryGetToken(ApexParser2.YESTERDAY, 0);
      }
      TODAY() {
        return this.tryGetToken(ApexParser2.TODAY, 0);
      }
      TOMORROW() {
        return this.tryGetToken(ApexParser2.TOMORROW, 0);
      }
      LAST_WEEK() {
        return this.tryGetToken(ApexParser2.LAST_WEEK, 0);
      }
      THIS_WEEK() {
        return this.tryGetToken(ApexParser2.THIS_WEEK, 0);
      }
      NEXT_WEEK() {
        return this.tryGetToken(ApexParser2.NEXT_WEEK, 0);
      }
      LAST_MONTH() {
        return this.tryGetToken(ApexParser2.LAST_MONTH, 0);
      }
      THIS_MONTH() {
        return this.tryGetToken(ApexParser2.THIS_MONTH, 0);
      }
      NEXT_MONTH() {
        return this.tryGetToken(ApexParser2.NEXT_MONTH, 0);
      }
      LAST_90_DAYS() {
        return this.tryGetToken(ApexParser2.LAST_90_DAYS, 0);
      }
      NEXT_90_DAYS() {
        return this.tryGetToken(ApexParser2.NEXT_90_DAYS, 0);
      }
      LAST_N_DAYS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_DAYS_N, 0);
      }
      COLON() {
        return this.tryGetToken(ApexParser2.COLON, 0);
      }
      signedInteger() {
        return this.tryGetRuleContext(0, SignedIntegerContext);
      }
      NEXT_N_DAYS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_DAYS_N, 0);
      }
      N_DAYS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_DAYS_AGO_N, 0);
      }
      NEXT_N_WEEKS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_WEEKS_N, 0);
      }
      LAST_N_WEEKS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_WEEKS_N, 0);
      }
      N_WEEKS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_WEEKS_AGO_N, 0);
      }
      NEXT_N_MONTHS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_MONTHS_N, 0);
      }
      LAST_N_MONTHS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_MONTHS_N, 0);
      }
      N_MONTHS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_MONTHS_AGO_N, 0);
      }
      THIS_QUARTER() {
        return this.tryGetToken(ApexParser2.THIS_QUARTER, 0);
      }
      LAST_QUARTER() {
        return this.tryGetToken(ApexParser2.LAST_QUARTER, 0);
      }
      NEXT_QUARTER() {
        return this.tryGetToken(ApexParser2.NEXT_QUARTER, 0);
      }
      NEXT_N_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_QUARTERS_N, 0);
      }
      LAST_N_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_QUARTERS_N, 0);
      }
      N_QUARTERS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_QUARTERS_AGO_N, 0);
      }
      THIS_YEAR() {
        return this.tryGetToken(ApexParser2.THIS_YEAR, 0);
      }
      LAST_YEAR() {
        return this.tryGetToken(ApexParser2.LAST_YEAR, 0);
      }
      NEXT_YEAR() {
        return this.tryGetToken(ApexParser2.NEXT_YEAR, 0);
      }
      NEXT_N_YEARS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_YEARS_N, 0);
      }
      LAST_N_YEARS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_YEARS_N, 0);
      }
      N_YEARS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_YEARS_AGO_N, 0);
      }
      THIS_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.THIS_FISCAL_QUARTER, 0);
      }
      LAST_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.LAST_FISCAL_QUARTER, 0);
      }
      NEXT_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.NEXT_FISCAL_QUARTER, 0);
      }
      NEXT_N_FISCAL_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_FISCAL_QUARTERS_N, 0);
      }
      LAST_N_FISCAL_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_FISCAL_QUARTERS_N, 0);
      }
      N_FISCAL_QUARTERS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_FISCAL_QUARTERS_AGO_N, 0);
      }
      THIS_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.THIS_FISCAL_YEAR, 0);
      }
      LAST_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.LAST_FISCAL_YEAR, 0);
      }
      NEXT_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.NEXT_FISCAL_YEAR, 0);
      }
      NEXT_N_FISCAL_YEARS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_FISCAL_YEARS_N, 0);
      }
      LAST_N_FISCAL_YEARS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_FISCAL_YEARS_N, 0);
      }
      N_FISCAL_YEARS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_FISCAL_YEARS_AGO_N, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_dateFormula;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterDateFormula) {
          listener.enterDateFormula(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitDateFormula) {
          listener.exitDateFormula(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitDateFormula) {
          return visitor.visitDateFormula(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.DateFormulaContext = DateFormulaContext;
    var SignedIntegerContext = class extends ParserRuleContext_1.ParserRuleContext {
      IntegerLiteral() {
        return this.getToken(ApexParser2.IntegerLiteral, 0);
      }
      ADD() {
        return this.tryGetToken(ApexParser2.ADD, 0);
      }
      SUB() {
        return this.tryGetToken(ApexParser2.SUB, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_signedInteger;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSignedInteger) {
          listener.enterSignedInteger(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSignedInteger) {
          listener.exitSignedInteger(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSignedInteger) {
          return visitor.visitSignedInteger(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SignedIntegerContext = SignedIntegerContext;
    var SoqlIdContext = class extends ParserRuleContext_1.ParserRuleContext {
      id() {
        return this.getRuleContext(0, IdContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soqlId;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoqlId) {
          listener.enterSoqlId(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoqlId) {
          listener.exitSoqlId(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoqlId) {
          return visitor.visitSoqlId(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoqlIdContext = SoqlIdContext;
    var SoslLiteralContext = class extends ParserRuleContext_1.ParserRuleContext {
      FindLiteral() {
        return this.tryGetToken(ApexParser2.FindLiteral, 0);
      }
      soslClauses() {
        return this.getRuleContext(0, SoslClausesContext);
      }
      RBRACK() {
        return this.getToken(ApexParser2.RBRACK, 0);
      }
      LBRACK() {
        return this.tryGetToken(ApexParser2.LBRACK, 0);
      }
      FIND() {
        return this.tryGetToken(ApexParser2.FIND, 0);
      }
      boundExpression() {
        return this.tryGetRuleContext(0, BoundExpressionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soslLiteral;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoslLiteral) {
          listener.enterSoslLiteral(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoslLiteral) {
          listener.exitSoslLiteral(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoslLiteral) {
          return visitor.visitSoslLiteral(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoslLiteralContext = SoslLiteralContext;
    var SoslLiteralAltContext = class extends ParserRuleContext_1.ParserRuleContext {
      FindLiteralAlt() {
        return this.getToken(ApexParser2.FindLiteralAlt, 0);
      }
      soslClauses() {
        return this.getRuleContext(0, SoslClausesContext);
      }
      RBRACK() {
        return this.getToken(ApexParser2.RBRACK, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soslLiteralAlt;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoslLiteralAlt) {
          listener.enterSoslLiteralAlt(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoslLiteralAlt) {
          listener.exitSoslLiteralAlt(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoslLiteralAlt) {
          return visitor.visitSoslLiteralAlt(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoslLiteralAltContext = SoslLiteralAltContext;
    var SoslClausesContext = class extends ParserRuleContext_1.ParserRuleContext {
      IN() {
        return this.tryGetToken(ApexParser2.IN, 0);
      }
      searchGroup() {
        return this.tryGetRuleContext(0, SearchGroupContext);
      }
      RETURNING() {
        return this.tryGetToken(ApexParser2.RETURNING, 0);
      }
      fieldSpecList() {
        return this.tryGetRuleContext(0, FieldSpecListContext);
      }
      soslWithClause(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SoslWithClauseContext);
        } else {
          return this.getRuleContext(i2, SoslWithClauseContext);
        }
      }
      limitClause() {
        return this.tryGetRuleContext(0, LimitClauseContext);
      }
      UPDATE() {
        return this.tryGetToken(ApexParser2.UPDATE, 0);
      }
      updateList() {
        return this.tryGetRuleContext(0, UpdateListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soslClauses;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoslClauses) {
          listener.enterSoslClauses(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoslClauses) {
          listener.exitSoslClauses(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoslClauses) {
          return visitor.visitSoslClauses(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoslClausesContext = SoslClausesContext;
    var SoslWithClauseContext = class extends ParserRuleContext_1.ParserRuleContext {
      WITH() {
        return this.getToken(ApexParser2.WITH, 0);
      }
      DIVISION() {
        return this.tryGetToken(ApexParser2.DIVISION, 0);
      }
      ASSIGN() {
        return this.tryGetToken(ApexParser2.ASSIGN, 0);
      }
      StringLiteral() {
        return this.tryGetToken(ApexParser2.StringLiteral, 0);
      }
      DATA() {
        return this.tryGetToken(ApexParser2.DATA, 0);
      }
      CATEGORY() {
        return this.tryGetToken(ApexParser2.CATEGORY, 0);
      }
      filteringExpression() {
        return this.tryGetRuleContext(0, FilteringExpressionContext);
      }
      SNIPPET() {
        return this.tryGetToken(ApexParser2.SNIPPET, 0);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      TARGET_LENGTH() {
        return this.tryGetToken(ApexParser2.TARGET_LENGTH, 0);
      }
      IntegerLiteral() {
        return this.tryGetToken(ApexParser2.IntegerLiteral, 0);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      NETWORK() {
        return this.tryGetToken(ApexParser2.NETWORK, 0);
      }
      IN() {
        return this.tryGetToken(ApexParser2.IN, 0);
      }
      networkList() {
        return this.tryGetRuleContext(0, NetworkListContext);
      }
      PRICEBOOKID() {
        return this.tryGetToken(ApexParser2.PRICEBOOKID, 0);
      }
      METADATA() {
        return this.tryGetToken(ApexParser2.METADATA, 0);
      }
      USER_MODE() {
        return this.tryGetToken(ApexParser2.USER_MODE, 0);
      }
      SYSTEM_MODE() {
        return this.tryGetToken(ApexParser2.SYSTEM_MODE, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soslWithClause;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoslWithClause) {
          listener.enterSoslWithClause(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoslWithClause) {
          listener.exitSoslWithClause(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoslWithClause) {
          return visitor.visitSoslWithClause(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoslWithClauseContext = SoslWithClauseContext;
    var SearchGroupContext = class extends ParserRuleContext_1.ParserRuleContext {
      FIELDS() {
        return this.getToken(ApexParser2.FIELDS, 0);
      }
      ALL() {
        return this.tryGetToken(ApexParser2.ALL, 0);
      }
      EMAIL() {
        return this.tryGetToken(ApexParser2.EMAIL, 0);
      }
      NAME() {
        return this.tryGetToken(ApexParser2.NAME, 0);
      }
      PHONE() {
        return this.tryGetToken(ApexParser2.PHONE, 0);
      }
      SIDEBAR() {
        return this.tryGetToken(ApexParser2.SIDEBAR, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_searchGroup;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSearchGroup) {
          listener.enterSearchGroup(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSearchGroup) {
          listener.exitSearchGroup(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSearchGroup) {
          return visitor.visitSearchGroup(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SearchGroupContext = SearchGroupContext;
    var FieldSpecListContext = class _FieldSpecListContext extends ParserRuleContext_1.ParserRuleContext {
      fieldSpec() {
        return this.getRuleContext(0, FieldSpecContext);
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      fieldSpecList(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(_FieldSpecListContext);
        } else {
          return this.getRuleContext(i2, _FieldSpecListContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldSpecList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldSpecList) {
          listener.enterFieldSpecList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldSpecList) {
          listener.exitFieldSpecList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldSpecList) {
          return visitor.visitFieldSpecList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldSpecListContext = FieldSpecListContext;
    var FieldSpecContext = class extends ParserRuleContext_1.ParserRuleContext {
      soslId(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SoslIdContext);
        } else {
          return this.getRuleContext(i2, SoslIdContext);
        }
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      fieldList() {
        return this.tryGetRuleContext(0, FieldListContext);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      WHERE() {
        return this.tryGetToken(ApexParser2.WHERE, 0);
      }
      logicalExpression() {
        return this.tryGetRuleContext(0, LogicalExpressionContext);
      }
      USING() {
        return this.tryGetToken(ApexParser2.USING, 0);
      }
      LISTVIEW() {
        return this.tryGetToken(ApexParser2.LISTVIEW, 0);
      }
      ASSIGN() {
        return this.tryGetToken(ApexParser2.ASSIGN, 0);
      }
      ORDER() {
        return this.tryGetToken(ApexParser2.ORDER, 0);
      }
      BY() {
        return this.tryGetToken(ApexParser2.BY, 0);
      }
      fieldOrderList() {
        return this.tryGetRuleContext(0, FieldOrderListContext);
      }
      limitClause() {
        return this.tryGetRuleContext(0, LimitClauseContext);
      }
      offsetClause() {
        return this.tryGetRuleContext(0, OffsetClauseContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldSpec;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldSpec) {
          listener.enterFieldSpec(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldSpec) {
          listener.exitFieldSpec(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldSpec) {
          return visitor.visitFieldSpec(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldSpecContext = FieldSpecContext;
    var FieldListContext = class _FieldListContext extends ParserRuleContext_1.ParserRuleContext {
      soslId(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(SoslIdContext);
        } else {
          return this.getRuleContext(i2, SoslIdContext);
        }
      }
      COMMA(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.COMMA);
        } else {
          return this.getToken(ApexParser2.COMMA, i2);
        }
      }
      fieldList(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(_FieldListContext);
        } else {
          return this.getRuleContext(i2, _FieldListContext);
        }
      }
      TOLABEL() {
        return this.tryGetToken(ApexParser2.TOLABEL, 0);
      }
      LPAREN() {
        return this.tryGetToken(ApexParser2.LPAREN, 0);
      }
      RPAREN() {
        return this.tryGetToken(ApexParser2.RPAREN, 0);
      }
      CONVERT_CURRENCY() {
        return this.tryGetToken(ApexParser2.CONVERT_CURRENCY, 0);
      }
      FORMAT() {
        return this.tryGetToken(ApexParser2.FORMAT, 0);
      }
      soqlFunction() {
        return this.tryGetRuleContext(0, SoqlFunctionContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_fieldList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterFieldList) {
          listener.enterFieldList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitFieldList) {
          listener.exitFieldList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitFieldList) {
          return visitor.visitFieldList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.FieldListContext = FieldListContext;
    var UpdateListContext = class _UpdateListContext extends ParserRuleContext_1.ParserRuleContext {
      updateType() {
        return this.getRuleContext(0, UpdateTypeContext);
      }
      COMMA() {
        return this.tryGetToken(ApexParser2.COMMA, 0);
      }
      updateList() {
        return this.tryGetRuleContext(0, _UpdateListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_updateList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterUpdateList) {
          listener.enterUpdateList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitUpdateList) {
          listener.exitUpdateList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitUpdateList) {
          return visitor.visitUpdateList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.UpdateListContext = UpdateListContext;
    var UpdateTypeContext = class extends ParserRuleContext_1.ParserRuleContext {
      TRACKING() {
        return this.tryGetToken(ApexParser2.TRACKING, 0);
      }
      VIEWSTAT() {
        return this.tryGetToken(ApexParser2.VIEWSTAT, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_updateType;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterUpdateType) {
          listener.enterUpdateType(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitUpdateType) {
          listener.exitUpdateType(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitUpdateType) {
          return visitor.visitUpdateType(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.UpdateTypeContext = UpdateTypeContext;
    var NetworkListContext = class _NetworkListContext extends ParserRuleContext_1.ParserRuleContext {
      StringLiteral() {
        return this.getToken(ApexParser2.StringLiteral, 0);
      }
      COMMA() {
        return this.tryGetToken(ApexParser2.COMMA, 0);
      }
      networkList() {
        return this.tryGetRuleContext(0, _NetworkListContext);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_networkList;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterNetworkList) {
          listener.enterNetworkList(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitNetworkList) {
          listener.exitNetworkList(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitNetworkList) {
          return visitor.visitNetworkList(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.NetworkListContext = NetworkListContext;
    var SoslIdContext = class _SoslIdContext extends ParserRuleContext_1.ParserRuleContext {
      id() {
        return this.getRuleContext(0, IdContext);
      }
      DOT(i2) {
        if (i2 === void 0) {
          return this.getTokens(ApexParser2.DOT);
        } else {
          return this.getToken(ApexParser2.DOT, i2);
        }
      }
      soslId(i2) {
        if (i2 === void 0) {
          return this.getRuleContexts(_SoslIdContext);
        } else {
          return this.getRuleContext(i2, _SoslIdContext);
        }
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_soslId;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterSoslId) {
          listener.enterSoslId(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitSoslId) {
          listener.exitSoslId(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitSoslId) {
          return visitor.visitSoslId(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.SoslIdContext = SoslIdContext;
    var IdContext = class extends ParserRuleContext_1.ParserRuleContext {
      Identifier() {
        return this.tryGetToken(ApexParser2.Identifier, 0);
      }
      AFTER() {
        return this.tryGetToken(ApexParser2.AFTER, 0);
      }
      BEFORE() {
        return this.tryGetToken(ApexParser2.BEFORE, 0);
      }
      GET() {
        return this.tryGetToken(ApexParser2.GET, 0);
      }
      INHERITED() {
        return this.tryGetToken(ApexParser2.INHERITED, 0);
      }
      INSTANCEOF() {
        return this.tryGetToken(ApexParser2.INSTANCEOF, 0);
      }
      SET() {
        return this.tryGetToken(ApexParser2.SET, 0);
      }
      SHARING() {
        return this.tryGetToken(ApexParser2.SHARING, 0);
      }
      SWITCH() {
        return this.tryGetToken(ApexParser2.SWITCH, 0);
      }
      TRANSIENT() {
        return this.tryGetToken(ApexParser2.TRANSIENT, 0);
      }
      TRIGGER() {
        return this.tryGetToken(ApexParser2.TRIGGER, 0);
      }
      WHEN() {
        return this.tryGetToken(ApexParser2.WHEN, 0);
      }
      WITH() {
        return this.tryGetToken(ApexParser2.WITH, 0);
      }
      WITHOUT() {
        return this.tryGetToken(ApexParser2.WITHOUT, 0);
      }
      USER() {
        return this.tryGetToken(ApexParser2.USER, 0);
      }
      SYSTEM() {
        return this.tryGetToken(ApexParser2.SYSTEM, 0);
      }
      IntegralCurrencyLiteral() {
        return this.tryGetToken(ApexParser2.IntegralCurrencyLiteral, 0);
      }
      SELECT() {
        return this.tryGetToken(ApexParser2.SELECT, 0);
      }
      COUNT() {
        return this.tryGetToken(ApexParser2.COUNT, 0);
      }
      FROM() {
        return this.tryGetToken(ApexParser2.FROM, 0);
      }
      AS() {
        return this.tryGetToken(ApexParser2.AS, 0);
      }
      USING() {
        return this.tryGetToken(ApexParser2.USING, 0);
      }
      SCOPE() {
        return this.tryGetToken(ApexParser2.SCOPE, 0);
      }
      WHERE() {
        return this.tryGetToken(ApexParser2.WHERE, 0);
      }
      ORDER() {
        return this.tryGetToken(ApexParser2.ORDER, 0);
      }
      BY() {
        return this.tryGetToken(ApexParser2.BY, 0);
      }
      LIMIT() {
        return this.tryGetToken(ApexParser2.LIMIT, 0);
      }
      SOQLAND() {
        return this.tryGetToken(ApexParser2.SOQLAND, 0);
      }
      SOQLOR() {
        return this.tryGetToken(ApexParser2.SOQLOR, 0);
      }
      NOT() {
        return this.tryGetToken(ApexParser2.NOT, 0);
      }
      AVG() {
        return this.tryGetToken(ApexParser2.AVG, 0);
      }
      COUNT_DISTINCT() {
        return this.tryGetToken(ApexParser2.COUNT_DISTINCT, 0);
      }
      MIN() {
        return this.tryGetToken(ApexParser2.MIN, 0);
      }
      MAX() {
        return this.tryGetToken(ApexParser2.MAX, 0);
      }
      SUM() {
        return this.tryGetToken(ApexParser2.SUM, 0);
      }
      TYPEOF() {
        return this.tryGetToken(ApexParser2.TYPEOF, 0);
      }
      END() {
        return this.tryGetToken(ApexParser2.END, 0);
      }
      THEN() {
        return this.tryGetToken(ApexParser2.THEN, 0);
      }
      LIKE() {
        return this.tryGetToken(ApexParser2.LIKE, 0);
      }
      IN() {
        return this.tryGetToken(ApexParser2.IN, 0);
      }
      INCLUDES() {
        return this.tryGetToken(ApexParser2.INCLUDES, 0);
      }
      EXCLUDES() {
        return this.tryGetToken(ApexParser2.EXCLUDES, 0);
      }
      ASC() {
        return this.tryGetToken(ApexParser2.ASC, 0);
      }
      DESC() {
        return this.tryGetToken(ApexParser2.DESC, 0);
      }
      NULLS() {
        return this.tryGetToken(ApexParser2.NULLS, 0);
      }
      FIRST() {
        return this.tryGetToken(ApexParser2.FIRST, 0);
      }
      LAST() {
        return this.tryGetToken(ApexParser2.LAST, 0);
      }
      GROUP() {
        return this.tryGetToken(ApexParser2.GROUP, 0);
      }
      ALL() {
        return this.tryGetToken(ApexParser2.ALL, 0);
      }
      ROWS() {
        return this.tryGetToken(ApexParser2.ROWS, 0);
      }
      VIEW() {
        return this.tryGetToken(ApexParser2.VIEW, 0);
      }
      HAVING() {
        return this.tryGetToken(ApexParser2.HAVING, 0);
      }
      ROLLUP() {
        return this.tryGetToken(ApexParser2.ROLLUP, 0);
      }
      TOLABEL() {
        return this.tryGetToken(ApexParser2.TOLABEL, 0);
      }
      OFFSET() {
        return this.tryGetToken(ApexParser2.OFFSET, 0);
      }
      DATA() {
        return this.tryGetToken(ApexParser2.DATA, 0);
      }
      CATEGORY() {
        return this.tryGetToken(ApexParser2.CATEGORY, 0);
      }
      AT() {
        return this.tryGetToken(ApexParser2.AT, 0);
      }
      ABOVE() {
        return this.tryGetToken(ApexParser2.ABOVE, 0);
      }
      BELOW() {
        return this.tryGetToken(ApexParser2.BELOW, 0);
      }
      ABOVE_OR_BELOW() {
        return this.tryGetToken(ApexParser2.ABOVE_OR_BELOW, 0);
      }
      SECURITY_ENFORCED() {
        return this.tryGetToken(ApexParser2.SECURITY_ENFORCED, 0);
      }
      USER_MODE() {
        return this.tryGetToken(ApexParser2.USER_MODE, 0);
      }
      SYSTEM_MODE() {
        return this.tryGetToken(ApexParser2.SYSTEM_MODE, 0);
      }
      REFERENCE() {
        return this.tryGetToken(ApexParser2.REFERENCE, 0);
      }
      CUBE() {
        return this.tryGetToken(ApexParser2.CUBE, 0);
      }
      FORMAT() {
        return this.tryGetToken(ApexParser2.FORMAT, 0);
      }
      TRACKING() {
        return this.tryGetToken(ApexParser2.TRACKING, 0);
      }
      VIEWSTAT() {
        return this.tryGetToken(ApexParser2.VIEWSTAT, 0);
      }
      STANDARD() {
        return this.tryGetToken(ApexParser2.STANDARD, 0);
      }
      CUSTOM() {
        return this.tryGetToken(ApexParser2.CUSTOM, 0);
      }
      DISTANCE() {
        return this.tryGetToken(ApexParser2.DISTANCE, 0);
      }
      GEOLOCATION() {
        return this.tryGetToken(ApexParser2.GEOLOCATION, 0);
      }
      GROUPING() {
        return this.tryGetToken(ApexParser2.GROUPING, 0);
      }
      CONVERT_CURRENCY() {
        return this.tryGetToken(ApexParser2.CONVERT_CURRENCY, 0);
      }
      CALENDAR_MONTH() {
        return this.tryGetToken(ApexParser2.CALENDAR_MONTH, 0);
      }
      CALENDAR_QUARTER() {
        return this.tryGetToken(ApexParser2.CALENDAR_QUARTER, 0);
      }
      CALENDAR_YEAR() {
        return this.tryGetToken(ApexParser2.CALENDAR_YEAR, 0);
      }
      DAY_IN_MONTH() {
        return this.tryGetToken(ApexParser2.DAY_IN_MONTH, 0);
      }
      DAY_IN_WEEK() {
        return this.tryGetToken(ApexParser2.DAY_IN_WEEK, 0);
      }
      DAY_IN_YEAR() {
        return this.tryGetToken(ApexParser2.DAY_IN_YEAR, 0);
      }
      DAY_ONLY() {
        return this.tryGetToken(ApexParser2.DAY_ONLY, 0);
      }
      FISCAL_MONTH() {
        return this.tryGetToken(ApexParser2.FISCAL_MONTH, 0);
      }
      FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.FISCAL_QUARTER, 0);
      }
      FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.FISCAL_YEAR, 0);
      }
      HOUR_IN_DAY() {
        return this.tryGetToken(ApexParser2.HOUR_IN_DAY, 0);
      }
      WEEK_IN_MONTH() {
        return this.tryGetToken(ApexParser2.WEEK_IN_MONTH, 0);
      }
      WEEK_IN_YEAR() {
        return this.tryGetToken(ApexParser2.WEEK_IN_YEAR, 0);
      }
      CONVERT_TIMEZONE() {
        return this.tryGetToken(ApexParser2.CONVERT_TIMEZONE, 0);
      }
      YESTERDAY() {
        return this.tryGetToken(ApexParser2.YESTERDAY, 0);
      }
      TODAY() {
        return this.tryGetToken(ApexParser2.TODAY, 0);
      }
      TOMORROW() {
        return this.tryGetToken(ApexParser2.TOMORROW, 0);
      }
      LAST_WEEK() {
        return this.tryGetToken(ApexParser2.LAST_WEEK, 0);
      }
      THIS_WEEK() {
        return this.tryGetToken(ApexParser2.THIS_WEEK, 0);
      }
      NEXT_WEEK() {
        return this.tryGetToken(ApexParser2.NEXT_WEEK, 0);
      }
      LAST_MONTH() {
        return this.tryGetToken(ApexParser2.LAST_MONTH, 0);
      }
      THIS_MONTH() {
        return this.tryGetToken(ApexParser2.THIS_MONTH, 0);
      }
      NEXT_MONTH() {
        return this.tryGetToken(ApexParser2.NEXT_MONTH, 0);
      }
      LAST_90_DAYS() {
        return this.tryGetToken(ApexParser2.LAST_90_DAYS, 0);
      }
      NEXT_90_DAYS() {
        return this.tryGetToken(ApexParser2.NEXT_90_DAYS, 0);
      }
      LAST_N_DAYS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_DAYS_N, 0);
      }
      NEXT_N_DAYS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_DAYS_N, 0);
      }
      N_DAYS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_DAYS_AGO_N, 0);
      }
      NEXT_N_WEEKS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_WEEKS_N, 0);
      }
      LAST_N_WEEKS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_WEEKS_N, 0);
      }
      N_WEEKS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_WEEKS_AGO_N, 0);
      }
      NEXT_N_MONTHS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_MONTHS_N, 0);
      }
      LAST_N_MONTHS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_MONTHS_N, 0);
      }
      N_MONTHS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_MONTHS_AGO_N, 0);
      }
      THIS_QUARTER() {
        return this.tryGetToken(ApexParser2.THIS_QUARTER, 0);
      }
      LAST_QUARTER() {
        return this.tryGetToken(ApexParser2.LAST_QUARTER, 0);
      }
      NEXT_QUARTER() {
        return this.tryGetToken(ApexParser2.NEXT_QUARTER, 0);
      }
      NEXT_N_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_QUARTERS_N, 0);
      }
      LAST_N_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_QUARTERS_N, 0);
      }
      N_QUARTERS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_QUARTERS_AGO_N, 0);
      }
      THIS_YEAR() {
        return this.tryGetToken(ApexParser2.THIS_YEAR, 0);
      }
      LAST_YEAR() {
        return this.tryGetToken(ApexParser2.LAST_YEAR, 0);
      }
      NEXT_YEAR() {
        return this.tryGetToken(ApexParser2.NEXT_YEAR, 0);
      }
      NEXT_N_YEARS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_YEARS_N, 0);
      }
      LAST_N_YEARS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_YEARS_N, 0);
      }
      N_YEARS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_YEARS_AGO_N, 0);
      }
      THIS_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.THIS_FISCAL_QUARTER, 0);
      }
      LAST_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.LAST_FISCAL_QUARTER, 0);
      }
      NEXT_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.NEXT_FISCAL_QUARTER, 0);
      }
      NEXT_N_FISCAL_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_FISCAL_QUARTERS_N, 0);
      }
      LAST_N_FISCAL_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_FISCAL_QUARTERS_N, 0);
      }
      N_FISCAL_QUARTERS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_FISCAL_QUARTERS_AGO_N, 0);
      }
      THIS_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.THIS_FISCAL_YEAR, 0);
      }
      LAST_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.LAST_FISCAL_YEAR, 0);
      }
      NEXT_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.NEXT_FISCAL_YEAR, 0);
      }
      NEXT_N_FISCAL_YEARS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_FISCAL_YEARS_N, 0);
      }
      LAST_N_FISCAL_YEARS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_FISCAL_YEARS_N, 0);
      }
      N_FISCAL_YEARS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_FISCAL_YEARS_AGO_N, 0);
      }
      FIND() {
        return this.tryGetToken(ApexParser2.FIND, 0);
      }
      EMAIL() {
        return this.tryGetToken(ApexParser2.EMAIL, 0);
      }
      NAME() {
        return this.tryGetToken(ApexParser2.NAME, 0);
      }
      PHONE() {
        return this.tryGetToken(ApexParser2.PHONE, 0);
      }
      SIDEBAR() {
        return this.tryGetToken(ApexParser2.SIDEBAR, 0);
      }
      FIELDS() {
        return this.tryGetToken(ApexParser2.FIELDS, 0);
      }
      METADATA() {
        return this.tryGetToken(ApexParser2.METADATA, 0);
      }
      PRICEBOOKID() {
        return this.tryGetToken(ApexParser2.PRICEBOOKID, 0);
      }
      NETWORK() {
        return this.tryGetToken(ApexParser2.NETWORK, 0);
      }
      SNIPPET() {
        return this.tryGetToken(ApexParser2.SNIPPET, 0);
      }
      TARGET_LENGTH() {
        return this.tryGetToken(ApexParser2.TARGET_LENGTH, 0);
      }
      DIVISION() {
        return this.tryGetToken(ApexParser2.DIVISION, 0);
      }
      RETURNING() {
        return this.tryGetToken(ApexParser2.RETURNING, 0);
      }
      LISTVIEW() {
        return this.tryGetToken(ApexParser2.LISTVIEW, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_id;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterId) {
          listener.enterId(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitId) {
          listener.exitId(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitId) {
          return visitor.visitId(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.IdContext = IdContext;
    var AnyIdContext = class extends ParserRuleContext_1.ParserRuleContext {
      Identifier() {
        return this.tryGetToken(ApexParser2.Identifier, 0);
      }
      ABSTRACT() {
        return this.tryGetToken(ApexParser2.ABSTRACT, 0);
      }
      AFTER() {
        return this.tryGetToken(ApexParser2.AFTER, 0);
      }
      BEFORE() {
        return this.tryGetToken(ApexParser2.BEFORE, 0);
      }
      BREAK() {
        return this.tryGetToken(ApexParser2.BREAK, 0);
      }
      CATCH() {
        return this.tryGetToken(ApexParser2.CATCH, 0);
      }
      CLASS() {
        return this.tryGetToken(ApexParser2.CLASS, 0);
      }
      CONTINUE() {
        return this.tryGetToken(ApexParser2.CONTINUE, 0);
      }
      DELETE() {
        return this.tryGetToken(ApexParser2.DELETE, 0);
      }
      DO() {
        return this.tryGetToken(ApexParser2.DO, 0);
      }
      ELSE() {
        return this.tryGetToken(ApexParser2.ELSE, 0);
      }
      ENUM() {
        return this.tryGetToken(ApexParser2.ENUM, 0);
      }
      EXTENDS() {
        return this.tryGetToken(ApexParser2.EXTENDS, 0);
      }
      FINAL() {
        return this.tryGetToken(ApexParser2.FINAL, 0);
      }
      FINALLY() {
        return this.tryGetToken(ApexParser2.FINALLY, 0);
      }
      FOR() {
        return this.tryGetToken(ApexParser2.FOR, 0);
      }
      GET() {
        return this.tryGetToken(ApexParser2.GET, 0);
      }
      GLOBAL() {
        return this.tryGetToken(ApexParser2.GLOBAL, 0);
      }
      IF() {
        return this.tryGetToken(ApexParser2.IF, 0);
      }
      IMPLEMENTS() {
        return this.tryGetToken(ApexParser2.IMPLEMENTS, 0);
      }
      INHERITED() {
        return this.tryGetToken(ApexParser2.INHERITED, 0);
      }
      INSERT() {
        return this.tryGetToken(ApexParser2.INSERT, 0);
      }
      INSTANCEOF() {
        return this.tryGetToken(ApexParser2.INSTANCEOF, 0);
      }
      INTERFACE() {
        return this.tryGetToken(ApexParser2.INTERFACE, 0);
      }
      LIST() {
        return this.tryGetToken(ApexParser2.LIST, 0);
      }
      MAP() {
        return this.tryGetToken(ApexParser2.MAP, 0);
      }
      MERGE() {
        return this.tryGetToken(ApexParser2.MERGE, 0);
      }
      NEW() {
        return this.tryGetToken(ApexParser2.NEW, 0);
      }
      NULL() {
        return this.tryGetToken(ApexParser2.NULL, 0);
      }
      ON() {
        return this.tryGetToken(ApexParser2.ON, 0);
      }
      OVERRIDE() {
        return this.tryGetToken(ApexParser2.OVERRIDE, 0);
      }
      PRIVATE() {
        return this.tryGetToken(ApexParser2.PRIVATE, 0);
      }
      PROTECTED() {
        return this.tryGetToken(ApexParser2.PROTECTED, 0);
      }
      PUBLIC() {
        return this.tryGetToken(ApexParser2.PUBLIC, 0);
      }
      RETURN() {
        return this.tryGetToken(ApexParser2.RETURN, 0);
      }
      SET() {
        return this.tryGetToken(ApexParser2.SET, 0);
      }
      SHARING() {
        return this.tryGetToken(ApexParser2.SHARING, 0);
      }
      STATIC() {
        return this.tryGetToken(ApexParser2.STATIC, 0);
      }
      SUPER() {
        return this.tryGetToken(ApexParser2.SUPER, 0);
      }
      SWITCH() {
        return this.tryGetToken(ApexParser2.SWITCH, 0);
      }
      TESTMETHOD() {
        return this.tryGetToken(ApexParser2.TESTMETHOD, 0);
      }
      THIS() {
        return this.tryGetToken(ApexParser2.THIS, 0);
      }
      THROW() {
        return this.tryGetToken(ApexParser2.THROW, 0);
      }
      TRANSIENT() {
        return this.tryGetToken(ApexParser2.TRANSIENT, 0);
      }
      TRIGGER() {
        return this.tryGetToken(ApexParser2.TRIGGER, 0);
      }
      TRY() {
        return this.tryGetToken(ApexParser2.TRY, 0);
      }
      UNDELETE() {
        return this.tryGetToken(ApexParser2.UNDELETE, 0);
      }
      UPDATE() {
        return this.tryGetToken(ApexParser2.UPDATE, 0);
      }
      UPSERT() {
        return this.tryGetToken(ApexParser2.UPSERT, 0);
      }
      VIRTUAL() {
        return this.tryGetToken(ApexParser2.VIRTUAL, 0);
      }
      WEBSERVICE() {
        return this.tryGetToken(ApexParser2.WEBSERVICE, 0);
      }
      WHEN() {
        return this.tryGetToken(ApexParser2.WHEN, 0);
      }
      WHILE() {
        return this.tryGetToken(ApexParser2.WHILE, 0);
      }
      WITH() {
        return this.tryGetToken(ApexParser2.WITH, 0);
      }
      WITHOUT() {
        return this.tryGetToken(ApexParser2.WITHOUT, 0);
      }
      USER() {
        return this.tryGetToken(ApexParser2.USER, 0);
      }
      SYSTEM() {
        return this.tryGetToken(ApexParser2.SYSTEM, 0);
      }
      IntegralCurrencyLiteral() {
        return this.tryGetToken(ApexParser2.IntegralCurrencyLiteral, 0);
      }
      SELECT() {
        return this.tryGetToken(ApexParser2.SELECT, 0);
      }
      COUNT() {
        return this.tryGetToken(ApexParser2.COUNT, 0);
      }
      FROM() {
        return this.tryGetToken(ApexParser2.FROM, 0);
      }
      AS() {
        return this.tryGetToken(ApexParser2.AS, 0);
      }
      USING() {
        return this.tryGetToken(ApexParser2.USING, 0);
      }
      SCOPE() {
        return this.tryGetToken(ApexParser2.SCOPE, 0);
      }
      WHERE() {
        return this.tryGetToken(ApexParser2.WHERE, 0);
      }
      ORDER() {
        return this.tryGetToken(ApexParser2.ORDER, 0);
      }
      BY() {
        return this.tryGetToken(ApexParser2.BY, 0);
      }
      LIMIT() {
        return this.tryGetToken(ApexParser2.LIMIT, 0);
      }
      SOQLAND() {
        return this.tryGetToken(ApexParser2.SOQLAND, 0);
      }
      SOQLOR() {
        return this.tryGetToken(ApexParser2.SOQLOR, 0);
      }
      NOT() {
        return this.tryGetToken(ApexParser2.NOT, 0);
      }
      AVG() {
        return this.tryGetToken(ApexParser2.AVG, 0);
      }
      COUNT_DISTINCT() {
        return this.tryGetToken(ApexParser2.COUNT_DISTINCT, 0);
      }
      MIN() {
        return this.tryGetToken(ApexParser2.MIN, 0);
      }
      MAX() {
        return this.tryGetToken(ApexParser2.MAX, 0);
      }
      SUM() {
        return this.tryGetToken(ApexParser2.SUM, 0);
      }
      TYPEOF() {
        return this.tryGetToken(ApexParser2.TYPEOF, 0);
      }
      END() {
        return this.tryGetToken(ApexParser2.END, 0);
      }
      THEN() {
        return this.tryGetToken(ApexParser2.THEN, 0);
      }
      LIKE() {
        return this.tryGetToken(ApexParser2.LIKE, 0);
      }
      IN() {
        return this.tryGetToken(ApexParser2.IN, 0);
      }
      INCLUDES() {
        return this.tryGetToken(ApexParser2.INCLUDES, 0);
      }
      EXCLUDES() {
        return this.tryGetToken(ApexParser2.EXCLUDES, 0);
      }
      ASC() {
        return this.tryGetToken(ApexParser2.ASC, 0);
      }
      DESC() {
        return this.tryGetToken(ApexParser2.DESC, 0);
      }
      NULLS() {
        return this.tryGetToken(ApexParser2.NULLS, 0);
      }
      FIRST() {
        return this.tryGetToken(ApexParser2.FIRST, 0);
      }
      LAST() {
        return this.tryGetToken(ApexParser2.LAST, 0);
      }
      GROUP() {
        return this.tryGetToken(ApexParser2.GROUP, 0);
      }
      ALL() {
        return this.tryGetToken(ApexParser2.ALL, 0);
      }
      ROWS() {
        return this.tryGetToken(ApexParser2.ROWS, 0);
      }
      VIEW() {
        return this.tryGetToken(ApexParser2.VIEW, 0);
      }
      HAVING() {
        return this.tryGetToken(ApexParser2.HAVING, 0);
      }
      ROLLUP() {
        return this.tryGetToken(ApexParser2.ROLLUP, 0);
      }
      TOLABEL() {
        return this.tryGetToken(ApexParser2.TOLABEL, 0);
      }
      OFFSET() {
        return this.tryGetToken(ApexParser2.OFFSET, 0);
      }
      DATA() {
        return this.tryGetToken(ApexParser2.DATA, 0);
      }
      CATEGORY() {
        return this.tryGetToken(ApexParser2.CATEGORY, 0);
      }
      AT() {
        return this.tryGetToken(ApexParser2.AT, 0);
      }
      ABOVE() {
        return this.tryGetToken(ApexParser2.ABOVE, 0);
      }
      BELOW() {
        return this.tryGetToken(ApexParser2.BELOW, 0);
      }
      ABOVE_OR_BELOW() {
        return this.tryGetToken(ApexParser2.ABOVE_OR_BELOW, 0);
      }
      SECURITY_ENFORCED() {
        return this.tryGetToken(ApexParser2.SECURITY_ENFORCED, 0);
      }
      SYSTEM_MODE() {
        return this.tryGetToken(ApexParser2.SYSTEM_MODE, 0);
      }
      USER_MODE() {
        return this.tryGetToken(ApexParser2.USER_MODE, 0);
      }
      REFERENCE() {
        return this.tryGetToken(ApexParser2.REFERENCE, 0);
      }
      CUBE() {
        return this.tryGetToken(ApexParser2.CUBE, 0);
      }
      FORMAT() {
        return this.tryGetToken(ApexParser2.FORMAT, 0);
      }
      TRACKING() {
        return this.tryGetToken(ApexParser2.TRACKING, 0);
      }
      VIEWSTAT() {
        return this.tryGetToken(ApexParser2.VIEWSTAT, 0);
      }
      STANDARD() {
        return this.tryGetToken(ApexParser2.STANDARD, 0);
      }
      CUSTOM() {
        return this.tryGetToken(ApexParser2.CUSTOM, 0);
      }
      DISTANCE() {
        return this.tryGetToken(ApexParser2.DISTANCE, 0);
      }
      GEOLOCATION() {
        return this.tryGetToken(ApexParser2.GEOLOCATION, 0);
      }
      GROUPING() {
        return this.tryGetToken(ApexParser2.GROUPING, 0);
      }
      CONVERT_CURRENCY() {
        return this.tryGetToken(ApexParser2.CONVERT_CURRENCY, 0);
      }
      CALENDAR_MONTH() {
        return this.tryGetToken(ApexParser2.CALENDAR_MONTH, 0);
      }
      CALENDAR_QUARTER() {
        return this.tryGetToken(ApexParser2.CALENDAR_QUARTER, 0);
      }
      CALENDAR_YEAR() {
        return this.tryGetToken(ApexParser2.CALENDAR_YEAR, 0);
      }
      DAY_IN_MONTH() {
        return this.tryGetToken(ApexParser2.DAY_IN_MONTH, 0);
      }
      DAY_IN_WEEK() {
        return this.tryGetToken(ApexParser2.DAY_IN_WEEK, 0);
      }
      DAY_IN_YEAR() {
        return this.tryGetToken(ApexParser2.DAY_IN_YEAR, 0);
      }
      DAY_ONLY() {
        return this.tryGetToken(ApexParser2.DAY_ONLY, 0);
      }
      FISCAL_MONTH() {
        return this.tryGetToken(ApexParser2.FISCAL_MONTH, 0);
      }
      FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.FISCAL_QUARTER, 0);
      }
      FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.FISCAL_YEAR, 0);
      }
      HOUR_IN_DAY() {
        return this.tryGetToken(ApexParser2.HOUR_IN_DAY, 0);
      }
      WEEK_IN_MONTH() {
        return this.tryGetToken(ApexParser2.WEEK_IN_MONTH, 0);
      }
      WEEK_IN_YEAR() {
        return this.tryGetToken(ApexParser2.WEEK_IN_YEAR, 0);
      }
      CONVERT_TIMEZONE() {
        return this.tryGetToken(ApexParser2.CONVERT_TIMEZONE, 0);
      }
      YESTERDAY() {
        return this.tryGetToken(ApexParser2.YESTERDAY, 0);
      }
      TODAY() {
        return this.tryGetToken(ApexParser2.TODAY, 0);
      }
      TOMORROW() {
        return this.tryGetToken(ApexParser2.TOMORROW, 0);
      }
      LAST_WEEK() {
        return this.tryGetToken(ApexParser2.LAST_WEEK, 0);
      }
      THIS_WEEK() {
        return this.tryGetToken(ApexParser2.THIS_WEEK, 0);
      }
      NEXT_WEEK() {
        return this.tryGetToken(ApexParser2.NEXT_WEEK, 0);
      }
      LAST_MONTH() {
        return this.tryGetToken(ApexParser2.LAST_MONTH, 0);
      }
      THIS_MONTH() {
        return this.tryGetToken(ApexParser2.THIS_MONTH, 0);
      }
      NEXT_MONTH() {
        return this.tryGetToken(ApexParser2.NEXT_MONTH, 0);
      }
      LAST_90_DAYS() {
        return this.tryGetToken(ApexParser2.LAST_90_DAYS, 0);
      }
      NEXT_90_DAYS() {
        return this.tryGetToken(ApexParser2.NEXT_90_DAYS, 0);
      }
      LAST_N_DAYS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_DAYS_N, 0);
      }
      NEXT_N_DAYS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_DAYS_N, 0);
      }
      N_DAYS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_DAYS_AGO_N, 0);
      }
      NEXT_N_WEEKS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_WEEKS_N, 0);
      }
      LAST_N_WEEKS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_WEEKS_N, 0);
      }
      N_WEEKS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_WEEKS_AGO_N, 0);
      }
      NEXT_N_MONTHS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_MONTHS_N, 0);
      }
      LAST_N_MONTHS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_MONTHS_N, 0);
      }
      N_MONTHS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_MONTHS_AGO_N, 0);
      }
      THIS_QUARTER() {
        return this.tryGetToken(ApexParser2.THIS_QUARTER, 0);
      }
      LAST_QUARTER() {
        return this.tryGetToken(ApexParser2.LAST_QUARTER, 0);
      }
      NEXT_QUARTER() {
        return this.tryGetToken(ApexParser2.NEXT_QUARTER, 0);
      }
      NEXT_N_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_QUARTERS_N, 0);
      }
      LAST_N_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_QUARTERS_N, 0);
      }
      N_QUARTERS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_QUARTERS_AGO_N, 0);
      }
      THIS_YEAR() {
        return this.tryGetToken(ApexParser2.THIS_YEAR, 0);
      }
      LAST_YEAR() {
        return this.tryGetToken(ApexParser2.LAST_YEAR, 0);
      }
      NEXT_YEAR() {
        return this.tryGetToken(ApexParser2.NEXT_YEAR, 0);
      }
      NEXT_N_YEARS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_YEARS_N, 0);
      }
      LAST_N_YEARS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_YEARS_N, 0);
      }
      N_YEARS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_YEARS_AGO_N, 0);
      }
      THIS_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.THIS_FISCAL_QUARTER, 0);
      }
      LAST_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.LAST_FISCAL_QUARTER, 0);
      }
      NEXT_FISCAL_QUARTER() {
        return this.tryGetToken(ApexParser2.NEXT_FISCAL_QUARTER, 0);
      }
      NEXT_N_FISCAL_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_FISCAL_QUARTERS_N, 0);
      }
      LAST_N_FISCAL_QUARTERS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_FISCAL_QUARTERS_N, 0);
      }
      N_FISCAL_QUARTERS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_FISCAL_QUARTERS_AGO_N, 0);
      }
      THIS_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.THIS_FISCAL_YEAR, 0);
      }
      LAST_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.LAST_FISCAL_YEAR, 0);
      }
      NEXT_FISCAL_YEAR() {
        return this.tryGetToken(ApexParser2.NEXT_FISCAL_YEAR, 0);
      }
      NEXT_N_FISCAL_YEARS_N() {
        return this.tryGetToken(ApexParser2.NEXT_N_FISCAL_YEARS_N, 0);
      }
      LAST_N_FISCAL_YEARS_N() {
        return this.tryGetToken(ApexParser2.LAST_N_FISCAL_YEARS_N, 0);
      }
      N_FISCAL_YEARS_AGO_N() {
        return this.tryGetToken(ApexParser2.N_FISCAL_YEARS_AGO_N, 0);
      }
      FIND() {
        return this.tryGetToken(ApexParser2.FIND, 0);
      }
      EMAIL() {
        return this.tryGetToken(ApexParser2.EMAIL, 0);
      }
      NAME() {
        return this.tryGetToken(ApexParser2.NAME, 0);
      }
      PHONE() {
        return this.tryGetToken(ApexParser2.PHONE, 0);
      }
      SIDEBAR() {
        return this.tryGetToken(ApexParser2.SIDEBAR, 0);
      }
      FIELDS() {
        return this.tryGetToken(ApexParser2.FIELDS, 0);
      }
      METADATA() {
        return this.tryGetToken(ApexParser2.METADATA, 0);
      }
      PRICEBOOKID() {
        return this.tryGetToken(ApexParser2.PRICEBOOKID, 0);
      }
      NETWORK() {
        return this.tryGetToken(ApexParser2.NETWORK, 0);
      }
      SNIPPET() {
        return this.tryGetToken(ApexParser2.SNIPPET, 0);
      }
      TARGET_LENGTH() {
        return this.tryGetToken(ApexParser2.TARGET_LENGTH, 0);
      }
      DIVISION() {
        return this.tryGetToken(ApexParser2.DIVISION, 0);
      }
      RETURNING() {
        return this.tryGetToken(ApexParser2.RETURNING, 0);
      }
      LISTVIEW() {
        return this.tryGetToken(ApexParser2.LISTVIEW, 0);
      }
      constructor(parent, invokingState) {
        super(parent, invokingState);
      }
      // @Override
      get ruleIndex() {
        return ApexParser2.RULE_anyId;
      }
      // @Override
      enterRule(listener) {
        if (listener.enterAnyId) {
          listener.enterAnyId(this);
        }
      }
      // @Override
      exitRule(listener) {
        if (listener.exitAnyId) {
          listener.exitAnyId(this);
        }
      }
      // @Override
      accept(visitor) {
        if (visitor.visitAnyId) {
          return visitor.visitAnyId(this);
        } else {
          return visitor.visitChildren(this);
        }
      }
    };
    exports2.AnyIdContext = AnyIdContext;
  }
});

// node_modules/@apexdevtools/apex-parser/lib/CaseInsensitiveInputStream.js
var require_CaseInsensitiveInputStream = __commonJS({
  "node_modules/@apexdevtools/apex-parser/lib/CaseInsensitiveInputStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CaseInsensitiveInputStream = void 0;
    var CaseInsensitiveInputStream2 = class {
      // userData is an untyped identifierfor the stream, for string input use CharStreams.fromString()
      constructor(src) {
        this.src = src;
      }
      getText(interval) {
        return this.src.getText(interval);
      }
      consume() {
        this.src.consume();
      }
      LA(i2) {
        return this.toLower(this.src.LA(i2));
      }
      mark() {
        return this.src.mark();
      }
      release(marker) {
        this.src.release(marker);
      }
      get index() {
        return this.src.index;
      }
      seek(index) {
        return this.src.seek(index);
      }
      get size() {
        return this.src.size;
      }
      get sourceName() {
        return this.src.sourceName;
      }
      // We only need basic upper to lower conversions
      toLower(c3) {
        if (c3 >= 65 && c3 <= 90) {
          return c3 + 32;
        } else {
          return c3;
        }
      }
    };
    exports2.CaseInsensitiveInputStream = CaseInsensitiveInputStream2;
  }
});

// node_modules/antlr4ts/ANTLRErrorListener.js
var require_ANTLRErrorListener = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorListener.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/ANTLRErrorStrategy.js
var require_ANTLRErrorStrategy = __commonJS({
  "node_modules/antlr4ts/ANTLRErrorStrategy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/ANTLRInputStream.js
var require_ANTLRInputStream = __commonJS({
  "node_modules/antlr4ts/ANTLRInputStream.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ANTLRInputStream = void 0;
    var assert = require("assert");
    var Decorators_1 = require_Decorators();
    var IntStream_1 = require_IntStream();
    var ANTLRInputStream = class {
      /** Copy data in string to a local char array */
      constructor(input) {
        this.p = 0;
        this.data = input;
        this.n = input.length;
      }
      /** Reset the stream so that it's in the same state it was
       *  when the object was created *except* the data array is not
       *  touched.
       */
      reset() {
        this.p = 0;
      }
      consume() {
        if (this.p >= this.n) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new Error("cannot consume EOF");
        }
        if (this.p < this.n) {
          this.p++;
        }
      }
      LA(i2) {
        if (i2 === 0) {
          return 0;
        }
        if (i2 < 0) {
          i2++;
          if (this.p + i2 - 1 < 0) {
            return IntStream_1.IntStream.EOF;
          }
        }
        if (this.p + i2 - 1 >= this.n) {
          return IntStream_1.IntStream.EOF;
        }
        return this.data.charCodeAt(this.p + i2 - 1);
      }
      LT(i2) {
        return this.LA(i2);
      }
      /** Return the current input symbol index 0..n where n indicates the
       *  last symbol has been read.  The index is the index of char to
       *  be returned from LA(1).
       */
      get index() {
        return this.p;
      }
      get size() {
        return this.n;
      }
      /** mark/release do nothing; we have entire buffer */
      mark() {
        return -1;
      }
      release(marker) {
      }
      /** consume() ahead until p==index; can't just set p=index as we must
       *  update line and charPositionInLine. If we seek backwards, just set p
       */
      seek(index) {
        if (index <= this.p) {
          this.p = index;
          return;
        }
        index = Math.min(index, this.n);
        while (this.p < index) {
          this.consume();
        }
      }
      getText(interval) {
        let start = interval.a;
        let stop = interval.b;
        if (stop >= this.n) {
          stop = this.n - 1;
        }
        let count2 = stop - start + 1;
        if (start >= this.n) {
          return "";
        }
        return this.data.substr(start, count2);
      }
      get sourceName() {
        if (!this.name) {
          return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return this.name;
      }
      toString() {
        return this.data;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "getText", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], ANTLRInputStream.prototype, "toString", null);
    exports2.ANTLRInputStream = ANTLRInputStream;
  }
});

// node_modules/antlr4ts/CharStream.js
var require_CharStream = __commonJS({
  "node_modules/antlr4ts/CharStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/Dependents.js
var require_Dependents = __commonJS({
  "node_modules/antlr4ts/Dependents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dependents = void 0;
    var Dependents;
    (function(Dependents2) {
      Dependents2[Dependents2["SELF"] = 0] = "SELF";
      Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
      Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
      Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
      Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
      Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
      Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
      Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
      Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
      Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
    })(Dependents = exports2.Dependents || (exports2.Dependents = {}));
  }
});

// node_modules/antlr4ts/DiagnosticErrorListener.js
var require_DiagnosticErrorListener = __commonJS({
  "node_modules/antlr4ts/DiagnosticErrorListener.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticErrorListener = void 0;
    var BitSet_1 = require_BitSet();
    var Decorators_1 = require_Decorators();
    var Interval_1 = require_Interval();
    var DiagnosticErrorListener = class {
      /**
       * Initializes a new instance of {@link DiagnosticErrorListener}, specifying
       * whether all ambiguities or only exact ambiguities are reported.
       *
       * @param exactOnly `true` to report only exact ambiguities, otherwise
       * `false` to report all ambiguities.  Defaults to true.
       */
      constructor(exactOnly = true) {
        this.exactOnly = exactOnly;
        this.exactOnly = exactOnly;
      }
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.exactOnly && !exact) {
          return;
        }
        let decision = this.getDecisionDescription(recognizer, dfa);
        let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
        let text2 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text2}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        let format3 = "reportAttemptingFullContext d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text2 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportAttemptingFullContext d=${decision}, input='${text2}'`;
        recognizer.notifyErrorListeners(message);
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        let format3 = "reportContextSensitivity d=%s, input='%s'";
        let decision = this.getDecisionDescription(recognizer, dfa);
        let text2 = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
        let message = `reportContextSensitivity d=${decision}, input='${text2}'`;
        recognizer.notifyErrorListeners(message);
      }
      getDecisionDescription(recognizer, dfa) {
        let decision = dfa.decision;
        let ruleIndex = dfa.atnStartState.ruleIndex;
        let ruleNames = recognizer.ruleNames;
        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
          return decision.toString();
        }
        let ruleName = ruleNames[ruleIndex];
        if (!ruleName) {
          return decision.toString();
        }
        return `${decision} (${ruleName})`;
      }
      /**
       * Computes the set of conflicting or ambiguous alternatives from a
       * configuration set, if that information was not already provided by the
       * parser.
       *
       * @param reportedAlts The set of conflicting or ambiguous alternatives, as
       * reported by the parser.
       * @param configs The conflicting or ambiguous configuration set.
       * @returns Returns `reportedAlts` if it is not `undefined`, otherwise
       * returns the set of alternatives represented in `configs`.
       */
      getConflictingAlts(reportedAlts, configs) {
        if (reportedAlts != null) {
          return reportedAlts;
        }
        let result = new BitSet_1.BitSet();
        for (let config2 of configs) {
          result.set(config2.alt);
        }
        return result;
      }
    };
    __decorate([
      Decorators_1.Override
    ], DiagnosticErrorListener.prototype, "syntaxError", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
    exports2.DiagnosticErrorListener = DiagnosticErrorListener;
  }
});

// node_modules/antlr4ts/LexerInterpreter.js
var require_LexerInterpreter = __commonJS({
  "node_modules/antlr4ts/LexerInterpreter.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LexerInterpreter = void 0;
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
      constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
        super(input);
        if (atn.grammarType !== 0) {
          throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
        }
        this._grammarFileName = grammarFileName;
        this._atn = atn;
        this._ruleNames = ruleNames.slice(0);
        this._channelNames = channelNames.slice(0);
        this._modeNames = modeNames.slice(0);
        this._vocabulary = vocabulary;
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
      }
      get atn() {
        return this._atn;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get channelNames() {
        return this._channelNames;
      }
      get modeNames() {
        return this._modeNames;
      }
      get vocabulary() {
        return this._vocabulary;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], LexerInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "channelNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "modeNames", null);
    __decorate([
      Decorators_2.Override
    ], LexerInterpreter.prototype, "vocabulary", null);
    LexerInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], LexerInterpreter);
    exports2.LexerInterpreter = LexerInterpreter;
  }
});

// node_modules/antlr4ts/ParserErrorListener.js
var require_ParserErrorListener = __commonJS({
  "node_modules/antlr4ts/ParserErrorListener.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/RuleContextWithAltNum.js
var require_RuleContextWithAltNum = __commonJS({
  "node_modules/antlr4ts/RuleContextWithAltNum.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleContextWithAltNum = void 0;
    var ATN_1 = require_ATN();
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      get altNumber() {
        return this._altNumber;
      }
      // @Override
      set altNumber(altNum) {
        this._altNumber = altNum;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContextWithAltNum.prototype, "altNumber", null);
    exports2.RuleContextWithAltNum = RuleContextWithAltNum;
  }
});

// node_modules/antlr4ts/RuleDependency.js
var require_RuleDependency = __commonJS({
  "node_modules/antlr4ts/RuleDependency.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleDependency = void 0;
    function RuleDependency(dependency) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports2.RuleDependency = RuleDependency;
  }
});

// node_modules/antlr4ts/RuleVersion.js
var require_RuleVersion = __commonJS({
  "node_modules/antlr4ts/RuleVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleVersion = void 0;
    function RuleVersion(version) {
      return (target, propertyKey, propertyDescriptor) => {
      };
    }
    exports2.RuleVersion = RuleVersion;
  }
});

// node_modules/antlr4ts/TokenFactory.js
var require_TokenFactory = __commonJS({
  "node_modules/antlr4ts/TokenFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenSource.js
var require_TokenSource = __commonJS({
  "node_modules/antlr4ts/TokenSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStream.js
var require_TokenStream = __commonJS({
  "node_modules/antlr4ts/TokenStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/TokenStreamRewriter.js
var require_TokenStreamRewriter = __commonJS({
  "node_modules/antlr4ts/TokenStreamRewriter.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c3 = arguments.length, r = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r;
      return c3 > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RewriteOperation = exports2.TokenStreamRewriter = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TokenStreamRewriter = class _TokenStreamRewriter {
      constructor(tokens) {
        this.tokens = tokens;
        this.programs = /* @__PURE__ */ new Map();
        this.programs.set(_TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
        this.lastRewriteTokenIndexes = /* @__PURE__ */ new Map();
      }
      getTokenStream() {
        return this.tokens;
      }
      rollback(instructionIndex, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let is = this.programs.get(programName);
        if (is != null) {
          this.programs.set(programName, is.slice(_TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
        }
      }
      deleteProgram(programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        this.rollback(_TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
      }
      insertAfter(tokenOrIndex, text2, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index;
        if (typeof tokenOrIndex === "number") {
          index = tokenOrIndex;
        } else {
          index = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertAfterOp(this.tokens, index, rewrites.length, text2);
        rewrites.push(op);
      }
      insertBefore(tokenOrIndex, text2, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let index;
        if (typeof tokenOrIndex === "number") {
          index = tokenOrIndex;
        } else {
          index = tokenOrIndex.tokenIndex;
        }
        let rewrites = this.getProgram(programName);
        let op = new InsertBeforeOp(this.tokens, index, rewrites.length, text2);
        rewrites.push(op);
      }
      replaceSingle(index, text2) {
        if (typeof index === "number") {
          this.replace(index, index, text2);
        } else {
          this.replace(index, index, text2);
        }
      }
      replace(from, to, text2, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (typeof from !== "number") {
          from = from.tokenIndex;
        }
        if (typeof to !== "number") {
          to = to.tokenIndex;
        }
        if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
          throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
        }
        let rewrites = this.getProgram(programName);
        let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text2);
        rewrites.push(op);
      }
      delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        if (to === void 0) {
          to = from;
        }
        if (typeof from === "number") {
          this.replace(from, to, "", programName);
        } else {
          this.replace(from, to, "", programName);
        }
      }
      getLastRewriteTokenIndex(programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let I = this.lastRewriteTokenIndexes.get(programName);
        if (I == null) {
          return -1;
        }
        return I;
      }
      setLastRewriteTokenIndex(programName, i2) {
        this.lastRewriteTokenIndexes.set(programName, i2);
      }
      getProgram(name) {
        let is = this.programs.get(name);
        if (is == null) {
          is = this.initializeProgram(name);
        }
        return is;
      }
      initializeProgram(name) {
        let is = [];
        this.programs.set(name, is);
        return is;
      }
      getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
        let interval;
        if (intervalOrProgram instanceof Interval_1.Interval) {
          interval = intervalOrProgram;
        } else {
          interval = Interval_1.Interval.of(0, this.tokens.size - 1);
        }
        if (typeof intervalOrProgram === "string") {
          programName = intervalOrProgram;
        }
        let rewrites = this.programs.get(programName);
        let start = interval.a;
        let stop = interval.b;
        if (stop > this.tokens.size - 1) {
          stop = this.tokens.size - 1;
        }
        if (start < 0) {
          start = 0;
        }
        if (rewrites == null || rewrites.length === 0) {
          return this.tokens.getText(interval);
        }
        let buf = [];
        let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
        let i2 = start;
        while (i2 <= stop && i2 < this.tokens.size) {
          let op = indexToOp.get(i2);
          indexToOp.delete(i2);
          let t = this.tokens.get(i2);
          if (op == null) {
            if (t.type !== Token_1.Token.EOF) {
              buf.push(String(t.text));
            }
            i2++;
          } else {
            i2 = op.execute(buf);
          }
        }
        if (stop === this.tokens.size - 1) {
          for (let op of indexToOp.values()) {
            if (op.index >= this.tokens.size - 1) {
              buf.push(op.text.toString());
            }
          }
        }
        return buf.join("");
      }
      /** We need to combine operations and report invalid operations (like
       *  overlapping replaces that are not completed nested). Inserts to
       *  same index need to be combined etc...  Here are the cases:
       *
       *  I.i.u I.j.v								leave alone, nonoverlapping
       *  I.i.u I.i.v								combine: Iivu
       *
       *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
       *  R.i-j.u R.i-j.v							delete first R
       *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
       *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
       *
       *  Delete special case of replace (text==undefined):
       *  D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
       *
       *  I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
       * 											we're not deleting i)
       *  I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
       *  R.x-y.v I.i.u | i in x-y				ERROR
       *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
       *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
       *
       *  I.i.u = insert u before op @ index i
       *  R.x-y.u = replace x-y indexed tokens with u
       *
       *  First we need to examine replaces. For any replace op:
       *
       * 		1. wipe out any insertions before op within that range.
       * 		2. Drop any replace op before that is contained completely within
       * 	 that range.
       * 		3. Throw exception upon boundary overlap with any previous replace.
       *
       *  Then we can deal with inserts:
       *
       * 		1. for any inserts to same index, combine even if not adjacent.
       * 		2. for any prior replace with same left boundary, combine this
       * 	 insert with replace and delete this replace.
       * 		3. throw exception if index in same range as previous replace
       *
       *  Don't actually delete; make op undefined in list. Easier to walk list.
       *  Later we can throw as we add to index &rarr; op map.
       *
       *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
       *  inserted stuff would be before the replace range. But, if you
       *  add tokens in front of a method body '{' and then delete the method
       *  body, I think the stuff before the '{' you added should disappear too.
       *
       *  Return a map from token index to operation.
       */
      reduceToSingleOperationPerIndex(rewrites) {
        for (let i2 = 0; i2 < rewrites.length; i2++) {
          let op = rewrites[i2];
          if (op == null) {
            continue;
          }
          if (!(op instanceof ReplaceOp)) {
            continue;
          }
          let rop = op;
          let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i2);
          for (let iop of inserts) {
            if (iop.index === rop.index) {
              rewrites[iop.instructionIndex] = void 0;
              rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
            } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
              rewrites[iop.instructionIndex] = void 0;
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i2);
          for (let prevRop of prevReplaces) {
            if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
              rewrites[prevRop.instructionIndex] = void 0;
              continue;
            }
            let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
            if (prevRop.text == null && rop.text == null && !disjoint) {
              rewrites[prevRop.instructionIndex] = void 0;
              rop.index = Math.min(prevRop.index, rop.index);
              rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
            } else if (!disjoint) {
              throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
            }
          }
        }
        for (let i2 = 0; i2 < rewrites.length; i2++) {
          let op = rewrites[i2];
          if (op == null) {
            continue;
          }
          if (!(op instanceof InsertBeforeOp)) {
            continue;
          }
          let iop = op;
          let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i2);
          for (let prevIop of prevInserts) {
            if (prevIop.index === iop.index) {
              if (prevIop instanceof InsertAfterOp) {
                iop.text = this.catOpText(prevIop.text, iop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              } else if (prevIop instanceof InsertBeforeOp) {
                iop.text = this.catOpText(iop.text, prevIop.text);
                rewrites[prevIop.instructionIndex] = void 0;
              }
            }
          }
          let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i2);
          for (let rop of prevReplaces) {
            if (iop.index === rop.index) {
              rop.text = this.catOpText(iop.text, rop.text);
              rewrites[i2] = void 0;
              continue;
            }
            if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
              throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
            }
          }
        }
        let m = /* @__PURE__ */ new Map();
        for (let op of rewrites) {
          if (op == null) {
            continue;
          }
          if (m.get(op.index) != null) {
            throw new Error("should only be one op per index");
          }
          m.set(op.index, op);
        }
        return m;
      }
      catOpText(a2, b) {
        let x = "";
        let y = "";
        if (a2 != null) {
          x = a2.toString();
        }
        if (b != null) {
          y = b.toString();
        }
        return x + y;
      }
      /** Get all operations before an index of a particular kind */
      getKindOfOps(rewrites, kind, before) {
        let ops = [];
        for (let i2 = 0; i2 < before && i2 < rewrites.length; i2++) {
          let op = rewrites[i2];
          if (op == null) {
            continue;
          }
          if (op instanceof kind) {
            ops.push(op);
          }
        }
        return ops;
      }
    };
    exports2.TokenStreamRewriter = TokenStreamRewriter;
    TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
    TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
    TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
    var RewriteOperation = class {
      constructor(tokens, index, instructionIndex, text2) {
        this.tokens = tokens;
        this.instructionIndex = instructionIndex;
        this.index = index;
        this.text = text2 === void 0 ? "" : text2;
      }
      /** Execute the rewrite operation by possibly adding to the buffer.
       *  Return the index of the next token to operate on.
       */
      execute(buf) {
        return this.index;
      }
      toString() {
        let opName = this.constructor.name;
        let $index = opName.indexOf("$");
        opName = opName.substring($index + 1, opName.length);
        return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], RewriteOperation.prototype, "toString", null);
    exports2.RewriteOperation = RewriteOperation;
    var InsertBeforeOp = class extends RewriteOperation {
      constructor(tokens, index, instructionIndex, text2) {
        super(tokens, index, instructionIndex, text2);
      }
      execute(buf) {
        buf.push(this.text.toString());
        if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
          buf.push(String(this.tokens.get(this.index).text));
        }
        return this.index + 1;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InsertBeforeOp.prototype, "execute", null);
    var InsertAfterOp = class extends InsertBeforeOp {
      constructor(tokens, index, instructionIndex, text2) {
        super(tokens, index + 1, instructionIndex, text2);
      }
    };
    var ReplaceOp = class extends RewriteOperation {
      constructor(tokens, from, to, instructionIndex, text2) {
        super(tokens, from, instructionIndex, text2);
        this.lastIndex = to;
      }
      execute(buf) {
        if (this.text != null) {
          buf.push(this.text.toString());
        }
        return this.lastIndex + 1;
      }
      toString() {
        if (this.text == null) {
          return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
        }
        return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
      }
    };
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], ReplaceOp.prototype, "toString", null);
  }
});

// node_modules/antlr4ts/Vocabulary.js
var require_Vocabulary = __commonJS({
  "node_modules/antlr4ts/Vocabulary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/WritableToken.js
var require_WritableToken = __commonJS({
  "node_modules/antlr4ts/WritableToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/index.js
var require_antlr4ts = __commonJS({
  "node_modules/antlr4ts/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ANTLRErrorListener(), exports2);
    __exportStar(require_ANTLRErrorStrategy(), exports2);
    __exportStar(require_ANTLRInputStream(), exports2);
    __exportStar(require_BailErrorStrategy(), exports2);
    __exportStar(require_BufferedTokenStream(), exports2);
    __exportStar(require_CharStream(), exports2);
    __exportStar(require_CharStreams(), exports2);
    __exportStar(require_CodePointBuffer(), exports2);
    __exportStar(require_CodePointCharStream(), exports2);
    __exportStar(require_CommonToken(), exports2);
    __exportStar(require_CommonTokenFactory(), exports2);
    __exportStar(require_CommonTokenStream(), exports2);
    __exportStar(require_ConsoleErrorListener(), exports2);
    __exportStar(require_DefaultErrorStrategy(), exports2);
    __exportStar(require_Dependents(), exports2);
    __exportStar(require_DiagnosticErrorListener(), exports2);
    __exportStar(require_FailedPredicateException(), exports2);
    __exportStar(require_InputMismatchException(), exports2);
    __exportStar(require_InterpreterRuleContext(), exports2);
    __exportStar(require_IntStream(), exports2);
    __exportStar(require_Lexer(), exports2);
    __exportStar(require_LexerInterpreter(), exports2);
    __exportStar(require_LexerNoViableAltException(), exports2);
    __exportStar(require_ListTokenSource(), exports2);
    __exportStar(require_NoViableAltException(), exports2);
    __exportStar(require_Parser(), exports2);
    __exportStar(require_ParserErrorListener(), exports2);
    __exportStar(require_ParserInterpreter(), exports2);
    __exportStar(require_ParserRuleContext(), exports2);
    __exportStar(require_ProxyErrorListener(), exports2);
    __exportStar(require_ProxyParserErrorListener(), exports2);
    __exportStar(require_RecognitionException(), exports2);
    __exportStar(require_Recognizer(), exports2);
    __exportStar(require_RuleContext(), exports2);
    __exportStar(require_RuleContextWithAltNum(), exports2);
    __exportStar(require_RuleDependency(), exports2);
    __exportStar(require_RuleVersion(), exports2);
    __exportStar(require_Token(), exports2);
    __exportStar(require_TokenFactory(), exports2);
    __exportStar(require_TokenSource(), exports2);
    __exportStar(require_TokenStream(), exports2);
    __exportStar(require_TokenStreamRewriter(), exports2);
    __exportStar(require_Vocabulary(), exports2);
    __exportStar(require_VocabularyImpl(), exports2);
    __exportStar(require_WritableToken(), exports2);
  }
});

// node_modules/@apexdevtools/apex-parser/lib/ThrowingErrorListener.js
var require_ThrowingErrorListener = __commonJS({
  "node_modules/@apexdevtools/apex-parser/lib/ThrowingErrorListener.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ThrowingErrorListener = exports2.SyntaxException = void 0;
    var SyntaxException = class {
      constructor(line, column, message) {
        this.line = line;
        this.column = column;
        this.message = message;
      }
    };
    exports2.SyntaxException = SyntaxException;
    var ThrowingErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        throw new SyntaxException(line, charPositionInLine, msg);
      }
    };
    exports2.ThrowingErrorListener = ThrowingErrorListener;
  }
});

// node_modules/@apexdevtools/apex-parser/lib/ApexParserListener.js
var require_ApexParserListener = __commonJS({
  "node_modules/@apexdevtools/apex-parser/lib/ApexParserListener.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@apexdevtools/apex-parser/lib/ApexParserVisitor.js
var require_ApexParserVisitor = __commonJS({
  "node_modules/@apexdevtools/apex-parser/lib/ApexParserVisitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/antlr4ts/tree/ParseTreeWalker.js
var require_ParseTreeWalker = __commonJS({
  "node_modules/antlr4ts/tree/ParseTreeWalker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParseTreeWalker = void 0;
    var ErrorNode_1 = require_ErrorNode();
    var TerminalNode_1 = require_TerminalNode();
    var RuleNode_1 = require_RuleNode();
    var ParseTreeWalker = class {
      /**
       * Performs a walk on the given parse tree starting at the root and going down recursively
       * with depth-first search. On each node, {@link ParseTreeWalker#enterRule} is called before
       * recursively walking down into child nodes, then
       * {@link ParseTreeWalker#exitRule} is called after the recursive call to wind up.
       * @param listener The listener used by the walker to process grammar rules
       * @param t The parse tree to be walked on
       */
      walk(listener, t) {
        let nodeStack = [];
        let indexStack = [];
        let currentNode = t;
        let currentIndex = 0;
        while (currentNode) {
          if (currentNode instanceof ErrorNode_1.ErrorNode) {
            if (listener.visitErrorNode) {
              listener.visitErrorNode(currentNode);
            }
          } else if (currentNode instanceof TerminalNode_1.TerminalNode) {
            if (listener.visitTerminal) {
              listener.visitTerminal(currentNode);
            }
          } else {
            this.enterRule(listener, currentNode);
          }
          if (currentNode.childCount > 0) {
            nodeStack.push(currentNode);
            indexStack.push(currentIndex);
            currentIndex = 0;
            currentNode = currentNode.getChild(0);
            continue;
          }
          do {
            if (currentNode instanceof RuleNode_1.RuleNode) {
              this.exitRule(listener, currentNode);
            }
            if (nodeStack.length === 0) {
              currentNode = void 0;
              currentIndex = 0;
              break;
            }
            let last = nodeStack[nodeStack.length - 1];
            currentIndex++;
            currentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : void 0;
            if (currentNode) {
              break;
            }
            currentNode = nodeStack.pop();
            currentIndex = indexStack.pop();
          } while (currentNode);
        }
      }
      /**
       * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener#enterEveryRule}
       * then by triggering the event specific to the given parse tree node
       * @param listener The listener responding to the trigger events
       * @param r The grammar rule containing the rule context
       */
      enterRule(listener, r) {
        let ctx = r.ruleContext;
        if (listener.enterEveryRule) {
          listener.enterEveryRule(ctx);
        }
        ctx.enterRule(listener);
      }
      /**
       * Exits a grammar rule by first triggering the event specific to the given parse tree node
       * then by triggering the generic event {@link ParseTreeListener#exitEveryRule}
       * @param listener The listener responding to the trigger events
       * @param r The grammar rule containing the rule context
       */
      exitRule(listener, r) {
        let ctx = r.ruleContext;
        ctx.exitRule(listener);
        if (listener.exitEveryRule) {
          listener.exitEveryRule(ctx);
        }
      }
    };
    exports2.ParseTreeWalker = ParseTreeWalker;
    (function(ParseTreeWalker2) {
      ParseTreeWalker2.DEFAULT = new ParseTreeWalker2();
    })(ParseTreeWalker = exports2.ParseTreeWalker || (exports2.ParseTreeWalker = {}));
  }
});

// node_modules/@apexdevtools/apex-parser/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@apexdevtools/apex-parser/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    }) : (function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve4) {
          resolve4(value);
        });
      }
      return new (P || (P = Promise))(function(resolve4, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkProject = exports2.check = exports2.ParseTreeWalker = exports2.CommonTokenStream = void 0;
    var path_1 = require("path");
    var dir = require_node_dir();
    var ApexLexer_1 = require_ApexLexer();
    var ApexParser_1 = require_ApexParser();
    var CaseInsensitiveInputStream_1 = require_CaseInsensitiveInputStream();
    var antlr4ts_1 = require_antlr4ts();
    var ThrowingErrorListener_1 = require_ThrowingErrorListener();
    var fs_1 = require("fs");
    __exportStar(require_ApexLexer(), exports2);
    __exportStar(require_ApexParser(), exports2);
    __exportStar(require_CaseInsensitiveInputStream(), exports2);
    __exportStar(require_ThrowingErrorListener(), exports2);
    __exportStar(require_ApexParserListener(), exports2);
    __exportStar(require_ApexParserVisitor(), exports2);
    var antlr4ts_2 = require_antlr4ts();
    Object.defineProperty(exports2, "CommonTokenStream", { enumerable: true, get: function() {
      return antlr4ts_2.CommonTokenStream;
    } });
    var ParseTreeWalker_1 = require_ParseTreeWalker();
    Object.defineProperty(exports2, "ParseTreeWalker", { enumerable: true, get: function() {
      return ParseTreeWalker_1.ParseTreeWalker;
    } });
    function check(pathStr) {
      return __awaiter(this, void 0, void 0, function* () {
        const path15 = (0, path_1.resolve)(pathStr || process.argv[1] || process.cwd());
        const result = {
          status: 0,
          errors: []
        };
        if (!(0, fs_1.existsSync)(path15)) {
          console.log(`Path does not exist, aborting: ${path15}`);
          result.status = 2;
        } else {
          try {
            yield parseFiles(path15);
          } catch (err) {
            console.log(`Error processing: ${path15}`);
            console.log(err);
            result.status = 1;
          }
        }
        process.exitCode = result.status;
        return result;
      });
    }
    exports2.check = check;
    function checkProject(pathStr) {
      return __awaiter(this, void 0, void 0, function* () {
        const path15 = (0, path_1.resolve)(pathStr || process.argv[1] || process.cwd());
        const name = (0, path_1.basename)(path15);
        const project = findProjectFile(path15, 1);
        const packages = getProjectPackages(project);
        if (packages.length == 0) {
          console.log(`[${name}]: No valid SFDX project, checking all cls & trigger files`);
          const result = yield check(path15);
          return [Object.assign({ name, path: "." }, result)];
        }
        const projectDir = (0, path_1.dirname)(project);
        const projectResult = yield Promise.all(packages.map((pkg) => __awaiter(this, void 0, void 0, function* () {
          console.log(`[${name}]: Checking package "${pkg}"`);
          const pkgPath = (0, path_1.resolve)(projectDir, pkg);
          const result = yield check(pkgPath);
          return Object.assign({
            name,
            pkg,
            path: (0, path_1.relative)(path15, pkgPath)
          }, result);
        })));
        process.exitCode = Math.max(...projectResult.map((r) => r.status));
        return projectResult;
      });
    }
    exports2.checkProject = checkProject;
    function parseFiles(path15) {
      return __awaiter(this, void 0, void 0, function* () {
        const files = yield dir.promiseFiles(path15);
        const classErrors = parseByType(path15, files, ".cls", (parser) => {
          parser.compilationUnit();
        });
        const triggerErrors = parseByType(path15, files, ".trigger", (parser) => {
          parser.triggerUnit();
        });
        return classErrors.concat(triggerErrors);
      });
    }
    function parseByType(rootPath, files, endsWith2, operation) {
      let parsedCount = 0;
      const errors = [];
      files.filter((name) => name.endsWith(endsWith2)).forEach((file) => {
        if ((0, fs_1.lstatSync)(file).isFile()) {
          const content = (0, fs_1.readFileSync)(file);
          const lexer = new ApexLexer_1.ApexLexer(new CaseInsensitiveInputStream_1.CaseInsensitiveInputStream(antlr4ts_1.CharStreams.fromString(content.toString())));
          const tokens = new antlr4ts_1.CommonTokenStream(lexer);
          const parser = new ApexParser_1.ApexParser(tokens);
          parser.removeErrorListeners();
          parser.addErrorListener(new ThrowingErrorListener_1.ThrowingErrorListener());
          try {
            operation(parser);
          } catch (err) {
            console.log(`Error parsing: ${file}`);
            console.log(err);
            errors.push({
              path: (0, path_1.relative)(rootPath, file),
              error: JSON.stringify(err)
            });
          }
          parsedCount += 1;
        }
      });
      console.log(`Parsed ${parsedCount} '${endsWith2}' files in: ${rootPath}`);
      return errors;
    }
    function findProjectFile(wd, depth) {
      const proj = "sfdx-project.json";
      const files = (0, fs_1.readdirSync)(wd).filter((i2) => !/(^|\/)\.[^\/\.]/g.test(i2));
      if (files.includes(proj)) {
        return (0, path_1.resolve)(wd, proj);
      }
      if (depth) {
        const dirs = files.map((f) => (0, path_1.resolve)(wd, f)).filter((f) => (0, fs_1.lstatSync)(f).isDirectory());
        const newDepth = depth - 1;
        for (const d of dirs) {
          const p = findProjectFile(d, newDepth);
          if (p) {
            return p;
          }
        }
      }
      return void 0;
    }
    function getProjectPackages(projectFilePath) {
      if (!projectFilePath) {
        return [];
      }
      const config2 = JSON.parse((0, fs_1.readFileSync)(projectFilePath, { encoding: "utf8" }));
      const packages = config2.packageDirectories || [];
      return packages.flatMap((p) => p.path ? p.path.replace(/\\/g, "/") : []);
    }
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(extension_exports);
var vscode14 = __toESM(require("vscode"));
var path14 = __toESM(require("path"));

// src/providers/dependenciesProvider.ts
var vscode3 = __toESM(require("vscode"));

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype3 = Object.getPrototypeOf(value);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/execa/lib/arguments/file-url.js
var import_node_url = require("node:url");
var safeNormalizeFileUrl = (file, name) => {
  const fileString = normalizeFileUrl(normalizeDenoExecPath(file));
  if (typeof fileString !== "string") {
    throw new TypeError(`${name} must be a string or a file URL: ${fileString}.`);
  }
  return fileString;
};
var normalizeDenoExecPath = (file) => isDenoExecPath(file) ? file.toString() : file;
var isDenoExecPath = (file) => typeof file !== "string" && file && Object.getPrototypeOf(file) === String.prototype;
var normalizeFileUrl = (file) => file instanceof URL ? (0, import_node_url.fileURLToPath)(file) : file;

// node_modules/execa/lib/methods/parameters.js
var normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {
  const filePath = safeNormalizeFileUrl(rawFile, "First argument");
  const [commandArguments, options] = isPlainObject(rawArguments) ? [[], rawArguments] : [rawArguments, rawOptions];
  if (!Array.isArray(commandArguments)) {
    throw new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);
  }
  if (commandArguments.some((commandArgument) => typeof commandArgument === "object" && commandArgument !== null)) {
    throw new TypeError(`Second argument must be an array of strings: ${commandArguments}`);
  }
  const normalizedArguments = commandArguments.map(String);
  const nullByteArgument = normalizedArguments.find((normalizedArgument) => normalizedArgument.includes("\0"));
  if (nullByteArgument !== void 0) {
    throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${nullByteArgument}`);
  }
  if (!isPlainObject(options)) {
    throw new TypeError(`Last argument must be an options object: ${options}`);
  }
  return [filePath, normalizedArguments, options];
};

// node_modules/execa/lib/methods/template.js
var import_node_child_process = require("node:child_process");

// node_modules/execa/lib/utils/uint-array.js
var import_node_string_decoder = require("node:string_decoder");
var { toString: objectToString } = Object.prototype;
var isArrayBuffer = (value) => objectToString.call(value) === "[object ArrayBuffer]";
var isUint8Array = (value) => objectToString.call(value) === "[object Uint8Array]";
var bufferToUint8Array = (buffer) => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
var textEncoder = new TextEncoder();
var stringToUint8Array = (string) => textEncoder.encode(string);
var textDecoder = new TextDecoder();
var uint8ArrayToString = (uint8Array) => textDecoder.decode(uint8Array);
var joinToString = (uint8ArraysOrStrings, encoding) => {
  const strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);
  return strings.join("");
};
var uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {
  if (encoding === "utf8" && uint8ArraysOrStrings.every((uint8ArrayOrString) => typeof uint8ArrayOrString === "string")) {
    return uint8ArraysOrStrings;
  }
  const decoder = new import_node_string_decoder.StringDecoder(encoding);
  const strings = uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString).map((uint8Array) => decoder.write(uint8Array));
  const finalString = decoder.end();
  return finalString === "" ? strings : [...strings, finalString];
};
var joinToUint8Array = (uint8ArraysOrStrings) => {
  if (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {
    return uint8ArraysOrStrings[0];
  }
  return concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));
};
var stringsToUint8Arrays = (uint8ArraysOrStrings) => uint8ArraysOrStrings.map((uint8ArrayOrString) => typeof uint8ArrayOrString === "string" ? stringToUint8Array(uint8ArrayOrString) : uint8ArrayOrString);
var concatUint8Arrays = (uint8Arrays) => {
  const result = new Uint8Array(getJoinLength(uint8Arrays));
  let index = 0;
  for (const uint8Array of uint8Arrays) {
    result.set(uint8Array, index);
    index += uint8Array.length;
  }
  return result;
};
var getJoinLength = (uint8Arrays) => {
  let joinLength = 0;
  for (const uint8Array of uint8Arrays) {
    joinLength += uint8Array.length;
  }
  return joinLength;
};

// node_modules/execa/lib/methods/template.js
var isTemplateString = (templates) => Array.isArray(templates) && Array.isArray(templates.raw);
var parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (const [index, template] of templates.entries()) {
    tokens = parseTemplate({
      templates,
      expressions,
      tokens,
      index,
      template
    });
  }
  if (tokens.length === 0) {
    throw new TypeError("Template script must not be empty");
  }
  const [file, ...commandArguments] = tokens;
  return [file, commandArguments, {}];
};
var parseTemplate = ({ templates, expressions, tokens, index, template }) => {
  if (template === void 0) {
    throw new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);
  }
  const { nextTokens, leadingWhitespaces, trailingWhitespaces } = splitByWhitespaces(template, templates.raw[index]);
  const newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);
  if (index === expressions.length) {
    return newTokens;
  }
  const expression = expressions[index];
  const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
  return concatTokens(newTokens, expressionTokens, trailingWhitespaces);
};
var splitByWhitespaces = (template, rawTemplate) => {
  if (rawTemplate.length === 0) {
    return { nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false };
  }
  const nextTokens = [];
  let templateStart = 0;
  const leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);
  for (let templateIndex = 0, rawIndex = 0; templateIndex < template.length; templateIndex += 1, rawIndex += 1) {
    const rawCharacter = rawTemplate[rawIndex];
    if (DELIMITERS.has(rawCharacter)) {
      if (templateStart !== templateIndex) {
        nextTokens.push(template.slice(templateStart, templateIndex));
      }
      templateStart = templateIndex + 1;
    } else if (rawCharacter === "\\") {
      const nextRawCharacter = rawTemplate[rawIndex + 1];
      if (nextRawCharacter === "\n") {
        templateIndex -= 1;
        rawIndex += 1;
      } else if (nextRawCharacter === "u" && rawTemplate[rawIndex + 2] === "{") {
        rawIndex = rawTemplate.indexOf("}", rawIndex + 3);
      } else {
        rawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;
      }
    }
  }
  const trailingWhitespaces = templateStart === template.length;
  if (!trailingWhitespaces) {
    nextTokens.push(template.slice(templateStart));
  }
  return { nextTokens, leadingWhitespaces, trailingWhitespaces };
};
var DELIMITERS = /* @__PURE__ */ new Set([" ", "	", "\r", "\n"]);
var ESCAPE_LENGTH = { x: 3, u: 5 };
var concatTokens = (tokens, nextTokens, isSeparated) => isSeparated || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens.at(-1)}${nextTokens[0]}`,
  ...nextTokens.slice(1)
];
var parseExpression = (expression) => {
  const typeOfExpression = typeof expression;
  if (typeOfExpression === "string") {
    return expression;
  }
  if (typeOfExpression === "number") {
    return String(expression);
  }
  if (isPlainObject(expression) && ("stdout" in expression || "isMaxBuffer" in expression)) {
    return getSubprocessResult(expression);
  }
  if (expression instanceof import_node_child_process.ChildProcess || Object.prototype.toString.call(expression) === "[object Promise]") {
    throw new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
};
var getSubprocessResult = ({ stdout }) => {
  if (typeof stdout === "string") {
    return stdout;
  }
  if (isUint8Array(stdout)) {
    return uint8ArrayToString(stdout);
  }
  if (stdout === void 0) {
    throw new TypeError(`Missing result.stdout in template expression. This is probably due to the previous subprocess' "stdout" option.`);
  }
  throw new TypeError(`Unexpected "${typeof stdout}" stdout in template expression`);
};

// node_modules/execa/lib/methods/main-sync.js
var import_node_child_process3 = require("node:child_process");

// node_modules/execa/lib/arguments/specific.js
var import_node_util = require("node:util");

// node_modules/execa/lib/utils/standard-stream.js
var import_node_process = __toESM(require("node:process"), 1);
var isStandardStream = (stream5) => STANDARD_STREAMS.includes(stream5);
var STANDARD_STREAMS = [import_node_process.default.stdin, import_node_process.default.stdout, import_node_process.default.stderr];
var STANDARD_STREAMS_ALIASES = ["stdin", "stdout", "stderr"];
var getStreamName = (fdNumber) => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;

// node_modules/execa/lib/arguments/specific.js
var normalizeFdSpecificOptions = (options) => {
  const optionsCopy = { ...options };
  for (const optionName of FD_SPECIFIC_OPTIONS) {
    optionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);
  }
  return optionsCopy;
};
var normalizeFdSpecificOption = (options, optionName) => {
  const optionBaseArray = Array.from({ length: getStdioLength(options) + 1 });
  const optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);
  return addDefaultValue(optionArray, optionName);
};
var getStdioLength = ({ stdio }) => Array.isArray(stdio) ? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length) : STANDARD_STREAMS_ALIASES.length;
var normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue) ? normalizeOptionObject(optionValue, optionArray, optionName) : optionArray.fill(optionValue);
var normalizeOptionObject = (optionValue, optionArray, optionName) => {
  for (const fdName of Object.keys(optionValue).sort(compareFdName)) {
    for (const fdNumber of parseFdName(fdName, optionName, optionArray)) {
      optionArray[fdNumber] = optionValue[fdName];
    }
  }
  return optionArray;
};
var compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;
var getFdNameOrder = (fdName) => {
  if (fdName === "stdout" || fdName === "stderr") {
    return 0;
  }
  return fdName === "all" ? 2 : 1;
};
var parseFdName = (fdName, optionName, optionArray) => {
  if (fdName === "ipc") {
    return [optionArray.length - 1];
  }
  const fdNumber = parseFd(fdName);
  if (fdNumber === void 0 || fdNumber === 0) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid.
It must be "${optionName}.stdout", "${optionName}.stderr", "${optionName}.all", "${optionName}.ipc", or "${optionName}.fd3", "${optionName}.fd4" (and so on).`);
  }
  if (fdNumber >= optionArray.length) {
    throw new TypeError(`"${optionName}.${fdName}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  return fdNumber === "all" ? [1, 2] : [fdNumber];
};
var parseFd = (fdName) => {
  if (fdName === "all") {
    return fdName;
  }
  if (STANDARD_STREAMS_ALIASES.includes(fdName)) {
    return STANDARD_STREAMS_ALIASES.indexOf(fdName);
  }
  const regexpResult = FD_REGEXP.exec(fdName);
  if (regexpResult !== null) {
    return Number(regexpResult[1]);
  }
};
var FD_REGEXP = /^fd(\d+)$/;
var addDefaultValue = (optionArray, optionName) => optionArray.map((optionValue) => optionValue === void 0 ? DEFAULT_OPTIONS[optionName] : optionValue);
var verboseDefault = (0, import_node_util.debuglog)("execa").enabled ? "full" : "none";
var DEFAULT_OPTIONS = {
  lines: false,
  buffer: true,
  maxBuffer: 1e3 * 1e3 * 100,
  verbose: verboseDefault,
  stripFinalNewline: true
};
var FD_SPECIFIC_OPTIONS = ["lines", "buffer", "maxBuffer", "verbose", "stripFinalNewline"];
var getFdSpecificValue = (optionArray, fdNumber) => fdNumber === "ipc" ? optionArray.at(-1) : optionArray[fdNumber];

// node_modules/execa/lib/verbose/values.js
var isVerbose = ({ verbose }, fdNumber) => getFdVerbose(verbose, fdNumber) !== "none";
var isFullVerbose = ({ verbose }, fdNumber) => !["none", "short"].includes(getFdVerbose(verbose, fdNumber));
var getVerboseFunction = ({ verbose }, fdNumber) => {
  const fdVerbose = getFdVerbose(verbose, fdNumber);
  return isVerboseFunction(fdVerbose) ? fdVerbose : void 0;
};
var getFdVerbose = (verbose, fdNumber) => fdNumber === void 0 ? getFdGenericVerbose(verbose) : getFdSpecificValue(verbose, fdNumber);
var getFdGenericVerbose = (verbose) => verbose.find((fdVerbose) => isVerboseFunction(fdVerbose)) ?? VERBOSE_VALUES.findLast((fdVerbose) => verbose.includes(fdVerbose));
var isVerboseFunction = (fdVerbose) => typeof fdVerbose === "function";
var VERBOSE_VALUES = ["none", "short", "full"];

// node_modules/execa/lib/verbose/log.js
var import_node_util3 = require("node:util");

// node_modules/execa/lib/arguments/escape.js
var import_node_process2 = require("node:process");
var import_node_util2 = require("node:util");
var joinCommand = (filePath, rawArguments) => {
  const fileAndArguments = [filePath, ...rawArguments];
  const command = fileAndArguments.join(" ");
  const escapedCommand = fileAndArguments.map((fileAndArgument) => quoteString(escapeControlCharacters(fileAndArgument))).join(" ");
  return { command, escapedCommand };
};
var escapeLines = (lines) => (0, import_node_util2.stripVTControlCharacters)(lines).split("\n").map((line) => escapeControlCharacters(line)).join("\n");
var escapeControlCharacters = (line) => line.replaceAll(SPECIAL_CHAR_REGEXP, (character) => escapeControlCharacter(character));
var escapeControlCharacter = (character) => {
  const commonEscape = COMMON_ESCAPES[character];
  if (commonEscape !== void 0) {
    return commonEscape;
  }
  const codepoint = character.codePointAt(0);
  const codepointHex = codepoint.toString(16);
  return codepoint <= ASTRAL_START ? `\\u${codepointHex.padStart(4, "0")}` : `\\U${codepointHex}`;
};
var getSpecialCharRegExp = () => {
  try {
    return new RegExp("\\p{Separator}|\\p{Other}", "gu");
  } catch {
    return /[\s\u0000-\u001F\u007F-\u009F\u00AD]/g;
  }
};
var SPECIAL_CHAR_REGEXP = getSpecialCharRegExp();
var COMMON_ESCAPES = {
  " ": " ",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
var ASTRAL_START = 65535;
var quoteString = (escapedArgument) => {
  if (NO_ESCAPE_REGEXP.test(escapedArgument)) {
    return escapedArgument;
  }
  return import_node_process2.platform === "win32" ? `"${escapedArgument.replaceAll('"', '""')}"` : `'${escapedArgument.replaceAll("'", "'\\''")}'`;
};
var NO_ESCAPE_REGEXP = /^[\w./-]+$/;

// node_modules/is-unicode-supported/index.js
var import_node_process3 = __toESM(require("node:process"), 1);
function isUnicodeSupported() {
  const { env: env2 } = import_node_process3.default;
  const { TERM, TERM_PROGRAM } = env2;
  if (import_node_process3.default.platform !== "win32") {
    return TERM !== "linux";
  }
  return Boolean(env2.WT_SESSION) || Boolean(env2.TERMINUS_SUBLIME) || env2.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env2.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/figures/index.js
var common = {
  circleQuestionMark: "(?)",
  questionMarkPrefix: "(?)",
  square: "\u2588",
  squareDarkShade: "\u2593",
  squareMediumShade: "\u2592",
  squareLightShade: "\u2591",
  squareTop: "\u2580",
  squareBottom: "\u2584",
  squareLeft: "\u258C",
  squareRight: "\u2590",
  squareCenter: "\u25A0",
  bullet: "\u25CF",
  dot: "\u2024",
  ellipsis: "\u2026",
  pointerSmall: "\u203A",
  triangleUp: "\u25B2",
  triangleUpSmall: "\u25B4",
  triangleDown: "\u25BC",
  triangleDownSmall: "\u25BE",
  triangleLeftSmall: "\u25C2",
  triangleRightSmall: "\u25B8",
  home: "\u2302",
  heart: "\u2665",
  musicNote: "\u266A",
  musicNoteBeamed: "\u266B",
  arrowUp: "\u2191",
  arrowDown: "\u2193",
  arrowLeft: "\u2190",
  arrowRight: "\u2192",
  arrowLeftRight: "\u2194",
  arrowUpDown: "\u2195",
  almostEqual: "\u2248",
  notEqual: "\u2260",
  lessOrEqual: "\u2264",
  greaterOrEqual: "\u2265",
  identical: "\u2261",
  infinity: "\u221E",
  subscriptZero: "\u2080",
  subscriptOne: "\u2081",
  subscriptTwo: "\u2082",
  subscriptThree: "\u2083",
  subscriptFour: "\u2084",
  subscriptFive: "\u2085",
  subscriptSix: "\u2086",
  subscriptSeven: "\u2087",
  subscriptEight: "\u2088",
  subscriptNine: "\u2089",
  oneHalf: "\xBD",
  oneThird: "\u2153",
  oneQuarter: "\xBC",
  oneFifth: "\u2155",
  oneSixth: "\u2159",
  oneEighth: "\u215B",
  twoThirds: "\u2154",
  twoFifths: "\u2156",
  threeQuarters: "\xBE",
  threeFifths: "\u2157",
  threeEighths: "\u215C",
  fourFifths: "\u2158",
  fiveSixths: "\u215A",
  fiveEighths: "\u215D",
  sevenEighths: "\u215E",
  line: "\u2500",
  lineBold: "\u2501",
  lineDouble: "\u2550",
  lineDashed0: "\u2504",
  lineDashed1: "\u2505",
  lineDashed2: "\u2508",
  lineDashed3: "\u2509",
  lineDashed4: "\u254C",
  lineDashed5: "\u254D",
  lineDashed6: "\u2574",
  lineDashed7: "\u2576",
  lineDashed8: "\u2578",
  lineDashed9: "\u257A",
  lineDashed10: "\u257C",
  lineDashed11: "\u257E",
  lineDashed12: "\u2212",
  lineDashed13: "\u2013",
  lineDashed14: "\u2010",
  lineDashed15: "\u2043",
  lineVertical: "\u2502",
  lineVerticalBold: "\u2503",
  lineVerticalDouble: "\u2551",
  lineVerticalDashed0: "\u2506",
  lineVerticalDashed1: "\u2507",
  lineVerticalDashed2: "\u250A",
  lineVerticalDashed3: "\u250B",
  lineVerticalDashed4: "\u254E",
  lineVerticalDashed5: "\u254F",
  lineVerticalDashed6: "\u2575",
  lineVerticalDashed7: "\u2577",
  lineVerticalDashed8: "\u2579",
  lineVerticalDashed9: "\u257B",
  lineVerticalDashed10: "\u257D",
  lineVerticalDashed11: "\u257F",
  lineDownLeft: "\u2510",
  lineDownLeftArc: "\u256E",
  lineDownBoldLeftBold: "\u2513",
  lineDownBoldLeft: "\u2512",
  lineDownLeftBold: "\u2511",
  lineDownDoubleLeftDouble: "\u2557",
  lineDownDoubleLeft: "\u2556",
  lineDownLeftDouble: "\u2555",
  lineDownRight: "\u250C",
  lineDownRightArc: "\u256D",
  lineDownBoldRightBold: "\u250F",
  lineDownBoldRight: "\u250E",
  lineDownRightBold: "\u250D",
  lineDownDoubleRightDouble: "\u2554",
  lineDownDoubleRight: "\u2553",
  lineDownRightDouble: "\u2552",
  lineUpLeft: "\u2518",
  lineUpLeftArc: "\u256F",
  lineUpBoldLeftBold: "\u251B",
  lineUpBoldLeft: "\u251A",
  lineUpLeftBold: "\u2519",
  lineUpDoubleLeftDouble: "\u255D",
  lineUpDoubleLeft: "\u255C",
  lineUpLeftDouble: "\u255B",
  lineUpRight: "\u2514",
  lineUpRightArc: "\u2570",
  lineUpBoldRightBold: "\u2517",
  lineUpBoldRight: "\u2516",
  lineUpRightBold: "\u2515",
  lineUpDoubleRightDouble: "\u255A",
  lineUpDoubleRight: "\u2559",
  lineUpRightDouble: "\u2558",
  lineUpDownLeft: "\u2524",
  lineUpBoldDownBoldLeftBold: "\u252B",
  lineUpBoldDownBoldLeft: "\u2528",
  lineUpDownLeftBold: "\u2525",
  lineUpBoldDownLeftBold: "\u2529",
  lineUpDownBoldLeftBold: "\u252A",
  lineUpDownBoldLeft: "\u2527",
  lineUpBoldDownLeft: "\u2526",
  lineUpDoubleDownDoubleLeftDouble: "\u2563",
  lineUpDoubleDownDoubleLeft: "\u2562",
  lineUpDownLeftDouble: "\u2561",
  lineUpDownRight: "\u251C",
  lineUpBoldDownBoldRightBold: "\u2523",
  lineUpBoldDownBoldRight: "\u2520",
  lineUpDownRightBold: "\u251D",
  lineUpBoldDownRightBold: "\u2521",
  lineUpDownBoldRightBold: "\u2522",
  lineUpDownBoldRight: "\u251F",
  lineUpBoldDownRight: "\u251E",
  lineUpDoubleDownDoubleRightDouble: "\u2560",
  lineUpDoubleDownDoubleRight: "\u255F",
  lineUpDownRightDouble: "\u255E",
  lineDownLeftRight: "\u252C",
  lineDownBoldLeftBoldRightBold: "\u2533",
  lineDownLeftBoldRightBold: "\u252F",
  lineDownBoldLeftRight: "\u2530",
  lineDownBoldLeftBoldRight: "\u2531",
  lineDownBoldLeftRightBold: "\u2532",
  lineDownLeftRightBold: "\u252E",
  lineDownLeftBoldRight: "\u252D",
  lineDownDoubleLeftDoubleRightDouble: "\u2566",
  lineDownDoubleLeftRight: "\u2565",
  lineDownLeftDoubleRightDouble: "\u2564",
  lineUpLeftRight: "\u2534",
  lineUpBoldLeftBoldRightBold: "\u253B",
  lineUpLeftBoldRightBold: "\u2537",
  lineUpBoldLeftRight: "\u2538",
  lineUpBoldLeftBoldRight: "\u2539",
  lineUpBoldLeftRightBold: "\u253A",
  lineUpLeftRightBold: "\u2536",
  lineUpLeftBoldRight: "\u2535",
  lineUpDoubleLeftDoubleRightDouble: "\u2569",
  lineUpDoubleLeftRight: "\u2568",
  lineUpLeftDoubleRightDouble: "\u2567",
  lineUpDownLeftRight: "\u253C",
  lineUpBoldDownBoldLeftBoldRightBold: "\u254B",
  lineUpDownBoldLeftBoldRightBold: "\u2548",
  lineUpBoldDownLeftBoldRightBold: "\u2547",
  lineUpBoldDownBoldLeftRightBold: "\u254A",
  lineUpBoldDownBoldLeftBoldRight: "\u2549",
  lineUpBoldDownLeftRight: "\u2540",
  lineUpDownBoldLeftRight: "\u2541",
  lineUpDownLeftBoldRight: "\u253D",
  lineUpDownLeftRightBold: "\u253E",
  lineUpBoldDownBoldLeftRight: "\u2542",
  lineUpDownLeftBoldRightBold: "\u253F",
  lineUpBoldDownLeftBoldRight: "\u2543",
  lineUpBoldDownLeftRightBold: "\u2544",
  lineUpDownBoldLeftBoldRight: "\u2545",
  lineUpDownBoldLeftRightBold: "\u2546",
  lineUpDoubleDownDoubleLeftDoubleRightDouble: "\u256C",
  lineUpDoubleDownDoubleLeftRight: "\u256B",
  lineUpDownLeftDoubleRightDouble: "\u256A",
  lineCross: "\u2573",
  lineBackslash: "\u2572",
  lineSlash: "\u2571"
};
var specialMainSymbols = {
  tick: "\u2714",
  info: "\u2139",
  warning: "\u26A0",
  cross: "\u2718",
  squareSmall: "\u25FB",
  squareSmallFilled: "\u25FC",
  circle: "\u25EF",
  circleFilled: "\u25C9",
  circleDotted: "\u25CC",
  circleDouble: "\u25CE",
  circleCircle: "\u24DE",
  circleCross: "\u24E7",
  circlePipe: "\u24BE",
  radioOn: "\u25C9",
  radioOff: "\u25EF",
  checkboxOn: "\u2612",
  checkboxOff: "\u2610",
  checkboxCircleOn: "\u24E7",
  checkboxCircleOff: "\u24BE",
  pointer: "\u276F",
  triangleUpOutline: "\u25B3",
  triangleLeft: "\u25C0",
  triangleRight: "\u25B6",
  lozenge: "\u25C6",
  lozengeOutline: "\u25C7",
  hamburger: "\u2630",
  smiley: "\u32E1",
  mustache: "\u0DF4",
  star: "\u2605",
  play: "\u25B6",
  nodejs: "\u2B22",
  oneSeventh: "\u2150",
  oneNinth: "\u2151",
  oneTenth: "\u2152"
};
var specialFallbackSymbols = {
  tick: "\u221A",
  info: "i",
  warning: "\u203C",
  cross: "\xD7",
  squareSmall: "\u25A1",
  squareSmallFilled: "\u25A0",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "(\u25CB)",
  circleCross: "(\xD7)",
  circlePipe: "(\u2502)",
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[\xD7]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "(\xD7)",
  checkboxCircleOff: "( )",
  pointer: ">",
  triangleUpOutline: "\u2206",
  triangleLeft: "\u25C4",
  triangleRight: "\u25BA",
  lozenge: "\u2666",
  lozengeOutline: "\u25CA",
  hamburger: "\u2261",
  smiley: "\u263A",
  mustache: "\u250C\u2500\u2510",
  star: "\u2736",
  play: "\u25BA",
  nodejs: "\u2666",
  oneSeventh: "1/7",
  oneNinth: "1/9",
  oneTenth: "1/10"
};
var mainSymbols = { ...common, ...specialMainSymbols };
var fallbackSymbols = { ...common, ...specialFallbackSymbols };
var shouldUseMain = isUnicodeSupported();
var figures = shouldUseMain ? mainSymbols : fallbackSymbols;
var figures_default = figures;
var replacements = Object.entries(specialMainSymbols);

// node_modules/yoctocolors/base.js
var import_node_tty = __toESM(require("node:tty"), 1);
var hasColors = import_node_tty.default?.WriteStream?.prototype?.hasColors?.() ?? false;
var format = (open, close) => {
  if (!hasColors) {
    return (input) => input;
  }
  const openCode = `\x1B[${open}m`;
  const closeCode = `\x1B[${close}m`;
  return (input) => {
    const string = input + "";
    let index = string.indexOf(closeCode);
    if (index === -1) {
      return openCode + string + closeCode;
    }
    let result = openCode;
    let lastIndex = 0;
    const reopenOnNestedClose = close === 22;
    const replaceCode = (reopenOnNestedClose ? closeCode : "") + openCode;
    while (index !== -1) {
      result += string.slice(lastIndex, index) + replaceCode;
      lastIndex = index + closeCode.length;
      index = string.indexOf(closeCode, lastIndex);
    }
    result += string.slice(lastIndex) + closeCode;
    return result;
  };
};
var reset = format(0, 0);
var bold = format(1, 22);
var dim = format(2, 22);
var italic = format(3, 23);
var underline = format(4, 24);
var overline = format(53, 55);
var inverse = format(7, 27);
var hidden = format(8, 28);
var strikethrough = format(9, 29);
var black = format(30, 39);
var red = format(31, 39);
var green = format(32, 39);
var yellow = format(33, 39);
var blue = format(34, 39);
var magenta = format(35, 39);
var cyan = format(36, 39);
var white = format(37, 39);
var gray = format(90, 39);
var bgBlack = format(40, 49);
var bgRed = format(41, 49);
var bgGreen = format(42, 49);
var bgYellow = format(43, 49);
var bgBlue = format(44, 49);
var bgMagenta = format(45, 49);
var bgCyan = format(46, 49);
var bgWhite = format(47, 49);
var bgGray = format(100, 49);
var redBright = format(91, 39);
var greenBright = format(92, 39);
var yellowBright = format(93, 39);
var blueBright = format(94, 39);
var magentaBright = format(95, 39);
var cyanBright = format(96, 39);
var whiteBright = format(97, 39);
var bgRedBright = format(101, 49);
var bgGreenBright = format(102, 49);
var bgYellowBright = format(103, 49);
var bgBlueBright = format(104, 49);
var bgMagentaBright = format(105, 49);
var bgCyanBright = format(106, 49);
var bgWhiteBright = format(107, 49);

// node_modules/execa/lib/verbose/default.js
var defaultVerboseFunction = ({
  type,
  message,
  timestamp,
  piped,
  commandId,
  result: { failed = false } = {},
  options: { reject = true }
}) => {
  const timestampString = serializeTimestamp(timestamp);
  const icon = ICONS[type]({ failed, reject, piped });
  const color = COLORS[type]({ reject });
  return `${gray(`[${timestampString}]`)} ${gray(`[${commandId}]`)} ${color(icon)} ${color(message)}`;
};
var serializeTimestamp = (timestamp) => `${padField(timestamp.getHours(), 2)}:${padField(timestamp.getMinutes(), 2)}:${padField(timestamp.getSeconds(), 2)}.${padField(timestamp.getMilliseconds(), 3)}`;
var padField = (field, padding) => String(field).padStart(padding, "0");
var getFinalIcon = ({ failed, reject }) => {
  if (!failed) {
    return figures_default.tick;
  }
  return reject ? figures_default.cross : figures_default.warning;
};
var ICONS = {
  command: ({ piped }) => piped ? "|" : "$",
  output: () => " ",
  ipc: () => "*",
  error: getFinalIcon,
  duration: getFinalIcon
};
var identity = (string) => string;
var COLORS = {
  command: () => bold,
  output: () => identity,
  ipc: () => identity,
  error: ({ reject }) => reject ? redBright : yellowBright,
  duration: () => gray
};

// node_modules/execa/lib/verbose/custom.js
var applyVerboseOnLines = (printedLines, verboseInfo, fdNumber) => {
  const verboseFunction = getVerboseFunction(verboseInfo, fdNumber);
  return printedLines.map(({ verboseLine, verboseObject }) => applyVerboseFunction(verboseLine, verboseObject, verboseFunction)).filter((printedLine) => printedLine !== void 0).map((printedLine) => appendNewline(printedLine)).join("");
};
var applyVerboseFunction = (verboseLine, verboseObject, verboseFunction) => {
  if (verboseFunction === void 0) {
    return verboseLine;
  }
  const printedLine = verboseFunction(verboseLine, verboseObject);
  if (typeof printedLine === "string") {
    return printedLine;
  }
};
var appendNewline = (printedLine) => printedLine.endsWith("\n") ? printedLine : `${printedLine}
`;

// node_modules/execa/lib/verbose/log.js
var verboseLog = ({ type, verboseMessage, fdNumber, verboseInfo, result }) => {
  const verboseObject = getVerboseObject({ type, result, verboseInfo });
  const printedLines = getPrintedLines(verboseMessage, verboseObject);
  const finalLines = applyVerboseOnLines(printedLines, verboseInfo, fdNumber);
  if (finalLines !== "") {
    console.warn(finalLines.slice(0, -1));
  }
};
var getVerboseObject = ({
  type,
  result,
  verboseInfo: { escapedCommand, commandId, rawOptions: { piped = false, ...options } }
}) => ({
  type,
  escapedCommand,
  commandId: `${commandId}`,
  timestamp: /* @__PURE__ */ new Date(),
  piped,
  result,
  options
});
var getPrintedLines = (verboseMessage, verboseObject) => verboseMessage.split("\n").map((message) => getPrintedLine({ ...verboseObject, message }));
var getPrintedLine = (verboseObject) => {
  const verboseLine = defaultVerboseFunction(verboseObject);
  return { verboseLine, verboseObject };
};
var serializeVerboseMessage = (message) => {
  const messageString = typeof message === "string" ? message : (0, import_node_util3.inspect)(message);
  const escapedMessage = escapeLines(messageString);
  return escapedMessage.replaceAll("	", " ".repeat(TAB_SIZE));
};
var TAB_SIZE = 2;

// node_modules/execa/lib/verbose/start.js
var logCommand = (escapedCommand, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  verboseLog({
    type: "command",
    verboseMessage: escapedCommand,
    verboseInfo
  });
};

// node_modules/execa/lib/verbose/info.js
var getVerboseInfo = (verbose, escapedCommand, rawOptions) => {
  validateVerbose(verbose);
  const commandId = getCommandId(verbose);
  return {
    verbose,
    escapedCommand,
    commandId,
    rawOptions
  };
};
var getCommandId = (verbose) => isVerbose({ verbose }) ? COMMAND_ID++ : void 0;
var COMMAND_ID = 0n;
var validateVerbose = (verbose) => {
  for (const fdVerbose of verbose) {
    if (fdVerbose === false) {
      throw new TypeError(`The "verbose: false" option was renamed to "verbose: 'none'".`);
    }
    if (fdVerbose === true) {
      throw new TypeError(`The "verbose: true" option was renamed to "verbose: 'short'".`);
    }
    if (!VERBOSE_VALUES.includes(fdVerbose) && !isVerboseFunction(fdVerbose)) {
      const allowedValues = VERBOSE_VALUES.map((allowedValue) => `'${allowedValue}'`).join(", ");
      throw new TypeError(`The "verbose" option must not be ${fdVerbose}. Allowed values are: ${allowedValues} or a function.`);
    }
  }
};

// node_modules/execa/lib/return/duration.js
var import_node_process4 = require("node:process");
var getStartTime = () => import_node_process4.hrtime.bigint();
var getDurationMs = (startTime) => Number(import_node_process4.hrtime.bigint() - startTime) / 1e6;

// node_modules/execa/lib/arguments/command.js
var handleCommand = (filePath, rawArguments, rawOptions) => {
  const startTime = getStartTime();
  const { command, escapedCommand } = joinCommand(filePath, rawArguments);
  const verbose = normalizeFdSpecificOption(rawOptions, "verbose");
  const verboseInfo = getVerboseInfo(verbose, escapedCommand, { ...rawOptions });
  logCommand(escapedCommand, verboseInfo);
  return {
    command,
    escapedCommand,
    startTime,
    verboseInfo
  };
};

// node_modules/execa/lib/arguments/options.js
var import_node_path5 = __toESM(require("node:path"), 1);
var import_node_process8 = __toESM(require("node:process"), 1);
var import_cross_spawn = __toESM(require_cross_spawn(), 1);

// node_modules/npm-run-path/index.js
var import_node_process5 = __toESM(require("node:process"), 1);
var import_node_path2 = __toESM(require("node:path"), 1);

// node_modules/npm-run-path/node_modules/path-key/index.js
function pathKey(options = {}) {
  const {
    env: env2 = process.env,
    platform: platform2 = process.platform
  } = options;
  if (platform2 !== "win32") {
    return "PATH";
  }
  return Object.keys(env2).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// node_modules/unicorn-magic/node.js
var import_node_util4 = require("node:util");
var import_node_child_process2 = require("node:child_process");
var import_node_path = __toESM(require("node:path"), 1);
var import_node_url2 = require("node:url");
var execFileOriginal = (0, import_node_util4.promisify)(import_node_child_process2.execFile);
function toPath(urlOrPath) {
  return urlOrPath instanceof URL ? (0, import_node_url2.fileURLToPath)(urlOrPath) : urlOrPath;
}
function traversePathUp(startPath) {
  return {
    *[Symbol.iterator]() {
      let currentPath = import_node_path.default.resolve(toPath(startPath));
      let previousPath;
      while (previousPath !== currentPath) {
        yield currentPath;
        previousPath = currentPath;
        currentPath = import_node_path.default.resolve(currentPath, "..");
      }
    }
  };
}
var TEN_MEGABYTES_IN_BYTES = 10 * 1024 * 1024;

// node_modules/npm-run-path/index.js
var npmRunPath = ({
  cwd = import_node_process5.default.cwd(),
  path: pathOption = import_node_process5.default.env[pathKey()],
  preferLocal = true,
  execPath: execPath2 = import_node_process5.default.execPath,
  addExecPath = true
} = {}) => {
  const cwdPath = import_node_path2.default.resolve(toPath(cwd));
  const result = [];
  const pathParts = pathOption.split(import_node_path2.default.delimiter);
  if (preferLocal) {
    applyPreferLocal(result, pathParts, cwdPath);
  }
  if (addExecPath) {
    applyExecPath(result, pathParts, execPath2, cwdPath);
  }
  return pathOption === "" || pathOption === import_node_path2.default.delimiter ? `${result.join(import_node_path2.default.delimiter)}${pathOption}` : [...result, pathOption].join(import_node_path2.default.delimiter);
};
var applyPreferLocal = (result, pathParts, cwdPath) => {
  for (const directory of traversePathUp(cwdPath)) {
    const pathPart = import_node_path2.default.join(directory, "node_modules/.bin");
    if (!pathParts.includes(pathPart)) {
      result.push(pathPart);
    }
  }
};
var applyExecPath = (result, pathParts, execPath2, cwdPath) => {
  const pathPart = import_node_path2.default.resolve(cwdPath, toPath(execPath2), "..");
  if (!pathParts.includes(pathPart)) {
    result.push(pathPart);
  }
};
var npmRunPathEnv = ({ env: env2 = import_node_process5.default.env, ...options } = {}) => {
  env2 = { ...env2 };
  const pathName = pathKey({ env: env2 });
  options.path = env2[pathName];
  env2[pathName] = npmRunPath(options);
  return env2;
};

// node_modules/execa/lib/terminate/kill.js
var import_promises = require("node:timers/promises");

// node_modules/execa/lib/return/final-error.js
var getFinalError = (originalError, message, isSync) => {
  const ErrorClass = isSync ? ExecaSyncError : ExecaError;
  const options = originalError instanceof DiscardedError ? {} : { cause: originalError };
  return new ErrorClass(message, options);
};
var DiscardedError = class extends Error {
};
var setErrorName = (ErrorClass, value) => {
  Object.defineProperty(ErrorClass.prototype, "name", {
    value,
    writable: true,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ErrorClass.prototype, execaErrorSymbol, {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
};
var isExecaError = (error) => isErrorInstance(error) && execaErrorSymbol in error;
var execaErrorSymbol = Symbol("isExecaError");
var isErrorInstance = (value) => Object.prototype.toString.call(value) === "[object Error]";
var ExecaError = class extends Error {
};
setErrorName(ExecaError, ExecaError.name);
var ExecaSyncError = class extends Error {
};
setErrorName(ExecaSyncError, ExecaSyncError.name);

// node_modules/execa/lib/terminate/signal.js
var import_node_os3 = require("node:os");

// node_modules/human-signals/build/src/main.js
var import_node_os2 = require("node:os");

// node_modules/human-signals/build/src/realtime.js
var getRealtimeSignals = () => {
  const length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
};
var getRealtimeSignal = (value, index) => ({
  name: `SIGRT${index + 1}`,
  number: SIGRTMIN + index,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
});
var SIGRTMIN = 34;
var SIGRTMAX = 64;

// node_modules/human-signals/build/src/signals.js
var import_node_os = require("node:os");

// node_modules/human-signals/build/src/core.js
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: true
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// node_modules/human-signals/build/src/signals.js
var getSignals = () => {
  const realtimeSignals = getRealtimeSignals();
  const signals2 = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
  return signals2;
};
var normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = false,
  standard
}) => {
  const {
    signals: { [name]: constantSignal }
  } = import_node_os.constants;
  const supported = constantSignal !== void 0;
  const number = supported ? constantSignal : defaultNumber;
  return { name, number, description, supported, action, forced, standard };
};

// node_modules/human-signals/build/src/main.js
var getSignalsByName = () => {
  const signals2 = getSignals();
  return Object.fromEntries(signals2.map(getSignalByName));
};
var getSignalByName = ({
  name,
  number,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number, description, supported, action, forced, standard }];
var signalsByName = getSignalsByName();
var getSignalsByNumber = () => {
  const signals2 = getSignals();
  const length = SIGRTMAX + 1;
  const signalsA = Array.from(
    { length },
    (value, number) => getSignalByNumber(number, signals2)
  );
  return Object.assign({}, ...signalsA);
};
var getSignalByNumber = (number, signals2) => {
  const signal = findSignalByNumber(number, signals2);
  if (signal === void 0) {
    return {};
  }
  const { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
};
var findSignalByNumber = (number, signals2) => {
  const signal = signals2.find(({ name }) => import_node_os2.constants.signals[name] === number);
  if (signal !== void 0) {
    return signal;
  }
  return signals2.find((signalA) => signalA.number === number);
};
var signalsByNumber = getSignalsByNumber();

// node_modules/execa/lib/terminate/signal.js
var normalizeKillSignal = (killSignal) => {
  const optionName = "option `killSignal`";
  if (killSignal === 0) {
    throw new TypeError(`Invalid ${optionName}: 0 cannot be used.`);
  }
  return normalizeSignal2(killSignal, optionName);
};
var normalizeSignalArgument = (signal) => signal === 0 ? signal : normalizeSignal2(signal, "`subprocess.kill()`'s argument");
var normalizeSignal2 = (signalNameOrInteger, optionName) => {
  if (Number.isInteger(signalNameOrInteger)) {
    return normalizeSignalInteger(signalNameOrInteger, optionName);
  }
  if (typeof signalNameOrInteger === "string") {
    return normalizeSignalName(signalNameOrInteger, optionName);
  }
  throw new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.
${getAvailableSignals()}`);
};
var normalizeSignalInteger = (signalInteger, optionName) => {
  if (signalsIntegerToName.has(signalInteger)) {
    return signalsIntegerToName.get(signalInteger);
  }
  throw new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.
${getAvailableSignals()}`);
};
var getSignalsIntegerToName = () => new Map(Object.entries(import_node_os3.constants.signals).reverse().map(([signalName, signalInteger]) => [signalInteger, signalName]));
var signalsIntegerToName = getSignalsIntegerToName();
var normalizeSignalName = (signalName, optionName) => {
  if (signalName in import_node_os3.constants.signals) {
    return signalName;
  }
  if (signalName.toUpperCase() in import_node_os3.constants.signals) {
    throw new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);
  }
  throw new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.
${getAvailableSignals()}`);
};
var getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.
Available signal numbers: ${getAvailableSignalIntegers()}.`;
var getAvailableSignalNames = () => Object.keys(import_node_os3.constants.signals).sort().map((signalName) => `'${signalName}'`).join(", ");
var getAvailableSignalIntegers = () => [...new Set(Object.values(import_node_os3.constants.signals).sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))].join(", ");
var getSignalDescription = (signal) => signalsByName[signal].description;

// node_modules/execa/lib/terminate/kill.js
var normalizeForceKillAfterDelay = (forceKillAfterDelay) => {
  if (forceKillAfterDelay === false) {
    return forceKillAfterDelay;
  }
  if (forceKillAfterDelay === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {
    throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${forceKillAfterDelay}\` (${typeof forceKillAfterDelay})`);
  }
  return forceKillAfterDelay;
};
var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
var subprocessKill = ({ kill, options: { forceKillAfterDelay, killSignal }, onInternalError, context, controller }, signalOrError, errorArgument) => {
  const { signal, error } = parseKillArguments(signalOrError, errorArgument, killSignal);
  emitKillError(error, onInternalError);
  const killResult = kill(signal);
  setKillTimeout({
    kill,
    signal,
    forceKillAfterDelay,
    killSignal,
    killResult,
    context,
    controller
  });
  return killResult;
};
var parseKillArguments = (signalOrError, errorArgument, killSignal) => {
  const [signal = killSignal, error] = isErrorInstance(signalOrError) ? [void 0, signalOrError] : [signalOrError, errorArgument];
  if (typeof signal !== "string" && !Number.isInteger(signal)) {
    throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);
  }
  if (error !== void 0 && !isErrorInstance(error)) {
    throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);
  }
  return { signal: normalizeSignalArgument(signal), error };
};
var emitKillError = (error, onInternalError) => {
  if (error !== void 0) {
    onInternalError.reject(error);
  }
};
var setKillTimeout = async ({ kill, signal, forceKillAfterDelay, killSignal, killResult, context, controller }) => {
  if (signal === killSignal && killResult) {
    killOnTimeout({
      kill,
      forceKillAfterDelay,
      context,
      controllerSignal: controller.signal
    });
  }
};
var killOnTimeout = async ({ kill, forceKillAfterDelay, context, controllerSignal }) => {
  if (forceKillAfterDelay === false) {
    return;
  }
  try {
    await (0, import_promises.setTimeout)(forceKillAfterDelay, void 0, { signal: controllerSignal });
    if (kill("SIGKILL")) {
      context.isForcefullyTerminated ??= true;
    }
  } catch {
  }
};

// node_modules/execa/lib/utils/abort-signal.js
var import_node_events = require("node:events");
var onAbortedSignal = async (mainSignal, stopSignal) => {
  if (!mainSignal.aborted) {
    await (0, import_node_events.once)(mainSignal, "abort", { signal: stopSignal });
  }
};

// node_modules/execa/lib/terminate/cancel.js
var validateCancelSignal = ({ cancelSignal }) => {
  if (cancelSignal !== void 0 && Object.prototype.toString.call(cancelSignal) !== "[object AbortSignal]") {
    throw new Error(`The \`cancelSignal\` option must be an AbortSignal: ${String(cancelSignal)}`);
  }
};
var throwOnCancel = ({ subprocess, cancelSignal, gracefulCancel, context, controller }) => cancelSignal === void 0 || gracefulCancel ? [] : [terminateOnCancel(subprocess, cancelSignal, context, controller)];
var terminateOnCancel = async (subprocess, cancelSignal, context, { signal }) => {
  await onAbortedSignal(cancelSignal, signal);
  context.terminationReason ??= "cancel";
  subprocess.kill();
  throw cancelSignal.reason;
};

// node_modules/execa/lib/ipc/graceful.js
var import_promises3 = require("node:timers/promises");

// node_modules/execa/lib/ipc/send.js
var import_node_util5 = require("node:util");

// node_modules/execa/lib/ipc/validation.js
var validateIpcMethod = ({ methodName, isSubprocess, ipc, isConnected: isConnected2 }) => {
  validateIpcOption(methodName, isSubprocess, ipc);
  validateConnection(methodName, isSubprocess, isConnected2);
};
var validateIpcOption = (methodName, isSubprocess, ipc) => {
  if (!ipc) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} can only be used if the \`ipc\` option is \`true\`.`);
  }
};
var validateConnection = (methodName, isSubprocess, isConnected2) => {
  if (!isConnected2) {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} has already exited or disconnected.`);
  }
};
var throwOnEarlyDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("getOneMessage", isSubprocess)} could not complete: the ${getOtherProcessName(isSubprocess)} exited or disconnected.`);
};
var throwOnStrictDeadlockError = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is sending a message too, instead of listening to incoming messages.
This can be fixed by both sending a message and listening to incoming messages at the same time:

const [receivedMessage] = await Promise.all([
	${getMethodName("getOneMessage", isSubprocess)},
	${getMethodName("sendMessage", isSubprocess, "message, {strict: true}")},
]);`);
};
var getStrictResponseError = (error, isSubprocess) => new Error(`${getMethodName("sendMessage", isSubprocess)} failed when sending an acknowledgment response to the ${getOtherProcessName(isSubprocess)}.`, { cause: error });
var throwOnMissingStrict = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} is not listening to incoming messages.`);
};
var throwOnStrictDisconnect = (isSubprocess) => {
  throw new Error(`${getMethodName("sendMessage", isSubprocess)} failed: the ${getOtherProcessName(isSubprocess)} exited without listening to incoming messages.`);
};
var getAbortDisconnectError = () => new Error(`\`cancelSignal\` aborted: the ${getOtherProcessName(true)} disconnected.`);
var throwOnMissingParent = () => {
  throw new Error("`getCancelSignal()` cannot be used without setting the `cancelSignal` subprocess option.");
};
var handleEpipeError = ({ error, methodName, isSubprocess }) => {
  if (error.code === "EPIPE") {
    throw new Error(`${getMethodName(methodName, isSubprocess)} cannot be used: the ${getOtherProcessName(isSubprocess)} is disconnecting.`, { cause: error });
  }
};
var handleSerializationError = ({ error, methodName, isSubprocess, message }) => {
  if (isSerializationError(error)) {
    throw new Error(`${getMethodName(methodName, isSubprocess)}'s argument type is invalid: the message cannot be serialized: ${String(message)}.`, { cause: error });
  }
};
var isSerializationError = ({ code: code2, message }) => SERIALIZATION_ERROR_CODES.has(code2) || SERIALIZATION_ERROR_MESSAGES.some((serializationErrorMessage) => message.includes(serializationErrorMessage));
var SERIALIZATION_ERROR_CODES = /* @__PURE__ */ new Set([
  // Message is `undefined`
  "ERR_MISSING_ARGS",
  // Message is a function, a bigint, a symbol
  "ERR_INVALID_ARG_TYPE"
]);
var SERIALIZATION_ERROR_MESSAGES = [
  // Message is a promise or a proxy, with `serialization: 'advanced'`
  "could not be cloned",
  // Message has cycles, with `serialization: 'json'`
  "circular structure",
  // Message has cycles inside toJSON(), with `serialization: 'json'`
  "call stack size exceeded"
];
var getMethodName = (methodName, isSubprocess, parameters = "") => methodName === "cancelSignal" ? "`cancelSignal`'s `controller.abort()`" : `${getNamespaceName(isSubprocess)}${methodName}(${parameters})`;
var getNamespaceName = (isSubprocess) => isSubprocess ? "" : "subprocess.";
var getOtherProcessName = (isSubprocess) => isSubprocess ? "parent process" : "subprocess";
var disconnect = (anyProcess) => {
  if (anyProcess.connected) {
    anyProcess.disconnect();
  }
};

// node_modules/execa/lib/utils/deferred.js
var createDeferred = () => {
  const methods = {};
  const promise = new Promise((resolve4, reject) => {
    Object.assign(methods, { resolve: resolve4, reject });
  });
  return Object.assign(promise, methods);
};

// node_modules/execa/lib/arguments/fd-options.js
var getToStream = (destination, to = "stdin") => {
  const isWritable2 = true;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(destination);
  const fdNumber = getFdNumber(fileDescriptors, to, isWritable2);
  const destinationStream = destination.stdio[fdNumber];
  if (destinationStream === null) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable2));
  }
  return destinationStream;
};
var getFromStream = (source, from = "stdout") => {
  const isWritable2 = false;
  const { options, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  const fdNumber = getFdNumber(fileDescriptors, from, isWritable2);
  const sourceStream = fdNumber === "all" ? source.all : source.stdio[fdNumber];
  if (sourceStream === null || sourceStream === void 0) {
    throw new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable2));
  }
  return sourceStream;
};
var SUBPROCESS_OPTIONS = /* @__PURE__ */ new WeakMap();
var getFdNumber = (fileDescriptors, fdName, isWritable2) => {
  const fdNumber = parseFdNumber(fdName, isWritable2);
  validateFdNumber(fdNumber, fdName, isWritable2, fileDescriptors);
  return fdNumber;
};
var parseFdNumber = (fdName, isWritable2) => {
  const fdNumber = parseFd(fdName);
  if (fdNumber !== void 0) {
    return fdNumber;
  }
  const { validOptions, defaultValue } = isWritable2 ? { validOptions: '"stdin"', defaultValue: "stdin" } : { validOptions: '"stdout", "stderr", "all"', defaultValue: "stdout" };
  throw new TypeError(`"${getOptionName(isWritable2)}" must not be "${fdName}".
It must be ${validOptions} or "fd3", "fd4" (and so on).
It is optional and defaults to "${defaultValue}".`);
};
var validateFdNumber = (fdNumber, fdName, isWritable2, fileDescriptors) => {
  const fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];
  if (fileDescriptor === void 0) {
    throw new TypeError(`"${getOptionName(isWritable2)}" must not be ${fdName}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);
  }
  if (fileDescriptor.direction === "input" && !isWritable2) {
    throw new TypeError(`"${getOptionName(isWritable2)}" must not be ${fdName}. It must be a readable stream, not writable.`);
  }
  if (fileDescriptor.direction !== "input" && isWritable2) {
    throw new TypeError(`"${getOptionName(isWritable2)}" must not be ${fdName}. It must be a writable stream, not readable.`);
  }
};
var getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable2) => {
  if (fdNumber === "all" && !options.all) {
    return `The "all" option must be true to use "from: 'all'".`;
  }
  const { optionName, optionValue } = getInvalidStdioOption(fdNumber, options);
  return `The "${optionName}: ${serializeOptionValue(optionValue)}" option is incompatible with using "${getOptionName(isWritable2)}: ${serializeOptionValue(fdName)}".
Please set this option with "pipe" instead.`;
};
var getInvalidStdioOption = (fdNumber, { stdin, stdout, stderr, stdio }) => {
  const usedDescriptor = getUsedDescriptor(fdNumber);
  if (usedDescriptor === 0 && stdin !== void 0) {
    return { optionName: "stdin", optionValue: stdin };
  }
  if (usedDescriptor === 1 && stdout !== void 0) {
    return { optionName: "stdout", optionValue: stdout };
  }
  if (usedDescriptor === 2 && stderr !== void 0) {
    return { optionName: "stderr", optionValue: stderr };
  }
  return { optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor] };
};
var getUsedDescriptor = (fdNumber) => fdNumber === "all" ? 1 : fdNumber;
var getOptionName = (isWritable2) => isWritable2 ? "to" : "from";
var serializeOptionValue = (value) => {
  if (typeof value === "string") {
    return `'${value}'`;
  }
  return typeof value === "number" ? `${value}` : "Stream";
};

// node_modules/execa/lib/ipc/strict.js
var import_node_events5 = require("node:events");

// node_modules/execa/lib/utils/max-listeners.js
var import_node_events2 = require("node:events");
var incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {
  const maxListeners = eventEmitter.getMaxListeners();
  if (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {
    return;
  }
  eventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);
  (0, import_node_events2.addAbortListener)(signal, () => {
    eventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);
  });
};

// node_modules/execa/lib/ipc/forward.js
var import_node_events4 = require("node:events");

// node_modules/execa/lib/ipc/incoming.js
var import_node_events3 = require("node:events");
var import_promises2 = require("node:timers/promises");

// node_modules/execa/lib/ipc/reference.js
var addReference = (channel, reference2) => {
  if (reference2) {
    addReferenceCount(channel);
  }
};
var addReferenceCount = (channel) => {
  channel.refCounted();
};
var removeReference = (channel, reference2) => {
  if (reference2) {
    removeReferenceCount(channel);
  }
};
var removeReferenceCount = (channel) => {
  channel.unrefCounted();
};
var undoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    removeReferenceCount(channel);
    removeReferenceCount(channel);
  }
};
var redoAddedReferences = (channel, isSubprocess) => {
  if (isSubprocess) {
    addReferenceCount(channel);
    addReferenceCount(channel);
  }
};

// node_modules/execa/lib/ipc/incoming.js
var onMessage = async ({ anyProcess, channel, isSubprocess, ipcEmitter }, wrappedMessage) => {
  if (handleStrictResponse(wrappedMessage) || handleAbort(wrappedMessage)) {
    return;
  }
  if (!INCOMING_MESSAGES.has(anyProcess)) {
    INCOMING_MESSAGES.set(anyProcess, []);
  }
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  incomingMessages.push(wrappedMessage);
  if (incomingMessages.length > 1) {
    return;
  }
  while (incomingMessages.length > 0) {
    await waitForOutgoingMessages(anyProcess, ipcEmitter, wrappedMessage);
    await import_promises2.scheduler.yield();
    const message = await handleStrictRequest({
      wrappedMessage: incomingMessages[0],
      anyProcess,
      channel,
      isSubprocess,
      ipcEmitter
    });
    incomingMessages.shift();
    ipcEmitter.emit("message", message);
    ipcEmitter.emit("message:done");
  }
};
var onDisconnect = async ({ anyProcess, channel, isSubprocess, ipcEmitter, boundOnMessage }) => {
  abortOnDisconnect();
  const incomingMessages = INCOMING_MESSAGES.get(anyProcess);
  while (incomingMessages?.length > 0) {
    await (0, import_node_events3.once)(ipcEmitter, "message:done");
  }
  anyProcess.removeListener("message", boundOnMessage);
  redoAddedReferences(channel, isSubprocess);
  ipcEmitter.connected = false;
  ipcEmitter.emit("disconnect");
};
var INCOMING_MESSAGES = /* @__PURE__ */ new WeakMap();

// node_modules/execa/lib/ipc/forward.js
var getIpcEmitter = (anyProcess, channel, isSubprocess) => {
  if (IPC_EMITTERS.has(anyProcess)) {
    return IPC_EMITTERS.get(anyProcess);
  }
  const ipcEmitter = new import_node_events4.EventEmitter();
  ipcEmitter.connected = true;
  IPC_EMITTERS.set(anyProcess, ipcEmitter);
  forwardEvents({
    ipcEmitter,
    anyProcess,
    channel,
    isSubprocess
  });
  return ipcEmitter;
};
var IPC_EMITTERS = /* @__PURE__ */ new WeakMap();
var forwardEvents = ({ ipcEmitter, anyProcess, channel, isSubprocess }) => {
  const boundOnMessage = onMessage.bind(void 0, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter
  });
  anyProcess.on("message", boundOnMessage);
  anyProcess.once("disconnect", onDisconnect.bind(void 0, {
    anyProcess,
    channel,
    isSubprocess,
    ipcEmitter,
    boundOnMessage
  }));
  undoAddedReferences(channel, isSubprocess);
};
var isConnected = (anyProcess) => {
  const ipcEmitter = IPC_EMITTERS.get(anyProcess);
  return ipcEmitter === void 0 ? anyProcess.channel !== null : ipcEmitter.connected;
};

// node_modules/execa/lib/ipc/strict.js
var handleSendStrict = ({ anyProcess, channel, isSubprocess, message, strict }) => {
  if (!strict) {
    return message;
  }
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const hasListeners = hasMessageListeners(anyProcess, ipcEmitter);
  return {
    id: count++,
    type: REQUEST_TYPE,
    message,
    hasListeners
  };
};
var count = 0n;
var validateStrictDeadlock = (outgoingMessages, wrappedMessage) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || wrappedMessage.hasListeners) {
    return;
  }
  for (const { id } of outgoingMessages) {
    if (id !== void 0) {
      STRICT_RESPONSES[id].resolve({ isDeadlock: true, hasListeners: false });
    }
  }
};
var handleStrictRequest = async ({ wrappedMessage, anyProcess, channel, isSubprocess, ipcEmitter }) => {
  if (wrappedMessage?.type !== REQUEST_TYPE || !anyProcess.connected) {
    return wrappedMessage;
  }
  const { id, message } = wrappedMessage;
  const response = { id, type: RESPONSE_TYPE, message: hasMessageListeners(anyProcess, ipcEmitter) };
  try {
    await sendMessage({
      anyProcess,
      channel,
      isSubprocess,
      ipc: true
    }, response);
  } catch (error) {
    ipcEmitter.emit("strict:error", error);
  }
  return message;
};
var handleStrictResponse = (wrappedMessage) => {
  if (wrappedMessage?.type !== RESPONSE_TYPE) {
    return false;
  }
  const { id, message: hasListeners } = wrappedMessage;
  STRICT_RESPONSES[id]?.resolve({ isDeadlock: false, hasListeners });
  return true;
};
var waitForStrictResponse = async (wrappedMessage, anyProcess, isSubprocess) => {
  if (wrappedMessage?.type !== REQUEST_TYPE) {
    return;
  }
  const deferred = createDeferred();
  STRICT_RESPONSES[wrappedMessage.id] = deferred;
  const controller = new AbortController();
  try {
    const { isDeadlock, hasListeners } = await Promise.race([
      deferred,
      throwOnDisconnect(anyProcess, isSubprocess, controller)
    ]);
    if (isDeadlock) {
      throwOnStrictDeadlockError(isSubprocess);
    }
    if (!hasListeners) {
      throwOnMissingStrict(isSubprocess);
    }
  } finally {
    controller.abort();
    delete STRICT_RESPONSES[wrappedMessage.id];
  }
};
var STRICT_RESPONSES = {};
var throwOnDisconnect = async (anyProcess, isSubprocess, { signal }) => {
  incrementMaxListeners(anyProcess, 1, signal);
  await (0, import_node_events5.once)(anyProcess, "disconnect", { signal });
  throwOnStrictDisconnect(isSubprocess);
};
var REQUEST_TYPE = "execa:ipc:request";
var RESPONSE_TYPE = "execa:ipc:response";

// node_modules/execa/lib/ipc/outgoing.js
var startSendMessage = (anyProcess, wrappedMessage, strict) => {
  if (!OUTGOING_MESSAGES.has(anyProcess)) {
    OUTGOING_MESSAGES.set(anyProcess, /* @__PURE__ */ new Set());
  }
  const outgoingMessages = OUTGOING_MESSAGES.get(anyProcess);
  const onMessageSent = createDeferred();
  const id = strict ? wrappedMessage.id : void 0;
  const outgoingMessage = { onMessageSent, id };
  outgoingMessages.add(outgoingMessage);
  return { outgoingMessages, outgoingMessage };
};
var endSendMessage = ({ outgoingMessages, outgoingMessage }) => {
  outgoingMessages.delete(outgoingMessage);
  outgoingMessage.onMessageSent.resolve();
};
var waitForOutgoingMessages = async (anyProcess, ipcEmitter, wrappedMessage) => {
  while (!hasMessageListeners(anyProcess, ipcEmitter) && OUTGOING_MESSAGES.get(anyProcess)?.size > 0) {
    const outgoingMessages = [...OUTGOING_MESSAGES.get(anyProcess)];
    validateStrictDeadlock(outgoingMessages, wrappedMessage);
    await Promise.all(outgoingMessages.map(({ onMessageSent }) => onMessageSent));
  }
};
var OUTGOING_MESSAGES = /* @__PURE__ */ new WeakMap();
var hasMessageListeners = (anyProcess, ipcEmitter) => ipcEmitter.listenerCount("message") > getMinListenerCount(anyProcess);
var getMinListenerCount = (anyProcess) => SUBPROCESS_OPTIONS.has(anyProcess) && !getFdSpecificValue(SUBPROCESS_OPTIONS.get(anyProcess).options.buffer, "ipc") ? 1 : 0;

// node_modules/execa/lib/ipc/send.js
var sendMessage = ({ anyProcess, channel, isSubprocess, ipc }, message, { strict = false } = {}) => {
  const methodName = "sendMessage";
  validateIpcMethod({
    methodName,
    isSubprocess,
    ipc,
    isConnected: anyProcess.connected
  });
  return sendMessageAsync({
    anyProcess,
    channel,
    methodName,
    isSubprocess,
    message,
    strict
  });
};
var sendMessageAsync = async ({ anyProcess, channel, methodName, isSubprocess, message, strict }) => {
  const wrappedMessage = handleSendStrict({
    anyProcess,
    channel,
    isSubprocess,
    message,
    strict
  });
  const outgoingMessagesState = startSendMessage(anyProcess, wrappedMessage, strict);
  try {
    await sendOneMessage({
      anyProcess,
      methodName,
      isSubprocess,
      wrappedMessage,
      message
    });
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    endSendMessage(outgoingMessagesState);
  }
};
var sendOneMessage = async ({ anyProcess, methodName, isSubprocess, wrappedMessage, message }) => {
  const sendMethod = getSendMethod(anyProcess);
  try {
    await Promise.all([
      waitForStrictResponse(wrappedMessage, anyProcess, isSubprocess),
      sendMethod(wrappedMessage)
    ]);
  } catch (error) {
    handleEpipeError({ error, methodName, isSubprocess });
    handleSerializationError({
      error,
      methodName,
      isSubprocess,
      message
    });
    throw error;
  }
};
var getSendMethod = (anyProcess) => {
  if (PROCESS_SEND_METHODS.has(anyProcess)) {
    return PROCESS_SEND_METHODS.get(anyProcess);
  }
  const sendMethod = (0, import_node_util5.promisify)(anyProcess.send.bind(anyProcess));
  PROCESS_SEND_METHODS.set(anyProcess, sendMethod);
  return sendMethod;
};
var PROCESS_SEND_METHODS = /* @__PURE__ */ new WeakMap();

// node_modules/execa/lib/ipc/graceful.js
var sendAbort = (subprocess, message) => {
  const methodName = "cancelSignal";
  validateConnection(methodName, false, subprocess.connected);
  return sendOneMessage({
    anyProcess: subprocess,
    methodName,
    isSubprocess: false,
    wrappedMessage: { type: GRACEFUL_CANCEL_TYPE, message },
    message
  });
};
var getCancelSignal = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  await startIpc({
    anyProcess,
    channel,
    isSubprocess,
    ipc
  });
  return cancelController.signal;
};
var startIpc = async ({ anyProcess, channel, isSubprocess, ipc }) => {
  if (cancelListening) {
    return;
  }
  cancelListening = true;
  if (!ipc) {
    throwOnMissingParent();
    return;
  }
  if (channel === null) {
    abortOnDisconnect();
    return;
  }
  getIpcEmitter(anyProcess, channel, isSubprocess);
  await import_promises3.scheduler.yield();
};
var cancelListening = false;
var handleAbort = (wrappedMessage) => {
  if (wrappedMessage?.type !== GRACEFUL_CANCEL_TYPE) {
    return false;
  }
  cancelController.abort(wrappedMessage.message);
  return true;
};
var GRACEFUL_CANCEL_TYPE = "execa:ipc:cancel";
var abortOnDisconnect = () => {
  cancelController.abort(getAbortDisconnectError());
};
var cancelController = new AbortController();

// node_modules/execa/lib/terminate/graceful.js
var validateGracefulCancel = ({ gracefulCancel, cancelSignal, ipc, serialization }) => {
  if (!gracefulCancel) {
    return;
  }
  if (cancelSignal === void 0) {
    throw new Error("The `cancelSignal` option must be defined when setting the `gracefulCancel` option.");
  }
  if (!ipc) {
    throw new Error("The `ipc` option cannot be false when setting the `gracefulCancel` option.");
  }
  if (serialization === "json") {
    throw new Error("The `serialization` option cannot be 'json' when setting the `gracefulCancel` option.");
  }
};
var throwOnGracefulCancel = ({
  subprocess,
  cancelSignal,
  gracefulCancel,
  forceKillAfterDelay,
  context,
  controller
}) => gracefulCancel ? [sendOnAbort({
  subprocess,
  cancelSignal,
  forceKillAfterDelay,
  context,
  controller
})] : [];
var sendOnAbort = async ({ subprocess, cancelSignal, forceKillAfterDelay, context, controller: { signal } }) => {
  await onAbortedSignal(cancelSignal, signal);
  const reason = getReason(cancelSignal);
  await sendAbort(subprocess, reason);
  killOnTimeout({
    kill: subprocess.kill,
    forceKillAfterDelay,
    context,
    controllerSignal: signal
  });
  context.terminationReason ??= "gracefulCancel";
  throw cancelSignal.reason;
};
var getReason = ({ reason }) => {
  if (!(reason instanceof DOMException)) {
    return reason;
  }
  const error = new Error(reason.message);
  Object.defineProperty(error, "stack", {
    value: reason.stack,
    enumerable: false,
    configurable: true,
    writable: true
  });
  return error;
};

// node_modules/execa/lib/terminate/timeout.js
var import_promises4 = require("node:timers/promises");
var validateTimeout = ({ timeout }) => {
  if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
  }
};
var throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === void 0 ? [] : [killAfterTimeout(subprocess, timeout, context, controller)];
var killAfterTimeout = async (subprocess, timeout, context, { signal }) => {
  await (0, import_promises4.setTimeout)(timeout, void 0, { signal });
  context.terminationReason ??= "timeout";
  subprocess.kill();
  throw new DiscardedError();
};

// node_modules/execa/lib/methods/node.js
var import_node_process6 = require("node:process");
var import_node_path3 = __toESM(require("node:path"), 1);
var mapNode = ({ options }) => {
  if (options.node === false) {
    throw new TypeError('The "node" option cannot be false with `execaNode()`.');
  }
  return { options: { ...options, node: true } };
};
var handleNodeOption = (file, commandArguments, {
  node: shouldHandleNode = false,
  nodePath = import_node_process6.execPath,
  nodeOptions = import_node_process6.execArgv.filter((nodeOption) => !nodeOption.startsWith("--inspect")),
  cwd,
  execPath: formerNodePath,
  ...options
}) => {
  if (formerNodePath !== void 0) {
    throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');
  }
  const normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The "nodePath" option');
  const resolvedNodePath = import_node_path3.default.resolve(cwd, normalizedNodePath);
  const newOptions = {
    ...options,
    nodePath: resolvedNodePath,
    node: shouldHandleNode,
    cwd
  };
  if (!shouldHandleNode) {
    return [file, commandArguments, newOptions];
  }
  if (import_node_path3.default.basename(file, ".exe") === "node") {
    throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');
  }
  return [
    resolvedNodePath,
    [...nodeOptions, file, ...commandArguments],
    { ipc: true, ...newOptions, shell: false }
  ];
};

// node_modules/execa/lib/ipc/ipc-input.js
var import_node_v8 = require("node:v8");
var validateIpcInputOption = ({ ipcInput, ipc, serialization }) => {
  if (ipcInput === void 0) {
    return;
  }
  if (!ipc) {
    throw new Error("The `ipcInput` option cannot be set unless the `ipc` option is `true`.");
  }
  validateIpcInput[serialization](ipcInput);
};
var validateAdvancedInput = (ipcInput) => {
  try {
    (0, import_node_v8.serialize)(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with a structured clone.", { cause: error });
  }
};
var validateJsonInput = (ipcInput) => {
  try {
    JSON.stringify(ipcInput);
  } catch (error) {
    throw new Error("The `ipcInput` option is not serializable with JSON.", { cause: error });
  }
};
var validateIpcInput = {
  advanced: validateAdvancedInput,
  json: validateJsonInput
};
var sendIpcInput = async (subprocess, ipcInput) => {
  if (ipcInput === void 0) {
    return;
  }
  await subprocess.sendMessage(ipcInput);
};

// node_modules/execa/lib/arguments/encoding-option.js
var validateEncoding = ({ encoding }) => {
  if (ENCODINGS.has(encoding)) {
    return;
  }
  const correctEncoding = getCorrectEncoding(encoding);
  if (correctEncoding !== void 0) {
    throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to ${serializeEncoding(correctEncoding)}.`);
  }
  const correctEncodings = [...ENCODINGS].map((correctEncoding2) => serializeEncoding(correctEncoding2)).join(", ");
  throw new TypeError(`Invalid option \`encoding: ${serializeEncoding(encoding)}\`.
Please rename it to one of: ${correctEncodings}.`);
};
var TEXT_ENCODINGS = /* @__PURE__ */ new Set(["utf8", "utf16le"]);
var BINARY_ENCODINGS = /* @__PURE__ */ new Set(["buffer", "hex", "base64", "base64url", "latin1", "ascii"]);
var ENCODINGS = /* @__PURE__ */ new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);
var getCorrectEncoding = (encoding) => {
  if (encoding === null) {
    return "buffer";
  }
  if (typeof encoding !== "string") {
    return;
  }
  const lowerEncoding = encoding.toLowerCase();
  if (lowerEncoding in ENCODING_ALIASES) {
    return ENCODING_ALIASES[lowerEncoding];
  }
  if (ENCODINGS.has(lowerEncoding)) {
    return lowerEncoding;
  }
};
var ENCODING_ALIASES = {
  // eslint-disable-next-line unicorn/text-encoding-identifier-case
  "utf-8": "utf8",
  "utf-16le": "utf16le",
  "ucs-2": "utf16le",
  ucs2: "utf16le",
  binary: "latin1"
};
var serializeEncoding = (encoding) => typeof encoding === "string" ? `"${encoding}"` : String(encoding);

// node_modules/execa/lib/arguments/cwd.js
var import_node_fs = require("node:fs");
var import_node_path4 = __toESM(require("node:path"), 1);
var import_node_process7 = __toESM(require("node:process"), 1);
var normalizeCwd = (cwd = getDefaultCwd()) => {
  const cwdString = safeNormalizeFileUrl(cwd, 'The "cwd" option');
  return import_node_path4.default.resolve(cwdString);
};
var getDefaultCwd = () => {
  try {
    return import_node_process7.default.cwd();
  } catch (error) {
    error.message = `The current directory does not exist.
${error.message}`;
    throw error;
  }
};
var fixCwdError = (originalMessage, cwd) => {
  if (cwd === getDefaultCwd()) {
    return originalMessage;
  }
  let cwdStat;
  try {
    cwdStat = (0, import_node_fs.statSync)(cwd);
  } catch (error) {
    return `The "cwd" option is invalid: ${cwd}.
${error.message}
${originalMessage}`;
  }
  if (!cwdStat.isDirectory()) {
    return `The "cwd" option is not a directory: ${cwd}.
${originalMessage}`;
  }
  return originalMessage;
};

// node_modules/execa/lib/arguments/options.js
var normalizeOptions = (filePath, rawArguments, rawOptions) => {
  rawOptions.cwd = normalizeCwd(rawOptions.cwd);
  const [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);
  const { command: file, args: commandArguments, options: initialOptions } = import_cross_spawn.default._parse(processedFile, processedArguments, processedOptions);
  const fdOptions = normalizeFdSpecificOptions(initialOptions);
  const options = addDefaultOptions(fdOptions);
  validateTimeout(options);
  validateEncoding(options);
  validateIpcInputOption(options);
  validateCancelSignal(options);
  validateGracefulCancel(options);
  options.shell = normalizeFileUrl(options.shell);
  options.env = getEnv(options);
  options.killSignal = normalizeKillSignal(options.killSignal);
  options.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);
  options.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);
  if (import_node_process8.default.platform === "win32" && import_node_path5.default.basename(file, ".exe") === "cmd") {
    commandArguments.unshift("/q");
  }
  return { file, commandArguments, options };
};
var addDefaultOptions = ({
  extendEnv = true,
  preferLocal = false,
  cwd,
  localDir: localDirectory = cwd,
  encoding = "utf8",
  reject = true,
  cleanup = true,
  all: all3 = false,
  windowsHide = true,
  killSignal = "SIGTERM",
  forceKillAfterDelay = true,
  gracefulCancel = false,
  ipcInput,
  ipc = ipcInput !== void 0 || gracefulCancel,
  serialization = "advanced",
  ...options
}) => ({
  ...options,
  extendEnv,
  preferLocal,
  cwd,
  localDirectory,
  encoding,
  reject,
  cleanup,
  all: all3,
  windowsHide,
  killSignal,
  forceKillAfterDelay,
  gracefulCancel,
  ipcInput,
  ipc,
  serialization
});
var getEnv = ({ env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath }) => {
  const env2 = extendEnv ? { ...import_node_process8.default.env, ...envOption } : envOption;
  if (preferLocal || node) {
    return npmRunPathEnv({
      env: env2,
      cwd: localDirectory,
      execPath: nodePath,
      preferLocal,
      addExecPath: node
    });
  }
  return env2;
};

// node_modules/execa/lib/arguments/shell.js
var concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0 ? [[file, ...commandArguments].join(" "), [], options] : [file, commandArguments, options];

// node_modules/execa/lib/return/message.js
var import_node_util6 = require("node:util");

// node_modules/strip-final-newline/index.js
function stripFinalNewline(input) {
  if (typeof input === "string") {
    return stripFinalNewlineString(input);
  }
  if (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {
    throw new Error("Input must be a string or a Uint8Array");
  }
  return stripFinalNewlineBinary(input);
}
var stripFinalNewlineString = (input) => input.at(-1) === LF ? input.slice(0, input.at(-2) === CR ? -2 : -1) : input;
var stripFinalNewlineBinary = (input) => input.at(-1) === LF_BINARY ? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1) : input;
var LF = "\n";
var LF_BINARY = LF.codePointAt(0);
var CR = "\r";
var CR_BINARY = CR.codePointAt(0);

// node_modules/get-stream/source/index.js
var import_node_events6 = require("node:events");
var import_promises5 = require("node:stream/promises");

// node_modules/is-stream/index.js
function isStream(stream5, { checkOpen = true } = {}) {
  return stream5 !== null && typeof stream5 === "object" && (stream5.writable || stream5.readable || !checkOpen || stream5.writable === void 0 && stream5.readable === void 0) && typeof stream5.pipe === "function";
}
function isWritableStream(stream5, { checkOpen = true } = {}) {
  return isStream(stream5, { checkOpen }) && (stream5.writable || !checkOpen) && typeof stream5.write === "function" && typeof stream5.end === "function" && typeof stream5.writable === "boolean" && typeof stream5.writableObjectMode === "boolean" && typeof stream5.destroy === "function" && typeof stream5.destroyed === "boolean";
}
function isReadableStream(stream5, { checkOpen = true } = {}) {
  return isStream(stream5, { checkOpen }) && (stream5.readable || !checkOpen) && typeof stream5.read === "function" && typeof stream5.readable === "boolean" && typeof stream5.readableObjectMode === "boolean" && typeof stream5.destroy === "function" && typeof stream5.destroyed === "boolean";
}
function isDuplexStream(stream5, options) {
  return isWritableStream(stream5, options) && isReadableStream(stream5, options);
}

// node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js
var a = Object.getPrototypeOf(
  Object.getPrototypeOf(
    /* istanbul ignore next */
    async function* () {
    }
  ).prototype
);
var c = class {
  #t;
  #n;
  #r = false;
  #e = void 0;
  constructor(e, t) {
    this.#t = e, this.#n = t;
  }
  next() {
    const e = () => this.#s();
    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;
  }
  return(e) {
    const t = () => this.#i(e);
    return this.#e ? this.#e.then(t, t) : t();
  }
  async #s() {
    if (this.#r)
      return {
        done: true,
        value: void 0
      };
    let e;
    try {
      e = await this.#t.read();
    } catch (t) {
      throw this.#e = void 0, this.#r = true, this.#t.releaseLock(), t;
    }
    return e.done && (this.#e = void 0, this.#r = true, this.#t.releaseLock()), e;
  }
  async #i(e) {
    if (this.#r)
      return {
        done: true,
        value: e
      };
    if (this.#r = true, !this.#n) {
      const t = this.#t.cancel(e);
      return this.#t.releaseLock(), await t, {
        done: true,
        value: e
      };
    }
    return this.#t.releaseLock(), {
      done: true,
      value: e
    };
  }
};
var n = Symbol();
function i() {
  return this[n].next();
}
Object.defineProperty(i, "name", { value: "next" });
function o(r) {
  return this[n].return(r);
}
Object.defineProperty(o, "name", { value: "return" });
var u = Object.create(a, {
  next: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: i
  },
  return: {
    enumerable: true,
    configurable: true,
    writable: true,
    value: o
  }
});
function h({ preventCancel: r = false } = {}) {
  const e = this.getReader(), t = new c(
    e,
    r
  ), s = Object.create(u);
  return s[n] = t, s;
}

// node_modules/get-stream/source/stream.js
var getAsyncIterable = (stream5) => {
  if (isReadableStream(stream5, { checkOpen: false }) && nodeImports.on !== void 0) {
    return getStreamIterable(stream5);
  }
  if (typeof stream5?.[Symbol.asyncIterator] === "function") {
    return stream5;
  }
  if (toString.call(stream5) === "[object ReadableStream]") {
    return h.call(stream5);
  }
  throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.");
};
var { toString } = Object.prototype;
var getStreamIterable = async function* (stream5) {
  const controller = new AbortController();
  const state = {};
  handleStreamEnd(stream5, controller, state);
  try {
    for await (const [chunk] of nodeImports.on(stream5, "data", { signal: controller.signal })) {
      yield chunk;
    }
  } catch (error) {
    if (state.error !== void 0) {
      throw state.error;
    } else if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    stream5.destroy();
  }
};
var handleStreamEnd = async (stream5, controller, state) => {
  try {
    await nodeImports.finished(stream5, {
      cleanup: true,
      readable: true,
      writable: false,
      error: false
    });
  } catch (error) {
    state.error = error;
  } finally {
    controller.abort();
  }
};
var nodeImports = {};

// node_modules/get-stream/source/contents.js
var getStreamContents = async (stream5, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {}) => {
  const asyncIterable = getAsyncIterable(stream5);
  const state = init();
  state.length = 0;
  try {
    for await (const chunk of asyncIterable) {
      const chunkType = getChunkType(chunk);
      const convertedChunk = convertChunk[chunkType](chunk, state);
      appendChunk({
        convertedChunk,
        state,
        getSize,
        truncateChunk,
        addChunk,
        maxBuffer
      });
    }
    appendFinalChunk({
      state,
      convertChunk,
      getSize,
      truncateChunk,
      addChunk,
      getFinalChunk,
      maxBuffer
    });
    return finalize(state);
  } catch (error) {
    const normalizedError = typeof error === "object" && error !== null ? error : new Error(error);
    normalizedError.bufferedData = finalize(state);
    throw normalizedError;
  }
};
var appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer }) => {
  const convertedChunk = getFinalChunk(state);
  if (convertedChunk !== void 0) {
    appendChunk({
      convertedChunk,
      state,
      getSize,
      truncateChunk,
      addChunk,
      maxBuffer
    });
  }
};
var appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer }) => {
  const chunkSize = getSize(convertedChunk);
  const newLength = state.length + chunkSize;
  if (newLength <= maxBuffer) {
    addNewChunk(convertedChunk, state, addChunk, newLength);
    return;
  }
  const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
  if (truncatedChunk !== void 0) {
    addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
  }
  throw new MaxBufferError();
};
var addNewChunk = (convertedChunk, state, addChunk, newLength) => {
  state.contents = addChunk(convertedChunk, state, newLength);
  state.length = newLength;
};
var getChunkType = (chunk) => {
  const typeOfChunk = typeof chunk;
  if (typeOfChunk === "string") {
    return "string";
  }
  if (typeOfChunk !== "object" || chunk === null) {
    return "others";
  }
  if (globalThis.Buffer?.isBuffer(chunk)) {
    return "buffer";
  }
  const prototypeName = objectToString2.call(chunk);
  if (prototypeName === "[object ArrayBuffer]") {
    return "arrayBuffer";
  }
  if (prototypeName === "[object DataView]") {
    return "dataView";
  }
  if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString2.call(chunk.buffer) === "[object ArrayBuffer]") {
    return "typedArray";
  }
  return "others";
};
var { toString: objectToString2 } = Object.prototype;
var MaxBufferError = class extends Error {
  name = "MaxBufferError";
  constructor() {
    super("maxBuffer exceeded");
  }
};

// node_modules/get-stream/source/utils.js
var identity2 = (value) => value;
var noop = () => void 0;
var getContentsProperty = ({ contents }) => contents;
var throwObjectStream = (chunk) => {
  throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
};
var getLengthProperty = (convertedChunk) => convertedChunk.length;

// node_modules/get-stream/source/array.js
async function getStreamAsArray(stream5, options) {
  return getStreamContents(stream5, arrayMethods, options);
}
var initArray = () => ({ contents: [] });
var increment = () => 1;
var addArrayChunk = (convertedChunk, { contents }) => {
  contents.push(convertedChunk);
  return contents;
};
var arrayMethods = {
  init: initArray,
  convertChunk: {
    string: identity2,
    buffer: identity2,
    arrayBuffer: identity2,
    dataView: identity2,
    typedArray: identity2,
    others: identity2
  },
  getSize: increment,
  truncateChunk: noop,
  addChunk: addArrayChunk,
  getFinalChunk: noop,
  finalize: getContentsProperty
};

// node_modules/get-stream/source/array-buffer.js
async function getStreamAsArrayBuffer(stream5, options) {
  return getStreamContents(stream5, arrayBufferMethods, options);
}
var initArrayBuffer = () => ({ contents: new ArrayBuffer(0) });
var useTextEncoder = (chunk) => textEncoder2.encode(chunk);
var textEncoder2 = new TextEncoder();
var useUint8Array = (chunk) => new Uint8Array(chunk);
var useUint8ArrayWithOffset = (chunk) => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
var truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length) => {
  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
  new Uint8Array(newContents).set(convertedChunk, previousLength);
  return newContents;
};
var resizeArrayBufferSlow = (contents, length) => {
  if (length <= contents.byteLength) {
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var resizeArrayBuffer = (contents, length) => {
  if (length <= contents.maxByteLength) {
    contents.resize(length);
    return contents;
  }
  const arrayBuffer = new ArrayBuffer(length, { maxByteLength: getNewContentsLength(length) });
  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
  return arrayBuffer;
};
var getNewContentsLength = (length) => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
var SCALE_FACTOR = 2;
var finalizeArrayBuffer = ({ contents, length }) => hasArrayBufferResize() ? contents : contents.slice(0, length);
var hasArrayBufferResize = () => "resize" in ArrayBuffer.prototype;
var arrayBufferMethods = {
  init: initArrayBuffer,
  convertChunk: {
    string: useTextEncoder,
    buffer: useUint8Array,
    arrayBuffer: useUint8Array,
    dataView: useUint8ArrayWithOffset,
    typedArray: useUint8ArrayWithOffset,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateArrayBufferChunk,
  addChunk: addArrayBufferChunk,
  getFinalChunk: noop,
  finalize: finalizeArrayBuffer
};

// node_modules/get-stream/source/string.js
async function getStreamAsString(stream5, options) {
  return getStreamContents(stream5, stringMethods, options);
}
var initString = () => ({ contents: "", textDecoder: new TextDecoder() });
var useTextDecoder = (chunk, { textDecoder: textDecoder2 }) => textDecoder2.decode(chunk, { stream: true });
var addStringChunk = (convertedChunk, { contents }) => contents + convertedChunk;
var truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);
var getFinalStringChunk = ({ textDecoder: textDecoder2 }) => {
  const finalChunk = textDecoder2.decode();
  return finalChunk === "" ? void 0 : finalChunk;
};
var stringMethods = {
  init: initString,
  convertChunk: {
    string: identity2,
    buffer: useTextDecoder,
    arrayBuffer: useTextDecoder,
    dataView: useTextDecoder,
    typedArray: useTextDecoder,
    others: throwObjectStream
  },
  getSize: getLengthProperty,
  truncateChunk: truncateStringChunk,
  addChunk: addStringChunk,
  getFinalChunk: getFinalStringChunk,
  finalize: getContentsProperty
};

// node_modules/get-stream/source/index.js
Object.assign(nodeImports, { on: import_node_events6.on, finished: import_promises5.finished });

// node_modules/execa/lib/io/max-buffer.js
var handleMaxBuffer = ({ error, stream: stream5, readableObjectMode, lines, encoding, fdNumber }) => {
  if (!(error instanceof MaxBufferError)) {
    throw error;
  }
  if (fdNumber === "all") {
    return error;
  }
  const unit = getMaxBufferUnit(readableObjectMode, lines, encoding);
  error.maxBufferInfo = { fdNumber, unit };
  stream5.destroy();
  throw error;
};
var getMaxBufferUnit = (readableObjectMode, lines, encoding) => {
  if (readableObjectMode) {
    return "objects";
  }
  if (lines) {
    return "lines";
  }
  if (encoding === "buffer") {
    return "bytes";
  }
  return "characters";
};
var checkIpcMaxBuffer = (subprocess, ipcOutput, maxBuffer) => {
  if (ipcOutput.length !== maxBuffer) {
    return;
  }
  const error = new MaxBufferError();
  error.maxBufferInfo = { fdNumber: "ipc" };
  throw error;
};
var getMaxBufferMessage = (error, maxBuffer) => {
  const { streamName, threshold, unit } = getMaxBufferInfo(error, maxBuffer);
  return `Command's ${streamName} was larger than ${threshold} ${unit}`;
};
var getMaxBufferInfo = (error, maxBuffer) => {
  if (error?.maxBufferInfo === void 0) {
    return { streamName: "output", threshold: maxBuffer[1], unit: "bytes" };
  }
  const { maxBufferInfo: { fdNumber, unit } } = error;
  delete error.maxBufferInfo;
  const threshold = getFdSpecificValue(maxBuffer, fdNumber);
  if (fdNumber === "ipc") {
    return { streamName: "IPC output", threshold, unit: "messages" };
  }
  return { streamName: getStreamName(fdNumber), threshold, unit };
};
var isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === "ENOBUFS" && output !== null && output.some((result) => result !== null && result.length > getMaxBufferSync(maxBuffer));
var truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {
  if (!isMaxBuffer) {
    return result;
  }
  const maxBufferValue = getMaxBufferSync(maxBuffer);
  return result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;
};
var getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;

// node_modules/execa/lib/return/message.js
var createMessages = ({
  stdio,
  all: all3,
  ipcOutput,
  originalError,
  signal,
  signalDescription,
  exitCode,
  escapedCommand,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal,
  maxBuffer,
  timeout,
  cwd
}) => {
  const errorCode = originalError?.code;
  const prefix = getErrorPrefix({
    originalError,
    timedOut,
    timeout,
    isMaxBuffer,
    maxBuffer,
    errorCode,
    signal,
    signalDescription,
    exitCode,
    isCanceled,
    isGracefullyCanceled,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal
  });
  const originalMessage = getOriginalMessage(originalError, cwd);
  const suffix = originalMessage === void 0 ? "" : `
${originalMessage}`;
  const shortMessage = `${prefix}: ${escapedCommand}${suffix}`;
  const messageStdio = all3 === void 0 ? [stdio[2], stdio[1]] : [all3];
  const message = [
    shortMessage,
    ...messageStdio,
    ...stdio.slice(3),
    ipcOutput.map((ipcMessage) => serializeIpcMessage(ipcMessage)).join("\n")
  ].map((messagePart) => escapeLines(stripFinalNewline(serializeMessagePart(messagePart)))).filter(Boolean).join("\n\n");
  return { originalMessage, shortMessage, message };
};
var getErrorPrefix = ({
  originalError,
  timedOut,
  timeout,
  isMaxBuffer,
  maxBuffer,
  errorCode,
  signal,
  signalDescription,
  exitCode,
  isCanceled,
  isGracefullyCanceled,
  isForcefullyTerminated,
  forceKillAfterDelay,
  killSignal
}) => {
  const forcefulSuffix = getForcefulSuffix(isForcefullyTerminated, forceKillAfterDelay);
  if (timedOut) {
    return `Command timed out after ${timeout} milliseconds${forcefulSuffix}`;
  }
  if (isGracefullyCanceled) {
    if (signal === void 0) {
      return `Command was gracefully canceled with exit code ${exitCode}`;
    }
    return isForcefullyTerminated ? `Command was gracefully canceled${forcefulSuffix}` : `Command was gracefully canceled with ${signal} (${signalDescription})`;
  }
  if (isCanceled) {
    return `Command was canceled${forcefulSuffix}`;
  }
  if (isMaxBuffer) {
    return `${getMaxBufferMessage(originalError, maxBuffer)}${forcefulSuffix}`;
  }
  if (errorCode !== void 0) {
    return `Command failed with ${errorCode}${forcefulSuffix}`;
  }
  if (isForcefullyTerminated) {
    return `Command was killed with ${killSignal} (${getSignalDescription(killSignal)})${forcefulSuffix}`;
  }
  if (signal !== void 0) {
    return `Command was killed with ${signal} (${signalDescription})`;
  }
  if (exitCode !== void 0) {
    return `Command failed with exit code ${exitCode}`;
  }
  return "Command failed";
};
var getForcefulSuffix = (isForcefullyTerminated, forceKillAfterDelay) => isForcefullyTerminated ? ` and was forcefully terminated after ${forceKillAfterDelay} milliseconds` : "";
var getOriginalMessage = (originalError, cwd) => {
  if (originalError instanceof DiscardedError) {
    return;
  }
  const originalMessage = isExecaError(originalError) ? originalError.originalMessage : String(originalError?.message ?? originalError);
  const escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));
  return escapedOriginalMessage === "" ? void 0 : escapedOriginalMessage;
};
var serializeIpcMessage = (ipcMessage) => typeof ipcMessage === "string" ? ipcMessage : (0, import_node_util6.inspect)(ipcMessage);
var serializeMessagePart = (messagePart) => Array.isArray(messagePart) ? messagePart.map((messageItem) => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join("\n") : serializeMessageItem(messagePart);
var serializeMessageItem = (messageItem) => {
  if (typeof messageItem === "string") {
    return messageItem;
  }
  if (isUint8Array(messageItem)) {
    return uint8ArrayToString(messageItem);
  }
  return "";
};

// node_modules/execa/lib/return/result.js
var makeSuccessResult = ({
  command,
  escapedCommand,
  stdio,
  all: all3,
  ipcOutput,
  options: { cwd },
  startTime
}) => omitUndefinedProperties({
  command,
  escapedCommand,
  cwd,
  durationMs: getDurationMs(startTime),
  failed: false,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isTerminated: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  exitCode: 0,
  stdout: stdio[1],
  stderr: stdio[2],
  all: all3,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var makeEarlyError = ({
  error,
  command,
  escapedCommand,
  fileDescriptors,
  options,
  startTime,
  isSync
}) => makeError({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut: false,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer: false,
  isForcefullyTerminated: false,
  stdio: Array.from({ length: fileDescriptors.length }),
  ipcOutput: [],
  options,
  isSync
});
var makeError = ({
  error: originalError,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode: rawExitCode,
  signal: rawSignal,
  stdio,
  all: all3,
  ipcOutput,
  options: {
    timeoutDuration,
    timeout = timeoutDuration,
    forceKillAfterDelay,
    killSignal,
    cwd,
    maxBuffer
  },
  isSync
}) => {
  const { exitCode, signal, signalDescription } = normalizeExitPayload(rawExitCode, rawSignal);
  const { originalMessage, shortMessage, message } = createMessages({
    stdio,
    all: all3,
    ipcOutput,
    originalError,
    signal,
    signalDescription,
    exitCode,
    escapedCommand,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    forceKillAfterDelay,
    killSignal,
    maxBuffer,
    timeout,
    cwd
  });
  const error = getFinalError(originalError, message, isSync);
  Object.assign(error, getErrorProperties({
    error,
    command,
    escapedCommand,
    startTime,
    timedOut,
    isCanceled,
    isGracefullyCanceled,
    isMaxBuffer,
    isForcefullyTerminated,
    exitCode,
    signal,
    signalDescription,
    stdio,
    all: all3,
    ipcOutput,
    cwd,
    originalMessage,
    shortMessage
  }));
  return error;
};
var getErrorProperties = ({
  error,
  command,
  escapedCommand,
  startTime,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  stdio,
  all: all3,
  ipcOutput,
  cwd,
  originalMessage,
  shortMessage
}) => omitUndefinedProperties({
  shortMessage,
  originalMessage,
  command,
  escapedCommand,
  cwd,
  durationMs: getDurationMs(startTime),
  failed: true,
  timedOut,
  isCanceled,
  isGracefullyCanceled,
  isTerminated: signal !== void 0,
  isMaxBuffer,
  isForcefullyTerminated,
  exitCode,
  signal,
  signalDescription,
  code: error.cause?.code,
  stdout: stdio[1],
  stderr: stdio[2],
  all: all3,
  stdio,
  ipcOutput,
  pipedFrom: []
});
var omitUndefinedProperties = (result) => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== void 0));
var normalizeExitPayload = (rawExitCode, rawSignal) => {
  const exitCode = rawExitCode === null ? void 0 : rawExitCode;
  const signal = rawSignal === null ? void 0 : rawSignal;
  const signalDescription = signal === void 0 ? void 0 : getSignalDescription(rawSignal);
  return { exitCode, signal, signalDescription };
};

// node_modules/parse-ms/index.js
var toZeroIfInfinity = (value) => Number.isFinite(value) ? value : 0;
function parseNumber(milliseconds) {
  return {
    days: Math.trunc(milliseconds / 864e5),
    hours: Math.trunc(milliseconds / 36e5 % 24),
    minutes: Math.trunc(milliseconds / 6e4 % 60),
    seconds: Math.trunc(milliseconds / 1e3 % 60),
    milliseconds: Math.trunc(milliseconds % 1e3),
    microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e3) % 1e3),
    nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1e3)
  };
}
function parseBigint(milliseconds) {
  return {
    days: milliseconds / 86400000n,
    hours: milliseconds / 3600000n % 24n,
    minutes: milliseconds / 60000n % 60n,
    seconds: milliseconds / 1000n % 60n,
    milliseconds: milliseconds % 1000n,
    microseconds: 0n,
    nanoseconds: 0n
  };
}
function parseMilliseconds(milliseconds) {
  switch (typeof milliseconds) {
    case "number": {
      if (Number.isFinite(milliseconds)) {
        return parseNumber(milliseconds);
      }
      break;
    }
    case "bigint": {
      return parseBigint(milliseconds);
    }
  }
  throw new TypeError("Expected a finite number or bigint");
}

// node_modules/pretty-ms/index.js
var isZero = (value) => value === 0 || value === 0n;
var pluralize = (word, count2) => count2 === 1 || count2 === 1n ? word : `${word}s`;
var SECOND_ROUNDING_EPSILON = 1e-7;
var ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
function prettyMilliseconds(milliseconds, options) {
  const isBigInt = typeof milliseconds === "bigint";
  if (!isBigInt && !Number.isFinite(milliseconds)) {
    throw new TypeError("Expected a finite number or bigint");
  }
  options = { ...options };
  const sign = milliseconds < 0 ? "-" : "";
  milliseconds = milliseconds < 0 ? -milliseconds : milliseconds;
  if (options.colonNotation) {
    options.compact = false;
    options.formatSubMilliseconds = false;
    options.separateMilliseconds = false;
    options.verbose = false;
  }
  if (options.compact) {
    options.unitCount = 1;
    options.secondsDecimalDigits = 0;
    options.millisecondsDecimalDigits = 0;
  }
  let result = [];
  const floorDecimals = (value, decimalDigits) => {
    const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON);
    const flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
    return flooredValue.toFixed(decimalDigits);
  };
  const add2 = (value, long, short, valueString) => {
    if ((result.length === 0 || !options.colonNotation) && isZero(value) && !(options.colonNotation && short === "m")) {
      return;
    }
    valueString ??= String(value);
    if (options.colonNotation) {
      const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length;
      const minLength = result.length > 0 ? 2 : 1;
      valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
    } else {
      valueString += options.verbose ? " " + pluralize(long, value) : short;
    }
    result.push(valueString);
  };
  const parsed = parseMilliseconds(milliseconds);
  const days = BigInt(parsed.days);
  if (options.hideYearAndDays) {
    add2(BigInt(days) * 24n + BigInt(parsed.hours), "hour", "h");
  } else {
    if (options.hideYear) {
      add2(days, "day", "d");
    } else {
      add2(days / 365n, "year", "y");
      add2(days % 365n, "day", "d");
    }
    add2(Number(parsed.hours), "hour", "h");
  }
  add2(Number(parsed.minutes), "minute", "m");
  if (!options.hideSeconds) {
    if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1e3 && !options.subSecondsAsDecimals) {
      const seconds = Number(parsed.seconds);
      const milliseconds2 = Number(parsed.milliseconds);
      const microseconds = Number(parsed.microseconds);
      const nanoseconds = Number(parsed.nanoseconds);
      add2(seconds, "second", "s");
      if (options.formatSubMilliseconds) {
        add2(milliseconds2, "millisecond", "ms");
        add2(microseconds, "microsecond", "\xB5s");
        add2(nanoseconds, "nanosecond", "ns");
      } else {
        const millisecondsAndBelow = milliseconds2 + microseconds / 1e3 + nanoseconds / 1e6;
        const millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0;
        const roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow);
        const millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
        add2(
          Number.parseFloat(millisecondsString),
          "millisecond",
          "ms",
          millisecondsString
        );
      }
    } else {
      const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1e3 % 60;
      const secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1;
      const secondsFixed = floorDecimals(seconds, secondsDecimalDigits);
      const secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
      add2(Number.parseFloat(secondsString), "second", "s", secondsString);
    }
  }
  if (result.length === 0) {
    return sign + "0" + (options.verbose ? " milliseconds" : "ms");
  }
  const separator = options.colonNotation ? ":" : " ";
  if (typeof options.unitCount === "number") {
    result = result.slice(0, Math.max(options.unitCount, 1));
  }
  return sign + result.join(separator);
}

// node_modules/execa/lib/verbose/error.js
var logError = (result, verboseInfo) => {
  if (result.failed) {
    verboseLog({
      type: "error",
      verboseMessage: result.shortMessage,
      verboseInfo,
      result
    });
  }
};

// node_modules/execa/lib/verbose/complete.js
var logResult = (result, verboseInfo) => {
  if (!isVerbose(verboseInfo)) {
    return;
  }
  logError(result, verboseInfo);
  logDuration(result, verboseInfo);
};
var logDuration = (result, verboseInfo) => {
  const verboseMessage = `(done in ${prettyMilliseconds(result.durationMs)})`;
  verboseLog({
    type: "duration",
    verboseMessage,
    verboseInfo,
    result
  });
};

// node_modules/execa/lib/return/reject.js
var handleResult = (result, verboseInfo, { reject }) => {
  logResult(result, verboseInfo);
  if (result.failed && reject) {
    throw result;
  }
  return result;
};

// node_modules/execa/lib/stdio/handle-sync.js
var import_node_fs3 = require("node:fs");

// node_modules/execa/lib/stdio/type.js
var getStdioItemType = (value, optionName) => {
  if (isAsyncGenerator(value)) {
    return "asyncGenerator";
  }
  if (isSyncGenerator(value)) {
    return "generator";
  }
  if (isUrl(value)) {
    return "fileUrl";
  }
  if (isFilePathObject(value)) {
    return "filePath";
  }
  if (isWebStream(value)) {
    return "webStream";
  }
  if (isStream(value, { checkOpen: false })) {
    return "native";
  }
  if (isUint8Array(value)) {
    return "uint8Array";
  }
  if (isAsyncIterableObject(value)) {
    return "asyncIterable";
  }
  if (isIterableObject(value)) {
    return "iterable";
  }
  if (isTransformStream(value)) {
    return getTransformStreamType({ transform: value }, optionName);
  }
  if (isTransformOptions(value)) {
    return getTransformObjectType(value, optionName);
  }
  return "native";
};
var getTransformObjectType = (value, optionName) => {
  if (isDuplexStream(value.transform, { checkOpen: false })) {
    return getDuplexType(value, optionName);
  }
  if (isTransformStream(value.transform)) {
    return getTransformStreamType(value, optionName);
  }
  return getGeneratorObjectType(value, optionName);
};
var getDuplexType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "Duplex stream");
  return "duplex";
};
var getTransformStreamType = (value, optionName) => {
  validateNonGeneratorType(value, optionName, "web TransformStream");
  return "webTransform";
};
var validateNonGeneratorType = ({ final, binary, objectMode }, optionName, typeName) => {
  checkUndefinedOption(final, `${optionName}.final`, typeName);
  checkUndefinedOption(binary, `${optionName}.binary`, typeName);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
};
var checkUndefinedOption = (value, optionName, typeName) => {
  if (value !== void 0) {
    throw new TypeError(`The \`${optionName}\` option can only be defined when using a generator, not a ${typeName}.`);
  }
};
var getGeneratorObjectType = ({ transform, final, binary, objectMode }, optionName) => {
  if (transform !== void 0 && !isGenerator(transform)) {
    throw new TypeError(`The \`${optionName}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);
  }
  if (isDuplexStream(final, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a Duplex stream.`);
  }
  if (isTransformStream(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must not be a web TransformStream.`);
  }
  if (final !== void 0 && !isGenerator(final)) {
    throw new TypeError(`The \`${optionName}.final\` option must be a generator.`);
  }
  checkBooleanOption(binary, `${optionName}.binary`);
  checkBooleanOption(objectMode, `${optionName}.objectMode`);
  return isAsyncGenerator(transform) || isAsyncGenerator(final) ? "asyncGenerator" : "generator";
};
var checkBooleanOption = (value, optionName) => {
  if (value !== void 0 && typeof value !== "boolean") {
    throw new TypeError(`The \`${optionName}\` option must use a boolean.`);
  }
};
var isGenerator = (value) => isAsyncGenerator(value) || isSyncGenerator(value);
var isAsyncGenerator = (value) => Object.prototype.toString.call(value) === "[object AsyncGeneratorFunction]";
var isSyncGenerator = (value) => Object.prototype.toString.call(value) === "[object GeneratorFunction]";
var isTransformOptions = (value) => isPlainObject(value) && (value.transform !== void 0 || value.final !== void 0);
var isUrl = (value) => Object.prototype.toString.call(value) === "[object URL]";
var isRegularUrl = (value) => isUrl(value) && value.protocol !== "file:";
var isFilePathObject = (value) => isPlainObject(value) && Object.keys(value).length > 0 && Object.keys(value).every((key) => FILE_PATH_KEYS.has(key)) && isFilePathString(value.file);
var FILE_PATH_KEYS = /* @__PURE__ */ new Set(["file", "append"]);
var isFilePathString = (file) => typeof file === "string";
var isUnknownStdioString = (type, value) => type === "native" && typeof value === "string" && !KNOWN_STDIO_STRINGS.has(value);
var KNOWN_STDIO_STRINGS = /* @__PURE__ */ new Set(["ipc", "ignore", "inherit", "overlapped", "pipe"]);
var isReadableStream2 = (value) => Object.prototype.toString.call(value) === "[object ReadableStream]";
var isWritableStream2 = (value) => Object.prototype.toString.call(value) === "[object WritableStream]";
var isWebStream = (value) => isReadableStream2(value) || isWritableStream2(value);
var isTransformStream = (value) => isReadableStream2(value?.readable) && isWritableStream2(value?.writable);
var isAsyncIterableObject = (value) => isObject(value) && typeof value[Symbol.asyncIterator] === "function";
var isIterableObject = (value) => isObject(value) && typeof value[Symbol.iterator] === "function";
var isObject = (value) => typeof value === "object" && value !== null;
var TRANSFORM_TYPES = /* @__PURE__ */ new Set(["generator", "asyncGenerator", "duplex", "webTransform"]);
var FILE_TYPES = /* @__PURE__ */ new Set(["fileUrl", "filePath", "fileNumber"]);
var SPECIAL_DUPLICATE_TYPES_SYNC = /* @__PURE__ */ new Set(["fileUrl", "filePath"]);
var SPECIAL_DUPLICATE_TYPES = /* @__PURE__ */ new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, "webStream", "nodeStream"]);
var FORBID_DUPLICATE_TYPES = /* @__PURE__ */ new Set(["webTransform", "duplex"]);
var TYPE_TO_MESSAGE = {
  generator: "a generator",
  asyncGenerator: "an async generator",
  fileUrl: "a file URL",
  filePath: "a file path string",
  fileNumber: "a file descriptor number",
  webStream: "a web stream",
  nodeStream: "a Node.js stream",
  webTransform: "a web TransformStream",
  duplex: "a Duplex stream",
  native: "any value",
  iterable: "an iterable",
  asyncIterable: "an async iterable",
  string: "a string",
  uint8Array: "a Uint8Array"
};

// node_modules/execa/lib/transform/object-mode.js
var getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === "output" ? getOutputObjectModes(objectMode, index, newTransforms) : getInputObjectModes(objectMode, index, newTransforms);
var getOutputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = objectMode ?? writableObjectMode;
  return { writableObjectMode, readableObjectMode };
};
var getInputObjectModes = (objectMode, index, newTransforms) => {
  const writableObjectMode = index === 0 ? objectMode === true : newTransforms[index - 1].value.readableObjectMode;
  const readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);
  return { writableObjectMode, readableObjectMode };
};
var getFdObjectMode = (stdioItems, direction) => {
  const lastTransform = stdioItems.findLast(({ type }) => TRANSFORM_TYPES.has(type));
  if (lastTransform === void 0) {
    return false;
  }
  return direction === "input" ? lastTransform.value.writableObjectMode : lastTransform.value.readableObjectMode;
};

// node_modules/execa/lib/transform/normalize.js
var normalizeTransforms = (stdioItems, optionName, direction, options) => [
  ...stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type)),
  ...getTransforms(stdioItems, optionName, direction, options)
];
var getTransforms = (stdioItems, optionName, direction, { encoding }) => {
  const transforms = stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type));
  const newTransforms = Array.from({ length: transforms.length });
  for (const [index, stdioItem] of Object.entries(transforms)) {
    newTransforms[index] = normalizeTransform({
      stdioItem,
      index: Number(index),
      newTransforms,
      optionName,
      direction,
      encoding
    });
  }
  return sortTransforms(newTransforms, direction);
};
var normalizeTransform = ({ stdioItem, stdioItem: { type }, index, newTransforms, optionName, direction, encoding }) => {
  if (type === "duplex") {
    return normalizeDuplex({ stdioItem, optionName });
  }
  if (type === "webTransform") {
    return normalizeTransformStream({
      stdioItem,
      index,
      newTransforms,
      direction
    });
  }
  return normalizeGenerator({
    stdioItem,
    index,
    newTransforms,
    direction,
    encoding
  });
};
var normalizeDuplex = ({
  stdioItem,
  stdioItem: {
    value: {
      transform,
      transform: { writableObjectMode, readableObjectMode },
      objectMode = readableObjectMode
    }
  },
  optionName
}) => {
  if (objectMode && !readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  if (!objectMode && readableObjectMode) {
    throw new TypeError(`The \`${optionName}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);
  }
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeTransformStream = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction }) => {
  const { transform, objectMode } = isPlainObject(value) ? value : { transform: value };
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: { transform, writableObjectMode, readableObjectMode }
  };
};
var normalizeGenerator = ({ stdioItem, stdioItem: { value }, index, newTransforms, direction, encoding }) => {
  const {
    transform,
    final,
    binary: binaryOption = false,
    preserveNewlines = false,
    objectMode
  } = isPlainObject(value) ? value : { transform: value };
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { writableObjectMode, readableObjectMode } = getTransformObjectModes(objectMode, index, newTransforms, direction);
  return {
    ...stdioItem,
    value: {
      transform,
      final,
      binary,
      preserveNewlines,
      writableObjectMode,
      readableObjectMode
    }
  };
};
var sortTransforms = (newTransforms, direction) => direction === "input" ? newTransforms.reverse() : newTransforms;

// node_modules/execa/lib/stdio/direction.js
var import_node_process9 = __toESM(require("node:process"), 1);
var getStreamDirection = (stdioItems, fdNumber, optionName) => {
  const directions = stdioItems.map((stdioItem) => getStdioItemDirection(stdioItem, fdNumber));
  if (directions.includes("input") && directions.includes("output")) {
    throw new TypeError(`The \`${optionName}\` option must not be an array of both readable and writable values.`);
  }
  return directions.find(Boolean) ?? DEFAULT_DIRECTION;
};
var getStdioItemDirection = ({ type, value }, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);
var KNOWN_DIRECTIONS = ["input", "output", "output"];
var anyDirection = () => void 0;
var alwaysInput = () => "input";
var guessStreamDirection = {
  generator: anyDirection,
  asyncGenerator: anyDirection,
  fileUrl: anyDirection,
  filePath: anyDirection,
  iterable: alwaysInput,
  asyncIterable: alwaysInput,
  uint8Array: alwaysInput,
  webStream: (value) => isWritableStream2(value) ? "output" : "input",
  nodeStream(value) {
    if (!isReadableStream(value, { checkOpen: false })) {
      return "output";
    }
    return isWritableStream(value, { checkOpen: false }) ? void 0 : "input";
  },
  webTransform: anyDirection,
  duplex: anyDirection,
  native(value) {
    const standardStreamDirection = getStandardStreamDirection(value);
    if (standardStreamDirection !== void 0) {
      return standardStreamDirection;
    }
    if (isStream(value, { checkOpen: false })) {
      return guessStreamDirection.nodeStream(value);
    }
  }
};
var getStandardStreamDirection = (value) => {
  if ([0, import_node_process9.default.stdin].includes(value)) {
    return "input";
  }
  if ([1, 2, import_node_process9.default.stdout, import_node_process9.default.stderr].includes(value)) {
    return "output";
  }
};
var DEFAULT_DIRECTION = "output";

// node_modules/execa/lib/ipc/array.js
var normalizeIpcStdioArray = (stdioArray, ipc) => ipc && !stdioArray.includes("ipc") ? [...stdioArray, "ipc"] : stdioArray;

// node_modules/execa/lib/stdio/stdio-option.js
var normalizeStdioOption = ({ stdio, ipc, buffer, ...options }, verboseInfo, isSync) => {
  const stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue2(stdioOption, fdNumber));
  return isSync ? normalizeStdioSync(stdioArray, buffer, verboseInfo) : normalizeIpcStdioArray(stdioArray, ipc);
};
var getStdioArray = (stdio, options) => {
  if (stdio === void 0) {
    return STANDARD_STREAMS_ALIASES.map((alias) => options[alias]);
  }
  if (hasAlias(options)) {
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${STANDARD_STREAMS_ALIASES.map((alias) => `\`${alias}\``).join(", ")}`);
  }
  if (typeof stdio === "string") {
    return [stdio, stdio, stdio];
  }
  if (!Array.isArray(stdio)) {
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  }
  const length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);
  return Array.from({ length }, (_, fdNumber) => stdio[fdNumber]);
};
var hasAlias = (options) => STANDARD_STREAMS_ALIASES.some((alias) => options[alias] !== void 0);
var addDefaultValue2 = (stdioOption, fdNumber) => {
  if (Array.isArray(stdioOption)) {
    return stdioOption.map((item) => addDefaultValue2(item, fdNumber));
  }
  if (stdioOption === null || stdioOption === void 0) {
    return fdNumber >= STANDARD_STREAMS_ALIASES.length ? "ignore" : "pipe";
  }
  return stdioOption;
};
var normalizeStdioSync = (stdioArray, buffer, verboseInfo) => stdioArray.map((stdioOption, fdNumber) => !buffer[fdNumber] && fdNumber !== 0 && !isFullVerbose(verboseInfo, fdNumber) && isOutputPipeOnly(stdioOption) ? "ignore" : stdioOption);
var isOutputPipeOnly = (stdioOption) => stdioOption === "pipe" || Array.isArray(stdioOption) && stdioOption.every((item) => item === "pipe");

// node_modules/execa/lib/stdio/native.js
var import_node_fs2 = require("node:fs");
var import_node_tty2 = __toESM(require("node:tty"), 1);
var handleNativeStream = ({ stdioItem, stdioItem: { type }, isStdioArray, fdNumber, direction, isSync }) => {
  if (!isStdioArray || type !== "native") {
    return stdioItem;
  }
  return isSync ? handleNativeStreamSync({ stdioItem, fdNumber, direction }) : handleNativeStreamAsync({ stdioItem, fdNumber });
};
var handleNativeStreamSync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber, direction }) => {
  const targetFd = getTargetFd({
    value,
    optionName,
    fdNumber,
    direction
  });
  if (targetFd !== void 0) {
    return targetFd;
  }
  if (isStream(value, { checkOpen: false })) {
    throw new TypeError(`The \`${optionName}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);
  }
  return stdioItem;
};
var getTargetFd = ({ value, optionName, fdNumber, direction }) => {
  const targetFdNumber = getTargetFdNumber(value, fdNumber);
  if (targetFdNumber === void 0) {
    return;
  }
  if (direction === "output") {
    return { type: "fileNumber", value: targetFdNumber, optionName };
  }
  if (import_node_tty2.default.isatty(targetFdNumber)) {
    throw new TypeError(`The \`${optionName}: ${serializeOptionValue(value)}\` option is invalid: it cannot be a TTY with synchronous methods.`);
  }
  return { type: "uint8Array", value: bufferToUint8Array((0, import_node_fs2.readFileSync)(targetFdNumber)), optionName };
};
var getTargetFdNumber = (value, fdNumber) => {
  if (value === "inherit") {
    return fdNumber;
  }
  if (typeof value === "number") {
    return value;
  }
  const standardStreamIndex = STANDARD_STREAMS.indexOf(value);
  if (standardStreamIndex !== -1) {
    return standardStreamIndex;
  }
};
var handleNativeStreamAsync = ({ stdioItem, stdioItem: { value, optionName }, fdNumber }) => {
  if (value === "inherit") {
    return { type: "nodeStream", value: getStandardStream(fdNumber, value, optionName), optionName };
  }
  if (typeof value === "number") {
    return { type: "nodeStream", value: getStandardStream(value, value, optionName), optionName };
  }
  if (isStream(value, { checkOpen: false })) {
    return { type: "nodeStream", value, optionName };
  }
  return stdioItem;
};
var getStandardStream = (fdNumber, value, optionName) => {
  const standardStream = STANDARD_STREAMS[fdNumber];
  if (standardStream === void 0) {
    throw new TypeError(`The \`${optionName}: ${value}\` option is invalid: no such standard stream.`);
  }
  return standardStream;
};

// node_modules/execa/lib/stdio/input-option.js
var handleInputOptions = ({ input, inputFile }, fdNumber) => fdNumber === 0 ? [
  ...handleInputOption(input),
  ...handleInputFileOption(inputFile)
] : [];
var handleInputOption = (input) => input === void 0 ? [] : [{
  type: getInputType(input),
  value: input,
  optionName: "input"
}];
var getInputType = (input) => {
  if (isReadableStream(input, { checkOpen: false })) {
    return "nodeStream";
  }
  if (typeof input === "string") {
    return "string";
  }
  if (isUint8Array(input)) {
    return "uint8Array";
  }
  throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.");
};
var handleInputFileOption = (inputFile) => inputFile === void 0 ? [] : [{
  ...getInputFileType(inputFile),
  optionName: "inputFile"
}];
var getInputFileType = (inputFile) => {
  if (isUrl(inputFile)) {
    return { type: "fileUrl", value: inputFile };
  }
  if (isFilePathString(inputFile)) {
    return { type: "filePath", value: { file: inputFile } };
  }
  throw new Error("The `inputFile` option must be a file path string or a file URL.");
};

// node_modules/execa/lib/stdio/duplicate.js
var filterDuplicates = (stdioItems) => stdioItems.filter((stdioItemOne, indexOne) => stdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value || indexOne >= indexTwo || stdioItemOne.type === "generator" || stdioItemOne.type === "asyncGenerator"));
var getDuplicateStream = ({ stdioItem: { type, value, optionName }, direction, fileDescriptors, isSync }) => {
  const otherStdioItems = getOtherStdioItems(fileDescriptors, type);
  if (otherStdioItems.length === 0) {
    return;
  }
  if (isSync) {
    validateDuplicateStreamSync({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
    return;
  }
  if (SPECIAL_DUPLICATE_TYPES.has(type)) {
    return getDuplicateStreamInstance({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
  }
  if (FORBID_DUPLICATE_TYPES.has(type)) {
    validateDuplicateTransform({
      otherStdioItems,
      type,
      value,
      optionName
    });
  }
};
var getOtherStdioItems = (fileDescriptors, type) => fileDescriptors.flatMap(({ direction, stdioItems }) => stdioItems.filter((stdioItem) => stdioItem.type === type).map(((stdioItem) => ({ ...stdioItem, direction }))));
var validateDuplicateStreamSync = ({ otherStdioItems, type, value, optionName, direction }) => {
  if (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {
    getDuplicateStreamInstance({
      otherStdioItems,
      type,
      value,
      optionName,
      direction
    });
  }
};
var getDuplicateStreamInstance = ({ otherStdioItems, type, value, optionName, direction }) => {
  const duplicateStdioItems = otherStdioItems.filter((stdioItem) => hasSameValue(stdioItem, value));
  if (duplicateStdioItems.length === 0) {
    return;
  }
  const differentStdioItem = duplicateStdioItems.find((stdioItem) => stdioItem.direction !== direction);
  throwOnDuplicateStream(differentStdioItem, optionName, type);
  return direction === "output" ? duplicateStdioItems[0].stream : void 0;
};
var hasSameValue = ({ type, value }, secondValue) => {
  if (type === "filePath") {
    return value.file === secondValue.file;
  }
  if (type === "fileUrl") {
    return value.href === secondValue.href;
  }
  return value === secondValue;
};
var validateDuplicateTransform = ({ otherStdioItems, type, value, optionName }) => {
  const duplicateStdioItem = otherStdioItems.find(({ value: { transform } }) => transform === value.transform);
  throwOnDuplicateStream(duplicateStdioItem, optionName, type);
};
var throwOnDuplicateStream = (stdioItem, optionName, type) => {
  if (stdioItem !== void 0) {
    throw new TypeError(`The \`${stdioItem.optionName}\` and \`${optionName}\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);
  }
};

// node_modules/execa/lib/stdio/handle.js
var handleStdio = (addProperties3, options, verboseInfo, isSync) => {
  const stdio = normalizeStdioOption(options, verboseInfo, isSync);
  const initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({
    stdioOption,
    fdNumber,
    options,
    isSync
  }));
  const fileDescriptors = getFinalFileDescriptors({
    initialFileDescriptors,
    addProperties: addProperties3,
    options,
    isSync
  });
  options.stdio = fileDescriptors.map(({ stdioItems }) => forwardStdio(stdioItems));
  return fileDescriptors;
};
var getFileDescriptor = ({ stdioOption, fdNumber, options, isSync }) => {
  const optionName = getStreamName(fdNumber);
  const { stdioItems: initialStdioItems, isStdioArray } = initializeStdioItems({
    stdioOption,
    fdNumber,
    options,
    optionName
  });
  const direction = getStreamDirection(initialStdioItems, fdNumber, optionName);
  const stdioItems = initialStdioItems.map((stdioItem) => handleNativeStream({
    stdioItem,
    isStdioArray,
    fdNumber,
    direction,
    isSync
  }));
  const normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);
  const objectMode = getFdObjectMode(normalizedStdioItems, direction);
  validateFileObjectMode(normalizedStdioItems, objectMode);
  return { direction, objectMode, stdioItems: normalizedStdioItems };
};
var initializeStdioItems = ({ stdioOption, fdNumber, options, optionName }) => {
  const values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];
  const initialStdioItems = [
    ...values.map((value) => initializeStdioItem(value, optionName)),
    ...handleInputOptions(options, fdNumber)
  ];
  const stdioItems = filterDuplicates(initialStdioItems);
  const isStdioArray = stdioItems.length > 1;
  validateStdioArray(stdioItems, isStdioArray, optionName);
  validateStreams(stdioItems);
  return { stdioItems, isStdioArray };
};
var initializeStdioItem = (value, optionName) => ({
  type: getStdioItemType(value, optionName),
  value,
  optionName
});
var validateStdioArray = (stdioItems, isStdioArray, optionName) => {
  if (stdioItems.length === 0) {
    throw new TypeError(`The \`${optionName}\` option must not be an empty array.`);
  }
  if (!isStdioArray) {
    return;
  }
  for (const { value, optionName: optionName2 } of stdioItems) {
    if (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {
      throw new Error(`The \`${optionName2}\` option must not include \`${value}\`.`);
    }
  }
};
var INVALID_STDIO_ARRAY_OPTIONS = /* @__PURE__ */ new Set(["ignore", "ipc"]);
var validateStreams = (stdioItems) => {
  for (const stdioItem of stdioItems) {
    validateFileStdio(stdioItem);
  }
};
var validateFileStdio = ({ type, value, optionName }) => {
  if (isRegularUrl(value)) {
    throw new TypeError(`The \`${optionName}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);
  }
  if (isUnknownStdioString(type, value)) {
    throw new TypeError(`The \`${optionName}: { file: '...' }\` option must be used instead of \`${optionName}: '...'\`.`);
  }
};
var validateFileObjectMode = (stdioItems, objectMode) => {
  if (!objectMode) {
    return;
  }
  const fileStdioItem = stdioItems.find(({ type }) => FILE_TYPES.has(type));
  if (fileStdioItem !== void 0) {
    throw new TypeError(`The \`${fileStdioItem.optionName}\` option cannot use both files and transforms in objectMode.`);
  }
};
var getFinalFileDescriptors = ({ initialFileDescriptors, addProperties: addProperties3, options, isSync }) => {
  const fileDescriptors = [];
  try {
    for (const fileDescriptor of initialFileDescriptors) {
      fileDescriptors.push(getFinalFileDescriptor({
        fileDescriptor,
        fileDescriptors,
        addProperties: addProperties3,
        options,
        isSync
      }));
    }
    return fileDescriptors;
  } catch (error) {
    cleanupCustomStreams(fileDescriptors);
    throw error;
  }
};
var getFinalFileDescriptor = ({
  fileDescriptor: { direction, objectMode, stdioItems },
  fileDescriptors,
  addProperties: addProperties3,
  options,
  isSync
}) => {
  const finalStdioItems = stdioItems.map((stdioItem) => addStreamProperties({
    stdioItem,
    addProperties: addProperties3,
    direction,
    options,
    fileDescriptors,
    isSync
  }));
  return { direction, objectMode, stdioItems: finalStdioItems };
};
var addStreamProperties = ({ stdioItem, addProperties: addProperties3, direction, options, fileDescriptors, isSync }) => {
  const duplicateStream = getDuplicateStream({
    stdioItem,
    direction,
    fileDescriptors,
    isSync
  });
  if (duplicateStream !== void 0) {
    return { ...stdioItem, stream: duplicateStream };
  }
  return {
    ...stdioItem,
    ...addProperties3[direction][stdioItem.type](stdioItem, options)
  };
};
var cleanupCustomStreams = (fileDescriptors) => {
  for (const { stdioItems } of fileDescriptors) {
    for (const { stream: stream5 } of stdioItems) {
      if (stream5 !== void 0 && !isStandardStream(stream5)) {
        stream5.destroy();
      }
    }
  }
};
var forwardStdio = (stdioItems) => {
  if (stdioItems.length > 1) {
    return stdioItems.some(({ value: value2 }) => value2 === "overlapped") ? "overlapped" : "pipe";
  }
  const [{ type, value }] = stdioItems;
  return type === "native" ? value : "pipe";
};

// node_modules/execa/lib/stdio/handle-sync.js
var handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);
var forbiddenIfSync = ({ type, optionName }) => {
  throwInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);
};
var forbiddenNativeIfSync = ({ optionName, value }) => {
  if (value === "ipc" || value === "overlapped") {
    throwInvalidSyncValue(optionName, `"${value}"`);
  }
  return {};
};
var throwInvalidSyncValue = (optionName, value) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${value} with synchronous methods.`);
};
var addProperties = {
  generator() {
  },
  asyncGenerator: forbiddenIfSync,
  webStream: forbiddenIfSync,
  nodeStream: forbiddenIfSync,
  webTransform: forbiddenIfSync,
  duplex: forbiddenIfSync,
  asyncIterable: forbiddenIfSync,
  native: forbiddenNativeIfSync
};
var addPropertiesSync = {
  input: {
    ...addProperties,
    fileUrl: ({ value }) => ({ contents: [bufferToUint8Array((0, import_node_fs3.readFileSync)(value))] }),
    filePath: ({ value: { file } }) => ({ contents: [bufferToUint8Array((0, import_node_fs3.readFileSync)(file))] }),
    fileNumber: forbiddenIfSync,
    iterable: ({ value }) => ({ contents: [...value] }),
    string: ({ value }) => ({ contents: [value] }),
    uint8Array: ({ value }) => ({ contents: [value] })
  },
  output: {
    ...addProperties,
    fileUrl: ({ value }) => ({ path: value }),
    filePath: ({ value: { file, append: append2 } }) => ({ path: file, append: append2 }),
    fileNumber: ({ value }) => ({ path: value }),
    iterable: forbiddenIfSync,
    string: forbiddenIfSync,
    uint8Array: forbiddenIfSync
  }
};

// node_modules/execa/lib/io/strip-newline.js
var stripNewline = (value, { stripFinalNewline: stripFinalNewline2 }, fdNumber) => getStripFinalNewline(stripFinalNewline2, fdNumber) && value !== void 0 && !Array.isArray(value) ? stripFinalNewline(value) : value;
var getStripFinalNewline = (stripFinalNewline2, fdNumber) => fdNumber === "all" ? stripFinalNewline2[1] || stripFinalNewline2[2] : stripFinalNewline2[fdNumber];

// node_modules/execa/lib/transform/generator.js
var import_node_stream = require("node:stream");

// node_modules/execa/lib/transform/split.js
var getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped ? void 0 : initializeSplitLines(preserveNewlines, state);
var splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode ? chunk.flatMap((item) => splitLinesItemSync(item, preserveNewlines)) : splitLinesItemSync(chunk, preserveNewlines);
var splitLinesItemSync = (chunk, preserveNewlines) => {
  const { transform, final } = initializeSplitLines(preserveNewlines, {});
  return [...transform(chunk), ...final()];
};
var initializeSplitLines = (preserveNewlines, state) => {
  state.previousChunks = "";
  return {
    transform: splitGenerator.bind(void 0, state, preserveNewlines),
    final: linesFinal.bind(void 0, state)
  };
};
var splitGenerator = function* (state, preserveNewlines, chunk) {
  if (typeof chunk !== "string") {
    yield chunk;
    return;
  }
  let { previousChunks } = state;
  let start = -1;
  for (let end = 0; end < chunk.length; end += 1) {
    if (chunk[end] === "\n") {
      const newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);
      let line = chunk.slice(start + 1, end + 1 - newlineLength);
      if (previousChunks.length > 0) {
        line = concatString(previousChunks, line);
        previousChunks = "";
      }
      yield line;
      start = end;
    }
  }
  if (start !== chunk.length - 1) {
    previousChunks = concatString(previousChunks, chunk.slice(start + 1));
  }
  state.previousChunks = previousChunks;
};
var getNewlineLength = (chunk, end, preserveNewlines, state) => {
  if (preserveNewlines) {
    return 0;
  }
  state.isWindowsNewline = end !== 0 && chunk[end - 1] === "\r";
  return state.isWindowsNewline ? 2 : 1;
};
var linesFinal = function* ({ previousChunks }) {
  if (previousChunks.length > 0) {
    yield previousChunks;
  }
};
var getAppendNewlineGenerator = ({ binary, preserveNewlines, readableObjectMode, state }) => binary || preserveNewlines || readableObjectMode ? void 0 : { transform: appendNewlineGenerator.bind(void 0, state) };
var appendNewlineGenerator = function* ({ isWindowsNewline = false }, chunk) {
  const { unixNewline, windowsNewline, LF: LF2, concatBytes } = typeof chunk === "string" ? linesStringInfo : linesUint8ArrayInfo;
  if (chunk.at(-1) === LF2) {
    yield chunk;
    return;
  }
  const newline2 = isWindowsNewline ? windowsNewline : unixNewline;
  yield concatBytes(chunk, newline2);
};
var concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;
var linesStringInfo = {
  windowsNewline: "\r\n",
  unixNewline: "\n",
  LF: "\n",
  concatBytes: concatString
};
var concatUint8Array = (firstChunk, secondChunk) => {
  const chunk = new Uint8Array(firstChunk.length + secondChunk.length);
  chunk.set(firstChunk, 0);
  chunk.set(secondChunk, firstChunk.length);
  return chunk;
};
var linesUint8ArrayInfo = {
  windowsNewline: new Uint8Array([13, 10]),
  unixNewline: new Uint8Array([10]),
  LF: 10,
  concatBytes: concatUint8Array
};

// node_modules/execa/lib/transform/validate.js
var import_node_buffer = require("node:buffer");
var getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode ? void 0 : validateStringTransformInput.bind(void 0, optionName);
var validateStringTransformInput = function* (optionName, chunk) {
  if (typeof chunk !== "string" && !isUint8Array(chunk) && !import_node_buffer.Buffer.isBuffer(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's transform must use "objectMode: true" to receive as input: ${typeof chunk}.`);
  }
  yield chunk;
};
var getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode ? validateObjectTransformReturn.bind(void 0, optionName) : validateStringTransformReturn.bind(void 0, optionName);
var validateObjectTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  yield chunk;
};
var validateStringTransformReturn = function* (optionName, chunk) {
  validateEmptyReturn(optionName, chunk);
  if (typeof chunk !== "string" && !isUint8Array(chunk)) {
    throw new TypeError(`The \`${optionName}\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);
  }
  yield chunk;
};
var validateEmptyReturn = (optionName, chunk) => {
  if (chunk === null || chunk === void 0) {
    throw new TypeError(`The \`${optionName}\` option's function must not call \`yield ${chunk}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`);
  }
};

// node_modules/execa/lib/transform/encoding-transform.js
var import_node_buffer2 = require("node:buffer");
var import_node_string_decoder2 = require("node:string_decoder");
var getEncodingTransformGenerator = (binary, encoding, skipped) => {
  if (skipped) {
    return;
  }
  if (binary) {
    return { transform: encodingUint8ArrayGenerator.bind(void 0, new TextEncoder()) };
  }
  const stringDecoder = new import_node_string_decoder2.StringDecoder(encoding);
  return {
    transform: encodingStringGenerator.bind(void 0, stringDecoder),
    final: encodingStringFinal.bind(void 0, stringDecoder)
  };
};
var encodingUint8ArrayGenerator = function* (textEncoder4, chunk) {
  if (import_node_buffer2.Buffer.isBuffer(chunk)) {
    yield bufferToUint8Array(chunk);
  } else if (typeof chunk === "string") {
    yield textEncoder4.encode(chunk);
  } else {
    yield chunk;
  }
};
var encodingStringGenerator = function* (stringDecoder, chunk) {
  yield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;
};
var encodingStringFinal = function* (stringDecoder) {
  const lastChunk = stringDecoder.end();
  if (lastChunk !== "") {
    yield lastChunk;
  }
};

// node_modules/execa/lib/transform/run-async.js
var import_node_util7 = require("node:util");
var pushChunks = (0, import_node_util7.callbackify)(async (getChunks, state, getChunksArguments, transformStream) => {
  state.currentIterable = getChunks(...getChunksArguments);
  try {
    for await (const chunk of state.currentIterable) {
      transformStream.push(chunk);
    }
  } finally {
    delete state.currentIterable;
  }
});
var transformChunk = async function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator } = generators[index];
  for await (const transformedChunk of transform(chunk)) {
    yield* transformChunk(transformedChunk, generators, index + 1);
  }
};
var finalChunks = async function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunks(final, Number(index), generators);
  }
};
var generatorFinalChunks = async function* (final, index, generators) {
  if (final === void 0) {
    return;
  }
  for await (const finalChunk of final()) {
    yield* transformChunk(finalChunk, generators, index + 1);
  }
};
var destroyTransform = (0, import_node_util7.callbackify)(async ({ currentIterable }, error) => {
  if (currentIterable !== void 0) {
    await (error ? currentIterable.throw(error) : currentIterable.return());
    return;
  }
  if (error) {
    throw error;
  }
});
var identityGenerator = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/run-sync.js
var pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {
  try {
    for (const chunk of getChunksSync(...getChunksArguments)) {
      transformStream.push(chunk);
    }
    done();
  } catch (error) {
    done(error);
  }
};
var runTransformSync = (generators, chunks) => [
  ...chunks.flatMap((chunk) => [...transformChunkSync(chunk, generators, 0)]),
  ...finalChunksSync(generators)
];
var transformChunkSync = function* (chunk, generators, index) {
  if (index === generators.length) {
    yield chunk;
    return;
  }
  const { transform = identityGenerator2 } = generators[index];
  for (const transformedChunk of transform(chunk)) {
    yield* transformChunkSync(transformedChunk, generators, index + 1);
  }
};
var finalChunksSync = function* (generators) {
  for (const [index, { final }] of Object.entries(generators)) {
    yield* generatorFinalChunksSync(final, Number(index), generators);
  }
};
var generatorFinalChunksSync = function* (final, index, generators) {
  if (final === void 0) {
    return;
  }
  for (const finalChunk of final()) {
    yield* transformChunkSync(finalChunk, generators, index + 1);
  }
};
var identityGenerator2 = function* (chunk) {
  yield chunk;
};

// node_modules/execa/lib/transform/generator.js
var generatorToStream = ({
  value,
  value: { transform, final, writableObjectMode, readableObjectMode },
  optionName
}, { encoding }) => {
  const state = {};
  const generators = addInternalGenerators(value, encoding, optionName);
  const transformAsync = isAsyncGenerator(transform);
  const finalAsync = isAsyncGenerator(final);
  const transformMethod = transformAsync ? pushChunks.bind(void 0, transformChunk, state) : pushChunksSync.bind(void 0, transformChunkSync);
  const finalMethod = transformAsync || finalAsync ? pushChunks.bind(void 0, finalChunks, state) : pushChunksSync.bind(void 0, finalChunksSync);
  const destroyMethod = transformAsync || finalAsync ? destroyTransform.bind(void 0, state) : void 0;
  const stream5 = new import_node_stream.Transform({
    writableObjectMode,
    writableHighWaterMark: (0, import_node_stream.getDefaultHighWaterMark)(writableObjectMode),
    readableObjectMode,
    readableHighWaterMark: (0, import_node_stream.getDefaultHighWaterMark)(readableObjectMode),
    transform(chunk, encoding2, done) {
      transformMethod([chunk, generators, 0], this, done);
    },
    flush(done) {
      finalMethod([generators], this, done);
    },
    destroy: destroyMethod
  });
  return { stream: stream5 };
};
var runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {
  const generators = stdioItems.filter(({ type }) => type === "generator");
  const reversedGenerators = isInput ? generators.reverse() : generators;
  for (const { value, optionName } of reversedGenerators) {
    const generators2 = addInternalGenerators(value, encoding, optionName);
    chunks = runTransformSync(generators2, chunks);
  }
  return chunks;
};
var addInternalGenerators = ({ transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines }, encoding, optionName) => {
  const state = {};
  return [
    { transform: getValidateTransformInput(writableObjectMode, optionName) },
    getEncodingTransformGenerator(binary, encoding, writableObjectMode),
    getSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),
    { transform, final },
    { transform: getValidateTransformReturn(readableObjectMode, optionName) },
    getAppendNewlineGenerator({
      binary,
      preserveNewlines,
      readableObjectMode,
      state
    })
  ].filter(Boolean);
};

// node_modules/execa/lib/io/input-sync.js
var addInputOptionsSync = (fileDescriptors, options) => {
  for (const fdNumber of getInputFdNumbers(fileDescriptors)) {
    addInputOptionSync(fileDescriptors, fdNumber, options);
  }
};
var getInputFdNumbers = (fileDescriptors) => new Set(Object.entries(fileDescriptors).filter(([, { direction }]) => direction === "input").map(([fdNumber]) => Number(fdNumber)));
var addInputOptionSync = (fileDescriptors, fdNumber, options) => {
  const { stdioItems } = fileDescriptors[fdNumber];
  const allStdioItems = stdioItems.filter(({ contents }) => contents !== void 0);
  if (allStdioItems.length === 0) {
    return;
  }
  if (fdNumber !== 0) {
    const [{ type, optionName }] = allStdioItems;
    throw new TypeError(`Only the \`stdin\` option, not \`${optionName}\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);
  }
  const allContents = allStdioItems.map(({ contents }) => contents);
  const transformedContents = allContents.map((contents) => applySingleInputGeneratorsSync(contents, stdioItems));
  options.input = joinToUint8Array(transformedContents);
};
var applySingleInputGeneratorsSync = (contents, stdioItems) => {
  const newContents = runGeneratorsSync(contents, stdioItems, "utf8", true);
  validateSerializable(newContents);
  return joinToUint8Array(newContents);
};
var validateSerializable = (newContents) => {
  const invalidItem = newContents.find((item) => typeof item !== "string" && !isUint8Array(item));
  if (invalidItem !== void 0) {
    throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);
  }
};

// node_modules/execa/lib/io/output-sync.js
var import_node_fs4 = require("node:fs");

// node_modules/execa/lib/verbose/output.js
var shouldLogOutput = ({ stdioItems, encoding, verboseInfo, fdNumber }) => fdNumber !== "all" && isFullVerbose(verboseInfo, fdNumber) && !BINARY_ENCODINGS.has(encoding) && fdUsesVerbose(fdNumber) && (stdioItems.some(({ type, value }) => type === "native" && PIPED_STDIO_VALUES.has(value)) || stdioItems.every(({ type }) => TRANSFORM_TYPES.has(type)));
var fdUsesVerbose = (fdNumber) => fdNumber === 1 || fdNumber === 2;
var PIPED_STDIO_VALUES = /* @__PURE__ */ new Set(["pipe", "overlapped"]);
var logLines = async (linesIterable, stream5, fdNumber, verboseInfo) => {
  for await (const line of linesIterable) {
    if (!isPipingStream(stream5)) {
      logLine(line, fdNumber, verboseInfo);
    }
  }
};
var logLinesSync = (linesArray, fdNumber, verboseInfo) => {
  for (const line of linesArray) {
    logLine(line, fdNumber, verboseInfo);
  }
};
var isPipingStream = (stream5) => stream5._readableState.pipes.length > 0;
var logLine = (line, fdNumber, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(line);
  verboseLog({
    type: "output",
    verboseMessage,
    fdNumber,
    verboseInfo
  });
};

// node_modules/execa/lib/io/output-sync.js
var transformOutputSync = ({ fileDescriptors, syncResult: { output }, options, isMaxBuffer, verboseInfo }) => {
  if (output === null) {
    return { output: Array.from({ length: 3 }) };
  }
  const state = {};
  const outputFiles = /* @__PURE__ */ new Set([]);
  const transformedOutput = output.map((result, fdNumber) => transformOutputResultSync({
    result,
    fileDescriptors,
    fdNumber,
    state,
    outputFiles,
    isMaxBuffer,
    verboseInfo
  }, options));
  return { output: transformedOutput, ...state };
};
var transformOutputResultSync = ({ result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo }, { buffer, encoding, lines, stripFinalNewline: stripFinalNewline2, maxBuffer }) => {
  if (result === null) {
    return;
  }
  const truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);
  const uint8ArrayResult = bufferToUint8Array(truncatedResult);
  const { stdioItems, objectMode } = fileDescriptors[fdNumber];
  const chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);
  const { serializedResult, finalResult = serializedResult } = serializeChunks({
    chunks,
    objectMode,
    encoding,
    lines,
    stripFinalNewline: stripFinalNewline2,
    fdNumber
  });
  logOutputSync({
    serializedResult,
    fdNumber,
    state,
    verboseInfo,
    encoding,
    stdioItems,
    objectMode
  });
  const returnedResult = buffer[fdNumber] ? finalResult : void 0;
  try {
    if (state.error === void 0) {
      writeToFiles(serializedResult, stdioItems, outputFiles);
    }
    return returnedResult;
  } catch (error) {
    state.error = error;
    return returnedResult;
  }
};
var runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {
  try {
    return runGeneratorsSync(chunks, stdioItems, encoding, false);
  } catch (error) {
    state.error = error;
    return chunks;
  }
};
var serializeChunks = ({ chunks, objectMode, encoding, lines, stripFinalNewline: stripFinalNewline2, fdNumber }) => {
  if (objectMode) {
    return { serializedResult: chunks };
  }
  if (encoding === "buffer") {
    return { serializedResult: joinToUint8Array(chunks) };
  }
  const serializedResult = joinToString(chunks, encoding);
  if (lines[fdNumber]) {
    return { serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline2[fdNumber], objectMode) };
  }
  return { serializedResult };
};
var logOutputSync = ({ serializedResult, fdNumber, state, verboseInfo, encoding, stdioItems, objectMode }) => {
  if (!shouldLogOutput({
    stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesArray = splitLinesSync(serializedResult, false, objectMode);
  try {
    logLinesSync(linesArray, fdNumber, verboseInfo);
  } catch (error) {
    state.error ??= error;
  }
};
var writeToFiles = (serializedResult, stdioItems, outputFiles) => {
  for (const { path: path15, append: append2 } of stdioItems.filter(({ type }) => FILE_TYPES.has(type))) {
    const pathString = typeof path15 === "string" ? path15 : path15.toString();
    if (append2 || outputFiles.has(pathString)) {
      (0, import_node_fs4.appendFileSync)(path15, serializedResult);
    } else {
      outputFiles.add(pathString);
      (0, import_node_fs4.writeFileSync)(path15, serializedResult);
    }
  }
};

// node_modules/execa/lib/resolve/all-sync.js
var getAllSync = ([, stdout, stderr], options) => {
  if (!options.all) {
    return;
  }
  if (stdout === void 0) {
    return stderr;
  }
  if (stderr === void 0) {
    return stdout;
  }
  if (Array.isArray(stdout)) {
    return Array.isArray(stderr) ? [...stdout, ...stderr] : [...stdout, stripNewline(stderr, options, "all")];
  }
  if (Array.isArray(stderr)) {
    return [stripNewline(stdout, options, "all"), ...stderr];
  }
  if (isUint8Array(stdout) && isUint8Array(stderr)) {
    return concatUint8Arrays([stdout, stderr]);
  }
  return `${stdout}${stderr}`;
};

// node_modules/execa/lib/resolve/exit-async.js
var import_node_events7 = require("node:events");
var waitForExit = async (subprocess, context) => {
  const [exitCode, signal] = await waitForExitOrError(subprocess);
  context.isForcefullyTerminated ??= false;
  return [exitCode, signal];
};
var waitForExitOrError = async (subprocess) => {
  const [spawnPayload, exitPayload] = await Promise.allSettled([
    (0, import_node_events7.once)(subprocess, "spawn"),
    (0, import_node_events7.once)(subprocess, "exit")
  ]);
  if (spawnPayload.status === "rejected") {
    return [];
  }
  return exitPayload.status === "rejected" ? waitForSubprocessExit(subprocess) : exitPayload.value;
};
var waitForSubprocessExit = async (subprocess) => {
  try {
    return await (0, import_node_events7.once)(subprocess, "exit");
  } catch {
    return waitForSubprocessExit(subprocess);
  }
};
var waitForSuccessfulExit = async (exitPromise) => {
  const [exitCode, signal] = await exitPromise;
  if (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {
    throw new DiscardedError();
  }
  return [exitCode, signal];
};
var isSubprocessErrorExit = (exitCode, signal) => exitCode === void 0 && signal === void 0;
var isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;

// node_modules/execa/lib/resolve/exit-sync.js
var getExitResultSync = ({ error, status: exitCode, signal, output }, { maxBuffer }) => {
  const resultError = getResultError(error, exitCode, signal);
  const timedOut = resultError?.code === "ETIMEDOUT";
  const isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);
  return {
    resultError,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer
  };
};
var getResultError = (error, exitCode, signal) => {
  if (error !== void 0) {
    return error;
  }
  return isFailedExit(exitCode, signal) ? new DiscardedError() : void 0;
};

// node_modules/execa/lib/methods/main-sync.js
var execaCoreSync = (rawFile, rawArguments, rawOptions) => {
  const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleSyncArguments(rawFile, rawArguments, rawOptions);
  const result = spawnSubprocessSync({
    file,
    commandArguments,
    options,
    command,
    escapedCommand,
    verboseInfo,
    fileDescriptors,
    startTime
  });
  return handleResult(result, verboseInfo, options);
};
var handleSyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const syncOptions = normalizeSyncOptions(rawOptions);
  const { file, commandArguments, options } = normalizeOptions(rawFile, rawArguments, syncOptions);
  validateSyncOptions(options);
  const fileDescriptors = handleStdioSync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
};
var normalizeSyncOptions = (options) => options.node && !options.ipc ? { ...options, ipc: false } : options;
var validateSyncOptions = ({ ipc, ipcInput, detached, cancelSignal }) => {
  if (ipcInput) {
    throwInvalidSyncOption("ipcInput");
  }
  if (ipc) {
    throwInvalidSyncOption("ipc: true");
  }
  if (detached) {
    throwInvalidSyncOption("detached: true");
  }
  if (cancelSignal) {
    throwInvalidSyncOption("cancelSignal");
  }
};
var throwInvalidSyncOption = (value) => {
  throw new TypeError(`The "${value}" option cannot be used with synchronous methods.`);
};
var spawnSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime }) => {
  const syncResult = runSubprocessSync({
    file,
    commandArguments,
    options,
    command,
    escapedCommand,
    fileDescriptors,
    startTime
  });
  if (syncResult.failed) {
    return syncResult;
  }
  const { resultError, exitCode, signal, timedOut, isMaxBuffer } = getExitResultSync(syncResult, options);
  const { output, error = resultError } = transformOutputSync({
    fileDescriptors,
    syncResult,
    options,
    isMaxBuffer,
    verboseInfo
  });
  const stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));
  const all3 = stripNewline(getAllSync(output, options), options, "all");
  return getSyncResult({
    error,
    exitCode,
    signal,
    timedOut,
    isMaxBuffer,
    stdio,
    all: all3,
    options,
    command,
    escapedCommand,
    startTime
  });
};
var runSubprocessSync = ({ file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime }) => {
  try {
    addInputOptionsSync(fileDescriptors, options);
    const normalizedOptions = normalizeSpawnSyncOptions(options);
    return (0, import_node_child_process3.spawnSync)(...concatenateShell(file, commandArguments, normalizedOptions));
  } catch (error) {
    return makeEarlyError({
      error,
      command,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      isSync: true
    });
  }
};
var normalizeSpawnSyncOptions = ({ encoding, maxBuffer, ...options }) => ({ ...options, encoding: "buffer", maxBuffer: getMaxBufferSync(maxBuffer) });
var getSyncResult = ({ error, exitCode, signal, timedOut, isMaxBuffer, stdio, all: all3, options, command, escapedCommand, startTime }) => error === void 0 ? makeSuccessResult({
  command,
  escapedCommand,
  stdio,
  all: all3,
  ipcOutput: [],
  options,
  startTime
}) : makeError({
  error,
  command,
  escapedCommand,
  timedOut,
  isCanceled: false,
  isGracefullyCanceled: false,
  isMaxBuffer,
  isForcefullyTerminated: false,
  exitCode,
  signal,
  stdio,
  all: all3,
  ipcOutput: [],
  options,
  startTime,
  isSync: true
});

// node_modules/execa/lib/methods/main-async.js
var import_node_events14 = require("node:events");
var import_node_child_process5 = require("node:child_process");

// node_modules/execa/lib/ipc/methods.js
var import_node_process10 = __toESM(require("node:process"), 1);

// node_modules/execa/lib/ipc/get-one.js
var import_node_events8 = require("node:events");
var getOneMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference: reference2 = true, filter: filter3 } = {}) => {
  validateIpcMethod({
    methodName: "getOneMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  return getOneMessageAsync({
    anyProcess,
    channel,
    isSubprocess,
    filter: filter3,
    reference: reference2
  });
};
var getOneMessageAsync = async ({ anyProcess, channel, isSubprocess, filter: filter3, reference: reference2 }) => {
  addReference(channel, reference2);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController();
  try {
    return await Promise.race([
      getMessage(ipcEmitter, filter3, controller),
      throwOnDisconnect2(ipcEmitter, isSubprocess, controller),
      throwOnStrictError(ipcEmitter, isSubprocess, controller)
    ]);
  } catch (error) {
    disconnect(anyProcess);
    throw error;
  } finally {
    controller.abort();
    removeReference(channel, reference2);
  }
};
var getMessage = async (ipcEmitter, filter3, { signal }) => {
  if (filter3 === void 0) {
    const [message] = await (0, import_node_events8.once)(ipcEmitter, "message", { signal });
    return message;
  }
  for await (const [message] of (0, import_node_events8.on)(ipcEmitter, "message", { signal })) {
    if (filter3(message)) {
      return message;
    }
  }
};
var throwOnDisconnect2 = async (ipcEmitter, isSubprocess, { signal }) => {
  await (0, import_node_events8.once)(ipcEmitter, "disconnect", { signal });
  throwOnEarlyDisconnect(isSubprocess);
};
var throwOnStrictError = async (ipcEmitter, isSubprocess, { signal }) => {
  const [error] = await (0, import_node_events8.once)(ipcEmitter, "strict:error", { signal });
  throw getStrictResponseError(error, isSubprocess);
};

// node_modules/execa/lib/ipc/get-each.js
var import_node_events9 = require("node:events");
var getEachMessage = ({ anyProcess, channel, isSubprocess, ipc }, { reference: reference2 = true } = {}) => loopOnMessages({
  anyProcess,
  channel,
  isSubprocess,
  ipc,
  shouldAwait: !isSubprocess,
  reference: reference2
});
var loopOnMessages = ({ anyProcess, channel, isSubprocess, ipc, shouldAwait, reference: reference2 }) => {
  validateIpcMethod({
    methodName: "getEachMessage",
    isSubprocess,
    ipc,
    isConnected: isConnected(anyProcess)
  });
  addReference(channel, reference2);
  const ipcEmitter = getIpcEmitter(anyProcess, channel, isSubprocess);
  const controller = new AbortController();
  const state = {};
  stopOnDisconnect(anyProcess, ipcEmitter, controller);
  abortOnStrictError({
    ipcEmitter,
    isSubprocess,
    controller,
    state
  });
  return iterateOnMessages({
    anyProcess,
    channel,
    ipcEmitter,
    isSubprocess,
    shouldAwait,
    controller,
    state,
    reference: reference2
  });
};
var stopOnDisconnect = async (anyProcess, ipcEmitter, controller) => {
  try {
    await (0, import_node_events9.once)(ipcEmitter, "disconnect", { signal: controller.signal });
    controller.abort();
  } catch {
  }
};
var abortOnStrictError = async ({ ipcEmitter, isSubprocess, controller, state }) => {
  try {
    const [error] = await (0, import_node_events9.once)(ipcEmitter, "strict:error", { signal: controller.signal });
    state.error = getStrictResponseError(error, isSubprocess);
    controller.abort();
  } catch {
  }
};
var iterateOnMessages = async function* ({ anyProcess, channel, ipcEmitter, isSubprocess, shouldAwait, controller, state, reference: reference2 }) {
  try {
    for await (const [message] of (0, import_node_events9.on)(ipcEmitter, "message", { signal: controller.signal })) {
      throwIfStrictError(state);
      yield message;
    }
  } catch {
    throwIfStrictError(state);
  } finally {
    controller.abort();
    removeReference(channel, reference2);
    if (!isSubprocess) {
      disconnect(anyProcess);
    }
    if (shouldAwait) {
      await anyProcess;
    }
  }
};
var throwIfStrictError = ({ error }) => {
  if (error) {
    throw error;
  }
};

// node_modules/execa/lib/ipc/methods.js
var addIpcMethods = (subprocess, { ipc }) => {
  Object.assign(subprocess, getIpcMethods(subprocess, false, ipc));
};
var getIpcExport = () => {
  const anyProcess = import_node_process10.default;
  const isSubprocess = true;
  const ipc = import_node_process10.default.channel !== void 0;
  return {
    ...getIpcMethods(anyProcess, isSubprocess, ipc),
    getCancelSignal: getCancelSignal.bind(void 0, {
      anyProcess,
      channel: anyProcess.channel,
      isSubprocess,
      ipc
    })
  };
};
var getIpcMethods = (anyProcess, isSubprocess, ipc) => ({
  sendMessage: sendMessage.bind(void 0, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getOneMessage: getOneMessage.bind(void 0, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  }),
  getEachMessage: getEachMessage.bind(void 0, {
    anyProcess,
    channel: anyProcess.channel,
    isSubprocess,
    ipc
  })
});

// node_modules/execa/lib/return/early-error.js
var import_node_child_process4 = require("node:child_process");
var import_node_stream2 = require("node:stream");
var handleEarlyError = ({ error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo }) => {
  cleanupCustomStreams(fileDescriptors);
  const subprocess = new import_node_child_process4.ChildProcess();
  createDummyStreams(subprocess, fileDescriptors);
  Object.assign(subprocess, { readable, writable, duplex });
  const earlyError = makeEarlyError({
    error,
    command,
    escapedCommand,
    fileDescriptors,
    options,
    startTime,
    isSync: false
  });
  const promise = handleDummyPromise(earlyError, verboseInfo, options);
  return { subprocess, promise };
};
var createDummyStreams = (subprocess, fileDescriptors) => {
  const stdin = createDummyStream();
  const stdout = createDummyStream();
  const stderr = createDummyStream();
  const extraStdio = Array.from({ length: fileDescriptors.length - 3 }, createDummyStream);
  const all3 = createDummyStream();
  const stdio = [stdin, stdout, stderr, ...extraStdio];
  Object.assign(subprocess, {
    stdin,
    stdout,
    stderr,
    all: all3,
    stdio
  });
};
var createDummyStream = () => {
  const stream5 = new import_node_stream2.PassThrough();
  stream5.end();
  return stream5;
};
var readable = () => new import_node_stream2.Readable({ read() {
} });
var writable = () => new import_node_stream2.Writable({ write() {
} });
var duplex = () => new import_node_stream2.Duplex({ read() {
}, write() {
} });
var handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);

// node_modules/execa/lib/stdio/handle-async.js
var import_node_fs5 = require("node:fs");
var import_node_buffer3 = require("node:buffer");
var import_node_stream3 = require("node:stream");
var handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);
var forbiddenIfAsync = ({ type, optionName }) => {
  throw new TypeError(`The \`${optionName}\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);
};
var addProperties2 = {
  fileNumber: forbiddenIfAsync,
  generator: generatorToStream,
  asyncGenerator: generatorToStream,
  nodeStream: ({ value }) => ({ stream: value }),
  webTransform({ value: { transform, writableObjectMode, readableObjectMode } }) {
    const objectMode = writableObjectMode || readableObjectMode;
    const stream5 = import_node_stream3.Duplex.fromWeb(transform, { objectMode });
    return { stream: stream5 };
  },
  duplex: ({ value: { transform } }) => ({ stream: transform }),
  native() {
  }
};
var addPropertiesAsync = {
  input: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: (0, import_node_fs5.createReadStream)(value) }),
    filePath: ({ value: { file } }) => ({ stream: (0, import_node_fs5.createReadStream)(file) }),
    webStream: ({ value }) => ({ stream: import_node_stream3.Readable.fromWeb(value) }),
    iterable: ({ value }) => ({ stream: import_node_stream3.Readable.from(value) }),
    asyncIterable: ({ value }) => ({ stream: import_node_stream3.Readable.from(value) }),
    string: ({ value }) => ({ stream: import_node_stream3.Readable.from(value) }),
    uint8Array: ({ value }) => ({ stream: import_node_stream3.Readable.from(import_node_buffer3.Buffer.from(value)) })
  },
  output: {
    ...addProperties2,
    fileUrl: ({ value }) => ({ stream: (0, import_node_fs5.createWriteStream)(value) }),
    filePath: ({ value: { file, append: append2 } }) => ({ stream: (0, import_node_fs5.createWriteStream)(file, append2 ? { flags: "a" } : {}) }),
    webStream: ({ value }) => ({ stream: import_node_stream3.Writable.fromWeb(value) }),
    iterable: forbiddenIfAsync,
    asyncIterable: forbiddenIfAsync,
    string: forbiddenIfAsync,
    uint8Array: forbiddenIfAsync
  }
};

// node_modules/@sindresorhus/merge-streams/index.js
var import_node_events10 = require("node:events");
var import_node_stream4 = require("node:stream");
var import_promises6 = require("node:stream/promises");
function mergeStreams(streams) {
  if (!Array.isArray(streams)) {
    throw new TypeError(`Expected an array, got \`${typeof streams}\`.`);
  }
  for (const stream5 of streams) {
    validateStream(stream5);
  }
  const objectMode = streams.some(({ readableObjectMode }) => readableObjectMode);
  const highWaterMark = getHighWaterMark(streams, objectMode);
  const passThroughStream = new MergedStream({
    objectMode,
    writableHighWaterMark: highWaterMark,
    readableHighWaterMark: highWaterMark
  });
  for (const stream5 of streams) {
    passThroughStream.add(stream5);
  }
  return passThroughStream;
}
var getHighWaterMark = (streams, objectMode) => {
  if (streams.length === 0) {
    return (0, import_node_stream4.getDefaultHighWaterMark)(objectMode);
  }
  const highWaterMarks = streams.filter(({ readableObjectMode }) => readableObjectMode === objectMode).map(({ readableHighWaterMark }) => readableHighWaterMark);
  return Math.max(...highWaterMarks);
};
var MergedStream = class extends import_node_stream4.PassThrough {
  #streams = /* @__PURE__ */ new Set([]);
  #ended = /* @__PURE__ */ new Set([]);
  #aborted = /* @__PURE__ */ new Set([]);
  #onFinished;
  #unpipeEvent = Symbol("unpipe");
  #streamPromises = /* @__PURE__ */ new WeakMap();
  add(stream5) {
    validateStream(stream5);
    if (this.#streams.has(stream5)) {
      return;
    }
    this.#streams.add(stream5);
    this.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);
    const streamPromise = endWhenStreamsDone({
      passThroughStream: this,
      stream: stream5,
      streams: this.#streams,
      ended: this.#ended,
      aborted: this.#aborted,
      onFinished: this.#onFinished,
      unpipeEvent: this.#unpipeEvent
    });
    this.#streamPromises.set(stream5, streamPromise);
    stream5.pipe(this, { end: false });
  }
  async remove(stream5) {
    validateStream(stream5);
    if (!this.#streams.has(stream5)) {
      return false;
    }
    const streamPromise = this.#streamPromises.get(stream5);
    if (streamPromise === void 0) {
      return false;
    }
    this.#streamPromises.delete(stream5);
    stream5.unpipe(this);
    await streamPromise;
    return true;
  }
};
var onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);
  const controller = new AbortController();
  try {
    await Promise.race([
      onMergedStreamEnd(passThroughStream, controller),
      onInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller)
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);
  }
};
var onMergedStreamEnd = async (passThroughStream, { signal }) => {
  try {
    await (0, import_promises6.finished)(passThroughStream, { signal, cleanup: true });
  } catch (error) {
    errorOrAbortStream(passThroughStream, error);
    throw error;
  }
};
var onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, { signal }) => {
  for await (const [unpipedStream] of (0, import_node_events10.on)(passThroughStream, "unpipe", { signal })) {
    if (streams.has(unpipedStream)) {
      unpipedStream.emit(unpipeEvent);
    }
  }
};
var validateStream = (stream5) => {
  if (typeof stream5?.pipe !== "function") {
    throw new TypeError(`Expected a readable stream, got: \`${typeof stream5}\`.`);
  }
};
var endWhenStreamsDone = async ({ passThroughStream, stream: stream5, streams, ended, aborted: aborted2, onFinished, unpipeEvent }) => {
  updateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);
  const controller = new AbortController();
  try {
    await Promise.race([
      afterMergedStreamFinished(onFinished, stream5, controller),
      onInputStreamEnd({
        passThroughStream,
        stream: stream5,
        streams,
        ended,
        aborted: aborted2,
        controller
      }),
      onInputStreamUnpipe({
        stream: stream5,
        streams,
        ended,
        aborted: aborted2,
        unpipeEvent,
        controller
      })
    ]);
  } finally {
    controller.abort();
    updateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);
  }
  if (streams.size > 0 && streams.size === ended.size + aborted2.size) {
    if (ended.size === 0 && aborted2.size > 0) {
      abortStream(passThroughStream);
    } else {
      endStream(passThroughStream);
    }
  }
};
var afterMergedStreamFinished = async (onFinished, stream5, { signal }) => {
  try {
    await onFinished;
    if (!signal.aborted) {
      abortStream(stream5);
    }
  } catch (error) {
    if (!signal.aborted) {
      errorOrAbortStream(stream5, error);
    }
  }
};
var onInputStreamEnd = async ({ passThroughStream, stream: stream5, streams, ended, aborted: aborted2, controller: { signal } }) => {
  try {
    await (0, import_promises6.finished)(stream5, {
      signal,
      cleanup: true,
      readable: true,
      writable: false
    });
    if (streams.has(stream5)) {
      ended.add(stream5);
    }
  } catch (error) {
    if (signal.aborted || !streams.has(stream5)) {
      return;
    }
    if (isAbortError(error)) {
      aborted2.add(stream5);
    } else {
      errorStream(passThroughStream, error);
    }
  }
};
var onInputStreamUnpipe = async ({ stream: stream5, streams, ended, aborted: aborted2, unpipeEvent, controller: { signal } }) => {
  await (0, import_node_events10.once)(stream5, unpipeEvent, { signal });
  if (!stream5.readable) {
    return (0, import_node_events10.once)(signal, "abort", { signal });
  }
  streams.delete(stream5);
  ended.delete(stream5);
  aborted2.delete(stream5);
};
var endStream = (stream5) => {
  if (stream5.writable) {
    stream5.end();
  }
};
var errorOrAbortStream = (stream5, error) => {
  if (isAbortError(error)) {
    abortStream(stream5);
  } else {
    errorStream(stream5, error);
  }
};
var isAbortError = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE";
var abortStream = (stream5) => {
  if (stream5.readable || stream5.writable) {
    stream5.destroy();
  }
};
var errorStream = (stream5, error) => {
  if (!stream5.destroyed) {
    stream5.once("error", noop2);
    stream5.destroy(error);
  }
};
var noop2 = () => {
};
var updateMaxListeners = (passThroughStream, increment2) => {
  const maxListeners = passThroughStream.getMaxListeners();
  if (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {
    passThroughStream.setMaxListeners(maxListeners + increment2);
  }
};
var PASSTHROUGH_LISTENERS_COUNT = 2;
var PASSTHROUGH_LISTENERS_PER_STREAM = 1;

// node_modules/execa/lib/io/pipeline.js
var import_promises7 = require("node:stream/promises");
var pipeStreams = (source, destination) => {
  source.pipe(destination);
  onSourceFinish(source, destination);
  onDestinationFinish(source, destination);
};
var onSourceFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await (0, import_promises7.finished)(source, { cleanup: true, readable: true, writable: false });
  } catch {
  }
  endDestinationStream(destination);
};
var endDestinationStream = (destination) => {
  if (destination.writable) {
    destination.end();
  }
};
var onDestinationFinish = async (source, destination) => {
  if (isStandardStream(source) || isStandardStream(destination)) {
    return;
  }
  try {
    await (0, import_promises7.finished)(destination, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  abortSourceStream(source);
};
var abortSourceStream = (source) => {
  if (source.readable) {
    source.destroy();
  }
};

// node_modules/execa/lib/io/output-async.js
var pipeOutputAsync = (subprocess, fileDescriptors, controller) => {
  const pipeGroups = /* @__PURE__ */ new Map();
  for (const [fdNumber, { stdioItems, direction }] of Object.entries(fileDescriptors)) {
    for (const { stream: stream5 } of stdioItems.filter(({ type }) => TRANSFORM_TYPES.has(type))) {
      pipeTransform(subprocess, stream5, direction, fdNumber);
    }
    for (const { stream: stream5 } of stdioItems.filter(({ type }) => !TRANSFORM_TYPES.has(type))) {
      pipeStdioItem({
        subprocess,
        stream: stream5,
        direction,
        fdNumber,
        pipeGroups,
        controller
      });
    }
  }
  for (const [outputStream, inputStreams] of pipeGroups.entries()) {
    const inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);
    pipeStreams(inputStream, outputStream);
  }
};
var pipeTransform = (subprocess, stream5, direction, fdNumber) => {
  if (direction === "output") {
    pipeStreams(subprocess.stdio[fdNumber], stream5);
  } else {
    pipeStreams(stream5, subprocess.stdio[fdNumber]);
  }
  const streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];
  if (streamProperty !== void 0) {
    subprocess[streamProperty] = stream5;
  }
  subprocess.stdio[fdNumber] = stream5;
};
var SUBPROCESS_STREAM_PROPERTIES = ["stdin", "stdout", "stderr"];
var pipeStdioItem = ({ subprocess, stream: stream5, direction, fdNumber, pipeGroups, controller }) => {
  if (stream5 === void 0) {
    return;
  }
  setStandardStreamMaxListeners(stream5, controller);
  const [inputStream, outputStream] = direction === "output" ? [stream5, subprocess.stdio[fdNumber]] : [subprocess.stdio[fdNumber], stream5];
  const outputStreams = pipeGroups.get(inputStream) ?? [];
  pipeGroups.set(inputStream, [...outputStreams, outputStream]);
};
var setStandardStreamMaxListeners = (stream5, { signal }) => {
  if (isStandardStream(stream5)) {
    incrementMaxListeners(stream5, MAX_LISTENERS_INCREMENT, signal);
  }
};
var MAX_LISTENERS_INCREMENT = 2;

// node_modules/execa/lib/terminate/cleanup.js
var import_node_events11 = require("node:events");

// node_modules/signal-exit/dist/mjs/signals.js
var signals = [];
signals.push("SIGHUP", "SIGINT", "SIGTERM");
if (process.platform !== "win32") {
  signals.push(
    "SIGALRM",
    "SIGABRT",
    "SIGVTALRM",
    "SIGXCPU",
    "SIGXFSZ",
    "SIGUSR2",
    "SIGTRAP",
    "SIGSYS",
    "SIGQUIT",
    "SIGIOT"
    // should detect profiler and enable/disable accordingly.
    // see #21
    // 'SIGPROF'
  );
}
if (process.platform === "linux") {
  signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
}

// node_modules/signal-exit/dist/mjs/index.js
var processOk = (process10) => !!process10 && typeof process10 === "object" && typeof process10.removeListener === "function" && typeof process10.emit === "function" && typeof process10.reallyExit === "function" && typeof process10.listeners === "function" && typeof process10.kill === "function" && typeof process10.pid === "number" && typeof process10.on === "function";
var kExitEmitter = Symbol.for("signal-exit emitter");
var global2 = globalThis;
var ObjectDefineProperty = Object.defineProperty.bind(Object);
var Emitter = class {
  emitted = {
    afterExit: false,
    exit: false
  };
  listeners = {
    afterExit: [],
    exit: []
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list2 = this.listeners[ev];
    const i2 = list2.indexOf(fn);
    if (i2 === -1) {
      return;
    }
    if (i2 === 0 && list2.length === 1) {
      list2.length = 0;
    } else {
      list2.splice(i2, 1);
    }
  }
  emit(ev, code2, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code2, signal) === true || ret;
    }
    if (ev === "exit") {
      ret = this.emit("afterExit", code2, signal) || ret;
    }
    return ret;
  }
};
var SignalExitBase = class {
};
var signalExitWrap = (handler) => {
  return {
    onExit(cb, opts) {
      return handler.onExit(cb, opts);
    },
    load() {
      return handler.load();
    },
    unload() {
      return handler.unload();
    }
  };
};
var SignalExitFallback = class extends SignalExitBase {
  onExit() {
    return () => {
    };
  }
  load() {
  }
  unload() {
  }
};
var SignalExit = class extends SignalExitBase {
  // "SIGHUP" throws an `ENOSYS` error on Windows,
  // so use a supported signal instead
  /* c8 ignore start */
  #hupSig = process9.platform === "win32" ? "SIGINT" : "SIGHUP";
  /* c8 ignore stop */
  #emitter = new Emitter();
  #process;
  #originalProcessEmit;
  #originalProcessReallyExit;
  #sigListeners = {};
  #loaded = false;
  constructor(process10) {
    super();
    this.#process = process10;
    this.#sigListeners = {};
    for (const sig of signals) {
      this.#sigListeners[sig] = () => {
        const listeners = this.#process.listeners(sig);
        let { count: count2 } = this.#emitter;
        const p = process10;
        if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
          count2 += p.__signal_exit_emitter__.count;
        }
        if (listeners.length === count2) {
          this.unload();
          const ret = this.#emitter.emit("exit", null, sig);
          const s = sig === "SIGHUP" ? this.#hupSig : sig;
          if (!ret)
            process10.kill(process10.pid, s);
        }
      };
    }
    this.#originalProcessReallyExit = process10.reallyExit;
    this.#originalProcessEmit = process10.emit;
  }
  onExit(cb, opts) {
    if (!processOk(this.#process)) {
      return () => {
      };
    }
    if (this.#loaded === false) {
      this.load();
    }
    const ev = opts?.alwaysLast ? "afterExit" : "exit";
    this.#emitter.on(ev, cb);
    return () => {
      this.#emitter.removeListener(ev, cb);
      if (this.#emitter.listeners["exit"].length === 0 && this.#emitter.listeners["afterExit"].length === 0) {
        this.unload();
      }
    };
  }
  load() {
    if (this.#loaded) {
      return;
    }
    this.#loaded = true;
    this.#emitter.count += 1;
    for (const sig of signals) {
      try {
        const fn = this.#sigListeners[sig];
        if (fn)
          this.#process.on(sig, fn);
      } catch (_) {
      }
    }
    this.#process.emit = (ev, ...a2) => {
      return this.#processEmit(ev, ...a2);
    };
    this.#process.reallyExit = (code2) => {
      return this.#processReallyExit(code2);
    };
  }
  unload() {
    if (!this.#loaded) {
      return;
    }
    this.#loaded = false;
    signals.forEach((sig) => {
      const listener = this.#sigListeners[sig];
      if (!listener) {
        throw new Error("Listener not defined for signal: " + sig);
      }
      try {
        this.#process.removeListener(sig, listener);
      } catch (_) {
      }
    });
    this.#process.emit = this.#originalProcessEmit;
    this.#process.reallyExit = this.#originalProcessReallyExit;
    this.#emitter.count -= 1;
  }
  #processReallyExit(code2) {
    if (!processOk(this.#process)) {
      return 0;
    }
    this.#process.exitCode = code2 || 0;
    this.#emitter.emit("exit", this.#process.exitCode, null);
    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
  }
  #processEmit(ev, ...args) {
    const og = this.#originalProcessEmit;
    if (ev === "exit" && processOk(this.#process)) {
      if (typeof args[0] === "number") {
        this.#process.exitCode = args[0];
      }
      const ret = og.call(this.#process, ev, ...args);
      this.#emitter.emit("exit", this.#process.exitCode, null);
      return ret;
    } else {
      return og.call(this.#process, ev, ...args);
    }
  }
};
var process9 = globalThis.process;
var {
  /**
   * Called when the process is exiting, whether via signal, explicit
   * exit, or running out of stuff to do.
   *
   * If the global process object is not suitable for instrumentation,
   * then this will be a no-op.
   *
   * Returns a function that may be used to unload signal-exit.
   */
  onExit,
  /**
   * Load the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  load,
  /**
   * Unload the listeners.  Likely you never need to call this, unless
   * doing a rather deep integration with signal-exit functionality.
   * Mostly exposed for the benefit of testing.
   *
   * @internal
   */
  unload
} = signalExitWrap(processOk(process9) ? new SignalExit(process9) : new SignalExitFallback());

// node_modules/execa/lib/terminate/cleanup.js
var cleanupOnExit = (subprocess, { cleanup, detached }, { signal }) => {
  if (!cleanup || detached) {
    return;
  }
  const removeExitHandler = onExit(() => {
    subprocess.kill();
  });
  (0, import_node_events11.addAbortListener)(signal, () => {
    removeExitHandler();
  });
};

// node_modules/execa/lib/pipe/pipe-arguments.js
var normalizePipeArguments = ({ source, sourcePromise, boundOptions, createNested }, ...pipeArguments) => {
  const startTime = getStartTime();
  const {
    destination,
    destinationStream,
    destinationError,
    from,
    unpipeSignal
  } = getDestinationStream(boundOptions, createNested, pipeArguments);
  const { sourceStream, sourceError } = getSourceStream(source, from);
  const { options: sourceOptions, fileDescriptors } = SUBPROCESS_OPTIONS.get(source);
  return {
    sourcePromise,
    sourceStream,
    sourceOptions,
    sourceError,
    destination,
    destinationStream,
    destinationError,
    unpipeSignal,
    fileDescriptors,
    startTime
  };
};
var getDestinationStream = (boundOptions, createNested, pipeArguments) => {
  try {
    const {
      destination,
      pipeOptions: { from, to, unpipeSignal } = {}
    } = getDestination(boundOptions, createNested, ...pipeArguments);
    const destinationStream = getToStream(destination, to);
    return {
      destination,
      destinationStream,
      from,
      unpipeSignal
    };
  } catch (error) {
    return { destinationError: error };
  }
};
var getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {
  if (Array.isArray(firstArgument)) {
    const destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);
    return { destination, pipeOptions: boundOptions };
  }
  if (typeof firstArgument === "string" || firstArgument instanceof URL || isDenoExecPath(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');
    }
    const [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);
    const destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);
    return { destination, pipeOptions: rawOptions };
  }
  if (SUBPROCESS_OPTIONS.has(firstArgument)) {
    if (Object.keys(boundOptions).length > 0) {
      throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");
    }
    return { destination: firstArgument, pipeOptions: pipeArguments[0] };
  }
  throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);
};
var mapDestinationArguments = ({ options }) => ({ options: { ...options, stdin: "pipe", piped: true } });
var getSourceStream = (source, from) => {
  try {
    const sourceStream = getFromStream(source, from);
    return { sourceStream };
  } catch (error) {
    return { sourceError: error };
  }
};

// node_modules/execa/lib/pipe/throw.js
var handlePipeArgumentsError = ({
  sourceStream,
  sourceError,
  destinationStream,
  destinationError,
  fileDescriptors,
  sourceOptions,
  startTime
}) => {
  const error = getPipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError
  });
  if (error !== void 0) {
    throw createNonCommandError({
      error,
      fileDescriptors,
      sourceOptions,
      startTime
    });
  }
};
var getPipeArgumentsError = ({ sourceStream, sourceError, destinationStream, destinationError }) => {
  if (sourceError !== void 0 && destinationError !== void 0) {
    return destinationError;
  }
  if (destinationError !== void 0) {
    abortSourceStream(sourceStream);
    return destinationError;
  }
  if (sourceError !== void 0) {
    endDestinationStream(destinationStream);
    return sourceError;
  }
};
var createNonCommandError = ({ error, fileDescriptors, sourceOptions, startTime }) => makeEarlyError({
  error,
  command: PIPE_COMMAND_MESSAGE,
  escapedCommand: PIPE_COMMAND_MESSAGE,
  fileDescriptors,
  options: sourceOptions,
  startTime,
  isSync: false
});
var PIPE_COMMAND_MESSAGE = "source.pipe(destination)";

// node_modules/execa/lib/pipe/sequence.js
var waitForBothSubprocesses = async (subprocessPromises) => {
  const [
    { status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason },
    { status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason }
  ] = await subprocessPromises;
  if (!destinationResult.pipedFrom.includes(sourceResult)) {
    destinationResult.pipedFrom.push(sourceResult);
  }
  if (destinationStatus === "rejected") {
    throw destinationResult;
  }
  if (sourceStatus === "rejected") {
    throw sourceResult;
  }
  return destinationResult;
};

// node_modules/execa/lib/pipe/streaming.js
var import_promises8 = require("node:stream/promises");
var pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {
  const mergedStream = MERGED_STREAMS.has(destinationStream) ? pipeMoreSubprocessStream(sourceStream, destinationStream) : pipeFirstSubprocessStream(sourceStream, destinationStream);
  incrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);
  incrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);
  cleanupMergedStreamsMap(destinationStream);
  return mergedStream;
};
var pipeFirstSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = mergeStreams([sourceStream]);
  pipeStreams(mergedStream, destinationStream);
  MERGED_STREAMS.set(destinationStream, mergedStream);
  return mergedStream;
};
var pipeMoreSubprocessStream = (sourceStream, destinationStream) => {
  const mergedStream = MERGED_STREAMS.get(destinationStream);
  mergedStream.add(sourceStream);
  return mergedStream;
};
var cleanupMergedStreamsMap = async (destinationStream) => {
  try {
    await (0, import_promises8.finished)(destinationStream, { cleanup: true, readable: false, writable: true });
  } catch {
  }
  MERGED_STREAMS.delete(destinationStream);
};
var MERGED_STREAMS = /* @__PURE__ */ new WeakMap();
var SOURCE_LISTENERS_PER_PIPE = 2;
var DESTINATION_LISTENERS_PER_PIPE = 1;

// node_modules/execa/lib/pipe/abort.js
var import_node_util8 = require("node:util");
var unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === void 0 ? [] : [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];
var unpipeOnSignalAbort = async (unpipeSignal, { sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime }) => {
  await (0, import_node_util8.aborted)(unpipeSignal, sourceStream);
  await mergedStream.remove(sourceStream);
  const error = new Error("Pipe canceled by `unpipeSignal` option.");
  throw createNonCommandError({
    error,
    fileDescriptors,
    sourceOptions,
    startTime
  });
};

// node_modules/execa/lib/pipe/setup.js
var pipeToSubprocess = (sourceInfo, ...pipeArguments) => {
  if (isPlainObject(pipeArguments[0])) {
    return pipeToSubprocess.bind(void 0, {
      ...sourceInfo,
      boundOptions: { ...sourceInfo.boundOptions, ...pipeArguments[0] }
    });
  }
  const { destination, ...normalizedInfo } = normalizePipeArguments(sourceInfo, ...pipeArguments);
  const promise = handlePipePromise({ ...normalizedInfo, destination });
  promise.pipe = pipeToSubprocess.bind(void 0, {
    ...sourceInfo,
    source: destination,
    sourcePromise: promise,
    boundOptions: {}
  });
  return promise;
};
var handlePipePromise = async ({
  sourcePromise,
  sourceStream,
  sourceOptions,
  sourceError,
  destination,
  destinationStream,
  destinationError,
  unpipeSignal,
  fileDescriptors,
  startTime
}) => {
  const subprocessPromises = getSubprocessPromises(sourcePromise, destination);
  handlePipeArgumentsError({
    sourceStream,
    sourceError,
    destinationStream,
    destinationError,
    fileDescriptors,
    sourceOptions,
    startTime
  });
  const maxListenersController = new AbortController();
  try {
    const mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);
    return await Promise.race([
      waitForBothSubprocesses(subprocessPromises),
      ...unpipeOnAbort(unpipeSignal, {
        sourceStream,
        mergedStream,
        sourceOptions,
        fileDescriptors,
        startTime
      })
    ]);
  } finally {
    maxListenersController.abort();
  }
};
var getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);

// node_modules/execa/lib/io/contents.js
var import_promises9 = require("node:timers/promises");

// node_modules/execa/lib/io/iterate.js
var import_node_events12 = require("node:events");
var import_node_stream5 = require("node:stream");
var iterateOnSubprocessStream = ({ subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines }) => {
  const controller = new AbortController();
  stopReadingOnExit(subprocess, controller);
  return iterateOnStream({
    stream: subprocessStdout,
    controller,
    binary,
    shouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,
    encoding,
    shouldSplit: !subprocessStdout.readableObjectMode,
    preserveNewlines
  });
};
var stopReadingOnExit = async (subprocess, controller) => {
  try {
    await subprocess;
  } catch {
  } finally {
    controller.abort();
  }
};
var iterateForResult = ({ stream: stream5, onStreamEnd, lines, encoding, stripFinalNewline: stripFinalNewline2, allMixed }) => {
  const controller = new AbortController();
  stopReadingOnStreamEnd(onStreamEnd, controller, stream5);
  const objectMode = stream5.readableObjectMode && !allMixed;
  return iterateOnStream({
    stream: stream5,
    controller,
    binary: encoding === "buffer",
    shouldEncode: !objectMode,
    encoding,
    shouldSplit: !objectMode && lines,
    preserveNewlines: !stripFinalNewline2
  });
};
var stopReadingOnStreamEnd = async (onStreamEnd, controller, stream5) => {
  try {
    await onStreamEnd;
  } catch {
    stream5.destroy();
  } finally {
    controller.abort();
  }
};
var iterateOnStream = ({ stream: stream5, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => {
  const onStdoutChunk = (0, import_node_events12.on)(stream5, "data", {
    signal: controller.signal,
    highWaterMark: HIGH_WATER_MARK,
    // Backward compatibility with older name for this option
    // See https://github.com/nodejs/node/pull/52080#discussion_r1525227861
    // @todo Remove after removing support for Node 21
    highWatermark: HIGH_WATER_MARK
  });
  return iterateOnData({
    onStdoutChunk,
    controller,
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
};
var DEFAULT_OBJECT_HIGH_WATER_MARK = (0, import_node_stream5.getDefaultHighWaterMark)(true);
var HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;
var iterateOnData = async function* ({ onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) {
  const generators = getGenerators({
    binary,
    shouldEncode,
    encoding,
    shouldSplit,
    preserveNewlines
  });
  try {
    for await (const [chunk] of onStdoutChunk) {
      yield* transformChunkSync(chunk, generators, 0);
    }
  } catch (error) {
    if (!controller.signal.aborted) {
      throw error;
    }
  } finally {
    yield* finalChunksSync(generators);
  }
};
var getGenerators = ({ binary, shouldEncode, encoding, shouldSplit, preserveNewlines }) => [
  getEncodingTransformGenerator(binary, encoding, !shouldEncode),
  getSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {})
].filter(Boolean);

// node_modules/execa/lib/io/contents.js
var getStreamOutput = async ({ stream: stream5, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  const logPromise = logOutputAsync({
    stream: stream5,
    onStreamEnd,
    fdNumber,
    encoding,
    allMixed,
    verboseInfo,
    streamInfo
  });
  if (!buffer) {
    await Promise.all([resumeStream(stream5), logPromise]);
    return;
  }
  const stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline2, fdNumber);
  const iterable = iterateForResult({
    stream: stream5,
    onStreamEnd,
    lines,
    encoding,
    stripFinalNewline: stripFinalNewlineValue,
    allMixed
  });
  const [output] = await Promise.all([
    getStreamContents2({
      stream: stream5,
      iterable,
      fdNumber,
      encoding,
      maxBuffer,
      lines
    }),
    logPromise
  ]);
  return output;
};
var logOutputAsync = async ({ stream: stream5, onStreamEnd, fdNumber, encoding, allMixed, verboseInfo, streamInfo: { fileDescriptors } }) => {
  if (!shouldLogOutput({
    stdioItems: fileDescriptors[fdNumber]?.stdioItems,
    encoding,
    verboseInfo,
    fdNumber
  })) {
    return;
  }
  const linesIterable = iterateForResult({
    stream: stream5,
    onStreamEnd,
    lines: true,
    encoding,
    stripFinalNewline: true,
    allMixed
  });
  await logLines(linesIterable, stream5, fdNumber, verboseInfo);
};
var resumeStream = async (stream5) => {
  await (0, import_promises9.setImmediate)();
  if (stream5.readableFlowing === null) {
    stream5.resume();
  }
};
var getStreamContents2 = async ({ stream: stream5, stream: { readableObjectMode }, iterable, fdNumber, encoding, maxBuffer, lines }) => {
  try {
    if (readableObjectMode || lines) {
      return await getStreamAsArray(iterable, { maxBuffer });
    }
    if (encoding === "buffer") {
      return new Uint8Array(await getStreamAsArrayBuffer(iterable, { maxBuffer }));
    }
    return await getStreamAsString(iterable, { maxBuffer });
  } catch (error) {
    return handleBufferedData(handleMaxBuffer({
      error,
      stream: stream5,
      readableObjectMode,
      lines,
      encoding,
      fdNumber
    }));
  }
};
var getBufferedData = async (streamPromise) => {
  try {
    return await streamPromise;
  } catch (error) {
    return handleBufferedData(error);
  }
};
var handleBufferedData = ({ bufferedData }) => isArrayBuffer(bufferedData) ? new Uint8Array(bufferedData) : bufferedData;

// node_modules/execa/lib/resolve/wait-stream.js
var import_promises10 = require("node:stream/promises");
var waitForStream = async (stream5, fdNumber, streamInfo, { isSameDirection, stopOnExit = false } = {}) => {
  const state = handleStdinDestroy(stream5, streamInfo);
  const abortController = new AbortController();
  try {
    await Promise.race([
      ...stopOnExit ? [streamInfo.exitPromise] : [],
      (0, import_promises10.finished)(stream5, { cleanup: true, signal: abortController.signal })
    ]);
  } catch (error) {
    if (!state.stdinCleanedUp) {
      handleStreamError(error, fdNumber, streamInfo, isSameDirection);
    }
  } finally {
    abortController.abort();
  }
};
var handleStdinDestroy = (stream5, { originalStreams: [originalStdin], subprocess }) => {
  const state = { stdinCleanedUp: false };
  if (stream5 === originalStdin) {
    spyOnStdinDestroy(stream5, subprocess, state);
  }
  return state;
};
var spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {
  const { _destroy } = subprocessStdin;
  subprocessStdin._destroy = (...destroyArguments) => {
    setStdinCleanedUp(subprocess, state);
    _destroy.call(subprocessStdin, ...destroyArguments);
  };
};
var setStdinCleanedUp = ({ exitCode, signalCode }, state) => {
  if (exitCode !== null || signalCode !== null) {
    state.stdinCleanedUp = true;
  }
};
var handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {
  if (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {
    throw error;
  }
};
var shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {
  if (streamInfo.propagating) {
    return isStreamEpipe(error) || isStreamAbort(error);
  }
  streamInfo.propagating = true;
  return isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection ? isStreamEpipe(error) : isStreamAbort(error);
};
var isInputFileDescriptor = ({ fileDescriptors }, fdNumber) => fdNumber !== "all" && fileDescriptors[fdNumber].direction === "input";
var isStreamAbort = (error) => error?.code === "ERR_STREAM_PREMATURE_CLOSE";
var isStreamEpipe = (error) => error?.code === "EPIPE";

// node_modules/execa/lib/resolve/stdio.js
var waitForStdioStreams = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => subprocess.stdio.map((stream5, fdNumber) => waitForSubprocessStream({
  stream: stream5,
  fdNumber,
  encoding,
  buffer: buffer[fdNumber],
  maxBuffer: maxBuffer[fdNumber],
  lines: lines[fdNumber],
  allMixed: false,
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
}));
var waitForSubprocessStream = async ({ stream: stream5, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => {
  if (!stream5) {
    return;
  }
  const onStreamEnd = waitForStream(stream5, fdNumber, streamInfo);
  if (isInputFileDescriptor(streamInfo, fdNumber)) {
    await onStreamEnd;
    return;
  }
  const [output] = await Promise.all([
    getStreamOutput({
      stream: stream5,
      onStreamEnd,
      fdNumber,
      encoding,
      buffer,
      maxBuffer,
      lines,
      allMixed,
      stripFinalNewline: stripFinalNewline2,
      verboseInfo,
      streamInfo
    }),
    onStreamEnd
  ]);
  return output;
};

// node_modules/execa/lib/resolve/all-async.js
var makeAllStream = ({ stdout, stderr }, { all: all3 }) => all3 && (stdout || stderr) ? mergeStreams([stdout, stderr].filter(Boolean)) : void 0;
var waitForAllStream = ({ subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline: stripFinalNewline2, verboseInfo, streamInfo }) => waitForSubprocessStream({
  ...getAllStream(subprocess, buffer),
  fdNumber: "all",
  encoding,
  maxBuffer: maxBuffer[1] + maxBuffer[2],
  lines: lines[1] || lines[2],
  allMixed: getAllMixed(subprocess),
  stripFinalNewline: stripFinalNewline2,
  verboseInfo,
  streamInfo
});
var getAllStream = ({ stdout, stderr, all: all3 }, [, bufferStdout, bufferStderr]) => {
  const buffer = bufferStdout || bufferStderr;
  if (!buffer) {
    return { stream: all3, buffer };
  }
  if (!bufferStdout) {
    return { stream: stderr, buffer };
  }
  if (!bufferStderr) {
    return { stream: stdout, buffer };
  }
  return { stream: all3, buffer };
};
var getAllMixed = ({ all: all3, stdout, stderr }) => all3 && stdout && stderr && stdout.readableObjectMode !== stderr.readableObjectMode;

// node_modules/execa/lib/resolve/wait-subprocess.js
var import_node_events13 = require("node:events");

// node_modules/execa/lib/verbose/ipc.js
var shouldLogIpc = (verboseInfo) => isFullVerbose(verboseInfo, "ipc");
var logIpcOutput = (message, verboseInfo) => {
  const verboseMessage = serializeVerboseMessage(message);
  verboseLog({
    type: "ipc",
    verboseMessage,
    fdNumber: "ipc",
    verboseInfo
  });
};

// node_modules/execa/lib/ipc/buffer-messages.js
var waitForIpcOutput = async ({
  subprocess,
  buffer: bufferArray,
  maxBuffer: maxBufferArray,
  ipc,
  ipcOutput,
  verboseInfo
}) => {
  if (!ipc) {
    return ipcOutput;
  }
  const isVerbose2 = shouldLogIpc(verboseInfo);
  const buffer = getFdSpecificValue(bufferArray, "ipc");
  const maxBuffer = getFdSpecificValue(maxBufferArray, "ipc");
  for await (const message of loopOnMessages({
    anyProcess: subprocess,
    channel: subprocess.channel,
    isSubprocess: false,
    ipc,
    shouldAwait: false,
    reference: true
  })) {
    if (buffer) {
      checkIpcMaxBuffer(subprocess, ipcOutput, maxBuffer);
      ipcOutput.push(message);
    }
    if (isVerbose2) {
      logIpcOutput(message, verboseInfo);
    }
  }
  return ipcOutput;
};
var getBufferedIpcOutput = async (ipcOutputPromise, ipcOutput) => {
  await Promise.allSettled([ipcOutputPromise]);
  return ipcOutput;
};

// node_modules/execa/lib/resolve/wait-subprocess.js
var waitForSubprocessResult = async ({
  subprocess,
  options: {
    encoding,
    buffer,
    maxBuffer,
    lines,
    timeoutDuration: timeout,
    cancelSignal,
    gracefulCancel,
    forceKillAfterDelay,
    stripFinalNewline: stripFinalNewline2,
    ipc,
    ipcInput
  },
  context,
  verboseInfo,
  fileDescriptors,
  originalStreams,
  onInternalError,
  controller
}) => {
  const exitPromise = waitForExit(subprocess, context);
  const streamInfo = {
    originalStreams,
    fileDescriptors,
    subprocess,
    exitPromise,
    propagating: false
  };
  const stdioPromises = waitForStdioStreams({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const allPromise = waitForAllStream({
    subprocess,
    encoding,
    buffer,
    maxBuffer,
    lines,
    stripFinalNewline: stripFinalNewline2,
    verboseInfo,
    streamInfo
  });
  const ipcOutput = [];
  const ipcOutputPromise = waitForIpcOutput({
    subprocess,
    buffer,
    maxBuffer,
    ipc,
    ipcOutput,
    verboseInfo
  });
  const originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);
  const customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);
  try {
    return await Promise.race([
      Promise.all([
        {},
        waitForSuccessfulExit(exitPromise),
        Promise.all(stdioPromises),
        allPromise,
        ipcOutputPromise,
        sendIpcInput(subprocess, ipcInput),
        ...originalPromises,
        ...customStreamsEndPromises
      ]),
      onInternalError,
      throwOnSubprocessError(subprocess, controller),
      ...throwOnTimeout(subprocess, timeout, context, controller),
      ...throwOnCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        context,
        controller
      }),
      ...throwOnGracefulCancel({
        subprocess,
        cancelSignal,
        gracefulCancel,
        forceKillAfterDelay,
        context,
        controller
      })
    ]);
  } catch (error) {
    context.terminationReason ??= "other";
    return Promise.all([
      { error },
      exitPromise,
      Promise.all(stdioPromises.map((stdioPromise) => getBufferedData(stdioPromise))),
      getBufferedData(allPromise),
      getBufferedIpcOutput(ipcOutputPromise, ipcOutput),
      Promise.allSettled(originalPromises),
      Promise.allSettled(customStreamsEndPromises)
    ]);
  }
};
var waitForOriginalStreams = (originalStreams, subprocess, streamInfo) => originalStreams.map((stream5, fdNumber) => stream5 === subprocess.stdio[fdNumber] ? void 0 : waitForStream(stream5, fdNumber, streamInfo));
var waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({ stdioItems }, fdNumber) => stdioItems.filter(({ value, stream: stream5 = value }) => isStream(stream5, { checkOpen: false }) && !isStandardStream(stream5)).map(({ type, value, stream: stream5 = value }) => waitForStream(stream5, fdNumber, streamInfo, {
  isSameDirection: TRANSFORM_TYPES.has(type),
  stopOnExit: type === "native"
})));
var throwOnSubprocessError = async (subprocess, { signal }) => {
  const [error] = await (0, import_node_events13.once)(subprocess, "error", { signal });
  throw error;
};

// node_modules/execa/lib/convert/concurrent.js
var initializeConcurrentStreams = () => ({
  readableDestroy: /* @__PURE__ */ new WeakMap(),
  writableFinal: /* @__PURE__ */ new WeakMap(),
  writableDestroy: /* @__PURE__ */ new WeakMap()
});
var addConcurrentStream = (concurrentStreams, stream5, waitName) => {
  const weakMap = concurrentStreams[waitName];
  if (!weakMap.has(stream5)) {
    weakMap.set(stream5, []);
  }
  const promises = weakMap.get(stream5);
  const promise = createDeferred();
  promises.push(promise);
  const resolve4 = promise.resolve.bind(promise);
  return { resolve: resolve4, promises };
};
var waitForConcurrentStreams = async ({ resolve: resolve4, promises }, subprocess) => {
  resolve4();
  const [isSubprocessExit] = await Promise.race([
    Promise.allSettled([true, subprocess]),
    Promise.all([false, ...promises])
  ]);
  return !isSubprocessExit;
};

// node_modules/execa/lib/convert/readable.js
var import_node_stream6 = require("node:stream");
var import_node_util9 = require("node:util");

// node_modules/execa/lib/convert/shared.js
var import_promises11 = require("node:stream/promises");
var safeWaitForSubprocessStdin = async (subprocessStdin) => {
  if (subprocessStdin === void 0) {
    return;
  }
  try {
    await waitForSubprocessStdin(subprocessStdin);
  } catch {
  }
};
var safeWaitForSubprocessStdout = async (subprocessStdout) => {
  if (subprocessStdout === void 0) {
    return;
  }
  try {
    await waitForSubprocessStdout(subprocessStdout);
  } catch {
  }
};
var waitForSubprocessStdin = async (subprocessStdin) => {
  await (0, import_promises11.finished)(subprocessStdin, { cleanup: true, readable: false, writable: true });
};
var waitForSubprocessStdout = async (subprocessStdout) => {
  await (0, import_promises11.finished)(subprocessStdout, { cleanup: true, readable: true, writable: false });
};
var waitForSubprocess = async (subprocess, error) => {
  await subprocess;
  if (error) {
    throw error;
  }
};
var destroyOtherStream = (stream5, isOpen, error) => {
  if (error && !isStreamAbort(error)) {
    stream5.destroy(error);
  } else if (isOpen) {
    stream5.destroy();
  }
};

// node_modules/execa/lib/convert/readable.js
var createReadable = ({ subprocess, concurrentStreams, encoding }, { from, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const readable2 = new import_node_stream6.Readable({
    read,
    destroy: (0, import_node_util9.callbackify)(onReadableDestroy.bind(void 0, { subprocessStdout, subprocess, waitReadableDestroy })),
    highWaterMark: readableHighWaterMark,
    objectMode: readableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: readable2,
    subprocess
  });
  return readable2;
};
var getSubprocessStdout = (subprocess, from, concurrentStreams) => {
  const subprocessStdout = getFromStream(subprocess, from);
  const waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, "readableDestroy");
  return { subprocessStdout, waitReadableDestroy };
};
var getReadableOptions = ({ readableEncoding, readableObjectMode, readableHighWaterMark }, binary) => binary ? { readableEncoding, readableObjectMode, readableHighWaterMark } : { readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK };
var getReadableMethods = ({ subprocessStdout, subprocess, binary, encoding, preserveNewlines }) => {
  const onStdoutDataDone = createDeferred();
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: !binary,
    encoding,
    preserveNewlines
  });
  return {
    read() {
      onRead(this, onStdoutData, onStdoutDataDone);
    },
    onStdoutDataDone
  };
};
var onRead = async (readable2, onStdoutData, onStdoutDataDone) => {
  try {
    const { value, done } = await onStdoutData.next();
    if (done) {
      onStdoutDataDone.resolve();
    } else {
      readable2.push(value);
    }
  } catch {
  }
};
var onStdoutFinished = async ({ subprocessStdout, onStdoutDataDone, readable: readable2, subprocess, subprocessStdin }) => {
  try {
    await waitForSubprocessStdout(subprocessStdout);
    await subprocess;
    await safeWaitForSubprocessStdin(subprocessStdin);
    await onStdoutDataDone;
    if (readable2.readable) {
      readable2.push(null);
    }
  } catch (error) {
    await safeWaitForSubprocessStdin(subprocessStdin);
    destroyOtherReadable(readable2, error);
  }
};
var onReadableDestroy = async ({ subprocessStdout, subprocess, waitReadableDestroy }, error) => {
  if (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {
    destroyOtherReadable(subprocessStdout, error);
    await waitForSubprocess(subprocess, error);
  }
};
var destroyOtherReadable = (stream5, error) => {
  destroyOtherStream(stream5, stream5.readable, error);
};

// node_modules/execa/lib/convert/writable.js
var import_node_stream7 = require("node:stream");
var import_node_util10 = require("node:util");
var createWritable = ({ subprocess, concurrentStreams }, { to } = {}) => {
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const writable2 = new import_node_stream7.Writable({
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: (0, import_node_util10.callbackify)(onWritableDestroy.bind(void 0, {
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    })),
    highWaterMark: subprocessStdin.writableHighWaterMark,
    objectMode: subprocessStdin.writableObjectMode
  });
  onStdinFinished(subprocessStdin, writable2);
  return writable2;
};
var getSubprocessStdin = (subprocess, to, concurrentStreams) => {
  const subprocessStdin = getToStream(subprocess, to);
  const waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, "writableFinal");
  const waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, "writableDestroy");
  return { subprocessStdin, waitWritableFinal, waitWritableDestroy };
};
var getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({
  write: onWrite.bind(void 0, subprocessStdin),
  final: (0, import_node_util10.callbackify)(onWritableFinal.bind(void 0, subprocessStdin, subprocess, waitWritableFinal))
});
var onWrite = (subprocessStdin, chunk, encoding, done) => {
  if (subprocessStdin.write(chunk, encoding)) {
    done();
  } else {
    subprocessStdin.once("drain", done);
  }
};
var onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {
  if (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {
    if (subprocessStdin.writable) {
      subprocessStdin.end();
    }
    await subprocess;
  }
};
var onStdinFinished = async (subprocessStdin, writable2, subprocessStdout) => {
  try {
    await waitForSubprocessStdin(subprocessStdin);
    if (writable2.writable) {
      writable2.end();
    }
  } catch (error) {
    await safeWaitForSubprocessStdout(subprocessStdout);
    destroyOtherWritable(writable2, error);
  }
};
var onWritableDestroy = async ({ subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy }, error) => {
  await waitForConcurrentStreams(waitWritableFinal, subprocess);
  if (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {
    destroyOtherWritable(subprocessStdin, error);
    await waitForSubprocess(subprocess, error);
  }
};
var destroyOtherWritable = (stream5, error) => {
  destroyOtherStream(stream5, stream5.writable, error);
};

// node_modules/execa/lib/convert/duplex.js
var import_node_stream8 = require("node:stream");
var import_node_util11 = require("node:util");
var createDuplex = ({ subprocess, concurrentStreams, encoding }, { from, to, binary: binaryOption = true, preserveNewlines = true } = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const { subprocessStdout, waitReadableDestroy } = getSubprocessStdout(subprocess, from, concurrentStreams);
  const { subprocessStdin, waitWritableFinal, waitWritableDestroy } = getSubprocessStdin(subprocess, to, concurrentStreams);
  const { readableEncoding, readableObjectMode, readableHighWaterMark } = getReadableOptions(subprocessStdout, binary);
  const { read, onStdoutDataDone } = getReadableMethods({
    subprocessStdout,
    subprocess,
    binary,
    encoding,
    preserveNewlines
  });
  const duplex2 = new import_node_stream8.Duplex({
    read,
    ...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),
    destroy: (0, import_node_util11.callbackify)(onDuplexDestroy.bind(void 0, {
      subprocessStdout,
      subprocessStdin,
      subprocess,
      waitReadableDestroy,
      waitWritableFinal,
      waitWritableDestroy
    })),
    readableHighWaterMark,
    writableHighWaterMark: subprocessStdin.writableHighWaterMark,
    readableObjectMode,
    writableObjectMode: subprocessStdin.writableObjectMode,
    encoding: readableEncoding
  });
  onStdoutFinished({
    subprocessStdout,
    onStdoutDataDone,
    readable: duplex2,
    subprocess,
    subprocessStdin
  });
  onStdinFinished(subprocessStdin, duplex2, subprocessStdout);
  return duplex2;
};
var onDuplexDestroy = async ({ subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy }, error) => {
  await Promise.all([
    onReadableDestroy({ subprocessStdout, subprocess, waitReadableDestroy }, error),
    onWritableDestroy({
      subprocessStdin,
      subprocess,
      waitWritableFinal,
      waitWritableDestroy
    }, error)
  ]);
};

// node_modules/execa/lib/convert/iterable.js
var createIterable = (subprocess, encoding, {
  from,
  binary: binaryOption = false,
  preserveNewlines = false
} = {}) => {
  const binary = binaryOption || BINARY_ENCODINGS.has(encoding);
  const subprocessStdout = getFromStream(subprocess, from);
  const onStdoutData = iterateOnSubprocessStream({
    subprocessStdout,
    subprocess,
    binary,
    shouldEncode: true,
    encoding,
    preserveNewlines
  });
  return iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);
};
var iterateOnStdoutData = async function* (onStdoutData, subprocessStdout, subprocess) {
  try {
    yield* onStdoutData;
  } finally {
    if (subprocessStdout.readable) {
      subprocessStdout.destroy();
    }
    await subprocess;
  }
};

// node_modules/execa/lib/convert/add.js
var addConvertedStreams = (subprocess, { encoding }) => {
  const concurrentStreams = initializeConcurrentStreams();
  subprocess.readable = createReadable.bind(void 0, { subprocess, concurrentStreams, encoding });
  subprocess.writable = createWritable.bind(void 0, { subprocess, concurrentStreams });
  subprocess.duplex = createDuplex.bind(void 0, { subprocess, concurrentStreams, encoding });
  subprocess.iterable = createIterable.bind(void 0, subprocess, encoding);
  subprocess[Symbol.asyncIterator] = createIterable.bind(void 0, subprocess, encoding, {});
};

// node_modules/execa/lib/methods/promise.js
var mergePromise = (subprocess, promise) => {
  for (const [property, descriptor] of descriptors) {
    const value = descriptor.value.bind(promise);
    Reflect.defineProperty(subprocess, property, { ...descriptor, value });
  }
};
var nativePromisePrototype = (async () => {
})().constructor.prototype;
var descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);

// node_modules/execa/lib/methods/main-async.js
var execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {
  const { file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors } = handleAsyncArguments(rawFile, rawArguments, rawOptions);
  const { subprocess, promise } = spawnSubprocessAsync({
    file,
    commandArguments,
    options,
    startTime,
    verboseInfo,
    command,
    escapedCommand,
    fileDescriptors
  });
  subprocess.pipe = pipeToSubprocess.bind(void 0, {
    source: subprocess,
    sourcePromise: promise,
    boundOptions: {},
    createNested
  });
  mergePromise(subprocess, promise);
  SUBPROCESS_OPTIONS.set(subprocess, { options, fileDescriptors });
  return subprocess;
};
var handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {
  const { command, escapedCommand, startTime, verboseInfo } = handleCommand(rawFile, rawArguments, rawOptions);
  const { file, commandArguments, options: normalizedOptions } = normalizeOptions(rawFile, rawArguments, rawOptions);
  const options = handleAsyncOptions(normalizedOptions);
  const fileDescriptors = handleStdioAsync(options, verboseInfo);
  return {
    file,
    commandArguments,
    command,
    escapedCommand,
    startTime,
    verboseInfo,
    options,
    fileDescriptors
  };
};
var handleAsyncOptions = ({ timeout, signal, ...options }) => {
  if (signal !== void 0) {
    throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');
  }
  return { ...options, timeoutDuration: timeout };
};
var spawnSubprocessAsync = ({ file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors }) => {
  let subprocess;
  try {
    subprocess = (0, import_node_child_process5.spawn)(...concatenateShell(file, commandArguments, options));
  } catch (error) {
    return handleEarlyError({
      error,
      command,
      escapedCommand,
      fileDescriptors,
      options,
      startTime,
      verboseInfo
    });
  }
  const controller = new AbortController();
  (0, import_node_events14.setMaxListeners)(Number.POSITIVE_INFINITY, controller.signal);
  const originalStreams = [...subprocess.stdio];
  pipeOutputAsync(subprocess, fileDescriptors, controller);
  cleanupOnExit(subprocess, options, controller);
  const context = {};
  const onInternalError = createDeferred();
  subprocess.kill = subprocessKill.bind(void 0, {
    kill: subprocess.kill.bind(subprocess),
    options,
    onInternalError,
    context,
    controller
  });
  subprocess.all = makeAllStream(subprocess, options);
  addConvertedStreams(subprocess, options);
  addIpcMethods(subprocess, options);
  const promise = handlePromise({
    subprocess,
    options,
    startTime,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    command,
    escapedCommand,
    context,
    onInternalError,
    controller
  });
  return { subprocess, promise };
};
var handlePromise = async ({ subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, context, onInternalError, controller }) => {
  const [
    errorInfo,
    [exitCode, signal],
    stdioResults,
    allResult,
    ipcOutput
  ] = await waitForSubprocessResult({
    subprocess,
    options,
    context,
    verboseInfo,
    fileDescriptors,
    originalStreams,
    onInternalError,
    controller
  });
  controller.abort();
  onInternalError.resolve();
  const stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));
  const all3 = stripNewline(allResult, options, "all");
  const result = getAsyncResult({
    errorInfo,
    exitCode,
    signal,
    stdio,
    all: all3,
    ipcOutput,
    context,
    options,
    command,
    escapedCommand,
    startTime
  });
  return handleResult(result, verboseInfo, options);
};
var getAsyncResult = ({ errorInfo, exitCode, signal, stdio, all: all3, ipcOutput, context, options, command, escapedCommand, startTime }) => "error" in errorInfo ? makeError({
  error: errorInfo.error,
  command,
  escapedCommand,
  timedOut: context.terminationReason === "timeout",
  isCanceled: context.terminationReason === "cancel" || context.terminationReason === "gracefulCancel",
  isGracefullyCanceled: context.terminationReason === "gracefulCancel",
  isMaxBuffer: errorInfo.error instanceof MaxBufferError,
  isForcefullyTerminated: context.isForcefullyTerminated,
  exitCode,
  signal,
  stdio,
  all: all3,
  ipcOutput,
  options,
  startTime,
  isSync: false
}) : makeSuccessResult({
  command,
  escapedCommand,
  stdio,
  all: all3,
  ipcOutput,
  options,
  startTime
});

// node_modules/execa/lib/methods/bind.js
var mergeOptions = (boundOptions, options) => {
  const newOptions = Object.fromEntries(
    Object.entries(options).map(([optionName, optionValue]) => [
      optionName,
      mergeOption(optionName, boundOptions[optionName], optionValue)
    ])
  );
  return { ...boundOptions, ...newOptions };
};
var mergeOption = (optionName, boundOptionValue, optionValue) => {
  if (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {
    return { ...boundOptionValue, ...optionValue };
  }
  return optionValue;
};
var DEEP_OPTIONS = /* @__PURE__ */ new Set(["env", ...FD_SPECIFIC_OPTIONS]);

// node_modules/execa/lib/methods/create.js
var createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {
  const createNested = (mapArguments2, boundOptions2, setBoundExeca2) => createExeca(mapArguments2, boundOptions2, deepOptions, setBoundExeca2);
  const boundExeca = (...execaArguments) => callBoundExeca({
    mapArguments,
    deepOptions,
    boundOptions,
    setBoundExeca,
    createNested
  }, ...execaArguments);
  if (setBoundExeca !== void 0) {
    setBoundExeca(boundExeca, createNested, boundOptions);
  }
  return boundExeca;
};
var callBoundExeca = ({ mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested }, firstArgument, ...nextArguments) => {
  if (isPlainObject(firstArgument)) {
    return createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);
  }
  const { file, commandArguments, options, isSync } = parseArguments({
    mapArguments,
    firstArgument,
    nextArguments,
    deepOptions,
    boundOptions
  });
  return isSync ? execaCoreSync(file, commandArguments, options) : execaCoreAsync(file, commandArguments, options, createNested);
};
var parseArguments = ({ mapArguments, firstArgument, nextArguments, deepOptions, boundOptions }) => {
  const callArguments = isTemplateString(firstArgument) ? parseTemplates(firstArgument, nextArguments) : [firstArgument, ...nextArguments];
  const [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);
  const mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);
  const {
    file = initialFile,
    commandArguments = initialArguments,
    options = mergedOptions,
    isSync = false
  } = mapArguments({ file: initialFile, commandArguments: initialArguments, options: mergedOptions });
  return {
    file,
    commandArguments,
    options,
    isSync
  };
};

// node_modules/execa/lib/methods/command.js
var mapCommandAsync = ({ file, commandArguments }) => parseCommand(file, commandArguments);
var mapCommandSync = ({ file, commandArguments }) => ({ ...parseCommand(file, commandArguments), isSync: true });
var parseCommand = (command, unusedArguments) => {
  if (unusedArguments.length > 0) {
    throw new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);
  }
  const [file, ...commandArguments] = parseCommandString(command);
  return { file, commandArguments };
};
var parseCommandString = (command) => {
  if (typeof command !== "string") {
    throw new TypeError(`The command must be a string: ${String(command)}.`);
  }
  const trimmedCommand = command.trim();
  if (trimmedCommand === "") {
    return [];
  }
  const tokens = [];
  for (const token of trimmedCommand.split(SPACES_REGEXP)) {
    const previousToken = tokens.at(-1);
    if (previousToken && previousToken.endsWith("\\")) {
      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
    } else {
      tokens.push(token);
    }
  }
  return tokens;
};
var SPACES_REGEXP = / +/g;

// node_modules/execa/lib/methods/script.js
var setScriptSync = (boundExeca, createNested, boundOptions) => {
  boundExeca.sync = createNested(mapScriptSync, boundOptions);
  boundExeca.s = boundExeca.sync;
};
var mapScriptAsync = ({ options }) => getScriptOptions(options);
var mapScriptSync = ({ options }) => ({ ...getScriptOptions(options), isSync: true });
var getScriptOptions = (options) => ({ options: { ...getScriptStdinOption(options), ...options } });
var getScriptStdinOption = ({ input, inputFile, stdio }) => input === void 0 && inputFile === void 0 && stdio === void 0 ? { stdin: "inherit" } : {};
var deepScriptOptions = { preferLocal: true };

// node_modules/execa/index.js
var execa = createExeca(() => ({}));
var execaSync = createExeca(() => ({ isSync: true }));
var execaCommand = createExeca(mapCommandAsync);
var execaCommandSync = createExeca(mapCommandSync);
var execaNode = createExeca(mapNode);
var $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);
var {
  sendMessage: sendMessage2,
  getOneMessage: getOneMessage2,
  getEachMessage: getEachMessage2,
  getCancelSignal: getCancelSignal2
} = getIpcExport();

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString2 } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer2 = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer2(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject2 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject2(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream2 = (val) => isObject2(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream3, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l = obj.length; i2 < l; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject2(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
var extend = (a2, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors3) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors3);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors3 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors3, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop3 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer: isArrayBuffer2,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject2,
  isPlainObject: isPlainObject2,
  isEmptyObject,
  isReadableStream: isReadableStream3,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream: isStream2,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop3,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code2, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors2[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors2);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code2 == null && error ? error.code : code2;
  AxiosError.call(axiosError, msg, errCode, config2, request, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path15, key, dots) {
  if (!path15) return key;
  return path15.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path15) {
    let arr = value;
    if (value && !path15 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path15, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path15) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path15.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path15,
        exposedHelpers
      );
      if (result === true) {
        build(el, path15 ? path15.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match3) {
    return charMap[match3];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString3(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/node/index.js
var import_crypto = __toESM(require("crypto"), 1);

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url = __toESM(require("url"), 1);
var URLSearchParams_default = import_url.default.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  import_crypto.default.randomFillSync(randomValues);
  for (let i2 = 0; i2 < size; i2++) {
    str += alphabet[randomValues[i2] % length];
  }
  return str;
};
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...node_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path15, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match3) => {
    return match3[0] === "[]" ? "" : match3[1] || match3[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path15, value, target, index) {
    let name = path15[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path15.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path15, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match3;
  while (match3 = tokensRE.exec(str)) {
    tokens[match3[1]] = match3[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils_default.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils_default.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format3) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format3 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context = response || config2;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config2, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve4, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve4(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_util2 = __toESM(require("util"), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
var import_zlib = __toESM(require("zlib"), 1);

// node_modules/axios/lib/env/data.js
var VERSION = "1.12.2";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match3 && match3[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match3 = DATA_URL_PATTERN.exec(uri);
    if (!match3) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match3[1];
    const isBase64 = match3[2];
    const body = match3[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
var import_stream6 = __toESM(require("stream"), 1);

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream3 = __toESM(require("stream"), 1);
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends import_stream3.default.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk2 = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk2(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk2(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
var import_events = require("events");

// node_modules/axios/lib/helpers/formDataToStream.js
var import_util = __toESM(require("util"), 1);
var import_stream4 = require("stream");

// node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder3 = typeof TextEncoder === "function" ? new TextEncoder() : new import_util.default.TextEncoder();
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder3.encode(CRLF);
var CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder3.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder3.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match3) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match3]);
  }
};
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder3.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder3.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return import_stream4.Readable.from((async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  })());
};
var formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream5 = __toESM(require("stream"), 1);
var ZlibHeaderTransformStream = class extends import_stream5.default.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/helpers/callbackify.js
var callbackify5 = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify5;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
function estimateDataURLDecodedBytes(url2) {
  if (!url2 || typeof url2 !== "string") return 0;
  if (!url2.startsWith("data:")) return 0;
  const comma = url2.indexOf(",");
  if (comma < 0) return 0;
  const meta = url2.slice(5, comma);
  const body = url2.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length;
    for (let i2 = 0; i2 < len; i2++) {
      if (body.charCodeAt(i2) === 37 && i2 + 2 < len) {
        const a2 = body.charCodeAt(i2 + 1);
        const b = body.charCodeAt(i2 + 2);
        const isHex = (a2 >= 48 && a2 <= 57 || a2 >= 65 && a2 <= 70 || a2 >= 97 && a2 <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
        if (isHex) {
          effectiveLen -= 2;
          i2 += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
    body.charCodeAt(j - 1) === 51 && // '3'
    (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }
  return Buffer.byteLength(body, "utf8");
}

// node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: import_zlib.default.constants.Z_SYNC_FLUSH,
  finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
var flushOnFinish = (stream5, [throttled, flush]) => {
  stream5.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve4, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve4(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config2) {
  return wrapAsync(async function dispatchHttpRequest(resolve4, reject, onDone) {
    let { data, lookup, family } = config2;
    const { responseType, responseEncoding } = config2;
    const method = config2.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new import_events.EventEmitter();
    const onFinished = () => {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(abort);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config2, req) : reason);
    }
    emitter.once("abort", reject);
    if (config2.cancelToken || config2.signal) {
      config2.cancelToken && config2.cancelToken.subscribe(abort);
      if (config2.signal) {
        config2.signal.aborted ? abort() : config2.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : void 0);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      if (config2.maxContentLength > -1) {
        const dataUrl = String(config2.url || fullPath || "");
        const estimated = estimateDataURLDecodedBytes(dataUrl);
        if (estimated > config2.maxContentLength) {
          return reject(new AxiosError_default(
            "maxContentLength size of " + config2.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config2
          ));
        }
      }
      let convertedData;
      if (method !== "GET") {
        return settle(resolve4, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: config2
        });
      }
      try {
        convertedData = fromDataURI(config2.url, responseType === "blob", {
          Blob: config2.env && config2.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config2);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = import_stream6.default.Readable.from(convertedData);
      }
      return settle(resolve4, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config: config2
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config2
      ));
    }
    const headers = AxiosHeaders_default.from(config2.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const { onUploadProgress, onDownloadProgress } = config2;
    const maxRate = config2.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await import_util2.default.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = import_stream6.default.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config2
        ));
      }
      headers.setContentLength(data.length, false);
      if (config2.maxBodyLength > -1 && data.length > config2.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config2
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = import_stream6.default.Readable.from(data, { objectMode: false });
      }
      data = import_stream6.default.pipeline([data, new AxiosTransformStream_default({
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path15;
    try {
      path15 = buildURL(
        parsed.pathname + parsed.search,
        config2.params,
        config2.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config2;
      customErr.url = config2.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path15,
      method,
      headers: headers.toJSON(),
      agents: { http: config2.httpAgent, https: config2.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup) && (options.lookup = lookup);
    if (config2.socketPath) {
      options.socketPath = config2.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config2.httpsAgent : config2.httpAgent;
    if (config2.transport) {
      transport = config2.transport;
    } else if (config2.maxRedirects === 0) {
      transport = isHttpsRequest ? import_https.default : import_http.default;
    } else {
      if (config2.maxRedirects) {
        options.maxRedirects = config2.maxRedirects;
      }
      if (config2.beforeRedirect) {
        options.beforeRedirects.config = config2.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config2.maxBodyLength > -1) {
      options.maxBodyLength = config2.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config2.insecureHTTPParser) {
      options.insecureHTTPParser = config2.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config2.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          /*eslint default-case:0*/
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default());
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? import_stream6.default.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = import_stream6.default.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config: config2,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve4, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config2.maxContentLength > -1 && totalResponseBytes > config2.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config2.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config2,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "stream has been aborted",
            AxiosError_default.ERR_BAD_RESPONSE,
            config2,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError2(err) {
          if (req.destroyed) return;
          reject(AxiosError_default.from(err, null, config2, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd2() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config2, response.request, response));
          }
          settle(resolve4, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config2, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config2.timeout) {
      const timeout = parseInt(config2.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config2,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config2.transitional || transitional_default;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config2,
          req
        ));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config2, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform_default.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path15, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path15) && cookie.push("path=" + path15);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match3 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match3 ? decodeURIComponent(match3[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a2, b, prop, caseless);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a2, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve4, reject) {
    const _config = resolveConfig_default(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve4(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort2() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config2, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals2, timeout) => {
  const { length } = signals2 = signals2 ? signals2.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted2;
    const onabort = function(reason) {
      if (!aborted2) {
        aborted2 = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals2) {
        timer && clearTimeout(timer);
        timer = null;
        signals2.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals2 = null;
      }
    };
    signals2.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream5) {
  if (stream5[Symbol.asyncIterator]) {
    yield* stream5;
    return;
  }
  const reader = stream5.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream5, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream5, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder: TextEncoder2
} = utils_default.global;
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var factory = (env2) => {
  env2 = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env2);
  const { fetch: envFetch, Request, Response } = env2;
  const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request);
  const isResponseSupported = isFunction2(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config2) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config2) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config2);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url2, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config2);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve4, reject) => {
        settle(resolve4, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config: config2,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config2, request);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config2) => {
  let env2 = config2 ? config2.env : {};
  const { fetch: fetch2, Request, Response } = env2;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i2 = len, seed, target, map = seedCache;
  while (i2--) {
    seed = seeds[i2];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i2 ? /* @__PURE__ */ new Map() : factory(env2));
    map = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
var adapters_default = {
  getAdapter: (adapters, config2) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters[i2];
      let id;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config2)))) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config2.adapter || defaults_default.adapter, config2);
  return adapter2(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config2, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve4) {
      resolvePromise = resolve4;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve4) => {
        token.subscribe(resolve4);
        _resolve = resolve4;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c3) {
      cancel = c3;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/core/IAAnalisis.ts
var vscode2 = __toESM(require("vscode"));

// src/core/utils.ts
var fs = __toESM(require_lib());
var path7 = __toESM(require("path"));

// node_modules/fast-xml-parser/src/util.js
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
var regexName = new RegExp("^" + nameRegexp + "$");
function getAllMatches(string, regex) {
  const matches = [];
  let match3 = regex.exec(string);
  while (match3) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match3[0].length;
    const len = match3.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match3[index]);
    }
    matches.push(allmatches);
    match3 = regex.exec(string);
  }
  return matches;
}
var isName = function(string) {
  const match3 = regexName.exec(string);
  return !(match3 === null || typeof match3 === "undefined");
};
function isExist(v) {
  return typeof v !== "undefined";
}

// node_modules/fast-xml-parser/src/validator.js
var defaultOptions = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
function validate(xmlData, options) {
  options = Object.assign({}, defaultOptions, options);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i2 = 0; i2 < xmlData.length; i2++) {
    if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
      i2 += 2;
      i2 = readPI(xmlData, i2);
      if (i2.err) return i2;
    } else if (xmlData[i2] === "<") {
      let tagStartPos = i2;
      i2++;
      if (xmlData[i2] === "!") {
        i2 = readCommentAndCDATA(xmlData, i2);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i2] === "/") {
          closingTag = true;
          i2++;
        }
        let tagName = "";
        for (; i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "	" && xmlData[i2] !== "\n" && xmlData[i2] !== "\r"; i2++) {
          tagName += xmlData[i2];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i2--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
        }
        const result = readAttributeStr(xmlData, i2);
        if (result === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
        }
        let attrStr = result.value;
        i2 = result.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i2 - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
          } else if (options.unpairedTags.indexOf(tagName) !== -1) {
          } else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i2++; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<") {
            if (xmlData[i2 + 1] === "!") {
              i2++;
              i2 = readCommentAndCDATA(xmlData, i2);
              continue;
            } else if (xmlData[i2 + 1] === "?") {
              i2 = readPI(xmlData, ++i2);
              if (i2.err) return i2;
            } else {
              break;
            }
          } else if (xmlData[i2] === "&") {
            const afterAmp = validateAmpersand(xmlData, i2);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
            i2 = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
            }
          }
        }
        if (xmlData[i2] === "<") {
          i2--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i2])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
}
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i2) {
  const start = i2;
  for (; i2 < xmlData.length; i2++) {
    if (xmlData[i2] == "?" || xmlData[i2] == " ") {
      const tagname = xmlData.substr(start, i2 - start);
      if (i2 > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
      } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
        i2++;
        break;
      } else {
        continue;
      }
    }
  }
  return i2;
}
function readCommentAndCDATA(xmlData, i2) {
  if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
    for (i2 += 3; i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
        i2 += 2;
        break;
      }
    }
  } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
    let angleBracketsCount = 1;
    for (i2 += 8; i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i2] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
    for (i2 += 8; i2 < xmlData.length; i2++) {
      if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
        i2 += 2;
        break;
      }
    }
  }
  return i2;
}
var doubleQuote = '"';
var singleQuote = "'";
function readAttributeStr(xmlData, i2) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i2 < xmlData.length; i2++) {
    if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i2];
      } else if (startChar !== xmlData[i2]) {
      } else {
        startChar = "";
      }
    } else if (xmlData[i2] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i2];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i2,
    tagClosed
  };
}
var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString(attrStr, options) {
  const matches = getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i2 = 0; i2 < matches.length; i2++) {
    if (matches[i2][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
    } else if (matches[i2][3] !== void 0 && matches[i2][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
    } else if (matches[i2][3] === void 0 && !options.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
    }
    const attrName = matches[i2][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i2) {
  let re = /\d/;
  if (xmlData[i2] === "x") {
    i2++;
    re = /[\da-fA-F]/;
  }
  for (; i2 < xmlData.length; i2++) {
    if (xmlData[i2] === ";")
      return i2;
    if (!xmlData[i2].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i2) {
  i2++;
  if (xmlData[i2] === ";")
    return -1;
  if (xmlData[i2] === "#") {
    i2++;
    return validateNumberAmpersand(xmlData, i2);
  }
  let count2 = 0;
  for (; i2 < xmlData.length; i2++, count2++) {
    if (xmlData[i2].match(/\w/) && count2 < 20)
      continue;
    if (xmlData[i2] === ";")
      break;
    return -1;
  }
  return i2;
}
function getErrorObject(code2, message, lineNumber) {
  return {
    err: {
      code: code2,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return isName(attrName);
}
function validateTagName(tagname) {
  return isName(tagname);
}
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match3) {
  return match3.startIndex + match3[1].length;
}

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var defaultOptions2 = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(tagName, val) {
    return val;
  },
  attributeValueProcessor: function(attrName, val) {
    return val;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(tagName, jPath, attrs) {
    return tagName;
  },
  // skipEmptyListItem: false
  captureMetaData: false
};
var buildOptions = function(options) {
  return Object.assign({}, defaultOptions2, options);
};

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var METADATA_SYMBOL;
if (typeof Symbol !== "function") {
  METADATA_SYMBOL = "@@xmlMetadata";
} else {
  METADATA_SYMBOL = Symbol("XML Node Metadata");
}
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname;
    this.child = [];
    this[":@"] = {};
  }
  add(key, val) {
    if (key === "__proto__") key = "#__proto__";
    this.child.push({ [key]: val });
  }
  addChild(node, startIndex) {
    if (node.tagname === "__proto__") node.tagname = "#__proto__";
    if (node[":@"] && Object.keys(node[":@"]).length > 0) {
      this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
    } else {
      this.child.push({ [node.tagname]: node.child });
    }
    if (startIndex !== void 0) {
      this.child[this.child.length - 1][METADATA_SYMBOL] = { startIndex };
    }
  }
  /** symbol used for metadata */
  static getMetaDataSymbol() {
    return METADATA_SYMBOL;
  }
};

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var DocTypeReader = class {
  constructor(processEntities) {
    this.suppressValidationErr = !processEntities;
  }
  readDocType(xmlData, i2) {
    const entities = {};
    if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
      i2 = i2 + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment2 = false;
      let exp = "";
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && !comment2) {
          if (hasBody && hasSeq(xmlData, "!ENTITY", i2)) {
            i2 += 7;
            let entityName, val;
            [entityName, val, i2] = this.readEntityExp(xmlData, i2 + 1, this.suppressValidationErr);
            if (val.indexOf("&") === -1)
              entities[entityName] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && hasSeq(xmlData, "!ELEMENT", i2)) {
            i2 += 8;
            const { index } = this.readElementExp(xmlData, i2 + 1);
            i2 = index;
          } else if (hasBody && hasSeq(xmlData, "!ATTLIST", i2)) {
            i2 += 8;
          } else if (hasBody && hasSeq(xmlData, "!NOTATION", i2)) {
            i2 += 9;
            const { index } = this.readNotationExp(xmlData, i2 + 1, this.suppressValidationErr);
            i2 = index;
          } else if (hasSeq(xmlData, "!--", i2)) comment2 = true;
          else throw new Error(`Invalid DOCTYPE`);
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i2] === ">") {
          if (comment2) {
            if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
              comment2 = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i2] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i2];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i: i2 };
  }
  readEntityExp(xmlData, i2) {
    i2 = skipWhitespace(xmlData, i2);
    let entityName = "";
    while (i2 < xmlData.length && !/\s/.test(xmlData[i2]) && xmlData[i2] !== '"' && xmlData[i2] !== "'") {
      entityName += xmlData[i2];
      i2++;
    }
    validateEntityName(entityName);
    i2 = skipWhitespace(xmlData, i2);
    if (!this.suppressValidationErr) {
      if (xmlData.substring(i2, i2 + 6).toUpperCase() === "SYSTEM") {
        throw new Error("External entities are not supported");
      } else if (xmlData[i2] === "%") {
        throw new Error("Parameter entities are not supported");
      }
    }
    let entityValue = "";
    [i2, entityValue] = this.readIdentifierVal(xmlData, i2, "entity");
    i2--;
    return [entityName, entityValue, i2];
  }
  readNotationExp(xmlData, i2) {
    i2 = skipWhitespace(xmlData, i2);
    let notationName = "";
    while (i2 < xmlData.length && !/\s/.test(xmlData[i2])) {
      notationName += xmlData[i2];
      i2++;
    }
    !this.suppressValidationErr && validateEntityName(notationName);
    i2 = skipWhitespace(xmlData, i2);
    const identifierType = xmlData.substring(i2, i2 + 6).toUpperCase();
    if (!this.suppressValidationErr && identifierType !== "SYSTEM" && identifierType !== "PUBLIC") {
      throw new Error(`Expected SYSTEM or PUBLIC, found "${identifierType}"`);
    }
    i2 += identifierType.length;
    i2 = skipWhitespace(xmlData, i2);
    let publicIdentifier = null;
    let systemIdentifier = null;
    if (identifierType === "PUBLIC") {
      [i2, publicIdentifier] = this.readIdentifierVal(xmlData, i2, "publicIdentifier");
      i2 = skipWhitespace(xmlData, i2);
      if (xmlData[i2] === '"' || xmlData[i2] === "'") {
        [i2, systemIdentifier] = this.readIdentifierVal(xmlData, i2, "systemIdentifier");
      }
    } else if (identifierType === "SYSTEM") {
      [i2, systemIdentifier] = this.readIdentifierVal(xmlData, i2, "systemIdentifier");
      if (!this.suppressValidationErr && !systemIdentifier) {
        throw new Error("Missing mandatory system identifier for SYSTEM notation");
      }
    }
    return { notationName, publicIdentifier, systemIdentifier, index: --i2 };
  }
  readIdentifierVal(xmlData, i2, type) {
    let identifierVal = "";
    const startChar = xmlData[i2];
    if (startChar !== '"' && startChar !== "'") {
      throw new Error(`Expected quoted string, found "${startChar}"`);
    }
    i2++;
    while (i2 < xmlData.length && xmlData[i2] !== startChar) {
      identifierVal += xmlData[i2];
      i2++;
    }
    if (xmlData[i2] !== startChar) {
      throw new Error(`Unterminated ${type} value`);
    }
    i2++;
    return [i2, identifierVal];
  }
  readElementExp(xmlData, i2) {
    i2 = skipWhitespace(xmlData, i2);
    let elementName = "";
    while (i2 < xmlData.length && !/\s/.test(xmlData[i2])) {
      elementName += xmlData[i2];
      i2++;
    }
    if (!this.suppressValidationErr && !isName(elementName)) {
      throw new Error(`Invalid element name: "${elementName}"`);
    }
    i2 = skipWhitespace(xmlData, i2);
    let contentModel = "";
    if (xmlData[i2] === "E" && hasSeq(xmlData, "MPTY", i2)) i2 += 4;
    else if (xmlData[i2] === "A" && hasSeq(xmlData, "NY", i2)) i2 += 2;
    else if (xmlData[i2] === "(") {
      i2++;
      while (i2 < xmlData.length && xmlData[i2] !== ")") {
        contentModel += xmlData[i2];
        i2++;
      }
      if (xmlData[i2] !== ")") {
        throw new Error("Unterminated content model");
      }
    } else if (!this.suppressValidationErr) {
      throw new Error(`Invalid Element Expression, found "${xmlData[i2]}"`);
    }
    return {
      elementName,
      contentModel: contentModel.trim(),
      index: i2
    };
  }
  readAttlistExp(xmlData, i2) {
    i2 = skipWhitespace(xmlData, i2);
    let elementName = "";
    while (i2 < xmlData.length && !/\s/.test(xmlData[i2])) {
      elementName += xmlData[i2];
      i2++;
    }
    validateEntityName(elementName);
    i2 = skipWhitespace(xmlData, i2);
    let attributeName = "";
    while (i2 < xmlData.length && !/\s/.test(xmlData[i2])) {
      attributeName += xmlData[i2];
      i2++;
    }
    if (!validateEntityName(attributeName)) {
      throw new Error(`Invalid attribute name: "${attributeName}"`);
    }
    i2 = skipWhitespace(xmlData, i2);
    let attributeType = "";
    if (xmlData.substring(i2, i2 + 8).toUpperCase() === "NOTATION") {
      attributeType = "NOTATION";
      i2 += 8;
      i2 = skipWhitespace(xmlData, i2);
      if (xmlData[i2] !== "(") {
        throw new Error(`Expected '(', found "${xmlData[i2]}"`);
      }
      i2++;
      let allowedNotations = [];
      while (i2 < xmlData.length && xmlData[i2] !== ")") {
        let notation = "";
        while (i2 < xmlData.length && xmlData[i2] !== "|" && xmlData[i2] !== ")") {
          notation += xmlData[i2];
          i2++;
        }
        notation = notation.trim();
        if (!validateEntityName(notation)) {
          throw new Error(`Invalid notation name: "${notation}"`);
        }
        allowedNotations.push(notation);
        if (xmlData[i2] === "|") {
          i2++;
          i2 = skipWhitespace(xmlData, i2);
        }
      }
      if (xmlData[i2] !== ")") {
        throw new Error("Unterminated list of notations");
      }
      i2++;
      attributeType += " (" + allowedNotations.join("|") + ")";
    } else {
      while (i2 < xmlData.length && !/\s/.test(xmlData[i2])) {
        attributeType += xmlData[i2];
        i2++;
      }
      const validTypes = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
      if (!this.suppressValidationErr && !validTypes.includes(attributeType.toUpperCase())) {
        throw new Error(`Invalid attribute type: "${attributeType}"`);
      }
    }
    i2 = skipWhitespace(xmlData, i2);
    let defaultValue = "";
    if (xmlData.substring(i2, i2 + 8).toUpperCase() === "#REQUIRED") {
      defaultValue = "#REQUIRED";
      i2 += 8;
    } else if (xmlData.substring(i2, i2 + 7).toUpperCase() === "#IMPLIED") {
      defaultValue = "#IMPLIED";
      i2 += 7;
    } else {
      [i2, defaultValue] = this.readIdentifierVal(xmlData, i2, "ATTLIST");
    }
    return {
      elementName,
      attributeName,
      attributeType,
      defaultValue,
      index: i2
    };
  }
};
var skipWhitespace = (data, index) => {
  while (index < data.length && /\s/.test(data[index])) {
    index++;
  }
  return index;
};
function hasSeq(data, seq, i2) {
  for (let j = 0; j < seq.length; j++) {
    if (seq[j] !== data[i2 + j + 1]) return false;
  }
  return true;
}
function validateEntityName(name) {
  if (isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}

// node_modules/strnum/strnum.js
var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
var consider = {
  hex: true,
  // oct: false,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function toNumber(str, options = {}) {
  options = Object.assign({}, consider, options);
  if (!str || typeof str !== "string") return str;
  let trimmedStr = str.trim();
  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;
  else if (str === "0") return 0;
  else if (options.hex && hexRegex.test(trimmedStr)) {
    return parse_int(trimmedStr, 16);
  } else if (trimmedStr.search(/.+[eE].+/) !== -1) {
    return resolveEnotation(str, trimmedStr, options);
  } else {
    const match3 = numRegex.exec(trimmedStr);
    if (match3) {
      const sign = match3[1] || "";
      const leadingZeros = match3[2];
      let numTrimmedByZeros = trimZeros(match3[3]);
      const decimalAdjacentToLeadingZeros = sign ? (
        // 0., -00., 000.
        str[leadingZeros.length + 1] === "."
      ) : str[leadingZeros.length] === ".";
      if (!options.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {
        return str;
      } else {
        const num = Number(trimmedStr);
        const parsedStr = String(num);
        if (num === 0) return num;
        if (parsedStr.search(/[eE]/) !== -1) {
          if (options.eNotation) return num;
          else return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (parsedStr === "0") return num;
          else if (parsedStr === numTrimmedByZeros) return num;
          else if (parsedStr === `${sign}${numTrimmedByZeros}`) return num;
          else return str;
        }
        let n2 = leadingZeros ? numTrimmedByZeros : trimmedStr;
        if (leadingZeros) {
          return n2 === parsedStr || sign + n2 === parsedStr ? num : str;
        } else {
          return n2 === parsedStr || n2 === sign + parsedStr ? num : str;
        }
      }
    } else {
      return str;
    }
  }
}
var eNotationRegx = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
function resolveEnotation(str, trimmedStr, options) {
  if (!options.eNotation) return str;
  const notation = trimmedStr.match(eNotationRegx);
  if (notation) {
    let sign = notation[1] || "";
    const eChar = notation[3].indexOf("e") === -1 ? "E" : "e";
    const leadingZeros = notation[2];
    const eAdjacentToLeadingZeros = sign ? (
      // 0E.
      str[leadingZeros.length + 1] === eChar
    ) : str[leadingZeros.length] === eChar;
    if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;
    else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {
      return Number(trimmedStr);
    } else if (options.leadingZeros && !eAdjacentToLeadingZeros) {
      trimmedStr = (notation[1] || "") + notation[3];
      return Number(trimmedStr);
    } else return str;
  } else {
    return str;
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".") numStr = "0";
    else if (numStr[0] === ".") numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".") numStr = numStr.substring(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
function parse_int(numStr, base) {
  if (parseInt) return parseInt(numStr, base);
  else if (Number.parseInt) return Number.parseInt(numStr, base);
  else if (window && window.parseInt) return window.parseInt(numStr, base);
  else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}

// node_modules/fast-xml-parser/src/ignoreAttributes.js
function getIgnoreAttributesFn(ignoreAttributes) {
  if (typeof ignoreAttributes === "function") {
    return ignoreAttributes;
  }
  if (Array.isArray(ignoreAttributes)) {
    return (attrName) => {
      for (const pattern of ignoreAttributes) {
        if (typeof pattern === "string" && attrName === pattern) {
          return true;
        }
        if (pattern instanceof RegExp && pattern.test(attrName)) {
          return true;
        }
      }
    };
  }
  return () => false;
}

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var OrderedObjParser = class {
  constructor(options) {
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
      "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
      "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
      "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
      "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
      "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
      "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
      "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
      "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
      "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCodePoint(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCodePoint(Number.parseInt(str, 16)) }
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
  }
};
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i2 = 0; i2 < entKeys.length; i2++) {
    const ent = entKeys[i2];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if (val.length > 0) {
      if (!escapeEntities) val = this.replaceEntitiesValue(val);
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === void 0) {
        return val;
      } else if (typeof newval !== typeof val || newval !== val) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val.trim();
        if (trimmedVal === val) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap(attrStr, jPath, tagName) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
    const matches = getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i2 = 0; i2 < len; i2++) {
      const attrName = this.resolveNameSpace(matches[i2][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue;
      }
      let oldVal = matches[i2][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__") aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
var parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  const xmlObj = new XmlNode("!xml");
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  const docTypeReader = new DocTypeReader(this.options.processEntities);
  for (let i2 = 0; i2 < xmlData.length; i2++) {
    const ch = xmlData[i2];
    if (ch === "<") {
      if (xmlData[i2 + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }
        const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop();
        textData = "";
        i2 = closeIndex;
      } else if (xmlData[i2 + 1] === "?") {
        let tagData = readTagExp(xmlData, i2, false, "?>");
        if (!tagData) throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
        } else {
          const childNode = new XmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath, i2);
        }
        i2 = tagData.closeIndex + 1;
      } else if (xmlData.substr(i2 + 1, 3) === "!--") {
        const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const comment2 = xmlData.substring(i2 + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment2 }]);
        }
        i2 = endIndex;
      } else if (xmlData.substr(i2 + 1, 2) === "!D") {
        const result = docTypeReader.readDocType(xmlData, i2);
        this.docTypeEntities = result.entities;
        i2 = result.i;
      } else if (xmlData.substr(i2 + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i2 + 9, closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val == void 0) val = "";
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
        } else {
          currentNode.add(this.options.textNodeName, val);
        }
        i2 = closeIndex + 2;
      } else {
        let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
        let tagName = result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode && textData) {
          if (currentNode.tagname !== "!xml") {
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }
        const lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + tagName : tagName;
        }
        const startIndex = i2;
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i2 = result.closeIndex;
          } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
            i2 = result.closeIndex;
          } else {
            const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
            i2 = result2.i;
            tagContent = result2.tagContent;
          }
          const childNode = new XmlNode(tagName);
          if (tagName !== tagExp && attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, childNode, jPath, startIndex);
        } else {
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            const childNode = new XmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new XmlNode(tagName);
            this.tagsNodeStack.push(currentNode);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            currentNode = childNode;
          }
          textData = "";
          i2 = closeIndex;
        }
      }
    } else {
      textData += xmlData[i2];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath, startIndex) {
  if (!this.options.captureMetaData) startIndex = void 0;
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false) {
  } else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode, startIndex);
  } else {
    currentNode.addChild(childNode, startIndex);
  }
}
var replaceEntitiesValue = function(val) {
  if (this.options.processEntities) {
    for (let entityName in this.docTypeEntities) {
      const entity2 = this.docTypeEntities[entityName];
      val = val.replace(entity2.regx, entity2.val);
    }
    for (let entityName in this.lastEntities) {
      const entity2 = this.lastEntities[entityName];
      val = val.replace(entity2.regex, entity2.val);
    }
    if (this.options.htmlEntities) {
      for (let entityName in this.htmlEntities) {
        const entity2 = this.htmlEntities[entityName];
        val = val.replace(entity2.regex, entity2.val);
      }
    }
    val = val.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodes, jPath, currentTagName) {
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
  }
  return false;
}
function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index = i2; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
      if (ch === attrBoundary) attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index
          };
        }
      } else {
        return {
          data: tagExp,
          index
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i2, errMsg) {
  const closingIndex = xmlData.indexOf(str, i2);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
  if (!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i2) {
  const startIndex = i2;
  let openTagCount = 1;
  for (; i2 < xmlData.length; i2++) {
    if (xmlData[i2] === "<") {
      if (xmlData[i2 + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i2),
              i: closeIndex
            };
          }
        }
        i2 = closeIndex;
      } else if (xmlData[i2 + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
        i2 = closeIndex;
      } else if (xmlData.substr(i2 + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
        i2 = closeIndex;
      } else if (xmlData.substr(i2 + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
        i2 = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i2, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i2 = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === "string") {
    const newval = val.trim();
    if (newval === "true") return true;
    else if (newval === "false") return false;
    else return toNumber(val, options);
  } else {
    if (isExist(val)) {
      return val;
    } else {
      return "";
    }
  }
}

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var METADATA_SYMBOL2 = XmlNode.getMetaDataSymbol();
function prettify(node, options) {
  return compress(node, options);
}
function compress(arr, options, jPath) {
  let text2;
  const compressedObj = {};
  for (let i2 = 0; i2 < arr.length; i2++) {
    const tagObj = arr[i2];
    const property = propName(tagObj);
    let newJpath = "";
    if (jPath === void 0) newJpath = property;
    else newJpath = jPath + "." + property;
    if (property === options.textNodeName) {
      if (text2 === void 0) text2 = tagObj[property];
      else text2 += "" + tagObj[property];
    } else if (property === void 0) {
      continue;
    } else if (tagObj[property]) {
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);
      if (tagObj[METADATA_SYMBOL2] !== void 0) {
        val[METADATA_SYMBOL2] = tagObj[METADATA_SYMBOL2];
      }
      if (tagObj[":@"]) {
        assignAttributes(val, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
        val = val[options.textNodeName];
      } else if (Object.keys(val).length === 0) {
        if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }
      if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val);
      } else {
        if (options.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val];
        } else {
          compressedObj[property] = val;
        }
      }
    }
  }
  if (typeof text2 === "string") {
    if (text2.length > 0) compressedObj[options.textNodeName] = text2;
  } else if (text2 !== void 0) compressedObj[options.textNodeName] = text2;
  return compressedObj;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i2 = 0; i2 < keys.length; i2++) {
    const key = keys[i2];
    if (key !== ":@") return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length;
    for (let i2 = 0; i2 < len; i2++) {
      const atrrName = keys[i2];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var XMLParser = class {
  constructor(options) {
    this.externalEntities = {};
    this.options = buildOptions(options);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Uint8Array} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(xmlData, validationOption) {
    if (typeof xmlData !== "string" && xmlData.toString) {
      xmlData = xmlData.toString();
    } else if (typeof xmlData !== "string") {
      throw new Error("XML data is accepted in String or Bytes[] form.");
    }
    if (validationOption) {
      if (validationOption === true) validationOption = {};
      const result = validate(xmlData, validationOption);
      if (result !== true) {
        throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
      }
    }
    const orderedObjParser = new OrderedObjParser(this.options);
    orderedObjParser.addExternalEntities(this.externalEntities);
    const orderedResult = orderedObjParser.parseXml(xmlData);
    if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
    else return prettify(orderedResult, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(key, value) {
    if (value.indexOf("&") !== -1) {
      throw new Error("Entity value can't have '&'");
    } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    } else if (value === "&") {
      throw new Error("An entity with value '&' is not permitted");
    } else {
      this.externalEntities[key] = value;
    }
  }
  /**
   * Returns a Symbol that can be used to access the metadata
   * property on a node.
   * 
   * If Symbol is not available in the environment, an ordinary property is used
   * and the name of the property is here returned.
   * 
   * The XMLMetaData property is only present when `captureMetaData`
   * is true in the options.
   */
  static getMetaDataSymbol() {
    return XmlNode.getMetaDataSymbol();
  }
};

// src/core/utils.ts
var vscode = __toESM(require("vscode"));

// node_modules/@isaacs/balanced-match/dist/esm/index.js
var balanced = (a2, b, str) => {
  const ma = a2 instanceof RegExp ? maybeMatch(a2, str) : a2;
  const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
  const r = ma !== null && mb != null && range(ma, mb, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + ma.length, r[1]),
    post: str.slice(r[1] + mb.length)
  };
};
var maybeMatch = (reg, str) => {
  const m = str.match(reg);
  return m ? m[0] : null;
};
var range = (a2, b, str) => {
  let begs, beg, left, right = void 0, result;
  let ai = str.indexOf(a2);
  let bi = str.indexOf(b, ai + 1);
  let i2 = ai;
  if (ai >= 0 && bi > 0) {
    if (a2 === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i2 >= 0 && !result) {
      if (i2 === ai) {
        begs.push(i2);
        ai = str.indexOf(a2, i2 + 1);
      } else if (begs.length === 1) {
        const r = begs.pop();
        if (r !== void 0)
          result = [r, bi];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i2 + 1);
      }
      i2 = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};

// node_modules/@isaacs/brace-expansion/dist/esm/index.js
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
var escSlashPattern = new RegExp(escSlash, "g");
var escOpenPattern = new RegExp(escOpen, "g");
var escClosePattern = new RegExp(escClose, "g");
var escCommaPattern = new RegExp(escComma, "g");
var escPeriodPattern = new RegExp(escPeriod, "g");
var slashPattern = /\\\\/g;
var openPattern = /\\{/g;
var closePattern = /\\}/g;
var commaPattern = /\\,/g;
var periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str);
  if (!m) {
    return str.split(",");
  }
  const { pre, body, post } = m;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    ;
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i2, y) {
  return i2 <= y;
}
function gte(i2, y) {
  return i2 >= y;
}
function expand_(str, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str);
  if (!m)
    return [str];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0; k < post.length; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str);
      }
      return [str];
    }
    let n2;
    if (isSequence) {
      n2 = m.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m.body);
      if (n2.length === 1 && n2[0] !== void 0) {
        n2 = expand_(n2[0], false).map(embrace);
        if (n2.length === 1) {
          return post.map((p) => m.pre + n2[0] + p);
        }
      }
    }
    let N;
    if (isSequence && n2[0] !== void 0 && n2[1] !== void 0) {
      const x = numeric(n2[0]);
      const y = numeric(n2[1]);
      const width = Math.max(n2[0].length, n2[1].length);
      let incr = n2.length === 3 && n2[2] !== void 0 ? Math.abs(numeric(n2[2])) : 1;
      let test3 = lte;
      const reverse = y < x;
      if (reverse) {
        incr *= -1;
        test3 = gte;
      }
      const pad = n2.some(isPadded);
      N = [];
      for (let i2 = x; test3(i2, y); i2 += incr) {
        let c3;
        if (isAlphaSequence) {
          c3 = String.fromCharCode(i2);
          if (c3 === "\\") {
            c3 = "";
          }
        } else {
          c3 = String(i2);
          if (pad) {
            const need = width - c3.length;
            if (need > 0) {
              const z = new Array(need + 1).join("0");
              if (i2 < 0) {
                c3 = "-" + z + c3.slice(1);
              } else {
                c3 = z + c3;
              }
            }
          }
        }
        N.push(c3);
      }
    } else {
      N = [];
      for (let j = 0; j < n2.length; j++) {
        N.push.apply(N, expand_(n2[j], false));
      }
    }
    for (let j = 0; j < N.length; j++) {
      for (let k = 0; k < post.length; k++) {
        const expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}

// node_modules/glob/node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/glob/node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob2, position) => {
  const pos = position;
  if (glob2.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i2 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i2 < glob2.length) {
    const c3 = glob2.charAt(i2);
    if ((c3 === "!" || c3 === "^") && i2 === pos + 1) {
      negate = true;
      i2++;
      continue;
    }
    if (c3 === "]" && sawStart && !escaping) {
      endPos = i2 + 1;
      break;
    }
    sawStart = true;
    if (c3 === "\\") {
      if (!escaping) {
        escaping = true;
        i2++;
        continue;
      }
    }
    if (c3 === "[" && !escaping) {
      for (const [cls, [unip, u2, neg]] of Object.entries(posixClasses)) {
        if (glob2.startsWith(cls, i2)) {
          if (rangeStart) {
            return ["$.", false, glob2.length - pos, true];
          }
          i2 += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u2;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c3 > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c3));
      } else if (c3 === rangeStart) {
        ranges.push(braceEscape(c3));
      }
      rangeStart = "";
      i2++;
      continue;
    }
    if (glob2.startsWith("-]", i2 + 1)) {
      ranges.push(braceEscape(c3 + "-"));
      i2 += 2;
      continue;
    }
    if (glob2.startsWith("-", i2 + 1)) {
      rangeStart = c3;
      i2 += 2;
      continue;
    }
    ranges.push(braceEscape(c3));
    i2++;
  }
  if (endPos < i2) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob2.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/glob/node_modules/minimatch/dist/esm/unescape.js
var unescape2 = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/glob/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c3) => types.has(c3);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n2;
    while (n2 = this.#negs.pop()) {
      if (n2.type !== "!")
        continue;
      let p = n2;
      let pp = p.#parent;
      while (pp) {
        for (let i2 = p.#parentIndex + 1; !pp.type && i2 < pp.#parts.length; i2++) {
          for (const part of n2.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i2]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i2 = 0; i2 < this.#parentIndex; i2++) {
      const pp = p.#parts[i2];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c3 = new _AST(this.type, parent);
    for (const p of this.#parts) {
      c3.copyIn(p);
    }
    return c3;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i3 = pos;
      let acc2 = "";
      while (i3 < str.length) {
        const c3 = str.charAt(i3++);
        if (escaping || c3 === "\\") {
          escaping = !escaping;
          acc2 += c3;
          continue;
        }
        if (inBrace) {
          if (i3 === braceStart + 1) {
            if (c3 === "^" || c3 === "!") {
              braceNeg = true;
            }
          } else if (c3 === "]" && !(i3 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c3;
          continue;
        } else if (c3 === "[") {
          inBrace = true;
          braceStart = i3;
          braceNeg = false;
          acc2 += c3;
          continue;
        }
        if (!opt.noext && isExtglobType(c3) && str.charAt(i3) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c3, ast);
          i3 = _AST.#parseAST(str, ext2, i3, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c3;
      }
      ast.push(acc2);
      return i3;
    }
    let i2 = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i2 < str.length) {
      const c3 = str.charAt(i2++);
      if (escaping || c3 === "\\") {
        escaping = !escaping;
        acc += c3;
        continue;
      }
      if (inBrace) {
        if (i2 === braceStart + 1) {
          if (c3 === "^" || c3 === "!") {
            braceNeg = true;
          }
        } else if (c3 === "]" && !(i2 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c3;
        continue;
      } else if (c3 === "[") {
        inBrace = true;
        braceStart = i2;
        braceNeg = false;
        acc += c3;
        continue;
      }
      if (isExtglobType(c3) && str.charAt(i2) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c3, part);
        part.push(ext2);
        i2 = _AST.#parseAST(str, ext2, i2, opt);
        continue;
      }
      if (c3 === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c3 === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i2;
      }
      acc += c3;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str.substring(pos - 1)];
    return i2;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob2 = this.toString();
    const [re, body, hasMagic2, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic2, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic2;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = void 0;
      return [s, unescape2(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i2 = 0; i2 < glob2.length; i2++) {
      const c3 = glob2.charAt(i2);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c3) ? "\\" : "") + c3;
        continue;
      }
      if (c3 === "\\") {
        if (i2 === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c3 === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i2);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i2 += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c3 === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c3 === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c3);
    }
    return [re, unescape2(glob2), !!hasMagic2, uflag];
  }
};

// node_modules/glob/node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/glob/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path6 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path6.win32.sep : path6.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter2 = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter2;
var ext = (a2, b = {}) => Object.assign({}, a2, b);
var defaults2 = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list2, pattern, options = {}) => orig.match(list2, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults2;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list2, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list2 = list2.filter((f) => mm.match(f));
  if (mm.options.nonull && !list2.length) {
    list2.push(pattern);
  }
  return list2;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set2 = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set2);
    this.set = set2.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i2 = 0; i2 < this.set.length; i2++) {
        const p = this.set[i2];
        if (p[0] === "" && p[1] === "" && this.globParts[i2][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i2 = 0; i2 < globParts.length; i2++) {
        for (let j = 0; j < globParts[i2].length; j++) {
          if (globParts[i2][j] === "**") {
            globParts[i2][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i2 = gs;
        while (parts[i2 + 1] === "**") {
          i2++;
        }
        if (i2 !== gs) {
          parts.splice(gs, i2 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set2, part) => {
        const prev = set2[set2.length - 1];
        if (part === "**" && prev === "**") {
          return set2;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set2.pop();
            return set2;
          }
        }
        set2.push(part);
        return set2;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i2 = 1; i2 < parts.length - 1; i2++) {
          const p = parts[i2];
          if (i2 === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i2, 1);
            i2--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i2 = 1; i2 < parts.length - 1; i2++) {
            const p = parts[i2];
            if (i2 === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i2, 1);
              i2--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i2 = 0; i2 < globParts.length - 1; i2++) {
      for (let j = i2 + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i2], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i2] = [];
          globParts[j] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a2, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a2.length && bi < b.length) {
      if (a2[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a2[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a2[ai] === "**" && b[bi] === a2[ai + 1]) {
        result.push(a2[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a2[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a2[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a2[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a2[ai] && (this.options.dot || !a2[ai].startsWith(".")) && a2[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a2.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set2.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i2) => {
        const next = pp[i2 + 1];
        const prev = pp[i2 - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next !== void 0 && next !== GLOBSTAR) {
            pp[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
          } else {
            pp[i2] = twoStar;
          }
        } else if (next === void 0) {
          pp[i2 - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next !== GLOBSTAR) {
          pp[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
          pp[i2 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i2 = ff.length - 2; !filename && i2 >= 0; i2--) {
        filename = ff[i2];
      }
    }
    for (let i2 = 0; i2 < set2.length; i2++) {
      const pattern = set2[i2];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape2;

// node_modules/glob/dist/esm/glob.js
var import_node_url4 = require("node:url");

// node_modules/path-scurry/node_modules/lru-cache/dist/esm/index.js
var defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code2, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code2, fn) : console.error(`[${code2}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code2) => !warned.has(code2);
var TYPE = Symbol("type");
var isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n2) {
    this.heap[this.length++] = n2;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  #perf;
  /**
   * {@link LRUCache.OptionsBase.perf}
   */
  get perf() {
    return this.#perf;
  }
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c3) {
    return {
      // properties
      starts: c3.#starts,
      ttls: c3.#ttls,
      sizes: c3.#sizes,
      keyMap: c3.#keyMap,
      keyList: c3.#keyList,
      valList: c3.#valList,
      next: c3.#next,
      prev: c3.#prev,
      get head() {
        return c3.#head;
      },
      get tail() {
        return c3.#tail;
      },
      free: c3.#free,
      // methods
      isBackgroundFetch: (p) => c3.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c3.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c3.#moveToTail(index),
      indexes: (options) => c3.#indexes(options),
      rindexes: (options) => c3.#rindexes(options),
      isStale: (index) => c3.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options;
    if (perf !== void 0) {
      if (typeof perf?.now !== "function") {
        throw new TypeError("perf option must have a now() method if specified");
      }
    }
    this.#perf = perf ?? defaultPerf;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code2 = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code2)) {
        warned.add(code2);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code2, _LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n2 = this.#perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n2;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n2;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i2 = this.#tail; true; ) {
        if (!this.#isValidIndex(i2)) {
          break;
        }
        if (allowStale || !this.#isStale(i2)) {
          yield i2;
        }
        if (i2 === this.#head) {
          break;
        } else {
          i2 = this.#prev[i2];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i2 = this.#head; true; ) {
        if (!this.#isValidIndex(i2)) {
          break;
        }
        if (allowStale || !this.#isStale(i2)) {
          yield i2;
        }
        if (i2 === this.#tail) {
          break;
        } else {
          i2 = this.#next[i2];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i2 of this.#indexes()) {
      if (this.#valList[i2] !== void 0 && this.#keyList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
        yield [this.#keyList[i2], this.#valList[i2]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i2 of this.#rindexes()) {
      if (this.#valList[i2] !== void 0 && this.#keyList[i2] !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
        yield [this.#keyList[i2], this.#valList[i2]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i2 of this.#indexes()) {
      const k = this.#keyList[i2];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i2 of this.#rindexes()) {
      const k = this.#keyList[i2];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i2 of this.#indexes()) {
      const v = this.#valList[i2];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
        yield this.#valList[i2];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i2 of this.#rindexes()) {
      const v = this.#valList[i2];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i2])) {
        yield this.#valList[i2];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i2 of this.#indexes()) {
      const v = this.#valList[i2];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i2], this)) {
        return this.get(this.#keyList[i2], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i2 of this.#indexes()) {
      const v = this.#valList[i2];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i2], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i2 of this.#rindexes()) {
      const v = this.#valList[i2];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i2], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i2 of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i2)) {
        this.#delete(this.#keyList[i2], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i2 = this.#keyMap.get(key);
    if (i2 === void 0)
      return void 0;
    const v = this.#valList[i2];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i2];
      const start = this.#starts[i2];
      if (ttl && start) {
        const remain = ttl - (this.#perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i2];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i2 of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i2];
      const v = this.#valList[i2];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i2];
        const age = this.#perf.now() - this.#starts[i2];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i2];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = this.#perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v, k, "add");
      }
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted: aborted2 } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted2 && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted2 && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      const vl = this.#valList[index];
      if (vl === p || ignoreAbort && updateCache && vl === void 0) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching !== void 0) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted: aborted2 } = ac.signal;
      const allowStaleAborted = aborted2 && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n2) {
    this.#prev[n2] = p;
    this.#next[p] = n2;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// node_modules/path-scurry/dist/esm/index.js
var import_node_path6 = require("node:path");
var import_node_url3 = require("node:url");
var import_fs = require("fs");
var actualFS = __toESM(require("node:fs"), 1);
var import_promises12 = require("node:fs/promises");

// node_modules/minipass/dist/esm/index.js
var import_node_events15 = require("node:events");
var import_node_stream9 = __toESM(require("node:stream"), 1);
var import_node_string_decoder3 = require("node:string_decoder");
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream3 = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof import_node_stream9.default || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof import_node_events15.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_node_stream9.default.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof import_node_events15.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions = (o2) => !!o2.objectMode;
var isEncodingOptions = (o2) => !o2.objectMode && !!o2.encoding && o2.encoding !== "buffer";
var Minipass = class extends import_node_events15.EventEmitter {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  /**
   * true if the stream can be written
   */
  writable = true;
  /**
   * true if the stream can be read
   */
  readable = true;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options)) {
      this[ENCODING] = options.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options.async;
    this[DECODER] = this[ENCODING] ? new import_node_string_decoder3.StringDecoder(this[ENCODING]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get ["async"]() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a2) {
    this[ASYNC] = this[ASYNC] || !!a2;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView2(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n2) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n2 === 0 || n2 && n2 > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n2 = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n2 || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n2, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c3 = chunk;
      if (n2 === c3.length || n2 === null)
        this[BUFFERSHIFT]();
      else if (typeof c3 === "string") {
        this[BUFFER][0] = c3.slice(n2);
        chunk = c3.slice(0, n2);
        this[BUFFERLENGTH] -= n2;
      } else {
        this[BUFFER][0] = c3.subarray(n2);
        chunk = c3.subarray(0, n2);
        this[BUFFERLENGTH] -= n2;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== void 0)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h2 = handler;
      if (this[ASYNC])
        defer(() => h2.call(this, this[EMITTED_ERROR]));
      else
        h2.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c3) => {
      buf.push(c3);
      if (!this[OBJECTMODE])
        buf.dataLength += c3.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve4, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve4());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve4;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve4({ value, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve4({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve4 = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next = () => {
      if (stopped)
        return stop();
      const value = this.read();
      return value === null ? stop() : { done: false, value };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream3;
  }
};

// node_modules/path-scurry/dist/esm/index.js
var realpathSync = import_fs.realpathSync.native;
var defaultFS = {
  lstatSync: import_fs.lstatSync,
  readdir: import_fs.readdir,
  readdirSync: import_fs.readdirSync,
  readlinkSync: import_fs.readlinkSync,
  realpathSync,
  promises: {
    lstat: import_promises12.lstat,
    readdir: import_promises12.readdir,
    readlink: import_promises12.readlink,
    realpath: import_promises12.realpath
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
var normalizeCache = /* @__PURE__ */ new Map();
var normalize = (s) => {
  const c3 = normalizeCache.get(s);
  if (c3)
    return c3;
  const n2 = s.normalize("NFKD");
  normalizeCache.set(s, n2);
  return n2;
};
var normalizeNocaseCache = /* @__PURE__ */ new Map();
var normalizeNocase = (s) => {
  const c3 = normalizeNocaseCache.get(s);
  if (c3)
    return c3;
  const n2 = normalize(s.toLowerCase());
  normalizeNocaseCache.set(s, n2);
  return n2;
};
var ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
};
var ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a2) => a2.length + 1
    });
  }
};
var setAsCwd = Symbol("PathScurry setAsCwd");
var PathBase = class {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  /**
   * boolean indicating that this path is the current working directory
   * of the PathScurry collection that contains it.
   */
  isCWD = false;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['parentPath'] refers to the path of the
   * directory that was passed to readdir. For root entries, it's the path
   * to the entry itself.
   */
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  /**
   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
   * this property refers to the *parent* path, not the path object itself.
   *
   * @deprecated
   */
  get path() {
    return this.parentPath;
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    this.name = name;
    this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
    this.#type = type & TYPEMASK;
    this.nocase = nocase;
    this.roots = roots;
    this.root = root || this;
    this.#children = children;
    this.#fullpath = opts.fullpath;
    this.#relative = opts.relative;
    this.#relativePosix = opts.relativePosix;
    this.parent = opts.parent;
    if (this.parent) {
      this.#fs = this.parent.#fs;
    } else {
      this.#fs = fsFromOption(opts.fs);
    }
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    if (this.#depth !== void 0)
      return this.#depth;
    if (!this.parent)
      return this.#depth = 0;
    return this.#depth = this.parent.depth() + 1;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path15) {
    if (!path15) {
      return this;
    }
    const rootPath = this.getRootString(path15);
    const dir = path15.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    return result;
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts) {
      p = p.child(part);
    }
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = this.#children.get(this);
    if (cached) {
      return cached;
    }
    const children = Object.assign([], { provisional: 0 });
    this.#children.set(this, children);
    this.#type &= ~READDIR_CALLED;
    return children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
    for (const p of children) {
      if (p.#matchName === name) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
    const pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      pchild.#type |= ENOENT;
    }
    children.push(pchild);
    return pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.isCWD)
      return "";
    if (this.#relative !== void 0) {
      return this.#relative;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relative = this.name;
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relativePosix = this.fullpathPosix();
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0) {
      return this.#fullpath;
    }
    const name = this.name;
    const p = this.parent;
    if (!p) {
      return this.#fullpath = this.name;
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return this.#fullpathPosix = `//?/${p2}`;
      } else {
        return this.#fullpathPosix = p2;
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type) {
    return this[`is${type}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return true;
    if (!this.parent)
      return false;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n2) {
    return !this.nocase ? this.#matchName === normalize(n2) : this.#matchName === normalizeNocase(n2);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = await this.#fs.promises.readlink(this.fullpath());
      const linkTarget = (await this.parent.realpath())?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read = this.#fs.readlinkSync(this.fullpath());
      const linkTarget = this.parent.realpathSync()?.resolve(read);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++) {
      const c3 = children[p];
      if (c3)
        c3.#markENOENT();
    }
  }
  #markENOENT() {
    if (this.#type & ENOENT)
      return;
    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
    this.#markChildrenENOENT();
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children) {
      p.#markENOENT();
    }
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH;
    this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    if ((t & IFMT) === IFDIR)
      t &= IFMT_UNKNOWN;
    this.#type = t | ENOTDIR;
    this.#markChildrenENOENT();
  }
  #readdirFail(code2 = "") {
    if (code2 === "ENOTDIR" || code2 === "EPERM") {
      this.#markENOTDIR();
    } else if (code2 === "ENOENT") {
      this.#markENOENT();
    } else {
      this.children().provisional = 0;
    }
  }
  #lstatFail(code2 = "") {
    if (code2 === "ENOTDIR") {
      const p = this.parent;
      p.#markENOTDIR();
    } else if (code2 === "ENOENT") {
      this.#markENOENT();
    }
  }
  #readlinkFail(code2 = "") {
    let ter = this.#type;
    ter |= ENOREADLINK;
    if (code2 === "ENOENT")
      ter |= ENOENT;
    if (code2 === "EINVAL" || code2 === "UNKNOWN") {
      ter &= IFMT_UNKNOWN;
    }
    this.#type = ter;
    if (code2 === "ENOTDIR" && this.parent) {
      this.parent.#markENOTDIR();
    }
  }
  #readdirAddChild(e, c3) {
    return this.#readdirMaybePromoteChild(e, c3) || this.#readdirAddNewChild(e, c3);
  }
  #readdirAddNewChild(e, c3) {
    const type = entToType(e);
    const child = this.newChild(e.name, type, { parent: this });
    const ifmt = child.#type & IFMT;
    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
      child.#type |= ENOTDIR;
    }
    c3.unshift(child);
    c3.provisional++;
    return child;
  }
  #readdirMaybePromoteChild(e, c3) {
    for (let p = c3.provisional; p < c3.length; p++) {
      const pchild = c3[p];
      const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
      if (name !== pchild.#matchName) {
        continue;
      }
      return this.#readdirPromoteChild(e, pchild, p, c3);
    }
  }
  #readdirPromoteChild(e, p, index, c3) {
    const v = p.name;
    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
    if (v !== e.name)
      p.name = e.name;
    if (index !== c3.provisional) {
      if (index === c3.length - 1)
        c3.pop();
      else
        c3.splice(index, 1);
      c3.unshift(p);
    }
    c3.provisional++;
    return p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(this.#fs.lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
    this.#atime = atime;
    this.#atimeMs = atimeMs;
    this.#birthtime = birthtime;
    this.#birthtimeMs = birthtimeMs;
    this.#blksize = blksize;
    this.#blocks = blocks;
    this.#ctime = ctime;
    this.#ctimeMs = ctimeMs;
    this.#dev = dev;
    this.#gid = gid;
    this.#ino = ino;
    this.#mode = mode;
    this.#mtime = mtime;
    this.#mtimeMs = mtimeMs;
    this.#nlink = nlink;
    this.#rdev = rdev;
    this.#size = size;
    this.#uid = uid;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
      this.#type |= ENOTDIR;
    }
  }
  #onReaddirCB = [];
  #readdirCBInFlight = false;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = false;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0;
    cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb(null, []);
      else
        queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c3 = children.slice(0, children.provisional);
      if (allowZalgo)
        cb(null, c3);
      else
        queueMicrotask(() => cb(null, c3));
      return;
    }
    this.#onReaddirCB.push(cb);
    if (this.#readdirCBInFlight) {
      return;
    }
    this.#readdirCBInFlight = true;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
      if (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      } else {
        for (const e of entries) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
      return;
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight) {
      await this.#asyncReaddirInFlight;
    } else {
      let resolve4 = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve4 = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0;
      resolve4();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: true
      })) {
        this.#readdirAddChild(e, children);
      }
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return false;
    const ifmt = IFMT & this.#type;
    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = await this.#fs.promises.realpath(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = this.#fs.realpathSync(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    oldCwd.isCWD = false;
    this.isCWD = true;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      p.#relative = rp.join(this.sep);
      p.#relativePosix = rp.join("/");
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      p.#relative = void 0;
      p.#relativePosix = void 0;
      p = p.parent;
    }
  }
};
var PathWin32 = class _PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path15) {
    return import_node_path6.win32.parse(path15).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare, root] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare)) {
        return this.roots[rootPath] = root;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare;
  }
};
var PathPosix = class _PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path15) {
    return path15.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
};
var PathScurryBase = class {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs9 = defaultFS } = {}) {
    this.#fs = fsFromOption(fs9);
    if (cwd instanceof URL || cwd.startsWith("file://")) {
      cwd = (0, import_node_url3.fileURLToPath)(cwd);
    }
    const cwdPath = pathImpl.resolve(cwd);
    this.roots = /* @__PURE__ */ Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    this.#resolveCache = new ResolveCache();
    this.#resolvePosixCache = new ResolveCache();
    this.#children = new ChildrenCache(childrenCacheSize);
    const split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0]) {
      split.pop();
    }
    if (nocase === void 0) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(this.#fs);
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split.length - 1;
    const joinSep = pathImpl.sep;
    let abs = this.rootPath;
    let sawFirst = false;
    for (const part of split) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path15 = this.cwd) {
    if (typeof path15 === "string") {
      path15 = this.cwd.resolve(path15);
    }
    return path15.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i2 = paths.length - 1; i2 >= 0; i2--) {
      const p = paths[i2];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolveCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpath();
    this.#resolveCache.set(r, result);
    return result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i2 = paths.length - 1; i2 >= 0; i2--) {
      const p = paths[i2];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpathPosix();
    this.#resolvePosixCache.set(r, result);
    return result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry.readdirSync();
    } else {
      return entry.readdirSync().map((e) => e.name);
    }
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = [];
    if (!filter3 || filter3(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const walk = (dir, cb) => {
      dirs.add(dir);
      dir.readdirCB((er, entries) => {
        if (er) {
          return cb(er);
        }
        let len = entries.length;
        if (!len)
          return cb();
        const next = () => {
          if (--len === 0) {
            cb();
          }
        };
        for (const e of entries) {
          if (!filter3 || filter3(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk(e, next);
            } else {
              next();
            }
          }
        }
      }, true);
    };
    const start = entry;
    return new Promise((res, rej) => {
      walk(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = [];
    if (!filter3 || filter3(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter3 || filter3(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      options = entry;
      entry = this.cwd;
    }
    return this.stream(entry, options)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    if (!filter3 || filter3(entry)) {
      yield withFileTypes ? entry : entry.fullpath();
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries = dir.readdirSync();
      for (const e of entries) {
        if (!filter3 || filter3(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter3 || filter3(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const queue = [entry];
    let processing2 = 0;
    const process10 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing2 === 0)
            results.end();
          return;
        }
        processing2++;
        dirs.add(dir);
        const onReaddir = (er, entries, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries, true));
              return;
            }
          }
          for (const e of entries) {
            if (e && (!filter3 || filter3(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing2--;
          for (const e of entries) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process10);
          } else if (!sync2) {
            process10();
          }
        };
        let sync2 = true;
        dir.readdirCB(onReaddir, true);
        sync2 = false;
      }
    };
    process10();
    return results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter3, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = /* @__PURE__ */ new Set();
    if (!filter3 || filter3(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const queue = [entry];
    let processing2 = 0;
    const process10 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing2 === 0)
            results.end();
          return;
        }
        processing2++;
        dirs.add(dir);
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter3 || filter3(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing2--;
        for (const e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process10);
    };
    process10();
    return results;
  }
  chdir(path15 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path15 === "string" ? this.cwd.resolve(path15) : path15;
    this.cwd[setAsCwd](oldCwd);
  }
};
var PathScurryWin32 = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, import_node_path6.win32, "\\", { ...opts, nocase });
    this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return import_node_path6.win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs9) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs9 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
};
var PathScurryPosix = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd, import_node_path6.posix, "/", { ...opts, nocase });
    this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs9) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs9 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
};
var PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd, { ...opts, nocase });
  }
};
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// node_modules/glob/dist/esm/pattern.js
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;
var Pattern = class _Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = true;
  constructor(patternList, globList, index, platform2) {
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index < 0 || index >= this.length) {
      throw new TypeError("index out of range");
    }
    this.#patternList = patternList;
    this.#globList = globList;
    this.#index = index;
    this.#platform = platform2;
    if (this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList;
        const [g0, g1, g2, g3, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList;
        const [g1, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] === "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    if (this.#rest !== void 0)
      return this.#rest;
    if (!this.hasMore())
      return this.#rest = null;
    this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
    this.#rest.#isAbsolute = this.#isAbsolute;
    this.#rest.#isUNC = this.#isUNC;
    this.#rest.#isDrive = this.#isDrive;
    return this.#rest;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = this.#patternList[0];
    return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
      return false;
    this.#followGlobstar = false;
    return true;
  }
};

// node_modules/glob/dist/esm/ignore.js
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Ignore = class {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform2 }) {
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    this.platform = platform2;
    this.mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform: platform2,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored)
      this.add(ign);
  }
  add(ign) {
    const mm = new Minimatch(ign, this.mmopts);
    for (let i2 = 0; i2 < mm.set.length; i2++) {
      const parsed = mm.set[i2];
      const globParts = mm.globParts[i2];
      if (!parsed || !globParts) {
        throw new Error("invalid pattern object");
      }
      while (parsed[0] === "." && globParts[0] === ".") {
        parsed.shift();
        globParts.shift();
      }
      const p = new Pattern(parsed, globParts, 0, this.platform);
      const m = new Minimatch(p.globString(), this.mmopts);
      const children = globParts[globParts.length - 1] === "**";
      const absolute = p.isAbsolute();
      if (absolute)
        this.absolute.push(m);
      else
        this.relative.push(m);
      if (children) {
        if (absolute)
          this.absoluteChildren.push(m);
        else
          this.relativeChildren.push(m);
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative = p.relative() || ".";
    const relatives = `${relative}/`;
    for (const m of this.relative) {
      if (m.match(relative) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
};

// node_modules/glob/dist/esm/processor.js
var HasWalkedCache = class _HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new _HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath();
    const cached = this.store.get(fullpath);
    if (cached)
      cached.add(pattern.globString());
    else
      this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
};
var MatchRecord = class {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    const n2 = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current = this.store.get(target);
    this.store.set(target, current === void 0 ? n2 : n2 & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path15, n2]) => [
      path15,
      !!(n2 & 2),
      !!(n2 & 1)
    ]);
  }
};
var SubWalks = class {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir()) {
      return;
    }
    const subs = this.store.get(target);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
};
var Processor = class _Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root) {
        t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
        const rest2 = pattern.rest();
        if (!rest2) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest2;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
        const c3 = t.resolve(p);
        t = c3;
        pattern = rest;
        changed = true;
      }
      p = pattern.pattern();
      rest = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest?.pattern();
        const rrest = rest?.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new _Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries) {
    const patterns = this.subwalks.get(parent);
    const results = this.child();
    for (const e of entries) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest, absolute);
        } else {
          results.testString(e, p, rest, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest) {
      const rp = rest.pattern();
      if (typeof rp === "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
  testString(e, p, rest, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest);
    }
  }
};

// node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
var GlobUtil = class {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = false;
  aborted = false;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(patterns, path15, opts) {
    this.patterns = patterns;
    this.path = path15;
    this.opts = opts;
    this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
    this.includeChildMatches = opts.includeChildMatches !== false;
    if (opts.ignore || !this.includeChildMatches) {
      this.#ignore = makeIgnore(opts.ignore ?? [], opts);
      if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
        const m = "cannot ignore child matches, ignore lacks add() method.";
        throw new Error(m);
      }
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        this.#onResume.length = 0;
      });
    }
  }
  #ignored(path15) {
    return this.seen.has(path15) || !!this.#ignore?.ignored?.(path15);
  }
  #childrenIgnored(path15) {
    return !!this.#ignore?.childrenIgnored?.(path15);
  }
  // backpressure mechanism
  pause() {
    this.paused = true;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = false;
    let fn = void 0;
    while (!this.paused && (fn = this.#onResume.shift())) {
      fn();
    }
  }
  onResume(fn) {
    if (this.signal?.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      this.#onResume.push(fn);
    }
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? await e.lstat() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = await s.realpath();
      if (target && (target.isUnknown() || this.opts.stat)) {
        await target.lstat();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? e.lstatSync() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = s.realpathSync();
      if (target && (target?.isUnknown() || this.opts.stat)) {
        target.lstatSync();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    if (!this.includeChildMatches && this.#ignore?.add) {
      const ign = `${e.relativePosix()}/**`;
      this.#ignore.add(ign);
    }
    const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs) {
      const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs2 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next);
      else {
        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
      }
    }
    next();
  }
  walkCB3(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next());
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target2, patterns, processor.child(), next);
    }
    next();
  }
  walkCBSync(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1;
    const next = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target2, patterns, processor.child(), next);
    }
    next();
  }
};
var GlobWalker = class extends GlobUtil {
  matches = /* @__PURE__ */ new Set();
  constructor(patterns, path15, opts) {
    super(patterns, path15, opts);
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        if (this.signal?.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
};
var GlobStream = class extends GlobUtil {
  results;
  constructor(patterns, path15, opts) {
    super(patterns, path15, opts);
    this.results = new Minipass({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target = this.path;
    if (target.isUnknown()) {
      target.lstat().then(() => {
        this.walkCB(target, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
};

// node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Glob = class {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = (0, import_node_url4.fileURLToPath)(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.includeChildMatches = opts.includeChildMatches !== false;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== void 0) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set2, m) => {
      set2[0].push(...m.set);
      set2[1].push(...m.globParts);
      return set2;
    }, [[], []]);
    this.patterns = matchSet.map((set2, i2) => {
      const g = globParts[i2];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern(set2, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// node_modules/glob/dist/esm/has-magic.js
var hasMagic = (pattern, options = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options).hasMagic())
      return true;
  }
  return false;
};

// node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options = {}) {
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
  return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
  return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
  return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
  return new Glob(pattern, options).iterate();
}
var streamSync = globStreamSync;
var stream4 = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream: stream4,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape: unescape2
});
glob.glob = glob;

// src/core/utils.ts
var _ctx;
function setExtensionContext(ctx) {
  console.log("[UAV][setExtensionContext] ExtensionContext recibido:", !!ctx);
  console.log("[UAV][setExtensionContext] globalStorageUri:", ctx?.globalStorageUri?.fsPath);
  _ctx = ctx;
}
var globalChannel = null;
var processHandlersRegistered = false;
var ignoredUnhandledPatterns = [
  /CreateEmbeddingSupplier/i
];
function shouldIgnoreUnhandled(reason) {
  const message = typeof reason === "string" ? reason : typeof reason?.message === "string" ? reason.message : "";
  return ignoredUnhandledPatterns.some((pattern) => pattern.test(message));
}
function getGlobalChannel() {
  if (!globalChannel) {
    globalChannel = vscode.window.createOutputChannel("Unified Apex Validator");
    globalChannel.show(true);
  }
  return globalChannel;
}
function getStorageRoot() {
  const base = _ctx?.globalStorageUri?.fsPath || path7.resolve(__dirname, "..", "..");
  const dir = path7.join(base, ".uav");
  try {
    fs.ensureDirSync(dir);
  } catch (err) {
    console.error("[UAV][getStorageRoot] \u274C Error creando directorio", err);
  }
  return dir;
}
var Logger = class {
  logPath;
  outputChannel;
  prefix;
  constructor(prefix, autoShow = false, channelName = "Unified Apex Validator") {
    this.prefix = prefix;
    const storageRoot = getStorageRoot();
    console.log(`[UAV][Logger] Creando logger para ${prefix} en ${storageRoot}`);
    const logDir = path7.join(storageRoot, "logs");
    try {
      fs.ensureDirSync(logDir);
    } catch (err) {
      console.error("[UAV][Logger] \u274C Error creando carpeta de logs:", err);
    }
    this.logPath = path7.join(logDir, `${prefix}.log`);
    this.outputChannel = getGlobalChannel();
    if (!fs.existsSync(this.logPath)) {
      fs.writeFileSync(this.logPath, "\uFEFF", { encoding: "utf8" });
    }
    if (autoShow) {
      this.outputChannel.show(true);
      console.log(`[UAV][Logger] Mostrando canal: ${channelName}`);
    }
    console.log(`[UAV][Logger] logPath=${this.logPath}`);
    if (!processHandlersRegistered) {
      process.on("uncaughtException", (err) => this.error(`Uncaught Exception: ${err.message}`));
      process.on("unhandledRejection", (reason) => {
        if (shouldIgnoreUnhandled(reason)) return;
        this.error(`Unhandled Rejection: ${reason}`);
      });
      processHandlersRegistered = true;
    }
  }
  clear() {
    console.log(`[UAV][Logger] Limpiando log: ${this.logPath}`);
    fs.writeFileSync(this.logPath, "\uFEFF", { encoding: "utf8" });
  }
  write(level, msg) {
    const line = `${(/* @__PURE__ */ new Date()).toISOString()} [${level}] [${this.prefix}] ${msg}`;
    try {
      fs.appendFileSync(this.logPath, line + "\n", { encoding: "utf8" });
    } catch (err) {
      console.error(`[UAV][Logger] \u274C Error escribiendo log ${this.logPath}:`, err);
    }
    this.outputChannel.appendLine(line);
  }
  info(msg) {
    this.write("INFO", msg);
  }
  warn(msg) {
    this.write("WARN", msg);
  }
  error(msg) {
    this.write("ERROR", msg);
  }
  pipe(childProcess) {
  }
};
async function parseApexClassesFromPackage(pkgPath, repoDir) {
  const logger3 = new Logger("PackageParser");
  try {
    logger3.info(`\u{1F4E6} Leyendo package.xml desde: ${pkgPath}`);
    const xml = await fs.readFile(pkgPath, "utf8");
    const parser = new XMLParser({ ignoreAttributes: false });
    const json = parser.parse(xml);
    const types2 = json?.Package?.types || [];
    const apexTypes = Array.isArray(types2) ? types2.find((t) => t.name === "ApexClass") : types2.name === "ApexClass" ? types2 : null;
    const members = Array.isArray(apexTypes.members) ? apexTypes.members : [apexTypes.members];
    const testClasses = [];
    const nonTestClasses = [];
    logger3.info(`\u{1F4C2} Buscando clases dentro de: ${repoDir}`);
    for (const cls of members) {
      const matches = sync(`**/${cls}.cls`, { cwd: repoDir, absolute: true });
      if (!matches.length) {
        continue;
      }
      const content = await fs.readFile(matches[0], "utf8");
      if (/@istest/i.test(content)) {
        testClasses.push(cls);
      } else {
        nonTestClasses.push(cls);
      }
    }
    logger3.info(`\u{1F9EA} Clases de prueba detectadas (${testClasses.length}): ${testClasses.join(", ") || "Ninguna"}`);
    logger3.info(`\u{1F4D6} Clases normales detectadas (${nonTestClasses.length}): ${nonTestClasses.join(", ") || "Ninguna"}`);
    return { testClasses, nonTestClasses };
  } catch (err) {
    console.error("[UAV][PackageParser] \u274C Error parseando package.xml:", err);
    throw err;
  }
}
async function cleanUpFiles(paths, logger3) {
  for (const dir of paths) {
    try {
      if (await fs.pathExists(dir)) {
        await fs.emptyDir(dir);
        logger3?.info(`\u{1F9F9} Carpeta limpiada: ${dir}`);
      } else {
        logger3?.warn(`\u26A0\uFE0F Carpeta no encontrada: ${dir}`);
      }
    } catch (err) {
      logger3?.warn(`\u274C No se pudo limpiar ${dir}: ${err.message}`);
    }
  }
}
function resolveSfCliPath() {
  const config2 = vscode.workspace.getConfiguration("UnifiedApexValidator");
  const configured = config2.get("sfCliPath")?.trim();
  const candidates = [];
  if (configured) candidates.push(configured);
  if (process.platform === "win32") {
    candidates.push("sf.cmd", "sf.CMD", "sf");
  } else {
    candidates.push("sf");
  }
  const attempts = [];
  for (const cmd of candidates) {
    if (!cmd) continue;
    try {
      execaSync(cmd, ["--version"]);
      return cmd;
    } catch (err) {
      const reason = err?.shortMessage || err?.message || String(err);
      attempts.push(`${cmd}: ${reason}`);
    }
  }
  throw new Error(
    `No se pudo localizar Salesforce CLI. Revisa UnifiedApexValidator.sfCliPath. Intentos: ${attempts.join("; ")}`
  );
}
async function ensureOrgAliasConnected(alias, logger3) {
  const trimmed = (alias || "").trim();
  if (!trimmed) {
    vscode.window.showErrorMessage("Configura UnifiedApexValidator.sfOrgAlias antes de ejecutar el validador.");
    return false;
  }
  const sfPath = resolveSfCliPath();
  const checkAlias = async () => {
    try {
      const { stdout } = await execa(sfPath, ["org", "display", "--json", "--target-org", trimmed], {
        env: { ...process.env, FORCE_COLOR: "0" }
      });
      const raw = stdout?.trim();
      if (!raw) return false;
      const info = JSON.parse(raw);
      const status = info?.result?.connectedStatus || info?.result?.status || info?.result?.connected;
      if (typeof status === "string" && status.toLowerCase() === "connected") {
        logger3.info(`Org "${trimmed}" detectada como conectada.`);
        return true;
      }
      logger3.warn(`Estado de la org "${trimmed}": ${status || "desconocido"}.`);
      return false;
    } catch (err) {
      const reason = err?.shortMessage || err?.stderr || err?.message || String(err);
      logger3.warn(`No se pudo verificar la org "${trimmed}": ${reason}`);
      return false;
    }
  };
  if (await checkAlias()) return true;
  const answer = await vscode.window.showWarningMessage(
    `La org con alias "${trimmed}" no aparece conectada en Salesforce CLI. \xBFQuieres iniciar sesion ahora?`,
    "Conectar ahora",
    "Cancelar"
  );
  if (answer !== "Conectar ahora") {
    logger3.warn(`Se cancela la validacion porque la org "${trimmed}" no esta conectada.`);
    return false;
  }
  try {
    await vscode.window.withProgress(
      {
        location: vscode.ProgressLocation.Notification,
        title: `Conectando org "${trimmed}"...`,
        cancellable: false
      },
      async () => {
        logger3.info(`Ejecutando "sf org login web --alias ${trimmed}". Completa el inicio de sesion en el navegador.`);
        const child = execa(sfPath, ["org", "login", "web", "--alias", trimmed], {
          stdout: "pipe",
          stderr: "pipe",
          env: { ...process.env, FORCE_COLOR: "0" }
        });
        child.stdout?.on("data", (data) => {
          const text2 = data.toString().trim();
          if (text2) logger3.info(`[sf] ${text2}`);
        });
        child.stderr?.on("data", (data) => {
          const text2 = data.toString().trim();
          if (text2) logger3.warn(`[sf] ${text2}`);
        });
        await child;
      }
    );
  } catch (err) {
    const reason = err?.shortMessage || err?.message || String(err);
    logger3.error(`No se pudo completar el login de la org "${trimmed}": ${reason}`);
    vscode.window.showErrorMessage(`No se pudo conectar la org "${trimmed}". Revisa el Output de UAV para mas detalles.`);
    return false;
  }
  if (await checkAlias()) {
    vscode.window.showInformationMessage(`Org "${trimmed}" conectada correctamente.`);
    return true;
  }
  vscode.window.showErrorMessage(
    `El alias "${trimmed}" sigue sin conexion tras el intento de login. Verifica tus permisos y repite el proceso.`
  );
  return false;
}

// src/core/IAAnalisis.ts
var IAConnectionError = class _IAConnectionError extends Error {
  constructor(message) {
    super(message);
    this.name = "IAConnectionError";
    Object.setPrototypeOf(this, _IAConnectionError.prototype);
  }
};
var IAAnalisis = class {
  logger;
  endpoint;
  model;
  clientId;
  clientSecret;
  domain;
  basePrompt;
  constructor() {
    const config2 = vscode2.workspace.getConfiguration("UnifiedApexValidator");
    this.endpoint = config2.get("sfGptEndpoint") ?? "";
    this.model = config2.get("sfGptModel") ?? "";
    this.clientId = config2.get("sfClientId") ?? "";
    this.clientSecret = config2.get("sfClientSecret") ?? "";
    this.domain = config2.get("sfDomain") ?? "test.salesforce.com";
    this.basePrompt = config2.get("iaPromptTemplate") ?? "";
    this.logger = new Logger("IAAnalisis", true);
  }
  async getAccessToken() {
    const url2 = `https://${this.domain.replace(/^https:\/\//i, "")}/services/oauth2/token`;
    const params = new URLSearchParams({
      grant_type: "client_credentials",
      client_id: this.clientId,
      client_secret: this.clientSecret
    });
    try {
      const response = await axios_default.post(url2, params);
      const token = response.data?.access_token;
      if (!token) {
        throw new Error("Token vacio en la respuesta del servidor IA.");
      }
      return token;
    } catch (error) {
      this.logger.error(`[IA] Error obteniendo token IA: ${error.message}`);
      if (error.response) {
        this.logger.error(`[IA] Respuesta del servidor IA: ${JSON.stringify(error.response.data)}`);
      }
      throw new IAConnectionError(`Error autenticando con el servidor de IA: ${error.message}`);
    }
  }
  async generate(prompt) {
    this.logger.info("[IA] Iniciando analisis IA...");
    const token = await this.getAccessToken();
    const finalPrompt = `${this.basePrompt}

${prompt}`;
    try {
      const apiEndpoint = `${this.endpoint}/v1/models/${this.model}/generations`;
      this.logger.info(`[IA] Enviando solicitud a Einstein GPT: ${apiEndpoint}`);
      const response = await axios_default.post(
        apiEndpoint,
        { prompt: finalPrompt },
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
            "x-sfdc-app-context": "EinsteinGPT",
            "x-client-feature-id": "ai-platform-models-connected-app"
          },
          timeout: 12e4
        }
      );
      this.logger.info("[IA] Analisis IA completado correctamente.");
      let generatedText = "";
      const data = response.data || {};
      if (data.generation?.generatedText) {
        generatedText = data.generation.generatedText;
      } else if (data.generations?.length) {
        generatedText = data.generations[0]?.text || "";
      } else if (data.generation?.text) {
        generatedText = data.generation.text;
      } else if (typeof data === "string") {
        generatedText = data;
      }
      if (!generatedText) {
        this.logger.warn("[IA] No se detecto texto generado en la respuesta de IA.");
      }
      return {
        resumen: generatedText || "Sin resumen disponible"
      };
    } catch (error) {
      this.logger.error(`[IA] Error durante el analisis IA: ${error.message}`);
      if (error.response) {
        const payload = JSON.stringify(error.response.data);
        this.logger.error(`[IA] Respuesta del servidor: ${payload.slice(0, 300)}...`);
      }
      throw new Error("No se pudo ejecutar el analisis IA.");
    }
  }
};
function evaluateIaConfig() {
  const config2 = vscode2.workspace.getConfiguration("UnifiedApexValidator");
  const requiredFields = [
    { key: "sfGptEndpoint", label: "sfGptEndpoint" },
    { key: "sfGptModel", label: "sfGptModel" },
    { key: "sfClientId", label: "sfClientId" },
    { key: "sfClientSecret", label: "sfClientSecret" },
    { key: "iaPromptTemplate", label: "iaPromptTemplate" }
  ];
  const missing = requiredFields.filter(({ key }) => {
    const value = config2.get(key);
    return typeof value !== "string" || value.trim().length === 0;
  }).map(({ label }) => label);
  return {
    ready: missing.length === 0,
    missing
  };
}

// src/providers/dependenciesProvider.ts
var DependenciesProvider = class {
  constructor(context) {
    this.context = context;
  }
  _onDidChangeTreeData = new vscode3.EventEmitter();
  onDidChangeTreeData = this._onDidChangeTreeData.event;
  refresh() {
    this._onDidChangeTreeData.fire();
  }
  getTreeItem(element) {
    return element;
  }
  async getChildren() {
    const dependencies = [];
    const checks = [
      { label: "Node.js", cmd: "node --version", minVersion: "18.0.0", installCmd: "npm install -g node" },
      { label: "Salesforce CLI (sf)", cmd: "sf --version", minVersion: "2.0.0", installCmd: "npm install -g @salesforce/cli" },
      {
        label: "Salesforce Code Analyzer",
        cmd: "sf code-analyzer run --help",
        minVersion: "5.0.0",
        installCmd: "sf plugins install @salesforce/sfdx-scanner"
      },
      { label: "Java", cmd: "java -version", minVersion: "11.0.0", installCmd: "apt install openjdk-11-jdk" },
      { label: "wkhtmltopdf", cmd: "wkhtmltopdf --version", minVersion: "0.12.6", installCmd: "brew install wkhtmltopdf" }
    ];
    for (const dep of checks) {
      const state = await this.checkCommand(dep);
      const item = new UavDependencyItem(dep.label, state);
      const iconMap = {
        ok: new vscode3.ThemeIcon("check", new vscode3.ThemeColor("testing.iconPassed")),
        outdated: new vscode3.ThemeIcon("triangle-right", new vscode3.ThemeColor("editorWarning.foreground")),
        missing: new vscode3.ThemeIcon("close", new vscode3.ThemeColor("errorForeground"))
      };
      item.iconPath = iconMap[state];
      if (state !== "ok" && dep.installCmd) {
        item.command = {
          title: "Actualizar dependencia",
          command: "uav.updateDependency",
          arguments: [dep]
        };
        item.tooltip = `Actualizar ${dep.label}`;
      }
      dependencies.push(item);
    }
    const iaStatus = evaluateIaConfig();
    const iaItem = new UavDependencyItem("IA Configuracion", iaStatus.ready ? "ok" : "missing");
    iaItem.iconPath = iaStatus.ready ? new vscode3.ThemeIcon("check", new vscode3.ThemeColor("testing.iconPassed")) : new vscode3.ThemeIcon("close", new vscode3.ThemeColor("errorForeground"));
    if (iaStatus.ready) {
      iaItem.description = "Actualizado";
      iaItem.tooltip = "Credenciales IA configuradas.";
    } else {
      const missingList = iaStatus.missing.join(", ");
      iaItem.description = `Faltan: ${missingList}`;
      iaItem.tooltip = `Configura los siguientes campos: ${missingList}`;
    }
    dependencies.push(iaItem);
    return dependencies;
  }
  async checkCommand(dep) {
    try {
      const { stdout, stderr } = await execa(dep.cmd, { shell: true });
      const output = stdout || stderr || "";
      const match3 = output.match(/\d+(\.\d+)+/);
      if (match3 && dep.minVersion) {
        return this.compareVersions(match3[0], dep.minVersion) >= 0 ? "ok" : "outdated";
      }
      return "ok";
    } catch {
      return "missing";
    }
  }
  compareVersions(a2, b) {
    const pa = a2.split(".").map(Number);
    const pb = b.split(".").map(Number);
    for (let i2 = 0; i2 < Math.max(pa.length, pb.length); i2++) {
      if ((pa[i2] || 0) > (pb[i2] || 0)) return 1;
      if ((pa[i2] || 0) < (pb[i2] || 0)) return -1;
    }
    return 0;
  }
};
var UavDependencyItem = class extends vscode3.TreeItem {
  constructor(label, state) {
    super(label, vscode3.TreeItemCollapsibleState.None);
    this.label = label;
    this.state = state;
    this.description = this.getDescription(state);
  }
  getDescription(state) {
    switch (state) {
      case "ok":
        return "Actualizado";
      case "outdated":
        return "Desactualizado";
      case "missing":
        return "No instalado";
    }
  }
};
function registerDependencyUpdater(context) {
  context.subscriptions.push(
    vscode3.commands.registerCommand("uav.updateDependency", async (dep) => {
      vscode3.window.withProgress(
        { location: vscode3.ProgressLocation.Notification, title: `Actualizando ${dep.label}...` },
        async () => {
          try {
            await execa(dep.installCmd, { shell: true });
            vscode3.window.showInformationMessage(`${dep.label} actualizado correctamente.`);
          } catch (err) {
            vscode3.window.showErrorMessage(`Error actualizando ${dep.label}: ${err.message}`);
          }
        }
      );
    })
  );
}

// src/core/uavController.ts
var vscode8 = __toESM(require("vscode"));
var path12 = __toESM(require("path"));
var fs6 = __toESM(require_lib());

// node_modules/markdown-it/lib/common/utils.mjs
var utils_exports2 = {};
__export(utils_exports2, {
  arrayReplaceAt: () => arrayReplaceAt,
  assign: () => assign,
  escapeHtml: () => escapeHtml,
  escapeRE: () => escapeRE,
  fromCodePoint: () => fromCodePoint2,
  has: () => has,
  isMdAsciiPunct: () => isMdAsciiPunct,
  isPunctChar: () => isPunctChar,
  isSpace: () => isSpace,
  isString: () => isString2,
  isValidEntityCode: () => isValidEntityCode,
  isWhiteSpace: () => isWhiteSpace2,
  lib: () => lib,
  normalizeReference: () => normalizeReference,
  unescapeAll: () => unescapeAll,
  unescapeMd: () => unescapeMd
});

// node_modules/mdurl/index.mjs
var mdurl_exports = {};
__export(mdurl_exports, {
  decode: () => decode_default,
  encode: () => encode_default,
  format: () => format2,
  parse: () => parse_default
});

// node_modules/mdurl/lib/decode.mjs
var decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i2 = 0; i2 < 128; i2++) {
    const ch = String.fromCharCode(i2);
    cache.push(ch);
  }
  for (let i2 = 0; i2 < exclude.length; i2++) {
    const ch = exclude.charCodeAt(i2);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode(string, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    let result = "";
    for (let i2 = 0, l = seq.length; i2 < l; i2 += 3) {
      const b1 = parseInt(seq.slice(i2 + 1, i2 + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i2 + 3 < l) {
        const b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i2 += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i2 + 6 < l) {
        const b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
        const b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i2 += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i2 + 9 < l) {
        const b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
        const b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
        const b4 = parseInt(seq.slice(i2 + 10, i2 + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i2 += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
decode.defaultChars = ";/?:@&=+$,#";
decode.componentChars = "";
var decode_default = decode;

// node_modules/mdurl/lib/encode.mjs
var encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i2 = 0; i2 < 128; i2++) {
    const ch = String.fromCharCode(i2);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i2 = 0; i2 < exclude.length; i2++) {
    cache[exclude.charCodeAt(i2)] = exclude[i2];
  }
  return cache;
}
function encode3(string, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode3.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i2 = 0, l = string.length; i2 < l; i2++) {
    const code2 = string.charCodeAt(i2);
    if (keepEscaped && code2 === 37 && i2 + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i2 + 1, i2 + 3))) {
        result += string.slice(i2, i2 + 3);
        i2 += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i2 + 1 < l) {
        const nextCode = string.charCodeAt(i2 + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i2] + string[i2 + 1]);
          i2++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i2]);
  }
  return result;
}
encode3.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode3.componentChars = "-_.!~*'()";
var encode_default = encode3;

// node_modules/mdurl/lib/format.mjs
function format2(url2) {
  let result = "";
  result += url2.protocol || "";
  result += url2.slashes ? "//" : "";
  result += url2.auth ? url2.auth + "@" : "";
  if (url2.hostname && url2.hostname.indexOf(":") !== -1) {
    result += "[" + url2.hostname + "]";
  } else {
    result += url2.hostname || "";
  }
  result += url2.port ? ":" + url2.port : "";
  result += url2.pathname || "";
  result += url2.search || "";
  result += url2.hash || "";
  return result;
}

// node_modules/mdurl/lib/parse.mjs
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url2, slashesDenoteHost) {
  if (url2 && url2 instanceof Url) return url2;
  const u2 = new Url();
  u2.parse(url2, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url2, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i2 = 0; i2 < hostEndingChars.length; i2++) {
      hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i2 = 0; i2 < nonHostChars.length; i2++) {
      hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i2 = 0, l = hostparts.length; i2 < l; i2++) {
        const part = hostparts[i2];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i2);
            const notHost = hostparts.slice(i2 + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse_default = urlParse;

// node_modules/uc.micro/index.mjs
var uc_exports = {};
__export(uc_exports, {
  Any: () => regex_default,
  Cc: () => regex_default2,
  Cf: () => regex_default3,
  P: () => regex_default4,
  S: () => regex_default5,
  Z: () => regex_default6
});

// node_modules/uc.micro/properties/Any/regex.mjs
var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

// node_modules/uc.micro/categories/Cc/regex.mjs
var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

// node_modules/uc.micro/categories/Cf/regex.mjs
var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

// node_modules/uc.micro/categories/P/regex.mjs
var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

// node_modules/uc.micro/categories/S/regex.mjs
var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

// node_modules/uc.micro/categories/Z/regex.mjs
var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c3) => c3.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c3) => c3.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber2(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber2(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber2(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber2(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}

// node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i2 = 1; i2 < arr.length; i2++) {
    arr[i2][0] += arr[i2 - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c3, index) => (c3.charCodeAt(index) & 64512) === 55296 ? (c3.charCodeAt(index) - 55296) * 1024 + c3.charCodeAt(index + 1) - 56320 + 65536 : c3.charCodeAt(index)
  )
);
function getEscaper(regex, map) {
  return function escape4(data) {
    let match3;
    let lastIdx = 0;
    let result = "";
    while (match3 = regex.exec(data)) {
      if (lastIdx !== match3.index) {
        result += data.substring(lastIdx, match3.index);
      }
      result += map.get(match3[0].charCodeAt(0));
      lastIdx = match3.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/markdown-it/lib/common/utils.mjs
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString2(obj) {
  return _class(obj) === "[object String]";
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function has(object, key) {
  return _hasOwnProperty.call(object, key);
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c3) {
  if (c3 >= 55296 && c3 <= 57343) {
    return false;
  }
  if (c3 >= 64976 && c3 <= 65007) {
    return false;
  }
  if ((c3 & 65535) === 65535 || (c3 & 65535) === 65534) {
    return false;
  }
  if (c3 >= 0 && c3 <= 8) {
    return false;
  }
  if (c3 === 11) {
    return false;
  }
  if (c3 >= 14 && c3 <= 31) {
    return false;
  }
  if (c3 >= 127 && c3 <= 159) {
    return false;
  }
  if (c3 > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint2(c3) {
  if (c3 > 65535) {
    c3 -= 65536;
    const surrogate1 = 55296 + (c3 >> 10);
    const surrogate2 = 56320 + (c3 & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c3);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match3, name) {
  if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
    const code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint2(code2);
    }
    return match3;
  }
  const decoded = decodeHTML(match3);
  if (decoded !== match3) {
    return decoded;
  }
  return match3;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match3, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match3, entity2);
  });
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace2(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return regex_default4.test(ch) || regex_default5.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("\u1E9E".toLowerCase() === "\u1E7E") {
    str = str.replace(//g, "\xDF");
  }
  return str.toLowerCase().toUpperCase();
}
var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

// node_modules/markdown-it/lib/helpers/index.mjs
var helpers_exports = {};
__export(helpers_exports, {
  parseLinkDestination: () => parseLinkDestination,
  parseLinkLabel: () => parseLinkLabel,
  parseLinkTitle: () => parseLinkTitle
});

// node_modules/markdown-it/lib/helpers/parse_link_label.mjs
function parseLinkLabel(state, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state.posMax;
  const oldPos = state.pos;
  state.pos = start + 1;
  level = 1;
  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
}

// node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
function parseLinkDestination(str, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}

// node_modules/markdown-it/lib/helpers/parse_link_title.mjs
function parseLinkTitle(str, start, max, prev_state) {
  let code2;
  let pos = start;
  const state = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state.str = prev_state.str;
    state.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state.marker = marker;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === state.marker) {
      state.pos = pos + 1;
      state.str += unescapeAll(str.slice(start, pos));
      state.ok = true;
      return state;
    } else if (code2 === 40 && state.marker === 41) {
      return state;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state.can_continue = true;
  state.str += unescapeAll(str.slice(start, pos));
  return state;
}

// node_modules/markdown-it/lib/renderer.mjs
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env2, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env2, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env2, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i2 = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i2 < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i2] = tmpAttrs[i2].slice();
      tmpAttrs[i2][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env2, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env2);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i2, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i2 = 0, l = token.attrs.length; i2 < l; i2++) {
    result += " " + escapeHtml(token.attrs[i2][0]) + '="' + escapeHtml(token.attrs[i2][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env2) {
  let result = "";
  const rules = this.rules;
  for (let i2 = 0, len = tokens.length; i2 < len; i2++) {
    const type = tokens[i2].type;
    if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i2, options, env2, this);
    } else {
      result += this.renderToken(tokens, i2, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env2) {
  let result = "";
  for (let i2 = 0, len = tokens.length; i2 < len; i2++) {
    switch (tokens[i2].type) {
      case "text":
        result += tokens[i2].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i2].children, options, env2);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i2].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
      default:
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env2) {
  let result = "";
  const rules = this.rules;
  for (let i2 = 0, len = tokens.length; i2 < len; i2++) {
    const type = tokens[i2].type;
    if (type === "inline") {
      result += this.renderInline(tokens[i2].children, options, env2);
    } else if (typeof rules[type] !== "undefined") {
      result += rules[type](tokens, i2, options, env2, this);
    } else {
      result += this.renderToken(tokens, i2, options, env2);
    }
  }
  return result;
};
var renderer_default = Renderer;

// node_modules/markdown-it/lib/ruler.mjs
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name) {
  for (let i2 = 0; i2 < this.__rules__.length; i2++) {
    if (this.__rules__[i2].name === name) {
      return i2;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self2 = this;
  const chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name, fn, options) {
  const index = this.__find__(name);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index = this.__find__(beforeName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index = this.__find__(afterName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler_default = Ruler;

// node_modules/markdown-it/lib/token.mjs
function Token(type, tag, nesting) {
  this.type = type;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i2 = 0, len = attrs.length; i2 < len; i2++) {
    if (attrs[i2][0] === name) {
      return i2;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name, value) {
  const idx = this.attrIndex(name);
  const attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name) {
  const idx = this.attrIndex(name);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name, value) {
  const idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token_default = Token;

// node_modules/markdown-it/lib/rules_core/state_core.mjs
function StateCore(src, md, env2) {
  this.src = src;
  this.env = env2;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = token_default;
var state_core_default = StateCore;

// node_modules/markdown-it/lib/rules_core/normalize.mjs
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
function normalize2(state) {
  let str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state.src = str;
}

// node_modules/markdown-it/lib/rules_core/block.mjs
function block(state) {
  let token;
  if (state.inlineMode) {
    token = new state.Token("inline", "", 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
}

// node_modules/markdown-it/lib/rules_core/inline.mjs
function inline(state) {
  const tokens = state.tokens;
  for (let i2 = 0, l = tokens.length; i2 < l; i2++) {
    const tok = tokens[i2];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/linkify.mjs
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify(state) {
  const blockTokens = state.tokens;
  if (!state.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
      const currentToken = tokens[i2];
      if (currentToken.type === "link_close") {
        i2--;
        while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
          i2--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content;
        let links = state.md.linkify.match(text2);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens[i2 - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url2 = links[ln].url;
          const fullUrl = state.md.normalizeLink(url2);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state.Token("text", "", 0);
            token.content = text2.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text2.length) {
          const token = new state.Token("text", "", 0);
          token.content = text2.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, nodes);
      }
    }
  }
}

// node_modules/markdown-it/lib/rules_core/replacements.mjs
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  tm: "\u2122"
};
function replaceFn(match3, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
    const token = inlineTokens[i2];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
    const token = inlineTokens[i2];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state) {
  let blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/smartquotes.mjs
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index, ch) {
  return str.slice(0, index) + ch + str.slice(index + 1);
}
function process_inlines(tokens, state) {
  let j;
  const stack = [];
  for (let i2 = 0; i2 < tokens.length; i2++) {
    const token = tokens[i2];
    const thisLevel = tokens[i2].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text2 = token.content;
    let pos = 0;
    let max = text2.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text2);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text2.charCodeAt(t.index - 1);
        } else {
          for (j = i2 - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text2.charCodeAt(pos);
        } else {
          for (j = i2 + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace2(lastChar);
        const isNextWhiteSpace = isWhiteSpace2(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i2) {
                pos += openQuote.length - 1;
              }
              text2 = token.content;
              max = text2.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i2,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state) {
  if (!state.md.options.typographer) {
    return;
  }
  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
}

// node_modules/markdown-it/lib/rules_core/text_join.mjs
function text_join(state) {
  let curr, last;
  const blockTokens = state.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline") continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
}

// node_modules/markdown-it/lib/parser_core.mjs
var _rules = [
  ["normalize", normalize2],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new ruler_default();
  for (let i2 = 0; i2 < _rules.length; i2++) {
    this.ruler.push(_rules[i2][0], _rules[i2][1]);
  }
}
Core.prototype.process = function(state) {
  const rules = this.ruler.getRules("");
  for (let i2 = 0, l = rules.length; i2 < l; i2++) {
    rules[i2](state);
  }
};
Core.prototype.State = state_core_default;
var parser_core_default = Core;

// node_modules/markdown-it/lib/rules_block/state_block.mjs
function StateBlock(src, md, env2, tokens) {
  this.src = src;
  this.md = md;
  this.env = env2;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type, tag, nesting) {
  const token = new token_default(type, tag, nesting);
  token.block = true;
  if (nesting < 0) this.level--;
  token.level = this.level;
  if (nesting > 0) this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return "";
  }
  const queue = new Array(end - begin);
  for (let i2 = 0, line = begin; line < end; line++, i2++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first = lineStart;
    let last;
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i2] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i2] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = token_default;
var state_block_default = StateBlock;

// node_modules/markdown-it/lib/rules_block/table.mjs
var MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state, line) {
  const pos = state.bMarks[line] + state.tShift[line];
  const max = state.eMarks[line];
  return state.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    const ch = state.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i2 = 0; i2 < columns.length; i2++) {
    const t = columns[i2].trim();
    if (!t) {
      if (i2 === 0 || i2 === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "") columns.shift();
  if (columns.length && columns[columns.length - 1] === "") columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state.parentType;
  state.parentType = "table";
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const token_to = state.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i2 = 0; i2 < columns.length; i2++) {
    const token_ho = state.push("th_open", "th", 1);
    if (aligns[i2]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i2]]];
    }
    const token_il = state.push("inline", "", 0);
    token_il.content = columns[i2].trim();
    token_il.children = [];
    state.push("th_close", "th", -1);
  }
  state.push("tr_close", "tr", -1);
  state.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i2 = 0; i2 < columnCount; i2++) {
      const token_tdo = state.push("td_open", "td", 1);
      if (aligns[i2]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i2]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i2] ? columns[i2].trim() : "";
      token_il.children = [];
      state.push("td_close", "td", -1);
    }
    state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/rules_block/code.mjs
function code(state, startLine, endLine) {
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last = nextLine;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  const token = state.push("code_block", "code", 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token.map = [startLine, state.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/fence.mjs
function fence(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state.src.slice(mem, pos);
  const params = state.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state.push("fence", "code", 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/blockquote.mjs
function blockquote(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  const oldLineMax = state.lineMax;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state.md.block.ruler.getRules("blockquote");
  const oldParentType = state.parentType;
  state.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  const oldIndent = state.blkIndent;
  state.blkIndent = 0;
  const token_o = state.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state.md.block.tokenize(state, startLine, nextLine);
  const token_c = state.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (let i2 = 0; i2 < oldTShift.length; i2++) {
    state.bMarks[i2 + startLine] = oldBMarks[i2];
    state.tShift[i2 + startLine] = oldTShift[i2];
    state.sCount[i2 + startLine] = oldSCount[i2];
    state.bsCount[i2 + startLine] = oldBSCount[i2];
  }
  state.blkIndent = oldIndent;
  return true;
}

// node_modules/markdown-it/lib/rules_block/hr.mjs
function hr(state, startLine, endLine, silent) {
  const max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  const token = state.push("hr", "hr", 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}

// node_modules/markdown-it/lib/rules_block/list.mjs
function skipBulletListMarker(state, startLine) {
  const max = state.eMarks[startLine];
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  const marker = state.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  const start = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  const level = state.level + 2;
  for (let i2 = idx + 2, l = state.tokens.length - 2; i2 < l; i2++) {
    if (state.tokens[i2].level === level && state.tokens[i2].type === "paragraph_open") {
      state.tokens[i2 + 2].hidden = true;
      state.tokens[i2].hidden = true;
      i2 += 2;
    }
  }
}
function list(state, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[nextLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[nextLine] + state.tShift[nextLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state.tokens.length;
  if (isOrdered) {
    token = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state.md.block.ruler.getRules("list");
  const oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state.tight;
    const oldTShift = state.tShift[nextLine];
    const oldSCount = state.sCount[nextLine];
    const oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
    state.sCount[nextLine] = offset;
    if (contentStart >= max && state.isEmpty(nextLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, nextLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[nextLine] = oldTShift;
    state.sCount[nextLine] = oldSCount;
    state.tight = oldTight;
    token = state.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state.push("ordered_list_close", "ol", -1);
  } else {
    token = state.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
}

// node_modules/markdown-it/lib/rules_block/reference.mjs
function reference(state, startLine, _endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state.lineMax;
    if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state.sCount[nextLine2] - state.blkIndent > 3) {
      isContinuation = true;
    }
    if (state.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state.md.block.ruler.getRules("reference");
      const oldParentType = state.parentType;
      state.parentType = "reference";
      let terminate = false;
      for (let i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
        if (terminatorRules[i2](state, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
    const max2 = state.eMarks[nextLine2];
    return state.src.slice(pos2, max2 + 1);
  }
  let str = state.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state.md.normalizeLink(destRes.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null) break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/common/html_blocks.mjs
var html_blocks_default = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];

// node_modules/markdown-it/lib/common/html_re.mjs
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Za-z][^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

// node_modules/markdown-it/lib/rules_block/html_block.mjs
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state.src.slice(pos, max);
  let i2 = 0;
  for (; i2 < HTML_SEQUENCES.length; i2++) {
    if (HTML_SEQUENCES[i2][0].test(lineText)) {
      break;
    }
  }
  if (i2 === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i2][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i2][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i2][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  const token = state.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
}

// node_modules/markdown-it/lib/rules_block/heading.mjs
function heading(state, startLine, endLine, silent) {
  let pos = state.bMarks[startLine] + state.tShift[startLine];
  let max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  let ch = state.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  const tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = state.src.slice(pos, max).trim();
  token_i.map = [startLine, state.line];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}

// node_modules/markdown-it/lib/rules_block/lheading.mjs
function lheading(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state.parentType;
  state.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      let pos = state.bMarks[nextLine] + state.tShift[nextLine];
      const max = state.eMarks[nextLine];
      if (pos < max) {
        marker = state.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  const token_o = state.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line - 1];
  token_i.children = [];
  const token_c = state.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/rules_block/paragraph.mjs
function paragraph(state, startLine, endLine) {
  const terminatorRules = state.md.block.ruler.getRules("paragraph");
  const oldParentType = state.parentType;
  let nextLine = startLine + 1;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
      if (terminatorRules[i2](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  const token_o = state.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state.line];
  const token_i = state.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state.line];
  token_i.children = [];
  state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/parser_block.mjs
var _rules2 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new ruler_default();
  for (let i2 = 0; i2 < _rules2.length; i2++) {
    this.ruler.push(_rules2[i2][0], _rules2[i2][1], { alt: (_rules2[i2][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    const prevLine = state.line;
    let ok = false;
    for (let i2 = 0; i2 < len; i2++) {
      ok = rules[i2](state, line, endLine, false);
      if (ok) {
        if (prevLine >= state.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok) throw new Error("none of the block rules matched");
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env2, outTokens) {
  if (!src) {
    return;
  }
  const state = new this.State(src, md, env2, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock.prototype.State = state_block_default;
var parser_block_default = ParserBlock;

// node_modules/markdown-it/lib/rules_inline/state_inline.mjs
function StateInline(src, md, env2, outTokens) {
  this.src = src;
  this.env = env2;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new token_default("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new token_default(type, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count2 = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace2(lastChar);
  const isNextWhiteSpace = isWhiteSpace2(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count2 };
};
StateInline.prototype.Token = token_default;
var state_inline_default = StateInline;

// node_modules/markdown-it/lib/rules_inline/text.mjs
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text(state, silent) {
  let pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/linkify.mjs
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify2(state, silent) {
  if (!state.md.options.linkify) return false;
  if (state.linkLevel > 0) return false;
  const pos = state.pos;
  const max = state.posMax;
  if (pos + 3 > max) return false;
  if (state.src.charCodeAt(pos) !== 58) return false;
  if (state.src.charCodeAt(pos + 1) !== 47) return false;
  if (state.src.charCodeAt(pos + 2) !== 47) return false;
  const match3 = state.pending.match(SCHEME_RE);
  if (!match3) return false;
  const proto = match3[1];
  const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
  if (!link2) return false;
  let url2 = link2.url;
  if (url2.length <= proto.length) return false;
  url2 = url2.replace(/\*+$/, "");
  const fullUrl = state.md.normalizeLink(url2);
  if (!state.md.validateLink(fullUrl)) return false;
  if (!silent) {
    state.pending = state.pending.slice(0, -proto.length);
    const token_o = state.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state.push("text", "", 0);
    token_t.content = state.md.normalizeLinkText(url2);
    const token_c = state.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state.pos += url2.length - proto.length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/newline.mjs
function newline(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/escape.mjs
var ESCAPED = [];
for (let i2 = 0; i2 < 256; i2++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape3(state, silent) {
  let pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92) return false;
  pos++;
  if (pos >= max) return false;
  let ch1 = state.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state.src.charCodeAt(pos);
      if (!isSpace(ch1)) break;
      pos++;
    }
    state.pos = pos;
    return true;
  }
  let escapedStr = state.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state.pos = pos + 1;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/backticks.mjs
function backtick(state, silent) {
  let pos = state.pos;
  const ch = state.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state.src.slice(start, pos);
  const openerLength = marker.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
function strikethrough_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i2 = 0; i2 < len; i2 += 2) {
    token = state.push("text", "", 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess(state, delimiters) {
  let token;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i2 = 0; i2 < max; i2++) {
    const startDelim = delimiters[i2];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i2 = loneMarkers.pop();
    let j = i2 + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i2 !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i2];
      state.tokens[i2] = token;
    }
  }
}
function strikethrough_postProcess(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
}
var strikethrough_default = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};

// node_modules/markdown-it/lib/rules_inline/emphasis.mjs
function emphasis_tokenize(state, silent) {
  const start = state.pos;
  const marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, marker === 42);
  for (let i2 = 0; i2 < scanned.length; i2++) {
    const token = state.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
}
function postProcess2(state, delimiters) {
  const max = delimiters.length;
  for (let i2 = max - 1; i2 >= 0; i2--) {
    const startDelim = delimiters[i2];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state.tokens[delimiters[i2 - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i2--;
    }
  }
}
function emphasis_post_process(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  postProcess2(state, state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess2(state, tokens_meta[curr].delimiters);
    }
  }
}
var emphasis_default = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};

// node_modules/markdown-it/lib/rules_inline/link.mjs
function link(state, silent) {
  let code2, label, res, ref;
  let href = "";
  let title = "";
  let start = state.pos;
  let parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  const oldPos = state.pos;
  const max = state.posMax;
  const labelStart = state.pos + 1;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    const token_o = state.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state.linkLevel++;
    state.md.inline.tokenize(state);
    state.linkLevel--;
    state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/image.mjs
function image(state, silent) {
  let code2, content, label, pos, ref, res, title, start;
  let href = "";
  const oldPos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state.pos + 2;
  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    const tokens = [];
    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens
    );
    const token = state.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token.attrs = attrs;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/autolink.mjs
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state, silent) {
  let pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max) return false;
    const ch = state.src.charCodeAt(pos);
    if (ch === 60) return false;
    if (ch === 62) break;
  }
  const url2 = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url2)) {
    const fullUrl = state.md.normalizeLink(url2);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url2);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url2.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url2)) {
    const fullUrl = state.md.normalizeLink("mailto:" + url2);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url2);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state.pos += url2.length + 2;
    return true;
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/html_inline.mjs
function isLinkOpen2(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose2(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state, silent) {
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  const pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match3 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match3) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = match3[0];
    if (isLinkOpen2(token.content)) state.linkLevel++;
    if (isLinkClose2(token.content)) state.linkLevel--;
  }
  state.pos += match3[0].length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/entity.mjs
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state, silent) {
  const pos = state.pos;
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38) return false;
  if (pos + 1 >= max) return false;
  const ch = state.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match3 = state.src.slice(pos).match(DIGITAL_RE);
    if (match3) {
      if (!silent) {
        const code2 = match3[1][0].toLowerCase() === "x" ? parseInt(match3[1].slice(1), 16) : parseInt(match3[1], 10);
        const token = state.push("text_special", "", 0);
        token.content = isValidEntityCode(code2) ? fromCodePoint2(code2) : fromCodePoint2(65533);
        token.markup = match3[0];
        token.info = "entity";
      }
      state.pos += match3[0].length;
      return true;
    }
  } else {
    const match3 = state.src.slice(pos).match(NAMED_RE);
    if (match3) {
      const decoded = decodeHTML(match3[0]);
      if (decoded !== match3[0]) {
        if (!silent) {
          const token = state.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match3[0];
          token.info = "entity";
        }
        state.pos += match3[0].length;
        return true;
      }
    }
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max) return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close) continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker) continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state) {
  const tokens_meta = state.tokens_meta;
  const max = state.tokens_meta.length;
  processDelimiters(state.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}

// node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
function fragments_join(state) {
  let curr, last;
  let level = 0;
  const tokens = state.tokens;
  const max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0) level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}

// node_modules/markdown-it/lib/parser_inline.mjs
var _rules3 = [
  ["text", text],
  ["linkify", linkify2],
  ["newline", newline],
  ["escape", escape3],
  ["backticks", backtick],
  ["strikethrough", strikethrough_default.tokenize],
  ["emphasis", emphasis_default.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules22 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", strikethrough_default.postProcess],
  ["emphasis", emphasis_default.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new ruler_default();
  for (let i2 = 0; i2 < _rules3.length; i2++) {
    this.ruler.push(_rules3[i2][0], _rules3[i2][1]);
  }
  this.ruler2 = new ruler_default();
  for (let i2 = 0; i2 < _rules22.length; i2++) {
    this.ruler2.push(_rules22[i2][0], _rules22[i2][1]);
  }
}
ParserInline.prototype.skipToken = function(state) {
  const pos = state.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state.md.options.maxNesting;
  const cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state.level < maxNesting) {
    for (let i2 = 0; i2 < len; i2++) {
      state.level++;
      ok = rules[i2](state, true);
      state.level--;
      if (ok) {
        if (pos >= state.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline.prototype.tokenize = function(state) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end = state.posMax;
  const maxNesting = state.md.options.maxNesting;
  while (state.pos < end) {
    const prevPos = state.pos;
    let ok = false;
    if (state.level < maxNesting) {
      for (let i2 = 0; i2 < len; i2++) {
        ok = rules[i2](state, false);
        if (ok) {
          if (prevPos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state.pos >= end) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md, env2, outTokens) {
  const state = new this.State(str, md, env2, outTokens);
  this.tokenize(state);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i2 = 0; i2 < len; i2++) {
    rules[i2](state);
  }
};
ParserInline.prototype.State = state_inline_default;
var parser_inline_default = ParserInline;

// node_modules/linkify-it/lib/re.mjs
function re_default(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = regex_default.source;
  re.src_Cc = regex_default2.source;
  re.src_Z = regex_default6.source;
  re.src_P = regex_default4.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><\uFF5C]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}

// node_modules/linkify-it/index.mjs
function assign2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString3(obj) {
  return _class2(obj) === "[object String]";
}
function isObject3(obj) {
  return _class2(obj) === "[object Object]";
}
function isRegExp2(obj) {
  return _class2(obj) === "[object RegExp]";
}
function isFunction3(obj) {
  return _class2(obj) === "[object Function]";
}
function escapeRE2(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions3 = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions3.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp(
          "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp(
          "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
          "i"
        );
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text2[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text2, pos, self2) {
      const tail = text2.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp(
          "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
          "i"
        );
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re) {
  return function(text2, pos) {
    const tail = text2.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match3, self2) {
    self2.normalize(match3);
  };
}
function compile(self2) {
  const re = self2.re = re_default(self2.__opts__);
  const tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re.src_xn);
  re.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases = [];
  self2.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name) {
    const val = self2.__schemas__[name];
    if (val === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self2.__compiled__[name] = compiled;
    if (isObject3(val)) {
      if (isRegExp2(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction3(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction3(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString3(val)) {
      aliases.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self2.__compiled__).filter(function(name) {
    return name.length > 0 && self2.__compiled__[name];
  }).map(escapeRE2).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
  self2.re.pretest = RegExp(
    "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self2);
}
function Match(self2, shift) {
  const start = self2.__index__;
  const end = self2.__last_index__;
  const text2 = self2.__text_cache__.slice(start, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text2;
  this.text = text2;
  this.url = text2;
}
function createMatch(self2, shift) {
  const match3 = new Match(self2, shift);
  self2.__compiled__[match3.schema].normalize(match3, self2);
  return match3;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign2({}, defaultOptions3, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign2({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign2(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test2(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) {
    return false;
  }
  let m, ml, me, len, shift, next, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text2)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text2.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text2.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
};
LinkifyIt.prototype.match = function match2(text2) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text2.slice(shift) : text2;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) return null;
  const m = this.re.schema_at_start.exec(text2);
  if (!m) return null;
  const len = this.testSchemaAt(text2, m[2], m[0].length);
  if (!len) return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize3(match3) {
  if (!match3.schema) {
    match3.url = "http://" + match3.url;
  }
  if (match3.schema === "mailto:" && !/^mailto:/i.test(match3.url)) {
    match3.url = "mailto:" + match3.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
var linkify_it_default = LinkifyIt;

// node_modules/markdown-it/lib/index.mjs
var import_punycode = __toESM(require_punycode(), 1);

// node_modules/markdown-it/lib/presets/default.mjs
var default_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

// node_modules/markdown-it/lib/presets/zero.mjs
var zero_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/presets/commonmark.mjs
var commonmark_default = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "\u201C\u201D\u2018\u2019",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/index.mjs
var config = {
  default: default_default,
  zero: zero_default,
  commonmark: commonmark_default
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url2) {
  const str = url2.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url2) {
  const parsed = parse_default(url2, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = import_punycode.default.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode_default(format2(parsed));
}
function normalizeLinkText(url2) {
  const parsed = parse_default(url2, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = import_punycode.default.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode_default(format2(parsed), decode_default.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString2(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new parser_inline_default();
  this.block = new parser_block_default();
  this.core = new parser_core_default();
  this.renderer = new renderer_default();
  this.linkify = new linkify_it_default();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils_exports2;
  this.helpers = assign({}, helpers_exports);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self2 = this;
  if (isString2(presets)) {
    const presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name) {
      if (presets.components[name].rules) {
        self2[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self2[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env2) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state = new this.core.State(src, this, env2);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env2) {
  env2 = env2 || {};
  return this.renderer.render(this.parse(src, env2), this.options, env2);
};
MarkdownIt.prototype.parseInline = function(src, env2) {
  const state = new this.core.State(src, this, env2);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env2) {
  env2 = env2 || {};
  return this.renderer.render(this.parseInline(src, env2), this.options, env2);
};
var lib_default = MarkdownIt;

// src/core/validator.ts
var vscode4 = __toESM(require("vscode"));
var fs2 = __toESM(require_lib());
var path8 = __toESM(require("path"));
var logger;
async function runValidator(uri, progress, repoDir) {
  console.log("[UAV][Validator] runValidator() inicializado");
  logger = new Logger("Validator", true);
  try {
    const workspaceFolder = vscode4.workspace.getWorkspaceFolder(uri) || vscode4.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) throw new Error("No se detect\xF3 carpeta de proyecto");
    const pkgPath = uri.fsPath;
    progress.report({ message: "Leyendo package.xml..." });
    const { testClasses, nonTestClasses } = await parseApexClassesFromPackage(pkgPath, repoDir);
    logger.info(`\u{1F9E9} Clases detectadas: tests=${testClasses.length}, normales=${nonTestClasses.length}`);
    if (!nonTestClasses.length) {
      logger.warn("\u26A0\uFE0F No se detectaron clases Apex no-test, omitiendo Code Analyzer.");
      return { testClasses, nonTestClasses, codeAnalyzerResults: [], pmdResults: [] };
    }
    const { codeAnalyzerResults, pmdResults } = await runCodeAnalyzer(nonTestClasses, repoDir);
    logger.info(`\u2705 Code Analyzer completado: ${codeAnalyzerResults.length} violaciones, ${pmdResults.length} duplicaciones.`);
    return {
      testClasses,
      nonTestClasses,
      codeAnalyzerResults,
      pmdResults
    };
  } catch (err) {
    logger.error(`\u274C Error en runValidator: ${err.message}`);
    return { testClasses: [], nonTestClasses: [], codeAnalyzerResults: [], pmdResults: [] };
  }
}
async function runCodeAnalyzer(classes, repoDir) {
  logger.info(`\u{1F9E0} Analizando ${classes.length} clases con Code Analyzer (PMD + CPD)...`);
  const storageRoot = getStorageRoot();
  const tempDir = path8.join(storageRoot, "temp");
  await fs2.ensureDir(tempDir);
  const workspaceRoot = vscode4.workspace.workspaceFolders?.[0]?.uri.fsPath || path8.resolve(repoDir, "../../../..");
  const embeddedConfig = path8.resolve(__dirname, "resources", "templates", "code-analyzer.yml");
  const outputFile = path8.join(tempDir, "code_analyzer_output.json");
  const execLog = path8.join(tempDir, "code_analyzer_exec.log");
  const targetGlob = path8.join(workspaceRoot, "force-app", "main", "default", "classes", "**", "*.cls");
  const cmd = ["sf", "code-analyzer", "run", "--workspace", workspaceRoot, "--rule-selector", "pmd:apex", "--rule-selector", "cpd", "--config-file", embeddedConfig, "--target", targetGlob, "--output-file", outputFile];
  try {
    const subprocess = execa(cmd[0], cmd.slice(1), {
      cwd: workspaceRoot,
      env: { FORCE_COLOR: "0" },
      reject: false,
      all: true,
      shell: false
    });
    const { all: all3, exitCode } = await subprocess;
    await fs2.writeFile(execLog, all3 || "(sin salida)", "utf8");
    if (exitCode !== 0 && exitCode !== void 0) {
      logger.error(`\u274C Code Analyzer termin\xF3 con c\xF3digo ${exitCode}`);
    }
    if (!await fs2.pathExists(outputFile)) {
      logger.warn("\u26A0\uFE0F El Code Analyzer no gener\xF3 el archivo de salida");
      return { codeAnalyzerResults: [], pmdResults: [] };
    }
    const json = JSON.parse(await fs2.readFile(outputFile, "utf8"));
    const violations = json.violations || json.results || json.runs?.[0]?.results || json.runs?.flatMap((r) => r.results) || [];
    const filtered = await filterAnalyzerFindings(violations, classes);
    const codeAnalyzerResults = filtered.filter((f) => f.tipo === "PMD");
    const pmdResults = filtered.filter((f) => f.tipo === "CPD").map((f) => ({
      tokens: parseInt((f.descripcion.match(/(\d+)\s+tokens/) || [])[1] || "0", 10),
      lines: parseInt((f.descripcion.match(/(\d+)\s+lines/) || [])[1] || "0", 10),
      clases: f.archivos,
      codeSnippet: f.codeSnippet
    }));
    logger.info(`\u{1F3C1} Code Analyzer finalizado: ${filtered.length} hallazgos relevantes.`);
    return { codeAnalyzerResults, pmdResults };
  } catch (err) {
    logger.error(`\u274C Error ejecutando Code Analyzer: ${err.message}`);
    await fs2.appendFile(execLog, `
[ERROR] ${err.stack || err.message}`);
    return { codeAnalyzerResults: [], pmdResults: [] };
  }
}
async function filterAnalyzerFindings(findings, apexClasses) {
  const results = [];
  for (const f of findings) {
    const engine = (f.engine || "").toLowerCase();
    const locs = f.locations || [];
    if (!Array.isArray(locs) || locs.length === 0) continue;
    const involvedClasses = locs.map(
      (l) => path8.basename(l.file || "").replace(/\.cls$/, "")
    );
    const hasRelevantClass = involvedClasses.some((cls) => apexClasses.includes(cls));
    if (!hasRelevantClass) continue;
    const primary = locs[f.primaryLocationIndex || 0] || locs[0];
    const normalizedPath = (primary.file || "").replace(/\\/g, "/");
    const baseName = path8.basename(normalizedPath).replace(/(-meta)?\.cls$/, "");
    if (engine === "pmd") {
      results.push({
        tipo: "PMD",
        clase: baseName,
        linea: primary.startLine || 0,
        regla: f.rule || "Desconocido",
        severidad: f.severity || "N/A",
        descripcion: f.message || "Sin descripci\xF3n",
        recurso: Array.isArray(f.resources) && f.resources.length > 0 ? f.resources[0] : null
      });
    } else if (engine === "cpd") {
      const codeSnippet = await extractCpdSnippet(locs);
      results.push({
        tipo: "CPD",
        clase: baseName,
        regla: f.rule || "DetectCopyPasteForApex",
        descripcion: f.message || "Duplicaci\xF3n detectada",
        severidad: f.severity || "N/A",
        lineas: `${primary.startLine}-${primary.endLine}`,
        archivos: locs.map((l) => {
          const base = path8.basename(l.file);
          const range2 = l.startLine && l.endLine ? ` (${l.startLine}-${l.endLine})` : "";
          return `${base}${range2}`;
        }).join(",\n "),
        recurso: Array.isArray(f.resources) && f.resources.length > 0 ? f.resources[0] : null,
        codeSnippet
      });
    }
  }
  return results;
}
async function extractCpdSnippet(locations) {
  if (!locations || locations.length === 0) return "";
  const firstLoc = locations[0];
  const filePath = path8.isAbsolute(firstLoc.file) ? firstLoc.file : path8.join(vscode4.workspace.workspaceFolders?.[0]?.uri.fsPath || "", firstLoc.file);
  try {
    const exists = await fs2.pathExists(filePath);
    if (!exists) {
      logger.warn(`\u26A0\uFE0F Archivo no encontrado para snippet CPD: ${filePath}`);
      return "";
    }
    const content = await fs2.readFile(filePath, "utf8");
    const lines = content.split(/\r?\n/);
    const start = Math.max(0, firstLoc.startLine - 1);
    const end = Math.min(lines.length, firstLoc.endLine || lines.length);
    const snippet = lines.slice(start, end).join("\n");
    return snippet.trim();
  } catch (err) {
    logger.warn(`\u26A0\uFE0F Error al leer fragmento CPD: ${err.message}`);
    return "";
  }
}

// src/core/testSuite.ts
var vscode5 = __toESM(require("vscode"));
var path9 = __toESM(require("path"));
var fs3 = __toESM(require_lib());
var TestSuite = class {
  logger;
  sfPath;
  orgAlias;
  tempDir;
  constructor(workspaceRoot) {
    const config2 = vscode5.workspace.getConfiguration("UnifiedApexValidator");
    this.orgAlias = config2.get("sfOrgAlias") || "DEVSEGC";
    this.tempDir = path9.join(workspaceRoot, ".uav", "temp");
    this.logger = new Logger("TestSuite", false);
    this.tempDir = path9.join(getStorageRoot(), "temp");
    fs3.ensureDirSync(this.tempDir);
    this.sfPath = resolveSfCliPath();
  }
  /**
   * Ejecuta un comando Salesforce y devuelve JSON limpio
   */
  async runSfCommand(command, description) {
    const env2 = { ...process.env, FORCE_COLOR: "0" };
    try {
      const child = execa(command[0], command.slice(1), {
        encoding: "utf8",
        env: env2,
        stdout: "pipe",
        stderr: "pipe"
      });
      child.stdout?.on("data", (data) => {
        const text2 = data.toString().trim();
        if (/TestRunId|outcome|status|passed|failing|error/i.test(text2)) {
        }
      });
      child.stderr?.on("data", (data) => {
        const text2 = data.toString().trim();
      });
      const { stdout, stderr } = await child;
      const raw = (stdout || stderr || "").trim();
      try {
        return JSON.parse(raw);
      } catch {
        const cleaned = raw.replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, "");
        return JSON.parse(cleaned);
      }
    } catch (err) {
      this.logger.error(`\u274C Error en ${description}: ${err.shortMessage || err.message}`);
      return {};
    }
  }
  /**
   * Lanza las clases de prueba y obtiene el testRunId
   */
  async executeTests(testClasses) {
    const command = [this.sfPath, "apex", "run", "test", "--json", "--target-org", this.orgAlias, "--test-level", "RunSpecifiedTests", "--code-coverage", "--class-names", ...testClasses];
    const result = await this.runSfCommand(command, "ejecucion de pruebas");
    const testRunId = result?.result?.testRunId || result?.result?.summary?.testRunId || null;
    if (!testRunId) {
      this.logger.error("\u274C No se obtuvo testRunId del resultado.");
    } else {
      this.logger.info(`\u{1F680} TestRun iniciado correctamente (ID: ${testRunId}).`);
    }
    return testRunId;
  }
  /**
   * Espera a que el test run finalice
   */
  async waitForTestCompletion(testRunId) {
    this.logger.info(`\u23F3 Esperando finalizacion del testRunId ${testRunId}...`);
    for (let i2 = 0; i2 < 60; i2++) {
      const command = [this.sfPath, "apex", "get", "test", "--json", "--target-org", this.orgAlias, "--test-run-id", testRunId];
      const result = await this.runSfCommand(command, `verificando estado (${i2 + 1}/60)`);
      const summary = result?.result?.summary || {};
      const outcome = summary.outcome || "Pendiente";
      const ran = Number(summary.testsRan || 0);
      const passing = Number(summary.passing || 0);
      const failing = Number(summary.failing || 0);
      if (ran === passing + failing && ran > 0) {
        this.logger.info(`\u2705 Ejecucion completada para TestRun ${testRunId}.`);
        return result;
      }
      await new Promise((r) => setTimeout(r, 1e4));
    }
    this.logger.warn("\u26A0\uFE0F Tiempo de espera agotado. Devolviendo resultado parcial.");
    return {};
  }
  /**
   * Obtiene resultados y cobertura
   */
  async fetchTestResults(testRunId) {
    const baseFile = path9.join(this.tempDir, `test-result-${testRunId}.json`);
    const coverageFile = path9.join(this.tempDir, `test-result-${testRunId}-codecoverage.json`);
    fs3.ensureDirSync(this.tempDir);
    this.logger.info(`\u{1F4E6} Recuperando resultados del test run ${testRunId}...`);
    for (let i2 = 0; i2 < 3; i2++) {
      const command = [this.sfPath, "apex", "get", "test", "--json", "--target-org", this.orgAlias, "--test-run-id", testRunId, "--code-coverage", "--output-dir", this.tempDir];
      await this.runSfCommand(command, `obtencion cobertura (intento ${i2 + 1})`);
      if (fs3.existsSync(baseFile)) {
        const testResult = fs3.readJsonSync(baseFile, { throws: false }) || {};
        const coverageSummary = testResult?.coverage?.coverage || [];
        let coverageDetail = {};
        if (fs3.existsSync(coverageFile)) {
          coverageDetail = fs3.readJsonSync(coverageFile, { throws: false }) || {};
        }
        return { testResult, coverageSummary, coverageDetail };
      }
      await new Promise((r) => setTimeout(r, 1e4));
    }
    this.logger.error("\u274C No se pudieron obtener resultados tras varios intentos.");
    return {};
  }
  /**
   * Procesa la cobertura
   */
  extractCoverageData(coverageSummary, coverageDetail, apexClasses) {
    const filtered = [];
    const processed = /* @__PURE__ */ new Set();
    if (Array.isArray(coverageSummary)) {
      for (const entry of coverageSummary) {
        const name = entry.name;
        if (apexClasses.includes(name)) {
          filtered.push({
            ClassName: name,
            TotalLines: entry.totalLines || 0,
            CoveredLines: entry.totalCovered || 0,
            CoveragePercentage: `${entry.coveredPercent || 0}%`,
            CoveragePercentageInt: entry.coveredPercent || 0
          });
          processed.add(name);
        }
      }
    }
    const missing = apexClasses.filter((cls) => !processed.has(cls));
    const detailList = coverageDetail?.result?.coverage?.coverage || [];
    for (const entry of detailList) {
      const name = entry.name;
      if (missing.includes(name)) {
        filtered.push({
          ClassName: name,
          TotalLines: entry.totalLines || 0,
          CoveredLines: entry.lines?.totalCovered || 0,
          CoveragePercentage: `${entry.lines?.coveredPercent || 0}%`,
          CoveragePercentageInt: entry.lines?.coveredPercent || 0
        });
        processed.add(name);
      }
    }
    const stillMissing = apexClasses.filter((cls) => !processed.has(cls));
    for (const cls of stillMissing) {
      filtered.push({
        ClassName: cls,
        TotalLines: 0,
        CoveredLines: 0,
        CoveragePercentage: "0%",
        CoveragePercentageInt: 0
      });
    }
    return filtered;
  }
  /**
   * Procesa resultados de test
   */
  extractTestResults(testsList) {
    return testsList.map((t) => ({
      class_name: t.ApexClass?.Name || "",
      method_name: t.MethodName || "",
      outcome: t.Outcome || "",
      message: t.Message || "",
      stack_trace: t.StackTrace || ""
    }));
  }
  /**
   * Orquestador principal
   */
  async runTestSuite(testClasses, apexClasses) {
    if (!testClasses?.length) {
      this.logger.warn("\u26A0\uFE0F No se detectaron clases de prueba en el package.xml.");
      return { error: "No hay clases test para ejecutar.", coverage_data: [], test_results: [] };
    }
    this.logger.info(`\u{1F9EA} Ejecutando clases de prueba: ${testClasses.join(", ")}`);
    const testRunId = await this.executeTests(testClasses);
    if (!testRunId) return { error: "No se pudo iniciar pruebas.", coverage_data: [], test_results: [] };
    this.logger.info(`\u{1F50D} Monitoreando progreso del testRunId ${testRunId}...`);
    await this.waitForTestCompletion(testRunId);
    this.logger.info("\u{1F4C8} Ejecucion de pruebas finalizada. Obteniendo resultados y cobertura...");
    const results = await this.fetchTestResults(testRunId);
    if (!results || Object.keys(results).length === 0) {
      this.logger.error("\u274C No se pudieron obtener resultados del test run.");
      return { error: "No se pudo obtener resultados.", coverage_data: [], test_results: [] };
    }
    this.logger.info("\u{1F4DD} Procesando datos de cobertura y resultados individuales...");
    const testResult = results.testResult || {};
    const coverageSummary = results.coverageSummary || [];
    const coverageDetail = results.coverageDetail || {};
    const testsRaw = Array.isArray(testResult.tests) ? testResult.tests : typeof testResult === "object" && "tests" in testResult ? testResult.tests : [];
    const coverage = this.extractCoverageData(coverageSummary, coverageDetail, apexClasses);
    const tests = this.extractTestResults(testsRaw);
    const total = tests.length;
    const passed = tests.filter((t) => t.outcome === "Pass").length;
    const failed = tests.filter((t) => t.outcome === "Fail").length;
    const skipped = tests.filter((t) => t.outcome === "Skip").length;
    this.logger.info(`\u{1F4CB} Resumen: ${passed} pasados, ${failed} fallidos, ${skipped} omitidos, total ${total}.`);
    for (const test3 of tests) {
      const statusIcon = test3.outcome === "Pass" ? "\u2705" : test3.outcome === "Fail" ? "\u274C" : "\u26A0\uFE0F";
      this.logger.info(`${statusIcon} ${test3.class_name}.${test3.method_name} \u2192 ${test3.outcome}`);
      if (test3.outcome === "Fail" && test3.message) {
        this.logger.warn(`   \u{1F4AC} Motivo: ${test3.message}`);
      }
    }
    this.logger.info("\u{1F389} Fin de la ejecucion de pruebas Apex.");
    return { coverage_data: coverage, test_results: tests };
  }
};

// src/core/reportGenerator.ts
var fs4 = __toESM(require_lib());
var path10 = __toESM(require("path"));
var vscode6 = __toESM(require("vscode"));
var nunjucks = __toESM(require_nunjucks());
var child_process = __toESM(require("child_process"));
var logger2 = new Logger("ReportGenerator", false);
async function generateReport(outputDir, data) {
  try {
    const config2 = vscode6.workspace.getConfiguration("UnifiedApexValidator");
    const workspaceRoot = vscode6.workspace.workspaceFolders?.[0]?.uri.fsPath || "";
    const outputSetting = config2.get("outputDir")?.trim();
    if (!outputSetting) {
      const msg = '\u274C No se ha configurado el par\xE1metro "UnifiedApexValidator.outputDir" en Settings.';
      logger2.error(msg);
      vscode6.window.showErrorMessage(msg);
      throw new Error(msg);
    }
    const finalOutputDir = path10.resolve(outputSetting);
    await fs4.ensureDir(finalOutputDir);
    const currentExt = vscode6.extensions.getExtension("ozkrgonzalez.unifiedapexvalidator");
    const extensionPath = currentExt?.extensionPath || __dirname;
    if (!extensionPath) {
      throw new Error("No se pudo determinar la ruta de la extensi\xF3n.");
    }
    let templatePath = path10.join(extensionPath, "dist", "resources", "templates", "reportTemplate.html");
    if (!fs4.existsSync(templatePath)) {
      templatePath = path10.join(extensionPath, "src", "resources", "templates", "reportTemplate.html");
    }
    if (!fs4.existsSync(templatePath)) {
      throw new Error(`No se encontr\xF3 el template empaquetado ni en dist ni en src (${templatePath})`);
    }
    const coverageData = (data.testResults?.coverage_data || []).map((c3) => ({
      ...c3,
      isLowCoverage: (c3.CoveragePercentageInt ?? 0) < 75
    }));
    const lowCoverageCount = coverageData.filter((c3) => c3.isLowCoverage).length;
    const iaFormatted = formatIAResults(data.iaResults || []);
    const duplicatedClasses = /* @__PURE__ */ new Set();
    for (const dup of data.pmdResults || []) {
      const classes = (dup.clases || "").split(",").map((c3) => c3.trim()).filter((c3) => c3.length > 0);
      classes.forEach((c3) => duplicatedClasses.add(c3));
    }
    const duplicate_class_count = duplicatedClasses.size;
    const context = {
      apex_results: data.codeAnalyzerResults || [],
      pmd_results: data.pmdResults || [],
      test_results: data.testResults?.test_results || [],
      test_coverage: coverageData,
      low_coverage_count: lowCoverageCount,
      einsteinAnalysis: iaFormatted,
      duplicate_class_count
    };
    const env2 = nunjucks.configure(path10.dirname(templatePath), { autoescape: true });
    const html = env2.render("reportTemplate.html", context);
    const htmlFilePath = path10.join(finalOutputDir, "reporte_validaciones.html");
    await fs4.writeFile(htmlFilePath, html, "utf8");
    logger2.info("\u{1F4C4} HTML del reporte generado correctamente.");
    const pdfFilePath = path10.join(finalOutputDir, "reporte_validaciones.pdf");
    const pdfOk = await tryGeneratePdfHybrid(htmlFilePath, pdfFilePath, logger2);
    if (!pdfOk) {
      logger2.warn("\u26A0\uFE0F No se gener\xF3 PDF (no se encontr\xF3 motor compatible). Se deja solo HTML.");
    }
    return { htmlFilePath, pdfFilePath };
  } catch (error) {
    const msg = `Error generando reporte: ${error.message}`;
    logger2.error(msg);
    vscode6.window.showErrorMessage(msg);
    throw error;
  }
}
async function tryGeneratePdfHybrid(htmlPath, pdfPath, logger3) {
  try {
    const wkPath = await findWkhtmltopdfPath();
    if (!wkPath) {
      logger3.warn("\u26A0\uFE0F wkhtmltopdf no encontrado en PATH.");
      return false;
    }
    logger3.info(`\u{1F9E9} Generando PDF con wkhtmltopdf (${wkPath})...`);
    await new Promise((resolve4, reject) => {
      child_process.execFile(wkPath, [htmlPath, pdfPath], (err) => err ? reject(err) : resolve4());
    });
    logger3.info("\u{1F5A8}\uFE0F PDF generado correctamente con wkhtmltopdf.");
    return true;
  } catch (e) {
    logger3.warn(`\u26A0\uFE0F Error usando wkhtmltopdf: ${e.message}`);
  }
  return false;
}
async function findWkhtmltopdfPath() {
  try {
    const cmd = process.platform === "win32" ? "where" : "which";
    const { stdout } = await execa(cmd, ["wkhtmltopdf"]);
    const candidate = stdout.split(/\r?\n/)[0].trim();
    if (candidate && fs4.existsSync(candidate)) {
      return candidate;
    }
  } catch {
    logger2.warn(`\u26A0\uFE0F wkhtmltopdf no encontrado`);
  }
  return null;
}
function formatIAResults(iaResults) {
  const map = {};
  for (const r of iaResults) {
    if (r.Clase) {
      map[r.Clase] = {
        resumenHtml: r.resumenHtml || `<p>${r.resumen || "Sin resumen"}</p>`
      };
    }
  }
  return map;
}
async function generateComparisonReport(outputDir, orgAlias, comparisonResults) {
  try {
    const config2 = vscode6.workspace.getConfiguration("UnifiedApexValidator");
    const workspaceRoot = vscode6.workspace.workspaceFolders?.[0]?.uri.fsPath || "";
    const extension = vscode6.extensions.getExtension("ozkrgonzalez.unifiedapexvalidator");
    const extensionPath = extension?.extensionPath || __dirname;
    let templatePath = path10.join(extensionPath, "dist", "resources", "templates", "class_comparison_report.html");
    if (!fs4.existsSync(templatePath)) {
      templatePath = path10.join(extensionPath, "src", "resources", "templates", "class_comparison_report.html");
    }
    if (!fs4.existsSync(templatePath)) {
      throw new Error(`No se encontr\xF3 el template HTML (${templatePath})`);
    }
    await fs4.ensureDir(outputDir);
    const env2 = nunjucks.configure(path10.dirname(templatePath), { autoescape: false });
    env2.addFilter("tojson", function(value) {
      try {
        return JSON.stringify(value || "").replace(/</g, "\\u003c");
      } catch {
        return '""';
      }
    });
    const match_count = comparisonResults.filter((r) => r.Status === "Match").length;
    const mismatch_count = comparisonResults.filter((r) => r.Status === "Mismatch").length;
    const not_in_local_count = comparisonResults.filter((r) => r.Status === "Solo en Local").length;
    const not_in_salesforce_count = comparisonResults.filter((r) => r.Status === "Solo en Org").length;
    const html = env2.render(path10.basename(templatePath), {
      results: comparisonResults,
      match_count,
      mismatch_count,
      not_in_local_count,
      not_in_salesforce_count
    });
    const fileName = `compare_${orgAlias}_${(/* @__PURE__ */ new Date()).getTime()}.html`;
    const htmlFilePath = path10.join(outputDir, fileName);
    await fs4.writeFile(htmlFilePath, html, "utf8");
    vscode6.window.showInformationMessage(`\u{1F4CA} Reporte HTML de comparaci\xF3n generado: ${htmlFilePath}`);
    return htmlFilePath;
  } catch (err) {
    const msg = `\u274C Error generando reporte de comparaci\xF3n: ${err.message}`;
    vscode6.window.showErrorMessage(msg);
    throw err;
  }
}

// src/core/reportViewer.ts
var vscode7 = __toESM(require("vscode"));
var fs5 = __toESM(require("fs"));
var path11 = __toESM(require("path"));
function getVSCodeThemeClass() {
  const themeKind = vscode7.window.activeColorTheme.kind;
  switch (themeKind) {
    case vscode7.ColorThemeKind.Light:
      return "vscode-light";
    case vscode7.ColorThemeKind.Dark:
      return "vscode-dark";
    case vscode7.ColorThemeKind.HighContrast:
      return "vscode-high-contrast";
    default:
      return "vscode-light";
  }
}
function showReport(htmlPath, title = "Reporte de Validaci\xF3n Apex") {
  try {
    if (!fs5.existsSync(htmlPath)) {
      vscode7.window.showErrorMessage(`No se encontr\xF3 el archivo: ${htmlPath}`);
      return;
    }
    const panel = vscode7.window.createWebviewPanel(
      "uavReport",
      title,
      vscode7.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [vscode7.Uri.file(path11.dirname(htmlPath))]
      }
    );
    const html = fs5.readFileSync(htmlPath, "utf8");
    const dirUri = vscode7.Uri.file(path11.dirname(htmlPath));
    const baseUri = panel.webview.asWebviewUri(dirUri);
    const themeClass = getVSCodeThemeClass();
    const content = html.replace(
      /<body([^>]*)>/i,
      `<body$1 class="${themeClass}">`
    ).replace(
      /(<head>)/i,
      `$1<base href="${baseUri}/">`
    );
    panel.webview.html = content;
    vscode7.window.showInformationMessage("\u{1F4CA} Reporte abierto en vista integrada.");
  } catch (err) {
    vscode7.window.showErrorMessage(`Error al abrir el reporte: ${err.message}`);
  }
}

// src/core/uavController.ts
async function runUAV(uri) {
  process.on("unhandledRejection", (reason) => {
    if (String(reason).includes("CreateEmbeddingSupplier")) {
      return;
    }
    console.error("[UAVController] Unhandled Rejection:", reason);
  });
  try {
    const channel = getGlobalChannel();
    if (channel) channel.clear();
    const storageRoot = getStorageRoot();
    const logDir = path12.join(storageRoot, "logs");
    const tempDir = path12.join(storageRoot, "temp");
    await fs6.ensureDir(logDir);
    await fs6.ensureDir(tempDir);
    await fs6.emptyDir(tempDir);
    const mainLog = path12.join(logDir, "Validator.log");
    if (await fs6.pathExists(mainLog)) await fs6.writeFile(mainLog, "");
    console.log(`[UAV][Controller] Limpieza previa completada en ${storageRoot}`);
  } catch (err) {
    console.warn("[UAV][Controller] \u26A0\uFE0F No se pudo limpiar logs/temp antes de la ejecuci\xF3n:", err);
  }
  const logger3 = new Logger("UAVController", true);
  logger3.info("\u{1F680} Iniciando ejecuci\xF3n del Unified Apex Validator...");
  await vscode8.window.withProgress(
    {
      location: vscode8.ProgressLocation.Notification,
      title: "Unified Apex Validator",
      cancellable: true
    },
    async (progress) => {
      try {
        const workspaceFolder = vscode8.workspace.getWorkspaceFolder(uri) || vscode8.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) throw new Error("No se detect\xF3 carpeta de proyecto");
        const config2 = vscode8.workspace.getConfiguration("UnifiedApexValidator");
        let repoDir = config2.get("sfRepositoryDir")?.trim() || "";
        if (!repoDir) {
          repoDir = workspaceFolder.uri.fsPath;
          logger3.warn("\u26A0\uFE0F sfRepositoryDir no configurado. Usando ra\xEDz del workspace.");
        }
        if (!fs6.existsSync(path12.join(repoDir, "sfdx-project.json"))) {
          logger3.warn("\u26A0\uFE0F No se encontr\xF3 sfdx-project.json. Ajustando repoDir al workspace ra\xEDz.");
          repoDir = workspaceFolder.uri.fsPath;
        }
        const pkgPath = uri.fsPath;
        const storageRoot = getStorageRoot();
        const tempDir = path12.join(storageRoot, "temp");
        const logDir = path12.join(storageRoot, "logs");
        await fs6.ensureDir(tempDir);
        await fs6.ensureDir(logDir);
        const content = await fs6.readFile(pkgPath, "utf8");
        if (!content.includes("<name>ApexClass</name>")) {
          const msg = "\u274C No se encontraron clases Apex en este XML.";
          logger3.error(msg);
          throw new Error(msg);
        }
        progress.report({ message: "Analizando package.xml..." });
        logger3.info("\u{1F4E6} Analizando package.xml...");
        ;
        if (!repoDir) {
          repoDir = path12.join(workspaceFolder.uri.fsPath, "force-app", "main", "default", "classes");
          logger3.warn(`\u26A0\uFE0F sfRepositoryDir no configurado. Usando ruta por defecto: ${repoDir}`);
        } else {
          logger3.info(`\u{1F4C1} Repositorio configurado: ${repoDir}`);
        }
        const sfOrgAlias = config2.get("sfOrgAlias")?.trim() || "DEVSEGC";
        const aliasReady = await ensureOrgAliasConnected(sfOrgAlias, logger3);
        if (!aliasReady) {
          logger3.warn(`Se cancela la ejecuci\uFFFDn: la org "${sfOrgAlias}" no est\uFFFD conectada.`);
          return;
        }
        const { testClasses, nonTestClasses } = await parseApexClassesFromPackage(pkgPath, repoDir);
        logger3.info("\u{1F9E0} Llamando a runValidator...");
        const { codeAnalyzerResults, pmdResults } = await runValidator(uri, progress, repoDir);
        progress.report({ message: "Ejecutando pruebas Apex..." });
        logger3.info("\u{1F9EA} Ejecutando pruebas Apex...");
        const testSuite = new TestSuite(workspaceFolder.uri.fsPath);
        const testResults = await testSuite.runTestSuite(testClasses, nonTestClasses);
        const skipIASetting = config2.get("skipIAAnalysis") ?? false;
        const iaStatus = evaluateIaConfig();
        const skipIA = skipIASetting || !iaStatus.ready;
        let iaResults = [];
        if (!skipIA) {
          const sfGptPrompt = config2.get("iaPromptTemplate") ?? "Analiza la clase {class_name}:\n{truncated_body}";
          const sfGptMaxChar = config2.get("maxIAClassChars") ?? 25e3;
          progress.report({ message: "Ejecutando analisis IA..." });
          logger3.info("Ejecutando analisis de IA con Einstein GPT...");
          const ia = new IAAnalisis();
          for (const cls of nonTestClasses) {
            const clsPath = path12.join(repoDir, "force-app", "main", "default", "classes", `${cls}.cls`);
            if (!fs6.existsSync(clsPath)) {
              logger3.warn(`Clase no encontrada: ${clsPath}`);
              continue;
            }
            try {
              logger3.info(`Enviando clase a IA: ${cls}`);
              const content2 = await fs6.readFile(clsPath, "utf8");
              const truncated = content2.length > sfGptMaxChar ? content2.slice(0, sfGptMaxChar) : content2;
              if (content2.length > sfGptMaxChar) {
                logger3.warn(`Clase ${cls} truncada a ${sfGptMaxChar} caracteres para analisis.`);
              }
              const prompt = sfGptPrompt.replace("{class_name}", cls).replace("{truncated_body}", truncated);
              const analysis = await ia.generate(prompt);
              const md = new lib_default({
                html: true,
                linkify: true,
                typographer: true
              });
              const resumenHtml = md.render(analysis.resumen || "");
              iaResults.push({ Clase: cls, resumenHtml });
            } catch (err) {
              const message = err instanceof Error ? err.message : String(err);
              logger3.warn(`IA fallo para ${cls}: ${message}`);
            }
          }
          logger3.info(`Analisis IA finalizado - clases procesadas: ${iaResults.length}`);
        } else if (skipIASetting) {
          logger3.info("Analisis IA omitido por configuracion (skipIAAnalysis=true).");
        } else {
          logger3.info(`IA deshabilitada - faltan parametros: ${iaStatus.missing.join(", ")}`);
        }
        progress.report({ message: "Generando reportes..." });
        logger3.info("\u{1F4CA} Generando reportes...");
        const outputDir = config2.get("outputDir")?.trim() || path12.join(storageRoot, "output");
        await fs6.ensureDir(outputDir);
        await generateReport(
          outputDir,
          {
            codeAnalyzerResults,
            pmdResults,
            testResults,
            iaResults
          }
        );
        logger3.info(`\u2705 UAV completado. Reporte generado en: ${outputDir}`);
        vscode8.window.showInformationMessage(`\u2705 UAV completado. Reporte generado en ${outputDir}.`);
        const htmlReport = path12.join(outputDir, "reporte_validaciones.html");
        if (fs6.existsSync(htmlReport)) {
          showReport(htmlReport, "Reporte de Validaci\xF3n Apex");
        } else {
          logger3.warn(`\u26A0\uFE0F No se encontr\xF3 el reporte HTML en ${htmlReport}`);
        }
        const keepLogFiles = config2.get("keepLogFiles") ?? false;
        if (!keepLogFiles) {
          await cleanUpFiles([tempDir, logDir], logger3);
          logger3.info("\u{1F9FC} Archivos temporales y logs eliminados tras ejecuci\xF3n exitosa.");
        } else {
          logger3.info("\u2705 Ejecuci\xF3n exitosa. Se conservaron los logs por configuraci\xF3n.");
        }
      } catch (err) {
        if (err.message.includes("No se encontraron clases Apex")) {
          vscode8.window.showWarningMessage(err.message);
          logger3.warn(`\u26A0\uFE0F UAV finalizado sin ApexClass (${uri.fsPath})`);
        } else {
          logger3.error(`\u274C Error en proceso UAV: ${err.message}`);
          vscode8.window.showErrorMessage(`Error en UAV: ${err.message}`);
        }
      }
    }
  );
}
var FolderViewProvider = class {
  constructor(folderPath, fileExtension, label) {
    this.folderPath = folderPath;
    this.fileExtension = fileExtension;
    this.label = label;
  }
  _onDidChangeTreeData = new vscode8.EventEmitter();
  onDidChangeTreeData = this._onDidChangeTreeData.event;
  refresh() {
    this._onDidChangeTreeData.fire();
  }
  getTreeItem(element) {
    return element;
  }
  async getChildren() {
    try {
      if (!this.folderPath || !await fs6.pathExists(this.folderPath)) {
        return [new FileItem(`No se encontr\xF3 carpeta: ${this.folderPath}`, "", false)];
      }
      const files = await fs6.readdir(this.folderPath, { withFileTypes: true });
      const filtered = files.filter((f) => {
        if (!f.isFile()) return false;
        const ext2 = path12.extname(f.name).toLowerCase();
        return this.fileExtension.split("|").some((e) => ext2 === `.${e.trim()}`);
      }).map((f) => new FileItem(f.name, path12.join(this.folderPath, f.name), true));
      if (!filtered.length) {
        return [new FileItem("Sin archivos disponibles", "", false)];
      }
      return filtered;
    } catch (err) {
      console.error(`[UAV][${this.label}] Error leyendo archivos:`, err);
      return [new FileItem("Error leyendo carpeta", "", false)];
    }
  }
};
var FileItem = class extends vscode8.TreeItem {
  constructor(label, filePath, clickable) {
    super(label);
    this.label = label;
    this.filePath = filePath;
    this.clickable = clickable;
    this.iconPath = new vscode8.ThemeIcon("file");
    this.tooltip = filePath;
    if (clickable) {
      this.command = {
        command: "uav.openFile",
        title: "Abrir archivo",
        arguments: [vscode8.Uri.file(filePath)]
      };
    }
  }
};

// src/core/compareController.ts
var vscode9 = __toESM(require("vscode"));
var path13 = __toESM(require("path"));
var fs7 = __toESM(require_lib());

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a2;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return void 0;
      } else {
        return value;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a2 = options.timeout) !== null && _a2 !== void 0 ? _a2 : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path15, added, removed, oldPosInc, options) {
    const last = path15.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path15.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path15.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i2 = 0; i2 < array.length; i2++) {
      if (array[i2]) {
        ret.push(array[i2]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value, options) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i2) {
            const oldValue = oldTokens[oldPos + i2];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = this.join(value);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/diff/line.js
var LineDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  equals(left, right, options) {
    if (options.ignoreWhitespace) {
      if (!options.newlineIsToken || !left.includes("\n")) {
        left = left.trim();
      }
      if (!options.newlineIsToken || !right.includes("\n")) {
        right = right.trim();
      }
    } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
      if (left.endsWith("\n")) {
        left = left.slice(0, -1);
      }
      if (right.endsWith("\n")) {
        right = right.slice(0, -1);
      }
    }
    return super.equals(left, right, options);
  }
};
var lineDiff = new LineDiff();
function diffLines(oldStr, newStr, options) {
  return lineDiff.diff(oldStr, newStr, options);
}
function tokenize(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  const retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i2 = 0; i2 < linesAndNewlines.length; i2++) {
    const line = linesAndNewlines[i2];
    if (i2 % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}

// src/core/compareController.ts
async function runCompareApexClasses(uri) {
  const logger3 = new Logger("compareController", true);
  logger3.info("\u{1F680} Iniciando Comparaci\xF3n de Clases...");
  const workspace13 = vscode9.workspace.workspaceFolders?.[0];
  if (!workspace13) {
    vscode9.window.showErrorMessage("No hay un workspace abierto.");
    logger3.error("\u274C No se detect\xF3 workspace activo.");
    return;
  }
  const baseDir = workspace13.uri.fsPath;
  const settings = vscode9.workspace.getConfiguration("UnifiedApexValidator");
  const repoDir = settings.get("sfRepositoryDir") || "";
  const outputDir = settings.get("outputDir") || path13.join(baseDir, "output");
  logger3.info(`\u{1F4C1} Workspace: ${baseDir}`);
  logger3.info(`\u{1F4E6} Repositorio configurado: ${repoDir}`);
  logger3.info(`\u{1F4C2} Carpeta de salida: ${outputDir}`);
  let classNames = [];
  if (uri && uri.fsPath.endsWith(".xml")) {
    logger3.info(`\u{1F9E9} Analizando package.xml: ${uri.fsPath}`);
    const { testClasses, nonTestClasses } = await parseApexClassesFromPackage(uri.fsPath, repoDir);
    classNames = [...testClasses, ...nonTestClasses];
  } else if (uri && uri.fsPath.endsWith(".cls")) {
    const className = path13.basename(uri.fsPath, ".cls");
    logger3.info(`\u{1F4D8} Comparando una sola clase: ${className}`);
    classNames = [className];
  } else {
    vscode9.window.showWarningMessage("Abre un package.xml o un archivo .cls para comparar.");
    logger3.warn("\u26A0\uFE0F Comando ejecutado sin archivo .xml ni .cls v\xE1lido.");
    return;
  }
  if (classNames.length === 0) {
    vscode9.window.showWarningMessage("No se encontraron clases Apex en el archivo seleccionado.");
    logger3.warn("\u26A0\uFE0F No se encontraron clases Apex en el archivo.");
    return;
  }
  logger3.info("\u{1F50D} Listando organizaciones conectadas con Salesforce CLI...");
  const { stdout: orgListJson } = await execa("sf", ["org", "list", "--json"], {
    env: { ...process.env, FORCE_COLOR: "0" }
  });
  const orgList = JSON.parse(orgListJson).result.nonScratchOrgs.filter((o2) => o2.connectedStatus === "Connected").map((o2) => o2.alias || o2.username);
  if (!orgList.length) {
    vscode9.window.showErrorMessage("No hay orgs conectadas.");
    logger3.error("\u274C No se encontraron orgs conectadas.");
    return;
  }
  const orgAlias = await vscode9.window.showQuickPick(orgList, {
    placeHolder: "Selecciona la organizaci\xF3n contra la que comparar"
  });
  if (!orgAlias) {
    logger3.warn("\u26A0\uFE0F Comparaci\xF3n cancelada: no se seleccion\xF3 ninguna org.");
    return;
  }
  const tempDir = path13.join(getStorageRoot(), "temp", "compare");
  await fs7.ensureDir(tempDir);
  logger3.info(`\u{1F4C2} Carpeta temporal creada: ${tempDir}`);
  logger3.info(`\u2B07\uFE0F Recuperando ${classNames.length} clases desde org '${orgAlias}'...`);
  const retrieveCmd = [
    "project",
    "retrieve",
    "start",
    "--target-org",
    orgAlias,
    "--output-dir",
    tempDir,
    "--json"
  ];
  for (const cls of classNames) {
    retrieveCmd.push("--metadata", `ApexClass:${cls}`);
  }
  logger3.info(`\u{1F9E9} Ejecutando comando: sf ${retrieveCmd.join(" ")}`);
  try {
    const { stdout } = await execa("sf", retrieveCmd, {
      env: { ...process.env, FORCE_COLOR: "0" }
    });
    const result = JSON.parse(stdout);
    logger3.info(`\u2705 Retrieve completado (${result.result.files?.length || 0} archivos).`);
  } catch (err) {
    logger3.error(`\u274C Error en retrieve: ${err.message}`);
    if (err.stdout) logger3.error(`\u{1F4C4} STDOUT: ${err.stdout}`);
    if (err.stderr) logger3.error(`\u26A0\uFE0F STDERR: ${err.stderr}`);
    vscode9.window.showErrorMessage(`Error recuperando clases: ${err.message}`);
    return;
  }
  logger3.info(`\u{1F52C} Iniciando comparaci\xF3n de ${classNames.length} clases...`);
  const results = [];
  for (const className of classNames) {
    const localPath = path13.join(repoDir, `${className}.cls`);
    let retrievedPath = path13.join(tempDir, "force-app", "main", "default", "classes", `${className}.cls`);
    if (!await fs7.pathExists(retrievedPath)) {
      const altPath = path13.join(tempDir, "classes", `${className}.cls`);
      if (await fs7.pathExists(altPath)) {
        logger3.warn(`\u{1F4E6} Archivo recuperado detectado en ruta alternativa: ${altPath}`);
        retrievedPath = altPath;
      }
    }
    const existsLocal = await fs7.pathExists(localPath);
    const existsRemote = await fs7.pathExists(retrievedPath);
    logger3.info(`\u{1F9E9} Procesando clase: ${className}`);
    logger3.info(`\u{1F539} Local: ${existsLocal ? "\u2705" : "\u274C"} ${localPath}`);
    logger3.info(`\u{1F539} Remote: ${existsRemote ? "\u2705" : "\u274C"} ${retrievedPath}`);
    if (!existsLocal && !existsRemote) {
      logger3.warn(`\u26A0\uFE0F ${className} no existe ni en local ni en org.`);
      results.push({ ClassName: className, Status: "No existe en ninguno" });
      continue;
    }
    if (!existsLocal) {
      logger3.warn(`\u26A0\uFE0F ${className} existe solo en la org.`);
      results.push({ ClassName: className, Status: "Solo en Org" });
      continue;
    }
    if (!existsRemote) {
      logger3.warn(`\u26A0\uFE0F ${className} existe solo en local.`);
      results.push({ ClassName: className, Status: "Solo en Local" });
      continue;
    }
    const localBody = await fs7.readFile(localPath, "utf8");
    const remoteBody = await fs7.readFile(retrievedPath, "utf8");
    if (localBody.trim() === remoteBody.trim()) {
      logger3.info(`\u2705 ${className}: Match`);
      results.push({ ClassName: className, Status: "Match" });
    } else {
      logger3.info(`\u26A1 ${className}: Diferencias detectadas`);
      const diff = diffLines(localBody, remoteBody).map((part) => {
        const sign = part.added ? "+" : part.removed ? "-" : " ";
        return part.value.split("\n").map((line) => `${sign} ${line}`).join("\n");
      }).join("\n");
      results.push({
        ClassName: className,
        Status: "Mismatch",
        Differences: diff,
        LocalVersion: localBody,
        SalesforceVersion: remoteBody
      });
    }
  }
  logger3.info("\u{1F4CA} Generando reporte HTML de comparaci\xF3n...");
  const htmlReport = await generateComparisonReport(outputDir, orgAlias, results);
  const htmlContent = await fs7.readFile(htmlReport, "utf8");
  const panel = vscode9.window.createWebviewPanel(
    "uavComparisonReport",
    // ID interno
    `Comparaci\xF3n - ${orgAlias}`,
    // ttulo visible
    vscode9.ViewColumn.One,
    // dnde se abre
    { enableScripts: true }
    // permitir JS (para el Monaco, etc.)
  );
  panel.webview.html = htmlContent;
  vscode9.window.setStatusBarMessage(`\u2705 Reporte cargado en VS Code: ${path13.basename(htmlReport)}`, 5e3);
  logger3.info(`\u2705 Reporte abierto dentro de VS Code.`);
}

// src/core/generateApexDocChunked.ts
var vscode13 = __toESM(require("vscode"));

// src/core/apexAstParser.ts
var fs8 = __toESM(require("fs"));
var vscode10 = __toESM(require("vscode"));
var import_apex_parser = __toESM(require_lib3());
var import_antlr4ts = __toESM(require_antlr4ts());
function sanitizeForParser(source) {
  const chars = source.split("");
  const length = chars.length;
  for (let i2 = 0; i2 < length; i2++) {
    if (chars[i2] !== "[") continue;
    let j = i2 + 1;
    while (j < length && /\s/.test(chars[j])) j++;
    if (j >= length) break;
    const keyword = source.substring(j, j + 6).toLowerCase();
    if (!keyword.startsWith("select") && !keyword.startsWith("find")) continue;
    let depth = 1;
    let k = j;
    while (k < length && depth > 0) {
      k++;
      if (k >= length) break;
      const ch = chars[k];
      if (ch === "[") {
        depth++;
      } else if (ch === "]") {
        depth--;
      }
    }
    if (depth !== 0) continue;
    chars[i2] = "0";
    for (let p = i2 + 1; p < k; p++) {
      const ch = chars[p];
      chars[p] = ch === "\n" || ch === "\r" ? ch : " ";
    }
    if (k < length) {
      const ch = chars[k];
      chars[k] = ch === "\n" || ch === "\r" ? ch : " ";
    }
    i2 = k;
  }
  return chars.join("");
}
var ApexAstParser = class _ApexAstParser {
  static parseFile(filePath) {
    let code2 = fs8.readFileSync(filePath, "utf8");
    if (code2.startsWith("\uFEFF")) {
      code2 = code2.slice(1);
    }
    const parserCode = sanitizeForParser(code2);
    const baseStream = import_antlr4ts.CharStreams.fromString(parserCode);
    const inputStream = new import_apex_parser.CaseInsensitiveInputStream(baseStream);
    const lexer = new import_apex_parser.ApexLexer(inputStream);
    const tokenStream = new import_antlr4ts.CommonTokenStream(lexer);
    const parser = new import_apex_parser.ApexParser(tokenStream);
    const config2 = vscode10.workspace.getConfiguration("UnifiedApexValidator");
    const traceAst = config2.get("traceAst") ?? false;
    const syntaxErrors = [];
    const chunks = [];
    const extract = (start, end) => code2.substring(start, end);
    parser.removeErrorListeners();
    parser.addErrorListener({
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        syntaxErrors.push(`line ${line}:${charPositionInLine} ${msg}`);
      }
    });
    const ast = parser.compilationUnit();
    const firstNonEmptyLine = (text2) => {
      const lines = text2.split(/\r?\n/);
      for (const raw of lines) {
        const trimmed = raw.trim();
        if (trimmed.length > 0) {
          return trimmed.replace(/\s+/g, " ");
        }
      }
      return text2.trim();
    };
    const hasDocComment = (startToken, startIndex) => {
      const hasHiddenDoc = () => {
        const tokenIndex = typeof startToken?.tokenIndex === "number" ? startToken.tokenIndex : -1;
        if (tokenIndex < 0) return false;
        const hiddenTokens = tokenStream.getHiddenTokensToLeft(tokenIndex) ?? [];
        for (let i2 = hiddenTokens.length - 1; i2 >= 0; i2--) {
          const hidden2 = hiddenTokens[i2];
          const text2 = hidden2?.text ?? "";
          const trimmed = text2.trim();
          if (!trimmed) continue;
          if (trimmed.startsWith("/**")) return true;
          if (trimmed.startsWith("/*") || trimmed.startsWith("//")) return false;
          break;
        }
        return false;
      };
      const hasDocByText = () => {
        if (startIndex <= 0) return false;
        let scanPos = startIndex;
        let onDeclarationLine = true;
        while (scanPos > 0) {
          const newlineIndex = code2.lastIndexOf("\n", scanPos - 1);
          const lineStart = newlineIndex + 1;
          if (onDeclarationLine) {
            scanPos = lineStart;
            onDeclarationLine = false;
            continue;
          }
          const line = code2.substring(lineStart, scanPos).trim();
          if (!line) {
            scanPos = newlineIndex >= 0 ? newlineIndex : 0;
            continue;
          }
          if (line.startsWith("@")) {
            scanPos = newlineIndex >= 0 ? newlineIndex : 0;
            continue;
          }
          break;
        }
        const commentEnd = code2.lastIndexOf("*/", scanPos - 1);
        if (commentEnd === -1) return false;
        const between = code2.substring(commentEnd + 2, scanPos).trim();
        if (between.length > 0) return false;
        const commentStart = code2.lastIndexOf("/**", commentEnd);
        return commentStart !== -1;
      };
      return hasHiddenDoc() || hasDocByText();
    };
    const tryCall = (node, method, ...args) => {
      try {
        const fn = node?.[method];
        if (typeof fn === "function") return fn.apply(node, args);
      } catch (err) {
        console.warn(`[ApexAST] getName call failed for ${method}: ${err.message}`);
      }
      return void 0;
    };
    const getIdText = (node) => {
      const idCtx = tryCall(node, "id");
      return idCtx?.text;
    };
    const extractFirstVariableName = (fieldNode) => {
      const varDecls = tryCall(fieldNode, "variableDeclarators");
      if (!varDecls) return void 0;
      const decls = tryCall(varDecls, "variableDeclarator");
      if (Array.isArray(decls) && decls.length > 0) {
        const text2 = getIdText(decls[0]);
        if (text2) return text2;
      } else if (decls) {
        const text2 = getIdText(decls);
        if (text2) return text2;
      }
      const firstIndexed = tryCall(varDecls, "variableDeclarator", 0);
      return getIdText(firstIndexed);
    };
    const getName = (node) => {
      if (!node) return "Unknown";
      const idCtx = tryCall(node, "id");
      if (idCtx?.text) return idCtx.text;
      const qualified = tryCall(node, "qualifiedName");
      if (qualified?.text) {
        const parts = qualified.text.split(".");
        return parts[parts.length - 1];
      }
      const identifierFn = node?.IDENTIFIER;
      if (typeof identifierFn === "function") {
        const value = identifierFn.call(node);
        if (Array.isArray(value)) {
          const last = value[value.length - 1];
          if (last?.text) return last.text;
        }
        if (value?.text) return value.text;
      }
      if (node.IDENTIFIER?.text) return node.IDENTIFIER.text;
      if (Array.isArray(node.children)) {
        const symbolNode = node.children.find((c3) => c3.symbol?.text);
        if (symbolNode) return symbolNode.symbol.text;
      }
      if (typeof node.text === "string") {
        const match3 = node.text.match(/([A-Za-z_]\w*)\s*(\(|\{|;)/);
        if (match3) return match3[1];
      }
      return "Unknown";
    };
    const visited = /* @__PURE__ */ new WeakSet();
    const traverse = (node, depth = 0) => {
      if (!node || visited.has(node) || depth > 50) return;
      visited.add(node);
      const type = node.constructor?.name;
      const startToken = node.start || node.symbol;
      const stopToken = node.stop || node.symbol;
      const start = typeof startToken?.startIndex === "number" ? startToken.startIndex : typeof startToken?.start === "number" ? startToken.start : 0;
      const stopIdx = typeof stopToken?.stopIndex === "number" ? stopToken.stopIndex : typeof stopToken?.stop === "number" ? stopToken.stop : start;
      const end = Math.min((stopIdx ?? start) + 1, code2.length);
      if (traceAst)
        console.log(`[ApexAST][Depth:${depth}] -> ${type} (${start}-${end})`);
      try {
        const text2 = extract(start, end);
        switch (type) {
          case "ClassDeclarationContext": {
            const className = getName(node);
            const parentType = node.parent?.constructor?.name;
            const isInner = parentType === "MemberDeclarationContext" || parentType === "TriggerMemberDeclarationContext";
            if (traceAst)
              console.log(`[ApexAST] Class found: ${className} (inner=${isInner})`);
            chunks.push({
              kind: isInner ? "innerClass" : "classHeader",
              name: className,
              start,
              end,
              text: text2,
              signature: firstNonEmptyLine(text2),
              needsDoc: !hasDocComment(startToken, start)
            });
            break;
          }
          case "FieldDeclarationContext": {
            const fieldName = extractFirstVariableName(node) ?? getName(node);
            if (traceAst)
              console.log(`[ApexAST] Field found: ${fieldName}`);
            chunks.push({
              kind: "field",
              name: fieldName,
              start,
              end,
              text: text2,
              signature: firstNonEmptyLine(text2.split("=")[0] ?? text2),
              needsDoc: !hasDocComment(startToken, start)
            });
            break;
          }
          case "ConstructorDeclarationContext":
            if (traceAst)
              console.log(`[ApexAST] Constructor found: ${getName(node)}`);
            chunks.push({
              kind: "constructor",
              name: getName(node),
              start,
              end,
              text: text2,
              signature: firstNonEmptyLine(text2),
              needsDoc: !hasDocComment(startToken, start)
            });
            break;
          case "MethodDeclarationContext": {
            const methodName = getIdText(node) ?? getName(node);
            if (traceAst)
              console.log(`[ApexAST] Method found: ${methodName}`);
            chunks.push({
              kind: "method",
              name: methodName,
              start,
              end,
              text: text2,
              signature: firstNonEmptyLine(text2),
              needsDoc: !hasDocComment(startToken, start)
            });
            break;
          }
          case "PropertyDeclarationContext": {
            const propertyName = getIdText(node) ?? getName(node);
            if (traceAst)
              console.log(`[ApexAST] Property found: ${propertyName}`);
            chunks.push({
              kind: "field",
              name: propertyName,
              start,
              end,
              text: text2,
              signature: firstNonEmptyLine(text2),
              needsDoc: !hasDocComment(startToken, start)
            });
            break;
          }
        }
      } catch (err) {
        if (traceAst)
          console.warn(`[ApexAST] Error parsing node ${type}: ${err.message}`);
      }
      for (const key of Object.keys(node)) {
        const val = node[key];
        if (!val) continue;
        if (Array.isArray(val)) {
          for (const child of val) {
            if (typeof child === "object") traverse(child, depth + 1);
          }
        } else if (typeof val === "object") {
          traverse(val, depth + 1);
        }
      }
      if (traceAst && depth === 0)
        console.log(`[ApexAST] Finalizo recorrido raiz con ${chunks.length} chunks`);
    };
    traverse(ast);
    chunks.sort((a2, b) => a2.start - b.start);
    if (traceAst) {
      if (syntaxErrors.length) {
        console.warn("[ApexAST] Syntax errors detectados:");
        for (const err of syntaxErrors) {
          console.warn(`  ! ${err}`);
        }
      }
      console.log("\n[ApexAST] Resumen de chunks detectados:");
      for (const ch of chunks) {
        const status = ch.needsDoc ? "sin doc" : "con doc";
        console.log(`  - ${ch.kind.padEnd(14)} ${ch.name.padEnd(60)} (${ch.start}-${ch.end})  ${status}`);
      }
      console.log(`[ApexAST] Total: ${chunks.length} elementos`);
    }
    return chunks;
  }
  static parseDocument(doc) {
    const tempFile = doc.uri.fsPath;
    fs8.writeFileSync(tempFile, doc.getText(), "utf8");
    return _ApexAstParser.parseFile(tempFile);
  }
};

// src/core/aiDocChunkRunner.ts
var vscode11 = __toESM(require("vscode"));
var AiDocChunkRunner = class _AiDocChunkRunner {
  static logger = new Logger("ApexDocChunkRunner", true);
  static async processChunk(docText, chunk) {
    const logger3 = _AiDocChunkRunner.logger;
    const iaClient = new IAAnalisis();
    logger3.info(`Processing chunk: ${chunk.kind} - ${chunk.name}`);
    const cfg = vscode11.workspace.getConfiguration("UnifiedApexValidator");
    const maxChars = cfg.get("maxIAClassChars") || 25e3;
    let snippet = chunk.text;
    let truncatedNotice = "";
    if (snippet.length > maxChars) {
      snippet = snippet.substring(0, maxChars);
      truncatedNotice = "\n\nNote: Only part of the code is shown due to size limit.\nDocument only the visible content, without inventing missing sections.\n";
      logger3.warn(`Chunk truncated to ${maxChars} characters (original length: ${chunk.text.length})`);
    }
    logger3.info(`Fragmento (${chunk.name}): ${snippet.slice(0, 200)}...`);
    const contextHeader = _AiDocChunkRunner.buildContextHeader(docText, chunk);
    const snippetWrapped = `/*__BEGIN_FRAGMENT__*/
${snippet}
/*__END_FRAGMENT__*/`;
    const prompt = `
        You are an expert Salesforce Apex developer.

        Your task is to add ApexDoc documentation comments to the given Apex code fragment.
        Follow these strict rules:

        - Do not remove, reorder, or modify any existing code.
        - Only add documentation comments /** ... */ above classes, methods, variables, or inner classes.
        - Keep the original indentation and spacing.
        - Keep the class header (public with sharing class ...) intact.
        - Return only the modified fragment between markers.
        - All documentation tags (@description, @param, @return) must be written in Spanish.
        - Classes, constructors, and methods must always include @description.
        - Each @param must describe the purpose of the parameter briefly.
        - Methods that return a value must include an @return tag describing what is returned.
        - Methods with return type 'void' must not include an @return tag.
        - Variable declarations must not include @return.
        - Surround the return type in the @return tag with single backticks (\`Tipo\`).
        - Do not add empty or placeholder tags.
        - Maintain consistent indentation and spacing with the original code.

        Context (for reference only, do not modify):
        ${contextHeader}
        ${truncatedNotice}

        Example:
        /**
         * @description Calcula la suma de dos n\xFAmeros.
         * @param a Primer n\xFAmero.
         * @param b Segundo n\xFAmero.
         * @return \`Integer\` Suma total.
         */
        public static Integer add(Integer a, Integer b)
        { ... }

        Now, document the following Apex code.
        Return only the code between delimiters:
        ---CODE START---
        ${snippetWrapped}
        ---CODE END---
        `.trim();
    try {
      const result = await iaClient.generate(prompt);
      let out = result?.resumen?.trim() || "";
      out = out.replace(/---CODE START---/gi, "").replace(/---CODE END---/gi, "").replace(/\/\*__BEGIN_FRAGMENT__\*\//g, "").replace(/\/\*__END_FRAGMENT__\*\//g, "").trim();
      const openBraces = (out.match(/{/g) || []).length;
      const closeBraces = (out.match(/}/g) || []).length;
      if (closeBraces > openBraces) {
        out = out.replace(/}\s*$/, "");
      }
      if (!out) {
        logger3.warn(`Empty response for chunk: ${chunk.name}`);
        return { ok: false, error: "Empty response from model" };
      }
      if (!out.includes("/**")) {
        logger3.warn(`No ApexDoc comments detected in chunk: ${chunk.name}`);
        return { ok: false, error: "No documentation generated" };
      }
      const anchorFound = new RegExp(`\\b${chunk.name}\\b`).test(out);
      if (!anchorFound) {
        logger3.warn(`Possible incomplete response for ${chunk.name}`);
      }
      const preview = out.substring(0, 400).replace(/\n/g, " ");
      logger3.info(`Model responded (${out.length} chars): ${preview}...`);
      return { ok: true, patchedText: out };
    } catch (e) {
      if (e instanceof IAConnectionError) {
        const message = e.message || "Error autenticando con el servidor de IA.";
        logger3.error(`Fatal error processing chunk ${chunk.name}: ${message}`);
        return { ok: false, error: message, fatal: true };
      }
      logger3.error(`Error processing chunk ${chunk.name}: ${e?.message}`);
      return { ok: false, error: e?.message || "Error invoking model" };
    }
  }
  static buildContextHeader(full, chunk) {
    const classMatch = full.match(/(public|global|private|protected)?\s*(with|without)?\s*sharing\s*class\s+([A-Za-z_]\w*)/);
    const className = classMatch ? classMatch[3] : "UnknownClass";
    const classSignature = classMatch ? classMatch[0] : "class definition not found";
    const methodRegex = new RegExp(
      `(public|global|private|protected)\\s+(static\\s+)?[A-Za-z_<>\\[\\]]+\\s+${chunk.name}\\s*\\([^)]*\\)`,
      "i"
    );
    const methodSig = full.match(methodRegex)?.[0] || `Signature for ${chunk.name} not found`;
    return [
      `Class: ${className}`,
      `Class signature: ${classSignature}`,
      `Current element: ${chunk.kind} ${chunk.name}`,
      `Signature: ${methodSig}`
    ].join("\n");
  }
};

// src/core/patchApplier.ts
var vscode12 = __toESM(require("vscode"));
var PatchApplier = class _PatchApplier {
  static logger = new Logger("PatchApplier", true);
  static applyInMemory(baseText, chunk, docBlock) {
    const logger3 = _PatchApplier.logger;
    try {
      const insertionPoint = Math.max(baseText.lastIndexOf("\n", chunk.start - 1) + 1, 0);
      const beforeInsert = baseText.substring(0, insertionPoint);
      const charBefore = insertionPoint > 0 ? baseText[insertionPoint - 1] : "";
      const needsSpacer = insertionPoint > 0 && charBefore !== "\n";
      const remainder = baseText.substring(insertionPoint);
      const indentMatch = remainder.match(/^[ \t]*/);
      const indent = indentMatch ? indentMatch[0] : "";
      const docLines = docBlock.trim().split(/\r?\n/);
      const indentedDoc = docLines.map((line) => line.length ? indent + line : indent).join("\n");
      const formattedBlock = (needsSpacer ? "\n" : "") + indentedDoc + "\n";
      const newText = baseText.substring(0, insertionPoint) + formattedBlock + baseText.substring(insertionPoint);
      logger3.info(`\u2705 ApexDoc insertado en ${chunk.kind} "${chunk.name}" (posici\xF3n ${insertionPoint})`);
      return newText;
    } catch (err) {
      logger3.error(`\u274C Error aplicando ApexDoc en ${chunk.name}: ${err.message}`);
      return baseText;
    }
  }
  static async openFinalDiff(original, modified, uri, title) {
    const logger3 = _PatchApplier.logger;
    try {
      logger3.info("\u{1F50D} Opening final diff preview...");
      const leftUri = uri;
      const rightDoc = await vscode12.workspace.openTextDocument({ content: modified, language: "apex" });
      await vscode12.commands.executeCommand("vscode.diff", leftUri, rightDoc.uri, title);
      logger3.info("\u{1FA84} Diff view opened successfully (left = original file, right = generated version).");
    } catch (err) {
      logger3.error(`\u274C Error opening diff view: ${err.message}`);
    }
  }
};

// src/core/generateApexDocChunked.ts
async function generateApexDocChunked() {
  const editor = vscode13.window.activeTextEditor;
  if (!editor) {
    vscode13.window.showErrorMessage("No hay ningun archivo abierto.");
    return;
  }
  const iaStatus = evaluateIaConfig();
  if (!iaStatus.ready) {
    vscode13.window.showWarningMessage(
      `Generacion de ApexDoc deshabilitada. Faltan parametros IA: ${iaStatus.missing.join(", ")}`
    );
    return;
  }
  const logger3 = new Logger("GenerateApexDoc", true);
  const doc = editor.document;
  const original = doc.getText();
  let working = original;
  const chunks = ApexAstParser.parseDocument(doc);
  const traceAst = vscode13.workspace.getConfiguration("UnifiedApexValidator").get("traceAst") ?? false;
  logger3.info(`[GenerateApexDoc] Chunks detectados: ${chunks.length}`);
  if (traceAst) {
    for (const ch of chunks) {
      logger3.info(
        `  \u2022 ${ch.kind.padEnd(12)} ${ch.name.padEnd(60)} (${ch.start}-${ch.end})  doc=${ch.needsDoc ? "pendiente" : "ok"}`
      );
    }
  }
  const missing = chunks.filter((c3) => c3.needsDoc);
  let fatalError;
  if (!missing.length) {
    vscode13.window.showInformationMessage("Todos los elementos ya tienen ApexDoc.");
    return;
  }
  const progressOptions = {
    location: vscode13.ProgressLocation.Notification,
    title: "Revisi\xF3n de ApexDoc generados",
    cancellable: true
  };
  await vscode13.window.withProgress(progressOptions, async (progress, token) => {
    const total = missing.length;
    let done = 0;
    const locateChunk = (source, snippet, hint) => {
      if (!snippet) return -1;
      const primary = source.indexOf(snippet, Math.max(0, hint));
      if (primary !== -1) return primary;
      const trimmed = snippet.trim();
      if (trimmed && trimmed !== snippet) {
        const fallback = source.indexOf(trimmed, Math.max(0, hint));
        if (fallback !== -1) return fallback;
      }
      return -1;
    };
    let searchCursor = 0;
    for (const chunk of missing) {
      if (token.isCancellationRequested) {
        break;
      }
      progress.report({ message: `Procesando ${chunk.kind} "${chunk.name}" (${++done}/${total})` });
      logger3.info(`Generando doc para: ${chunk.kind} "${chunk.name}"`);
      const snippet = chunk.text;
      let realStart = locateChunk(working, snippet, searchCursor);
      if (realStart === -1) {
        realStart = locateChunk(working, snippet, 0);
      }
      if (realStart === -1) {
        logger3.warn(`No se encontro el fragmento actualizado para ${chunk.name}; se omite.`);
        continue;
      }
      const realEnd = realStart + snippet.length;
      const currentSlice = working.substring(realStart, realEnd);
      const localChunk = { ...chunk, start: realStart, end: realEnd, text: currentSlice };
      const result = await AiDocChunkRunner.processChunk(working, localChunk);
      if (result.ok && result.patchedText) {
        try {
          const config2 = vscode13.workspace.getConfiguration("UnifiedApexValidator");
          const outputDir = config2.get("outputDir") || vscode13.workspace.workspaceFolders?.[0]?.uri.fsPath || __dirname;
          const safeName = `${chunk.kind}_${chunk.name.replace(/[^a-zA-Z0-9_]/g, "_")}.txt`;
          const rawPath = vscode13.Uri.file(`${outputDir}/ApexDoc_Debug_${safeName}`);
          await vscode13.workspace.fs.writeFile(rawPath, Buffer.from(result.patchedText, "utf8"));
          logger3.info(`Guardado bloque IA crudo para ${chunk.name} en ${rawPath.fsPath}`);
          const matches = [...result.patchedText.matchAll(/\/\*\*[\s\S]*?\*\//g)];
          if (matches.length > 0) {
            for (let i2 = 0; i2 < matches.length; i2++) {
              const block2 = matches[i2][0];
              const blkPath = vscode13.Uri.file(`${outputDir}/ApexDoc_Debug_${chunk.kind}_${chunk.name.replace(/[^a-zA-Z0-9_]/g, "_")}_${i2}.txt`);
              await vscode13.workspace.fs.writeFile(blkPath, Buffer.from(block2, "utf8"));
            }
            let docBlock = matches[0][0];
            if (chunk.kind === "classHeader") {
              docBlock = ensureClassPlaceholders(docBlock);
            } else if (chunk.kind === "method") {
              docBlock = ensureMethodPlaceholders(docBlock, chunk, false);
            } else if (chunk.kind === "constructor") {
              docBlock = ensureMethodPlaceholders(docBlock, chunk, true);
            }
            working = PatchApplier.applyInMemory(working, localChunk, docBlock);
            searchCursor = realStart + docBlock.length + snippet.length;
            logger3.info(`Documentacion insertada para ${chunk.name} (${matches.length} bloque(s) detectados)`);
          } else {
            logger3.warn(`No se detectaron bloques ApexDoc en la respuesta para ${chunk.name}`);
          }
        } catch (err) {
          logger3.warn(`Error guardando/insertando doc para ${chunk.name}: ${err.message}`);
        }
      } else if (result.fatal) {
        fatalError = result.error || "Error fatal al invocar el servicio de IA.";
        logger3.error(`Proceso detenido para ${chunk.name}: ${fatalError}`);
        break;
      } else {
        logger3.warn(`Fallo ${chunk.name}: ${result.error}`);
      }
      if (searchCursor < realStart + snippet.length) {
        searchCursor = realStart + snippet.length;
      }
    }
    if (fatalError) {
      return;
    }
  });
  if (fatalError) {
    vscode13.window.showErrorMessage(`No se pudo generar ApexDoc: ${fatalError}`);
    return;
  }
  await PatchApplier.openFinalDiff(original, working, doc.uri, "Comparar documentacion generada (chunked)");
  const applyAnswer = await vscode13.window.showInformationMessage(
    "Revisa el diff abierto. \xBFQuieres aplicar la documentacion generada al archivo?",
    "Aplicar",
    "Omitir"
  );
  if (applyAnswer === "Aplicar") {
    const targetEditor = await vscode13.window.showTextDocument(doc, { preview: false });
    const applied = await targetEditor.edit((editBuilder) => {
      const start = new vscode13.Position(0, 0);
      const lastLine = doc.lineCount > 0 ? doc.lineAt(doc.lineCount - 1) : void 0;
      const end = lastLine ? lastLine.range.end : start;
      editBuilder.replace(new vscode13.Range(start, end), working);
    });
    if (applied) {
      logger3.info("Documentacion aplicada al archivo.");
    } else {
      logger3.warn("No fue posible aplicar la documentacion al archivo.");
    }
  } else {
    logger3.info("Documentacion generada omitida por el usuario.");
  }
}
function analyzeDocBlock(docBlock) {
  const lines = docBlock.split(/\r?\n/);
  const closeIndex = [...lines].reverse().findIndex((line) => line.trim().startsWith("*/"));
  if (closeIndex === -1) return void 0;
  const closingLineIndex = lines.length - 1 - closeIndex;
  let indent = "";
  for (const line of lines) {
    const match3 = line.match(/^(\s*)\*/);
    if (match3) {
      indent = match3[1];
      break;
    }
  }
  return { lines, closingLineIndex, indent };
}
function normalizeTags(settingKey, fallback) {
  const config2 = vscode13.workspace.getConfiguration("UnifiedApexValidator");
  const configured = config2.get(settingKey) ?? fallback;
  return configured.map((tag) => tag.startsWith("@") ? tag : `@${tag}`).map((tag) => tag.trim()).filter((tag, index, array) => tag.length > 1 && array.indexOf(tag) === index);
}
function docBlockHasTag(docBlock, tag) {
  const tagPattern = new RegExp(`\\*\\s*${tag.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&")}\\b`, "i");
  return tagPattern.test(docBlock);
}
function ensureClassPlaceholders(docBlock) {
  const normalized = normalizeTags("classDocTags", ["@description", "@since", "@author", "@testClass"]);
  if (!normalized.length) return docBlock;
  const metadata = analyzeDocBlock(docBlock);
  if (!metadata) return docBlock;
  const { lines, closingLineIndex, indent } = metadata;
  const missing = normalized.filter((tag) => !docBlockHasTag(docBlock, tag));
  if (!missing.length) return docBlock;
  const insertionLines = missing.map((tag) => `${indent} * ${tag} `);
  lines.splice(closingLineIndex, 0, ...insertionLines);
  return lines.join("\n");
}
function ensureMethodPlaceholders(docBlock, chunk, isConstructor) {
  const normalized = normalizeTags("methodDocTags", ["@description", "@param", "@return"]);
  if (!normalized.length) return docBlock;
  const metadata = analyzeDocBlock(docBlock);
  if (!metadata) return docBlock;
  const { lines, closingLineIndex, indent } = metadata;
  const methodInfo = extractMethodMetadata(chunk, isConstructor);
  const insertionLines = [];
  const existingParams = new Set(
    [...docBlock.matchAll(/\*\s*@param\s+([A-Za-z_][A-Za-z0-9_]*)/gi)].map((match3) => match3[1].toLowerCase())
  );
  for (const tag of normalized) {
    const lower = tag.toLowerCase();
    if (lower === "@param") {
      if (!methodInfo.params.length) continue;
      for (const paramName of methodInfo.params) {
        if (!existingParams.has(paramName.toLowerCase())) {
          insertionLines.push(`${indent} * @param ${paramName} `);
        }
      }
      continue;
    }
    if (lower === "@return") {
      if (isConstructor || methodInfo.returnsVoid) continue;
      if (docBlockHasTag(docBlock, tag)) continue;
      if (methodInfo.returnType) {
        insertionLines.push(`${indent} * @return \`${methodInfo.returnType}\` `);
      } else {
        insertionLines.push(`${indent} * @return `);
      }
      continue;
    }
    if (!docBlockHasTag(docBlock, tag)) {
      insertionLines.push(`${indent} * ${tag} `);
    }
  }
  if (!insertionLines.length) return docBlock;
  lines.splice(closingLineIndex, 0, ...insertionLines);
  return lines.join("\n");
}
function extractMethodMetadata(chunk, isConstructor) {
  const beforeBody = chunk.text.split("{", 1)[0] ?? chunk.text;
  const sanitized = beforeBody.replace(/\/\*[\s\S]*?\*\//g, " ").replace(/\/\/.*$/gm, " ");
  const lines = sanitized.split(/\r?\n/).map((line) => line.trim()).filter((line) => line.length > 0 && !line.startsWith("@"));
  const header = lines.join(" ");
  const methodPattern = new RegExp(`\\b${chunk.name}\\s*\\(`);
  const match3 = methodPattern.exec(header);
  if (!match3) {
    return {
      params: [],
      returnsVoid: isConstructor,
      returnType: isConstructor ? void 0 : void 0
    };
  }
  const prefix = header.slice(0, match3.index).trim();
  const suffix = header.slice(match3.index);
  const paramsStart = suffix.indexOf("(");
  let paramsEnd = -1;
  let depth = 0;
  for (let i2 = paramsStart; i2 < suffix.length; i2++) {
    const char = suffix[i2];
    if (char === "(") {
      depth++;
    } else if (char === ")") {
      depth--;
      if (depth === 0) {
        paramsEnd = i2;
        break;
      }
    }
  }
  const paramSegment = paramsEnd > paramsStart ? suffix.slice(paramsStart + 1, paramsEnd) : "";
  const params = splitParameterList(paramSegment);
  if (isConstructor) {
    return {
      params,
      returnsVoid: true,
      returnType: void 0
    };
  }
  const tokens = tokenizeSignaturePrefix(prefix);
  const filtered = tokens.filter((token) => {
    const lower = token.toLowerCase();
    if (lower === "with" || lower === "without" || lower === "sharing") return false;
    return ![
      "public",
      "private",
      "protected",
      "global",
      "static",
      "virtual",
      "override",
      "abstract",
      "final",
      "transient",
      "testmethod",
      "webservice",
      "future",
      "synchronized"
    ].includes(lower);
  });
  const returnType = filtered.length ? filtered[filtered.length - 1] : void 0;
  const returnsVoid = (returnType ?? "").toLowerCase() === "void";
  return {
    params,
    returnsVoid,
    returnType: returnType && returnType.toLowerCase() !== "void" ? returnType : void 0
  };
}
function tokenizeSignaturePrefix(prefix) {
  if (!prefix) return [];
  const rawTokens = prefix.split(/\s+/).filter(Boolean);
  const merged = [];
  let buffer;
  let angleDepth = 0;
  for (const token of rawTokens) {
    if (buffer === void 0) {
      buffer = token;
    } else {
      buffer += ` ${token}`;
    }
    angleDepth += (token.match(/</g) ?? []).length;
    angleDepth -= (token.match(/>/g) ?? []).length;
    if (angleDepth <= 0) {
      merged.push(buffer);
      buffer = void 0;
    }
  }
  if (buffer !== void 0) {
    merged.push(buffer);
  }
  return merged;
}
function splitParameterList(raw) {
  if (!raw.trim()) return [];
  const segments = [];
  let current = "";
  let angleDepth = 0;
  let parenDepth = 0;
  let braceDepth = 0;
  let inString = null;
  for (let i2 = 0; i2 < raw.length; i2++) {
    const char = raw[i2];
    if (inString) {
      current += char;
      if (char === inString && raw[i2 - 1] !== "\\") {
        inString = null;
      }
      continue;
    }
    if (char === '"' || char === "'") {
      inString = char;
      current += char;
      continue;
    }
    switch (char) {
      case "<":
        angleDepth++;
        break;
      case ">":
        if (angleDepth > 0) angleDepth--;
        break;
      case "(":
        parenDepth++;
        break;
      case ")":
        if (parenDepth > 0) parenDepth--;
        break;
      case "{":
        braceDepth++;
        break;
      case "}":
        if (braceDepth > 0) braceDepth--;
        break;
      case ",":
        if (angleDepth === 0 && parenDepth === 0 && braceDepth === 0) {
          segments.push(current.trim());
          current = "";
          continue;
        }
        break;
    }
    current += char;
  }
  if (current.trim()) {
    segments.push(current.trim());
  }
  const names = [];
  const seen = /* @__PURE__ */ new Set();
  for (const segment of segments) {
    const name = extractParamName(segment);
    if (name && !seen.has(name.toLowerCase())) {
      seen.add(name.toLowerCase());
      names.push(name);
    }
  }
  return names;
}
function extractParamName(param) {
  if (!param) return void 0;
  let cleaned = param.replace(/@[A-Za-z_][A-Za-z0-9_]*(?:\s*\([^)]*\))?/g, " ").trim();
  if (!cleaned) return void 0;
  const equalsIndex = cleaned.indexOf("=");
  if (equalsIndex !== -1) {
    cleaned = cleaned.slice(0, equalsIndex).trim();
  }
  const match3 = cleaned.match(/([A-Za-z_][A-Za-z0-9_]*)\s*$/);
  return match3 ? match3[1] : void 0;
}

// src/extension.ts
async function activate(context) {
  console.log("[UAV][extension] Unified Apex Validator activado.");
  console.log("[UAV][extension] globalStorageUri:", context.globalStorageUri.fsPath);
  const dependenciesProvider = new DependenciesProvider(context);
  vscode14.window.registerTreeDataProvider("uav.dependenciesView", dependenciesProvider);
  context.subscriptions.push(
    vscode14.commands.registerCommand("uav.dependenciesView.refresh", () => dependenciesProvider.refresh())
  );
  registerDependencyUpdater(context);
  const syncIaContext = () => {
    const iaStatus = evaluateIaConfig();
    void vscode14.commands.executeCommand("setContext", "uav.iaReady", iaStatus.ready);
    if (!iaStatus.ready) {
      console.warn(`[UAV][extension] IA deshabilitada. Faltan parametros: ${iaStatus.missing.join(", ")}`);
    }
  };
  syncIaContext();
  context.subscriptions.push(
    vscode14.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration("UnifiedApexValidator")) {
        syncIaContext();
        dependenciesProvider.refresh();
      }
    })
  );
  const outputDir = vscode14.workspace.getConfiguration("UnifiedApexValidator").get("outputDir") || path14.join(context.globalStorageUri.fsPath, "output");
  const logDir = path14.join(context.globalStorageUri.fsPath, ".uav", "logs");
  await vscode14.workspace.fs.createDirectory(vscode14.Uri.file(outputDir));
  await vscode14.workspace.fs.createDirectory(vscode14.Uri.file(logDir));
  const reportsProvider = new FolderViewProvider(outputDir, "html|pdf", "Reportes");
  vscode14.window.registerTreeDataProvider("uav.reportsView", reportsProvider);
  const logsProvider = new FolderViewProvider(logDir, "log", "Logs");
  vscode14.window.registerTreeDataProvider("uav.logsView", logsProvider);
  context.subscriptions.push(
    vscode14.commands.registerCommand("uav.reportsView.refresh", () => reportsProvider.refresh()),
    vscode14.commands.registerCommand("uav.logsView.refresh", () => logsProvider.refresh()),
    vscode14.commands.registerCommand(
      "uav.reportsView.openFolder",
      () => vscode14.env.openExternal(vscode14.Uri.file(outputDir))
    ),
    vscode14.commands.registerCommand(
      "uav.logsView.openFolder",
      () => vscode14.env.openExternal(vscode14.Uri.file(logDir))
    ),
    vscode14.commands.registerCommand("uav.openFile", (uri) => vscode14.env.openExternal(uri))
  );
  setExtensionContext(context);
  console.log("[UAV][extension] Contexto registrado.");
  try {
    await vscode14.workspace.fs.createDirectory(context.globalStorageUri);
    console.log("[UAV][extension] Carpeta global creada o existente.");
  } catch (err) {
    console.error("[UAV][extension] Error creando carpeta global:", err);
  }
  const validateApexCmd = vscode14.commands.registerCommand(
    "UnifiedApexValidator.validateApex",
    async (uri) => {
      try {
        console.log("[UAV][extension] Ejecutando runUAV()...");
        await runUAV(uri);
      } catch (error) {
        console.error("[UAV][extension] Error ejecutando UAV:", error);
        vscode14.window.showErrorMessage(`Error ejecutando UAV: ${error.message}`);
      }
    }
  );
  const compareApexClassesCmd = vscode14.commands.registerCommand(
    "UnifiedApexValidator.compareApexClasses",
    async (uri) => {
      await vscode14.window.withProgress(
        {
          location: vscode14.ProgressLocation.Notification,
          title: "Comparando clases Apex contra la organizaci\xF3n seleccionada...",
          cancellable: false
        },
        async () => {
          try {
            await runCompareApexClasses(uri);
          } catch (err) {
            console.error("[UAV][extension] Error en comparaci\xF3n:", err);
            vscode14.window.showErrorMessage(`\u274C Error al comparar clases: ${err.message}`);
          }
        }
      );
    }
  );
  const generateApexDocChunkedCmd = vscode14.commands.registerCommand(
    "UnifiedApexValidator.generateApexDocChunked",
    async () => {
      try {
        await generateApexDocChunked();
      } catch (error) {
        console.error("[UAV][extension] Error en generaci\xF3n de ApexDoc:", error);
        vscode14.window.showErrorMessage(`\u274C Error generando ApexDoc: ${error.message}`);
      }
    }
  );
  context.subscriptions.push(validateApexCmd, compareApexClassesCmd, generateApexDocChunkedCmd);
  vscode14.window.showInformationMessage("Unified Apex Validator activado.");
}
function deactivate() {
  vscode14.window.showInformationMessage("Unified Apex Validator desactivado.");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

antlr4ts/Decorators.js:
antlr4ts/atn/Transition.js:
antlr4ts/atn/ActionTransition.js:
antlr4ts/misc/MurmurHash.js:
antlr4ts/misc/ObjectEqualityComparator.js:
antlr4ts/misc/DefaultEqualityComparator.js:
antlr4ts/misc/Array2DHashSet.js:
antlr4ts/misc/Array2DHashMap.js:
antlr4ts/misc/ArrayEqualityComparator.js:
antlr4ts/atn/ATNState.js:
antlr4ts/atn/DecisionState.js:
antlr4ts/misc/Arrays.js:
antlr4ts/atn/PredictionContextCache.js:
antlr4ts/atn/PredictionContext.js:
antlr4ts/misc/Utils.js:
antlr4ts/atn/SemanticContext.js:
antlr4ts/atn/ATNConfig.js:
antlr4ts/misc/BitSet.js:
antlr4ts/atn/ATNConfigSet.js:
antlr4ts/dfa/DFAState.js:
antlr4ts/atn/ATNSimulator.js:
antlr4ts/ConsoleErrorListener.js:
antlr4ts/ProxyErrorListener.js:
antlr4ts/IntStream.js:
antlr4ts/Token.js:
antlr4ts/Recognizer.js:
antlr4ts/VocabularyImpl.js:
antlr4ts/dfa/DFASerializer.js:
antlr4ts/dfa/LexerDFASerializer.js:
antlr4ts/atn/ATNStateType.js:
antlr4ts/atn/StarLoopEntryState.js:
antlr4ts/dfa/DFA.js:
antlr4ts/misc/IntegerList.js:
antlr4ts/misc/Interval.js:
antlr4ts/CommonToken.js:
antlr4ts/CommonTokenFactory.js:
antlr4ts/misc/IntegerStack.js:
antlr4ts/dfa/AcceptStateInfo.js:
antlr4ts/atn/LexerIndexedCustomAction.js:
antlr4ts/atn/LexerActionExecutor.js:
antlr4ts/RecognitionException.js:
antlr4ts/LexerNoViableAltException.js:
antlr4ts/atn/OrderedATNConfigSet.js:
antlr4ts/atn/RuleStopState.js:
antlr4ts/atn/LexerATNSimulator.js:
antlr4ts/Lexer.js:
antlr4ts/misc/IntervalSet.js:
antlr4ts/atn/BasicState.js:
antlr4ts/atn/InvalidState.js:
antlr4ts/atn/AbstractPredicateTransition.js:
antlr4ts/atn/SetTransition.js:
antlr4ts/atn/NotSetTransition.js:
antlr4ts/atn/RuleTransition.js:
antlr4ts/atn/WildcardTransition.js:
antlr4ts/atn/LL1Analyzer.js:
antlr4ts/atn/ATN.js:
antlr4ts/atn/ATNDeserializationOptions.js:
antlr4ts/atn/AtomTransition.js:
antlr4ts/atn/BlockStartState.js:
antlr4ts/atn/BasicBlockStartState.js:
antlr4ts/atn/BlockEndState.js:
antlr4ts/atn/EpsilonTransition.js:
antlr4ts/atn/LexerChannelAction.js:
antlr4ts/atn/LexerCustomAction.js:
antlr4ts/atn/LexerModeAction.js:
antlr4ts/atn/LexerMoreAction.js:
antlr4ts/atn/LexerPopModeAction.js:
antlr4ts/atn/LexerPushModeAction.js:
antlr4ts/atn/LexerSkipAction.js:
antlr4ts/atn/LexerTypeAction.js:
antlr4ts/atn/LoopEndState.js:
antlr4ts/atn/ConflictInfo.js:
antlr4ts/atn/PredicateTransition.js:
antlr4ts/FailedPredicateException.js:
antlr4ts/InputMismatchException.js:
antlr4ts/DefaultErrorStrategy.js:
antlr4ts/tree/TerminalNode.js:
antlr4ts/tree/ErrorNode.js:
antlr4ts/atn/ParseInfo.js:
antlr4ts/ProxyParserErrorListener.js:
antlr4ts/misc/ParseCancellationException.js:
antlr4ts/BailErrorStrategy.js:
antlr4ts/misc/Character.js:
antlr4ts/CodePointBuffer.js:
antlr4ts/CodePointCharStream.js:
antlr4ts/CharStreams.js:
antlr4ts/BufferedTokenStream.js:
antlr4ts/CommonTokenStream.js:
antlr4ts/ListTokenSource.js:
antlr4ts/misc/MultiMap.js:
antlr4ts/tree/RuleNode.js:
antlr4ts/tree/Trees.js:
antlr4ts/RuleContext.js:
antlr4ts/ParserRuleContext.js:
antlr4ts/InterpreterRuleContext.js:
antlr4ts/ParserInterpreter.js:
antlr4ts/tree/pattern/ParseTreeMatch.js:
antlr4ts/tree/xpath/XPathLexerErrorListener.js:
antlr4ts/tree/xpath/XPathElement.js:
antlr4ts/tree/xpath/XPathRuleAnywhereElement.js:
antlr4ts/tree/xpath/XPathRuleElement.js:
antlr4ts/tree/xpath/XPathTokenAnywhereElement.js:
antlr4ts/tree/xpath/XPathTokenElement.js:
antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js:
antlr4ts/tree/xpath/XPathWildcardElement.js:
antlr4ts/tree/xpath/XPath.js:
antlr4ts/tree/pattern/ParseTreePattern.js:
antlr4ts/tree/pattern/RuleTagToken.js:
antlr4ts/tree/pattern/Chunk.js:
antlr4ts/tree/pattern/TagChunk.js:
antlr4ts/tree/pattern/TextChunk.js:
antlr4ts/tree/pattern/TokenTagToken.js:
antlr4ts/tree/pattern/ParseTreePatternMatcher.js:
antlr4ts/atn/DecisionEventInfo.js:
antlr4ts/atn/AmbiguityInfo.js:
antlr4ts/atn/ContextSensitivityInfo.js:
antlr4ts/atn/DecisionInfo.js:
antlr4ts/atn/ErrorInfo.js:
antlr4ts/atn/LookaheadEventInfo.js:
antlr4ts/atn/PredicateEvalInfo.js:
antlr4ts/atn/SimulatorState.js:
antlr4ts/atn/ProfilingATNSimulator.js:
antlr4ts/Parser.js:
antlr4ts/NoViableAltException.js:
antlr4ts/atn/PredictionMode.js:
antlr4ts/atn/ParserATNSimulator.js:
antlr4ts/atn/PlusBlockStartState.js:
antlr4ts/atn/PlusLoopbackState.js:
antlr4ts/atn/PrecedencePredicateTransition.js:
antlr4ts/atn/RangeTransition.js:
antlr4ts/atn/RuleStartState.js:
antlr4ts/atn/StarBlockStartState.js:
antlr4ts/atn/StarLoopbackState.js:
antlr4ts/atn/TokensStartState.js:
antlr4ts/misc/UUID.js:
antlr4ts/atn/ATNDeserializer.js:
antlr4ts/ANTLRErrorListener.js:
antlr4ts/ANTLRErrorStrategy.js:
antlr4ts/ANTLRInputStream.js:
antlr4ts/CharStream.js:
antlr4ts/Dependents.js:
antlr4ts/DiagnosticErrorListener.js:
antlr4ts/LexerInterpreter.js:
antlr4ts/ParserErrorListener.js:
antlr4ts/RuleContextWithAltNum.js:
antlr4ts/RuleDependency.js:
antlr4ts/RuleVersion.js:
antlr4ts/TokenFactory.js:
antlr4ts/TokenSource.js:
antlr4ts/TokenStream.js:
antlr4ts/TokenStreamRewriter.js:
antlr4ts/Vocabulary.js:
antlr4ts/WritableToken.js:
antlr4ts/index.js:
antlr4ts/tree/ParseTreeWalker.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)
*/
